const main = "";
const moduleId = "mobile-companion";
const foundryContextId = "foundryContextId";
const settings = {
  users: "users",
  usersMenu: "usersMenu",
  lastActorId: "lastActorId",
  dnd5e: {
    useCurrency: "useCurrency",
    useEncumbrance: "useEncumbrance"
  },
  a5e: {
    useCurrency: "useCurrency",
    useEncumbrance: "useEncumbrance"
  },
  pf2e: {
    useCurrency: "useCurrency",
    useEncumbrance: "useEncumbrance"
  }
};
const system = {
  A5E: "a5e",
  DND5E: "dnd5e",
  PF2E: "pf2e"
};
function saveLastActorId(actorId) {
  game.settings.set(moduleId, settings.lastActorId, actorId);
}
function getLastActorId() {
  return game.settings.get(moduleId, settings.lastActorId);
}
function isSheetOnly() {
  const playerData = game.settings.get(moduleId, settings.users);
  const user = game.user;
  const userData = playerData[user.id];
  if (userData) {
    const useSheetOnly = userData.enabled;
    if (useSheetOnly) {
      const screenWidthToIgnoreSheetOnly = userData.screenWidth;
      if (screenWidthToIgnoreSheetOnly <= 0) {
        return true;
      }
      if (screen.width < screenWidthToIgnoreSheetOnly) {
        return true;
      }
    }
  }
  return false;
}
let currentSheet;
let factory$1;
function activateSheet(factoryToUse) {
  factory$1 = factoryToUse;
  checkCanvas();
  popupSheet();
  addEventListener("resize", onResize);
}
function onResize() {
  currentSheet?.element.css({
    width: window.innerWidth,
    height: window.innerHeight
  });
}
function checkCanvas() {
  const coreIsDisabled = game.settings.get("core", "noCanvas");
  if (!coreIsDisabled) {
    game.settings.set("core", "noCanvas", true);
  }
}
function popupSheet() {
  const ownedActors = getOwnedActors();
  const lastActorId = getLastActorId();
  if (lastActorId) {
    const lastActor = game.actors.get(lastActorId);
    const actorIsOwned = ownedActors.some((actor) => actor.id === lastActorId);
    if (lastActor && actorIsOwned) {
      switchToActor(lastActor);
      return;
    } else {
      console.log("The saved actor could not be found, opening the first actor.");
    }
  }
  if (ownedActors?.length > 0) {
    switchToActor(ownedActors[0]);
  } else {
    console.error("No actor for user found.");
  }
}
function getOwnedActors() {
  return game.actors.filter((actor) => isActorOwnedByUser(actor));
}
function isActorOwnedByUser(actor) {
  return actor.ownership[game.user.id] === 3;
}
function switchToActor(actor) {
  if (currentSheet) {
    currentSheet.close();
  }
  openMobileCompanion(actor);
  saveLastActorId(actor.id);
}
function openMobileCompanion(actor) {
  currentSheet = factory$1(actor);
  if (currentSheet) {
    currentSheet.render(true, { focus: true });
  } else {
    console.error("Mobile-Companion does not support this system. Please disable Mobile-Companion.");
  }
}
function noop() {
}
const identity$1 = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function is_promise(value) {
  return !!value && (typeof value === "object" || typeof value === "function") && typeof /** @type {any} */
  value.then === "function";
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
let src_url_equal_anchor;
function src_url_equal(element_src, url) {
  if (element_src === url)
    return true;
  if (!src_url_equal_anchor) {
    src_url_equal_anchor = document.createElement("a");
  }
  src_url_equal_anchor.href = url;
  return element_src === src_url_equal_anchor.href;
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i2 = 0; i2 < len; i2 += 1) {
        merged[i2] = $$scope.dirty[i2] | lets[i2];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i2 = 0; i2 < length; i2++) {
      dirty[i2] = -1;
    }
    return dirty;
  }
  return -1;
}
function null_to_empty(value) {
  return value == null ? "" : value;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}
const is_client = typeof window !== "undefined";
let now = is_client ? () => window.performance.now() : () => Date.now();
let raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
const tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
function append(target, node) {
  target.appendChild(node);
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  style_element.textContent = "/* empty */";
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i2 = 0; i2 < iterations.length; i2 += 1) {
    if (iterations[i2])
      iterations[i2].d(detaching);
  }
}
function element(name2) {
  return document.createElement(name2);
}
function svg_element(name2) {
  return document.createElementNS("http://www.w3.org/2000/svg", name2);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name2, toggle) {
  element2.classList.toggle(name2, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
class HtmlTag {
  /**
   * @private
   * @default false
   */
  is_svg = false;
  /** parent for creating node */
  e = void 0;
  /** html tag nodes */
  n = void 0;
  /** target */
  t = void 0;
  /** anchor */
  a = void 0;
  constructor(is_svg = false) {
    this.is_svg = is_svg;
    this.e = this.n = null;
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  c(html) {
    this.h(html);
  }
  /**
   * @param {string} html
   * @param {HTMLElement | SVGElement} target
   * @param {HTMLElement | SVGElement} anchor
   * @returns {void}
   */
  m(html, target, anchor = null) {
    if (!this.e) {
      if (this.is_svg)
        this.e = svg_element(
          /** @type {keyof SVGElementTagNameMap} */
          target.nodeName
        );
      else
        this.e = element(
          /** @type {keyof HTMLElementTagNameMap} */
          target.nodeType === 11 ? "TEMPLATE" : target.nodeName
        );
      this.t = target.tagName !== "TEMPLATE" ? target : (
        /** @type {HTMLTemplateElement} */
        target.content
      );
      this.c(html);
    }
    this.i(anchor);
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  h(html) {
    this.e.innerHTML = html;
    this.n = Array.from(
      this.e.nodeName === "TEMPLATE" ? this.e.content.childNodes : this.e.childNodes
    );
  }
  /**
   * @returns {void} */
  i(anchor) {
    for (let i2 = 0; i2 < this.n.length; i2 += 1) {
      insert(this.t, this.n[i2], anchor);
    }
  }
  /**
   * @param {string} html
   * @returns {void}
   */
  p(html) {
    this.d();
    this.h(html);
    this.i(this.a);
  }
  /**
   * @returns {void} */
  d() {
    this.n.forEach(detach);
  }
}
function construct_svelte_component(component, props) {
  return new component(props);
}
const managed_styles = /* @__PURE__ */ new Map();
let active = 0;
function hash(str) {
  let hash2 = 5381;
  let i2 = str.length;
  while (i2--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i2);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name2 = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name2]) {
    rules[name2] = true;
    stylesheet.insertRule(`@keyframes ${name2} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name2} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name2;
}
function delete_rule(node, name2) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name2 ? (anim) => anim.indexOf(name2) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
let current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function setContext(key, context) {
  get_current_component().$$.context.set(key, context);
  return context;
}
function getContext(key) {
  return get_current_component().$$.context.get(key);
}
const dirty_components = [];
const binding_callbacks = [];
let render_callbacks = [];
const flush_callbacks = [];
const resolved_promise = /* @__PURE__ */ Promise.resolve();
let update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
const seen_callbacks = /* @__PURE__ */ new Set();
let flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e2) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e2;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i2 = 0; i2 < render_callbacks.length; i2 += 1) {
      const callback = render_callbacks[i2];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
let promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
const outroing = /* @__PURE__ */ new Set();
let outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
const null_transition = { duration: 0 };
function create_in_transition(node, fn, params) {
  const options = { direction: "in" };
  let config3 = fn(node, params, options);
  let running = false;
  let animation_name;
  let task;
  let uid = 0;
  function cleanup() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function go() {
    const {
      delay = 0,
      duration = 300,
      easing = identity$1,
      tick = noop,
      css
    } = config3 || null_transition;
    if (css)
      animation_name = create_rule(node, 0, 1, duration, delay, easing, css, uid++);
    tick(0, 1);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    if (task)
      task.abort();
    running = true;
    add_render_callback(() => dispatch(node, true, "start"));
    task = loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(1, 0);
          dispatch(node, true, "end");
          cleanup();
          return running = false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick(t, 1 - t);
        }
      }
      return running;
    });
  }
  let started = false;
  return {
    start() {
      if (started)
        return;
      started = true;
      delete_rule(node);
      if (is_function(config3)) {
        config3 = config3(options);
        wait().then(go);
      } else {
        go();
      }
    },
    invalidate() {
      started = false;
    },
    end() {
      if (running) {
        cleanup();
        running = false;
      }
    }
  };
}
function create_out_transition(node, fn, params) {
  const options = { direction: "out" };
  let config3 = fn(node, params, options);
  let running = true;
  let animation_name;
  const group = outros;
  group.r += 1;
  let original_inert_value;
  function go() {
    const {
      delay = 0,
      duration = 300,
      easing = identity$1,
      tick = noop,
      css
    } = config3 || null_transition;
    if (css)
      animation_name = create_rule(node, 1, 0, duration, delay, easing, css);
    const start_time = now() + delay;
    const end_time = start_time + duration;
    add_render_callback(() => dispatch(node, false, "start"));
    if ("inert" in node) {
      original_inert_value = /** @type {HTMLElement} */
      node.inert;
      node.inert = true;
    }
    loop((now2) => {
      if (running) {
        if (now2 >= end_time) {
          tick(0, 1);
          dispatch(node, false, "end");
          if (!--group.r) {
            run_all(group.c);
          }
          return false;
        }
        if (now2 >= start_time) {
          const t = easing((now2 - start_time) / duration);
          tick(1 - t, t);
        }
      }
      return running;
    });
  }
  if (is_function(config3)) {
    wait().then(() => {
      config3 = config3(options);
      go();
    });
  } else {
    go();
  }
  return {
    end(reset) {
      if (reset && "inert" in node) {
        node.inert = original_inert_value;
      }
      if (reset && config3.tick) {
        config3.tick(1, 0);
      }
      if (running) {
        if (animation_name)
          delete_rule(node, animation_name);
        running = false;
      }
    }
  };
}
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config3 = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  let original_inert_value;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = (
      /** @type {Program['d']} */
      program.b - t
    );
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const {
      delay = 0,
      duration = 300,
      easing = identity$1,
      tick = noop,
      css
    } = config3 || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if ("inert" in node) {
      if (b) {
        if (original_inert_value !== void 0) {
          node.inert = original_inert_value;
        }
      } else {
        original_inert_value = /** @type {HTMLElement} */
        node.inert;
        node.inert = true;
      }
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(
              node,
              t,
              running_program.b,
              running_program.duration,
              0,
              easing,
              config3.css
            );
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config3)) {
        wait().then(() => {
          const opts = { direction: b ? "in" : "out" };
          config3 = config3(opts);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function handle_promise(promise2, info) {
  const token = info.token = {};
  function update2(type, index2, key, value) {
    if (info.token !== token)
      return;
    info.resolved = value;
    let child_ctx = info.ctx;
    if (key !== void 0) {
      child_ctx = child_ctx.slice();
      child_ctx[key] = value;
    }
    const block = type && (info.current = type)(child_ctx);
    let needs_flush = false;
    if (info.block) {
      if (info.blocks) {
        info.blocks.forEach((block2, i2) => {
          if (i2 !== index2 && block2) {
            group_outros();
            transition_out(block2, 1, 1, () => {
              if (info.blocks[i2] === block2) {
                info.blocks[i2] = null;
              }
            });
            check_outros();
          }
        });
      } else {
        info.block.d(1);
      }
      block.c();
      transition_in(block, 1);
      block.m(info.mount(), info.anchor);
      needs_flush = true;
    }
    info.block = block;
    if (info.blocks)
      info.blocks[index2] = block;
    if (needs_flush) {
      flush();
    }
  }
  if (is_promise(promise2)) {
    const current_component2 = get_current_component();
    promise2.then(
      (value) => {
        set_current_component(current_component2);
        update2(info.then, 1, info.value, value);
        set_current_component(null);
      },
      (error) => {
        set_current_component(current_component2);
        update2(info.catch, 2, info.error, error);
        set_current_component(null);
        if (!info.hasCatch) {
          throw error;
        }
      }
    );
    if (info.current !== info.pending) {
      update2(info.pending, 0);
      return true;
    }
  } else {
    if (info.current !== info.then) {
      update2(info.then, 1, info.value, promise2);
      return true;
    }
    info.resolved = /** @type {T} */
    promise2;
  }
}
function update_await_block_branch(info, ctx, dirty) {
  const child_ctx = ctx.slice();
  const { resolved } = info;
  if (info.current === info.then) {
    child_ctx[info.value] = resolved;
  }
  if (info.current === info.catch) {
    child_ctx[info.error] = resolved;
  }
  info.block.p(child_ctx, dirty);
}
function ensure_array_like(array_like_or_iterator) {
  return array_like_or_iterator?.length !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}
function destroy_block(block, lookup) {
  block.d(1);
  lookup.delete(block.key);
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block2, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i2 = o;
  const old_indexes = {};
  while (i2--)
    old_indexes[old_blocks[i2].key] = i2;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i2 = n;
  while (i2--) {
    const child_ctx = get_context(ctx, list, i2);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block2(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i2] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i2 - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i2 = levels.length;
  while (i2--) {
    const o = levels[i2];
    const n = updates[i2];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i2] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
function bind(component, name2, callback) {
  const index2 = component.$$.props[name2];
  if (index2 !== void 0) {
    component.$$.bound[index2] = callback;
    callback(component.$$.ctx[index2]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i2) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i2 / 31 | 0] |= 1 << i2 % 31;
}
function init$3(component, options, instance2, create_fragment2, not_equal, props, append_styles, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles && append_styles($$.root);
  let ready = false;
  $$.ctx = instance2 ? instance2(component, options.props || {}, (i2, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i2], $$.ctx[i2] = value)) {
      if (!$$.skip_bound && $$.bound[i2])
        $$.bound[i2](value);
      if (ready)
        make_dirty(component, i2);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment2 ? create_fragment2($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    flush();
  }
  set_current_component(parent_component);
}
class SvelteComponent {
  /**
   * ### PRIVATE API
   *
   * Do not use, may change at any time
   *
   * @type {any}
   */
  $$ = void 0;
  /**
   * ### PRIVATE API
   *
   * Do not use, may change at any time
   *
   * @type {any}
   */
  $$set = void 0;
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index2 = callbacks.indexOf(callback);
      if (index2 !== -1)
        callbacks.splice(index2, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
}
const PUBLIC_VERSION = "4";
const subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
            subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set2(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update2);
      if (auto) {
        set2(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i2) => subscribe(
        store,
        (value) => {
          values[i2] = value;
          pending &= ~(1 << i2);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i2;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}
function writableDerived(origins, derive, reflect, initial) {
  var childDerivedSetter, originValues, blockNextDerive = false;
  var reflectOldValues = reflect.length >= 2;
  var wrappedDerive = (got, set2, update3) => {
    childDerivedSetter = set2;
    if (reflectOldValues) {
      originValues = got;
    }
    if (!blockNextDerive) {
      let returned = derive(got, set2, update3);
      if (derive.length < 2) {
        set2(returned);
      } else {
        return returned;
      }
    }
    blockNextDerive = false;
  };
  var childDerived = derived(origins, wrappedDerive, initial);
  var singleOrigin = !Array.isArray(origins);
  function doReflect(reflecting) {
    var setWith = reflect(reflecting, originValues);
    if (singleOrigin) {
      blockNextDerive = true;
      origins.set(setWith);
    } else {
      setWith.forEach((value, i2) => {
        blockNextDerive = true;
        origins[i2].set(value);
      });
    }
    blockNextDerive = false;
  }
  var tryingSet = false;
  function update2(fn) {
    var isUpdated, mutatedBySubscriptions, oldValue, newValue;
    if (tryingSet) {
      newValue = fn(get_store_value(childDerived));
      childDerivedSetter(newValue);
      return;
    }
    var unsubscribe = childDerived.subscribe((value) => {
      if (!tryingSet) {
        oldValue = value;
      } else if (!isUpdated) {
        isUpdated = true;
      } else {
        mutatedBySubscriptions = true;
      }
    });
    newValue = fn(oldValue);
    tryingSet = true;
    childDerivedSetter(newValue);
    unsubscribe();
    tryingSet = false;
    if (mutatedBySubscriptions) {
      newValue = get_store_value(childDerived);
    }
    if (isUpdated) {
      doReflect(newValue);
    }
  }
  return {
    subscribe: childDerived.subscribe,
    set(value) {
      update2(() => value);
    },
    update: update2
  };
}
function propertyStore(origin, propName) {
  if (!Array.isArray(propName)) {
    return writableDerived(
      origin,
      (object) => object[propName],
      (reflecting, object) => {
        object[propName] = reflecting;
        return object;
      }
    );
  } else {
    let props = propName.concat();
    return writableDerived(
      origin,
      (value) => {
        for (let i2 = 0; i2 < props.length; ++i2) {
          value = value[props[i2]];
        }
        return value;
      },
      (reflecting, object) => {
        let target = object;
        for (let i2 = 0; i2 < props.length - 1; ++i2) {
          target = target[props[i2]];
        }
        target[props[props.length - 1]] = reflecting;
        return object;
      }
    );
  }
}
function set(obj, key, val) {
  if (typeof val.value === "object")
    val.value = klona(val.value);
  if (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === "__proto__") {
    Object.defineProperty(obj, key, val);
  } else
    obj[key] = val.value;
}
function klona(x) {
  if (typeof x !== "object")
    return x;
  var i2 = 0, k, list, tmp, str = Object.prototype.toString.call(x);
  if (str === "[object Object]") {
    tmp = Object.create(x.__proto__ || null);
  } else if (str === "[object Array]") {
    tmp = Array(x.length);
  } else if (str === "[object Set]") {
    tmp = /* @__PURE__ */ new Set();
    x.forEach(function(val) {
      tmp.add(klona(val));
    });
  } else if (str === "[object Map]") {
    tmp = /* @__PURE__ */ new Map();
    x.forEach(function(val, key) {
      tmp.set(klona(key), klona(val));
    });
  } else if (str === "[object Date]") {
    tmp = /* @__PURE__ */ new Date(+x);
  } else if (str === "[object RegExp]") {
    tmp = new RegExp(x.source, x.flags);
  } else if (str === "[object DataView]") {
    tmp = new x.constructor(klona(x.buffer));
  } else if (str === "[object ArrayBuffer]") {
    tmp = x.slice(0);
  } else if (str.slice(-6) === "Array]") {
    tmp = new x.constructor(x);
  }
  if (tmp) {
    for (list = Object.getOwnPropertySymbols(x); i2 < list.length; i2++) {
      set(tmp, list[i2], Object.getOwnPropertyDescriptor(x, list[i2]));
    }
    for (i2 = 0, list = Object.getOwnPropertyNames(x); i2 < list.length; i2++) {
      if (Object.hasOwnProperty.call(tmp, k = list[i2]) && tmp[k] === x[k])
        continue;
      set(tmp, k, Object.getOwnPropertyDescriptor(x, k));
    }
  }
  return tmp || x;
}
const s_TAG_OBJECT = "[object Object]";
function deepMerge(target = {}, ...sourceObj) {
  if (Object.prototype.toString.call(target) !== s_TAG_OBJECT) {
    throw new TypeError(`deepMerge error: 'target' is not an 'object'.`);
  }
  for (let cntr = 0; cntr < sourceObj.length; cntr++) {
    if (Object.prototype.toString.call(sourceObj[cntr]) !== s_TAG_OBJECT) {
      throw new TypeError(`deepMerge error: 'sourceObj[${cntr}]' is not an 'object'.`);
    }
  }
  return _deepMerge(target, ...sourceObj);
}
function hasGetter(object, accessor) {
  if (typeof object !== "object" || object === null || object === void 0) {
    return false;
  }
  const iDescriptor = Object.getOwnPropertyDescriptor(object, accessor);
  if (iDescriptor !== void 0 && iDescriptor.get !== void 0) {
    return true;
  }
  for (let o = Object.getPrototypeOf(object); o; o = Object.getPrototypeOf(o)) {
    const descriptor = Object.getOwnPropertyDescriptor(o, accessor);
    if (descriptor !== void 0 && descriptor.get !== void 0) {
      return true;
    }
  }
  return false;
}
function isIterable(value) {
  if (value === null || value === void 0 || typeof value !== "object") {
    return false;
  }
  return Symbol.iterator in value;
}
function isObject$1(value) {
  return value !== null && typeof value === "object" && !Array.isArray(value);
}
function isPlainObject$1(value) {
  if (Object.prototype.toString.call(value) !== s_TAG_OBJECT) {
    return false;
  }
  const prototype = Object.getPrototypeOf(value);
  return prototype === null || prototype === Object.prototype;
}
function safeAccess(data, accessor, defaultValue) {
  if (typeof data !== "object") {
    return defaultValue;
  }
  if (typeof accessor !== "string") {
    return defaultValue;
  }
  const access = accessor.split(".");
  for (let cntr = 0; cntr < access.length; cntr++) {
    if (typeof data[access[cntr]] === "undefined" || data[access[cntr]] === null) {
      return defaultValue;
    }
    data = data[access[cntr]];
  }
  return data;
}
function safeSet(data, accessor, value, operation = "set", createMissing = true) {
  if (typeof data !== "object") {
    throw new TypeError(`safeSet Error: 'data' is not an 'object'.`);
  }
  if (typeof accessor !== "string") {
    throw new TypeError(`safeSet Error: 'accessor' is not a 'string'.`);
  }
  const access = accessor.split(".");
  for (let cntr = 0; cntr < access.length; cntr++) {
    if (Array.isArray(data)) {
      const number2 = +access[cntr];
      if (!Number.isInteger(number2) || number2 < 0) {
        return false;
      }
    }
    if (cntr === access.length - 1) {
      switch (operation) {
        case "add":
          data[access[cntr]] += value;
          break;
        case "div":
          data[access[cntr]] /= value;
          break;
        case "mult":
          data[access[cntr]] *= value;
          break;
        case "set":
          data[access[cntr]] = value;
          break;
        case "set-undefined":
          if (typeof data[access[cntr]] === "undefined") {
            data[access[cntr]] = value;
          }
          break;
        case "sub":
          data[access[cntr]] -= value;
          break;
      }
    } else {
      if (createMissing && typeof data[access[cntr]] === "undefined") {
        data[access[cntr]] = {};
      }
      if (data[access[cntr]] === null || typeof data[access[cntr]] !== "object") {
        return false;
      }
      data = data[access[cntr]];
    }
  }
  return true;
}
function _deepMerge(target = {}, ...sourceObj) {
  for (let cntr = 0; cntr < sourceObj.length; cntr++) {
    const obj = sourceObj[cntr];
    for (const prop in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, prop)) {
        if (prop.startsWith("-=")) {
          delete target[prop.slice(2)];
          continue;
        }
        target[prop] = Object.prototype.hasOwnProperty.call(target, prop) && target[prop]?.constructor === Object && obj[prop]?.constructor === Object ? _deepMerge({}, target[prop], obj[prop]) : obj[prop];
      }
    }
  }
  return target;
}
function isUpdatableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function" && typeof store.update === "function";
  }
  return false;
}
function isWritableStore(store) {
  if (store === null || store === void 0) {
    return false;
  }
  switch (typeof store) {
    case "function":
    case "object":
      return typeof store.subscribe === "function" && typeof store.set === "function";
  }
  return false;
}
function subscribeIgnoreFirst(store, update2) {
  let firedFirst = false;
  return store.subscribe((value) => {
    if (!firedFirst) {
      firedFirst = true;
    } else {
      update2(value);
    }
  });
}
function cubicOut(t) {
  const f = t - 1;
  return f * f * f + 1;
}
function lerp(start, end, amount) {
  return (1 - amount) * start + amount * end;
}
class A11yHelper {
  /**
   * Apply focus to the HTMLElement targets in a given A11yFocusSource data object. An iterable list `options.focusEl`
   * can contain HTMLElements or selector strings. If multiple focus targets are provided in a list then the first
   * valid target found will be focused. If focus target is a string then a lookup via `document.querySelector` is
   * performed. In this case you should provide a unique selector for the desired focus target.
   *
   * Note: The body of this method is postponed to the next clock tick to allow any changes in the DOM to occur that
   * might alter focus targets before applying.
   *
   * @param {A11yFocusSource|{ focusSource: A11yFocusSource }}   options - The focus options instance to apply.
   */
  static applyFocusSource(options) {
    if (!isObject$1(options)) {
      return;
    }
    const focusOpts = isObject$1(options?.focusSource) ? options.focusSource : options;
    setTimeout(() => {
      const debug = typeof focusOpts.debug === "boolean" ? focusOpts.debug : false;
      if (isIterable(focusOpts.focusEl)) {
        if (debug) {
          console.debug(`A11yHelper.applyFocusSource debug - Attempting to apply focus target: `, focusOpts.focusEl);
        }
        for (const target of focusOpts.focusEl) {
          if (target instanceof HTMLElement && target.isConnected) {
            target.focus();
            if (debug) {
              console.debug(`A11yHelper.applyFocusSource debug - Applied focus to target: `, target);
            }
            break;
          } else if (typeof target === "string") {
            const element2 = document.querySelector(target);
            if (element2 instanceof HTMLElement && element2.isConnected) {
              element2.focus();
              if (debug) {
                console.debug(`A11yHelper.applyFocusSource debug - Applied focus to target: `, element2);
              }
              break;
            } else if (debug) {
              console.debug(`A11yHelper.applyFocusSource debug - Could not query selector: `, target);
            }
          }
        }
      } else if (debug) {
        console.debug(`A11yHelper.applyFocusSource debug - No focus targets defined.`);
      }
    }, 0);
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] - Optional element to start query.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>} [options.ignoreElements] - Set of elements to ignore.
   *
   * @returns {HTMLElement} First focusable child element
   */
  static getFirstFocusableElement(element2 = document, options) {
    const focusableElements = this.getFocusableElements(element2, options);
    return focusableElements.length > 0 ? focusableElements[0] : void 0;
  }
  /**
   * Returns all focusable elements within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] Optional element to start query.
   *
   * @param {object}            [options] - Optional parameters.
   *
   * @param {boolean}           [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>}  [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>}  [options.ignoreElements] - Set of elements to ignore.
   *
   * @param {string}            [options.selectors] - Custom list of focusable selectors for `querySelectorAll`.
   *
   * @returns {Array<HTMLElement>} Child keyboard focusable
   */
  static getFocusableElements(element2 = document, { anchorHref = true, ignoreClasses, ignoreElements, selectors } = {}) {
    if (!(element2 instanceof HTMLElement) && !(element2 instanceof Document)) {
      throw new TypeError(`'element' is not a HTMLElement or Document instance.`);
    }
    if (typeof anchorHref !== "boolean") {
      throw new TypeError(`'anchorHref' is not a boolean.`);
    }
    if (ignoreClasses !== void 0 && !isIterable(ignoreClasses)) {
      throw new TypeError(`'ignoreClasses' is not an iterable list.`);
    }
    if (ignoreElements !== void 0 && !(ignoreElements instanceof Set)) {
      throw new TypeError(`'ignoreElements' is not a Set.`);
    }
    if (selectors !== void 0 && typeof selectors !== "string") {
      throw new TypeError(`'selectors' is not a string.`);
    }
    const selectorQuery = selectors ?? this.#getFocusableSelectors(anchorHref);
    const allElements = [...element2.querySelectorAll(selectorQuery)];
    if (ignoreElements && ignoreClasses) {
      return allElements.filter((el) => {
        let hasIgnoreClass = false;
        for (const ignoreClass of ignoreClasses) {
          if (el.classList.contains(ignoreClass)) {
            hasIgnoreClass = true;
            break;
          }
        }
        return !hasIgnoreClass && !ignoreElements.has(el) && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else if (ignoreClasses) {
      return allElements.filter((el) => {
        let hasIgnoreClass = false;
        for (const ignoreClass of ignoreClasses) {
          if (el.classList.contains(ignoreClass)) {
            hasIgnoreClass = true;
            break;
          }
        }
        return !hasIgnoreClass && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else if (ignoreElements) {
      return allElements.filter((el) => {
        return !ignoreElements.has(el) && el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    } else {
      return allElements.filter((el) => {
        return el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
      });
    }
  }
  /**
   * Returns the default focusable selectors query.
   *
   * @param {boolean}  [anchorHref=true] - When true anchors must have an HREF.
   *
   * @returns {string} Focusable selectors for `querySelectorAll`.
   */
  static #getFocusableSelectors(anchorHref = true) {
    return `button, [contenteditable=""], [contenteditable="true"], details summary:not([tabindex="-1"]), embed, a${anchorHref ? "[href]" : ""}, iframe, object, input:not([type=hidden]), select, textarea, [tabindex]:not([tabindex="-1"])`;
  }
  /**
   * Gets a A11yFocusSource object from the given DOM event allowing for optional X / Y screen space overrides.
   * Browsers (Firefox / Chrome) forwards a mouse event for the context menu keyboard button. Provides detection of
   * when the context menu event is from the keyboard. Firefox as of (1/23) does not provide the correct screen space
   * coordinates, so for keyboard context menu presses coordinates are generated from the centroid point of the
   * element.
   *
   * A default fallback element or selector string may be provided to provide the focus target. If the event comes from
   * the keyboard however the source focused element is inserted as the target with the fallback value appended to the
   * list of focus targets. When A11yFocusSource is applied by {@link A11yHelper.applyFocusSource} the target focus
   * list is iterated through until a connected target is found and focus applied.
   *
   * @param {object} options - Options
   *
   * @param {KeyboardEvent|MouseEvent}   [options.event] - The source DOM event.
   *
   * @param {boolean} [options.debug] - When true {@link A11yHelper.applyFocusSource} logs focus target data.
   *
   * @param {HTMLElement|string} [options.focusEl] - A specific HTMLElement or selector string as the focus target.
   *
   * @param {number}   [options.x] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @param {number}   [options.y] - Used when an event isn't provided; integer of event source in screen space.
   *
   * @returns {A11yFocusSource} A A11yFocusSource object.
   *
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=1426671
   * @see https://bugzilla.mozilla.org/show_bug.cgi?id=314314
   *
   * TODO: Evaluate / test against touch input devices.
   */
  static getFocusSource({ event, x, y, focusEl, debug = false }) {
    if (focusEl !== void 0 && !(focusEl instanceof HTMLElement) && typeof focusEl !== "string") {
      throw new TypeError(
        `A11yHelper.getFocusSource error: 'focusEl' is not a HTMLElement or string.`
      );
    }
    if (debug !== void 0 && typeof debug !== "boolean") {
      throw new TypeError(`A11yHelper.getFocusSource error: 'debug' is not a boolean.`);
    }
    if (event === void 0) {
      if (typeof x !== "number") {
        throw new TypeError(`A11yHelper.getFocusSource error: 'event' not defined and 'x' is not a number.`);
      }
      if (typeof y !== "number") {
        throw new TypeError(`A11yHelper.getFocusSource error: 'event' not defined and 'y' is not a number.`);
      }
      return {
        debug,
        focusEl: focusEl !== void 0 ? [focusEl] : void 0,
        x,
        y
      };
    }
    if (!(event instanceof KeyboardEvent) && !(event instanceof MouseEvent)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'event' is not a KeyboardEvent or MouseEvent.`);
    }
    if (x !== void 0 && !Number.isInteger(x)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'x' is not a number.`);
    }
    if (y !== void 0 && !Number.isInteger(y)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'y' is not a number.`);
    }
    const targetEl = event.target;
    if (!(targetEl instanceof HTMLElement)) {
      throw new TypeError(`A11yHelper.getFocusSource error: 'event.target' is not an HTMLElement.`);
    }
    const result = { debug };
    if (event instanceof MouseEvent) {
      if (event?.button !== 2 && event.type === "contextmenu") {
        const rect = targetEl.getBoundingClientRect();
        result.x = x ?? rect.left + rect.width / 2;
        result.y = y ?? rect.top + rect.height / 2;
        result.focusEl = focusEl !== void 0 ? [targetEl, focusEl] : [targetEl];
        result.source = "keyboard";
      } else {
        result.x = x ?? event.pageX;
        result.y = y ?? event.pageY;
        result.focusEl = focusEl !== void 0 ? [focusEl] : void 0;
      }
    } else {
      const rect = targetEl.getBoundingClientRect();
      result.x = x ?? rect.left + rect.width / 2;
      result.y = y ?? rect.top + rect.height / 2;
      result.focusEl = focusEl !== void 0 ? [targetEl, focusEl] : [targetEl];
      result.source = "keyboard";
    }
    return result;
  }
  /**
   * Returns first focusable element within a specified element.
   *
   * @param {HTMLElement|Document} [element=document] - Optional element to start query.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @param {Set<HTMLElement>} [options.ignoreElements] - Set of elements to ignore.
   *
   * @returns {HTMLElement} First focusable child element
   */
  static getLastFocusableElement(element2 = document, options) {
    const focusableElements = this.getFocusableElements(element2, options);
    return focusableElements.length > 0 ? focusableElements[focusableElements.length - 1] : void 0;
  }
  /**
   * Tests if the given element is focusable.
   *
   * @param {HTMLElement} [el] - Element to test.
   *
   * @param {object} [options] - Optional parameters.
   *
   * @param {boolean} [options.anchorHref=true] - When true anchors must have an HREF.
   *
   * @param {Iterable<string>} [options.ignoreClasses] - Iterable list of classes to ignore elements.
   *
   * @returns {boolean} Element is focusable.
   */
  static isFocusable(el, { anchorHref = true, ignoreClasses } = {}) {
    if (el === void 0 || el === null || !(el instanceof HTMLElement) || el?.hidden || !el?.isConnected) {
      return false;
    }
    if (typeof anchorHref !== "boolean") {
      throw new TypeError(`'anchorHref' is not a boolean.`);
    }
    if (ignoreClasses !== void 0 && !isIterable(ignoreClasses)) {
      throw new TypeError(`'ignoreClasses' is not an iterable list.`);
    }
    const contenteditableAttr = el.getAttribute("contenteditable");
    const contenteditableFocusable = typeof contenteditableAttr === "string" && (contenteditableAttr === "" || contenteditableAttr === "true");
    const tabindexAttr = el.getAttribute("tabindex");
    const tabindexFocusable = typeof tabindexAttr === "string" && tabindexAttr !== "-1";
    const isAnchor = el instanceof HTMLAnchorElement;
    if (contenteditableFocusable || tabindexFocusable || isAnchor || el instanceof HTMLButtonElement || el instanceof HTMLDetailsElement || el instanceof HTMLEmbedElement || el instanceof HTMLIFrameElement || el instanceof HTMLInputElement || el instanceof HTMLObjectElement || el instanceof HTMLSelectElement || el instanceof HTMLTextAreaElement) {
      if (isAnchor && anchorHref && typeof el.getAttribute("href") !== "string") {
        return false;
      }
      return el.style.display !== "none" && el.style.visibility !== "hidden" && !el.hasAttribute("disabled") && !el.hasAttribute("inert") && el.getAttribute("aria-hidden") !== "true";
    }
    return false;
  }
  /**
   * Convenience method to check if the given data is a valid focus source.
   *
   * @param {HTMLElement|string}   data - Either an HTMLElement or selector string.
   *
   * @returns {boolean} Is valid focus source.
   */
  static isFocusSource(data) {
    return data instanceof HTMLElement || typeof data === "string";
  }
}
class StyleParse {
  static #regexPixels = /(\d+)\s*px/;
  /**
   * Parses a pixel string / computed styles. Ex. `100px` returns `100`.
   *
   * @param {string}   value - Value to parse.
   *
   * @returns {number|undefined} The integer component of a pixel string.
   */
  static pixels(value) {
    if (typeof value !== "string") {
      return void 0;
    }
    const isPixels = this.#regexPixels.test(value);
    const number2 = parseInt(value);
    return isPixels && Number.isFinite(number2) ? number2 : void 0;
  }
}
class TJSStyleManager {
  /** @type {CSSStyleRule} */
  #cssRule;
  /** @type {string} */
  #docKey;
  /** @type {string} */
  #selector;
  /** @type {HTMLStyleElement} */
  #styleElement;
  /** @type {number} */
  #version;
  /**
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.docKey - Required key providing a link to a specific style sheet element.
   *
   * @param {string}   [opts.selector=:root] - Selector element.
   *
   * @param {Document} [opts.document] - Target document to load styles into.
   *
   * @param {number}   [opts.version] - An integer representing the version / level of styles being managed.
   */
  constructor({ docKey, selector = ":root", document: document2 = globalThis.document, version: version2 } = {}) {
    if (typeof docKey !== "string") {
      throw new TypeError(`StyleManager error: 'docKey' is not a string.`);
    }
    if (typeof selector !== "string") {
      throw new TypeError(`StyleManager error: 'selector' is not a string.`);
    }
    if (version2 !== void 0 && !Number.isSafeInteger(version2) && version2 < 1) {
      throw new TypeError(`StyleManager error: 'version' is defined and is not a positive integer >= 1.`);
    }
    this.#selector = selector;
    this.#docKey = docKey;
    this.#version = version2;
    if (document2[this.#docKey] === void 0) {
      this.#styleElement = document2.createElement("style");
      document2.head.append(this.#styleElement);
      this.#styleElement._STYLE_MANAGER_VERSION = version2;
      this.#styleElement.sheet.insertRule(`${selector} {}`, 0);
      this.#cssRule = this.#styleElement.sheet.cssRules[0];
      document2[docKey] = this.#styleElement;
    } else {
      this.#styleElement = document2[docKey];
      this.#cssRule = this.#styleElement.sheet.cssRules[0];
      if (version2) {
        const existingVersion = this.#styleElement._STYLE_MANAGER_VERSION ?? 0;
        if (version2 > existingVersion) {
          this.#cssRule.style.cssText = "";
        }
      }
    }
  }
  /**
   * @returns {string} Provides an accessor to get the `cssText` for the style sheet.
   */
  get cssText() {
    return this.#cssRule.style.cssText;
  }
  /**
   * @returns {number} Returns the version of this instance.
   */
  get version() {
    return this.#version;
  }
  /**
   * Provides a copy constructor to duplicate an existing TJSStyleManager instance into a new document.
   *
   * Note: This is used to support the `PopOut` module.
   *
   * @param {Document} [document] Target browser document to clone into.
   *
   * @returns {TJSStyleManager} New style manager instance.
   */
  clone(document2 = globalThis.document) {
    const newStyleManager = new TJSStyleManager({
      selector: this.#selector,
      docKey: this.#docKey,
      document: document2,
      version: this.#version
    });
    newStyleManager.#cssRule.style.cssText = this.#cssRule.style.cssText;
    return newStyleManager;
  }
  get() {
    const cssText = this.#cssRule.style.cssText;
    const result = {};
    if (cssText !== "") {
      for (const entry of cssText.split(";")) {
        if (entry !== "") {
          const values = entry.split(":");
          result[values[0].trim()] = values[1];
        }
      }
    }
    return result;
  }
  /**
   * Gets a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} Returns CSS variable value.
   */
  getProperty(key) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    return this.#cssRule.style.getPropertyValue(key);
  }
  /**
   * Set rules by property / value; useful for CSS variables.
   *
   * @param {{ [key: string]: string }}  rules - An object with property / value string pairs to load.
   *
   * @param {boolean}                 [overwrite=true] - When true overwrites any existing values.
   */
  setProperties(rules, overwrite = true) {
    if (!isObject$1(rules)) {
      throw new TypeError(`StyleManager error: 'rules' is not an object.`);
    }
    if (typeof overwrite !== "boolean") {
      throw new TypeError(`StyleManager error: 'overwrite' is not a boolean.`);
    }
    if (overwrite) {
      for (const [key, value] of Object.entries(rules)) {
        this.#cssRule.style.setProperty(key, value);
      }
    } else {
      for (const [key, value] of Object.entries(rules)) {
        if (this.#cssRule.style.getPropertyValue(key) === "") {
          this.#cssRule.style.setProperty(key, value);
        }
      }
    }
  }
  /**
   * Sets a particular property.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @param {string}   value - CSS variable value.
   *
   * @param {boolean}  [overwrite=true] - Overwrite any existing value.
   */
  setProperty(key, value, overwrite = true) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    if (typeof value !== "string") {
      throw new TypeError(`StyleManager error: 'value' is not a string.`);
    }
    if (typeof overwrite !== "boolean") {
      throw new TypeError(`StyleManager error: 'overwrite' is not a boolean.`);
    }
    if (overwrite) {
      this.#cssRule.style.setProperty(key, value);
    } else {
      if (this.#cssRule.style.getPropertyValue(key) === "") {
        this.#cssRule.style.setProperty(key, value);
      }
    }
  }
  /**
   * Removes the property keys specified. If `keys` is an iterable list then all property keys in the list are removed.
   *
   * @param {Iterable<string>} keys - The property keys to remove.
   */
  removeProperties(keys) {
    if (!isIterable(keys)) {
      throw new TypeError(`StyleManager error: 'keys' is not an iterable list.`);
    }
    for (const key of keys) {
      if (typeof key === "string") {
        this.#cssRule.style.removeProperty(key);
      }
    }
  }
  /**
   * Removes a particular CSS variable.
   *
   * @param {string}   key - CSS variable property key.
   *
   * @returns {string} CSS variable value when removed.
   */
  removeProperty(key) {
    if (typeof key !== "string") {
      throw new TypeError(`StyleManager error: 'key' is not a string.`);
    }
    return this.#cssRule.style.removeProperty(key);
  }
}
const EPSILON = 1e-6;
const IDENTITY_4X4 = new Float32Array([
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1,
  0,
  0,
  0,
  0,
  1
]);
class Mat4 extends Float32Array {
  /**
   * The number of bytes in a {@link Mat4}.
   */
  static BYTE_LENGTH = 16 * Float32Array.BYTES_PER_ELEMENT;
  /**
   * Create a {@link Mat4}.
   */
  constructor(...values) {
    switch (values.length) {
      case 16:
        super(values);
        break;
      case 2:
        super(values[0], values[1], 16);
        break;
      case 1:
        const v = values[0];
        if (typeof v === "number") {
          super([
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v,
            v
          ]);
        } else {
          super(v, 0, 16);
        }
        break;
      default:
        super(IDENTITY_4X4);
        break;
    }
  }
  //============
  // Attributes
  //============
  /**
   * A string representation of `this`
   * Equivalent to `Mat4.str(this);`
   */
  get str() {
    return Mat4.str(this);
  }
  //===================
  // Instance methods
  //===================
  /**
   * Copy the values from another {@link Mat4} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(a) {
    this.set(a);
    return this;
  }
  /**
   * Set `this` to the identity matrix
   * Equivalent to Mat4.identity(this)
   *
   * @returns `this`
   */
  identity() {
    this.set(IDENTITY_4X4);
    return this;
  }
  /**
   * Multiplies this {@link Mat4} against another one
   * Equivalent to `Mat4.multiply(this, this, b);`
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `this`
   */
  multiply(b) {
    return Mat4.multiply(this, this, b);
  }
  /**
   * Alias for {@link Mat4.multiply}
   */
  mul(b) {
    return this;
  }
  /**
   * Transpose this {@link Mat4}
   * Equivalent to `Mat4.transpose(this, this);`
   *
   * @returns `this`
   */
  transpose() {
    return Mat4.transpose(this, this);
  }
  /**
   * Inverts this {@link Mat4}
   * Equivalent to `Mat4.invert(this, this);`
   *
   * @returns `this`
   */
  invert() {
    return Mat4.invert(this, this);
  }
  /**
   * Translate this {@link Mat4} by the given vector
   * Equivalent to `Mat4.translate(this, this, v);`
   *
   * @param v - The {@link Vec3} to translate by
   * @returns `this`
   */
  translate(v) {
    return Mat4.translate(this, this, v);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the given axis
   * Equivalent to `Mat4.rotate(this, this, rad, axis);`
   *
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out`
   */
  rotate(rad, axis) {
    return Mat4.rotate(this, this, rad, axis);
  }
  /**
   * Scales this {@link Mat4} by the dimensions in the given vec3 not using vectorization
   * Equivalent to `Mat4.scale(this, this, v);`
   *
   * @param v - The {@link Vec3} to scale the matrix by
   * @returns `this`
   */
  scale(v) {
    return Mat4.scale(this, this, v);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the X axis
   * Equivalent to `Mat4.rotateX(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateX(rad) {
    return Mat4.rotateX(this, this, rad);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Y axis
   * Equivalent to `Mat4.rotateY(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateY(rad) {
    return Mat4.rotateY(this, this, rad);
  }
  /**
   * Rotates this {@link Mat4} by the given angle around the Z axis
   * Equivalent to `Mat4.rotateZ(this, this, rad);`
   *
   * @param rad - the angle to rotate the matrix by
   * @returns `this`
   */
  rotateZ(rad) {
    return Mat4.rotateZ(this, this, rad);
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveNO(this, fovy, aspect, near, far);`
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveNO(fovy, aspect, near, far) {
    return Mat4.perspectiveNO(this, fovy, aspect, near, far);
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * Equivalent to `Mat4.perspectiveZO(this, fovy, aspect, near, far);`
   *
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `this`
   */
  perspectiveZO(fovy, aspect, near, far) {
    return Mat4.perspectiveZO(this, fovy, aspect, near, far);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Equivalent to `Mat4.orthoNO(this, left, right, bottom, top, near, far);`
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoNO(left, right, bottom, top, near, far) {
    return Mat4.orthoNO(this, left, right, bottom, top, near, far);
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Equivalent to `Mat4.orthoZO(this, left, right, bottom, top, near, far);`
   *
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `this`
   */
  orthoZO(left, right, bottom, top, near, far) {
    return Mat4.orthoZO(this, left, right, bottom, top, near, far);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, identity {@link Mat4}
   * @category Static
   *
   * @returns A new {@link Mat4}
   */
  static create() {
    return new Mat4();
  }
  /**
   * Creates a new {@link Mat4} initialized with values from an existing matrix
   * @category Static
   *
   * @param a - Matrix to clone
   * @returns A new {@link Mat4}
   */
  static clone(a) {
    return new Mat4(a);
  }
  /**
   * Copy the values from one {@link Mat4} to another
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - Matrix to copy
   * @returns `out`
   */
  static copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    out[3] = a[3];
    out[4] = a[4];
    out[5] = a[5];
    out[6] = a[6];
    out[7] = a[7];
    out[8] = a[8];
    out[9] = a[9];
    out[10] = a[10];
    out[11] = a[11];
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Create a new mat4 with the given values
   * @category Static
   *
   * @param values - Matrix components
   * @returns A new {@link Mat4}
   */
  static fromValues(...values) {
    return new Mat4(...values);
  }
  /**
   * Set the components of a mat4 to the given values
   * @category Static
   *
   * @param out - The receiving matrix
   * @param values - Matrix components
   * @returns `out`
   */
  static set(out, ...values) {
    out[0] = values[0];
    out[1] = values[1];
    out[2] = values[2];
    out[3] = values[3];
    out[4] = values[4];
    out[5] = values[5];
    out[6] = values[6];
    out[7] = values[7];
    out[8] = values[8];
    out[9] = values[9];
    out[10] = values[10];
    out[11] = values[11];
    out[12] = values[12];
    out[13] = values[13];
    out[14] = values[14];
    out[15] = values[15];
    return out;
  }
  /**
   * Set a {@link Mat4} to the identity matrix
   * @category Static
   *
   * @param out - The receiving Matrix
   * @returns `out`
   */
  static identity(out) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Transpose the values of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static transpose(out, a) {
    if (out === a) {
      const a01 = a[1], a02 = a[2], a03 = a[3];
      const a12 = a[6], a13 = a[7];
      const a23 = a[11];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a01;
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a02;
      out[9] = a12;
      out[11] = a[14];
      out[12] = a03;
      out[13] = a13;
      out[14] = a23;
    } else {
      out[0] = a[0];
      out[1] = a[4];
      out[2] = a[8];
      out[3] = a[12];
      out[4] = a[1];
      out[5] = a[5];
      out[6] = a[9];
      out[7] = a[13];
      out[8] = a[2];
      out[9] = a[6];
      out[10] = a[10];
      out[11] = a[14];
      out[12] = a[3];
      out[13] = a[7];
      out[14] = a[11];
      out[15] = a[15];
    }
    return out;
  }
  /**
   * Inverts a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static invert(out, a) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    let det2 = b00 * b11 - b01 * b10 + b02 * b09 + b03 * b08 - b04 * b07 + b05 * b06;
    if (!det2) {
      return null;
    }
    det2 = 1 / det2;
    out[0] = (a11 * b11 - a12 * b10 + a13 * b09) * det2;
    out[1] = (a02 * b10 - a01 * b11 - a03 * b09) * det2;
    out[2] = (a31 * b05 - a32 * b04 + a33 * b03) * det2;
    out[3] = (a22 * b04 - a21 * b05 - a23 * b03) * det2;
    out[4] = (a12 * b08 - a10 * b11 - a13 * b07) * det2;
    out[5] = (a00 * b11 - a02 * b08 + a03 * b07) * det2;
    out[6] = (a32 * b02 - a30 * b05 - a33 * b01) * det2;
    out[7] = (a20 * b05 - a22 * b02 + a23 * b01) * det2;
    out[8] = (a10 * b10 - a11 * b08 + a13 * b06) * det2;
    out[9] = (a01 * b08 - a00 * b10 - a03 * b06) * det2;
    out[10] = (a30 * b04 - a31 * b02 + a33 * b00) * det2;
    out[11] = (a21 * b02 - a20 * b04 - a23 * b00) * det2;
    out[12] = (a11 * b07 - a10 * b09 - a12 * b06) * det2;
    out[13] = (a00 * b09 - a01 * b07 + a02 * b06) * det2;
    out[14] = (a31 * b01 - a30 * b03 - a32 * b00) * det2;
    out[15] = (a20 * b03 - a21 * b01 + a22 * b00) * det2;
    return out;
  }
  /**
   * Calculates the adjugate of a {@link Mat4}
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the source matrix
   * @returns `out`
   */
  static adjoint(out, a) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    const b00 = a00 * a11 - a01 * a10;
    const b01 = a00 * a12 - a02 * a10;
    const b02 = a00 * a13 - a03 * a10;
    const b03 = a01 * a12 - a02 * a11;
    const b04 = a01 * a13 - a03 * a11;
    const b05 = a02 * a13 - a03 * a12;
    const b06 = a20 * a31 - a21 * a30;
    const b07 = a20 * a32 - a22 * a30;
    const b08 = a20 * a33 - a23 * a30;
    const b09 = a21 * a32 - a22 * a31;
    const b10 = a21 * a33 - a23 * a31;
    const b11 = a22 * a33 - a23 * a32;
    out[0] = a11 * b11 - a12 * b10 + a13 * b09;
    out[1] = a02 * b10 - a01 * b11 - a03 * b09;
    out[2] = a31 * b05 - a32 * b04 + a33 * b03;
    out[3] = a22 * b04 - a21 * b05 - a23 * b03;
    out[4] = a12 * b08 - a10 * b11 - a13 * b07;
    out[5] = a00 * b11 - a02 * b08 + a03 * b07;
    out[6] = a32 * b02 - a30 * b05 - a33 * b01;
    out[7] = a20 * b05 - a22 * b02 + a23 * b01;
    out[8] = a10 * b10 - a11 * b08 + a13 * b06;
    out[9] = a01 * b08 - a00 * b10 - a03 * b06;
    out[10] = a30 * b04 - a31 * b02 + a33 * b00;
    out[11] = a21 * b02 - a20 * b04 - a23 * b00;
    out[12] = a11 * b07 - a10 * b09 - a12 * b06;
    out[13] = a00 * b09 - a01 * b07 + a02 * b06;
    out[14] = a31 * b01 - a30 * b03 - a32 * b00;
    out[15] = a20 * b03 - a21 * b01 + a22 * b00;
    return out;
  }
  /**
   * Calculates the determinant of a {@link Mat4}
   * @category Static
   *
   * @param a - the source matrix
   * @returns determinant of a
   */
  static determinant(a) {
    const a00 = a[0], a01 = a[1], a02 = a[2], a03 = a[3];
    const a10 = a[4], a11 = a[5], a12 = a[6], a13 = a[7];
    const a20 = a[8], a21 = a[9], a22 = a[10], a23 = a[11];
    const a30 = a[12], a31 = a[13], a32 = a[14], a33 = a[15];
    const b0 = a00 * a11 - a01 * a10;
    const b1 = a00 * a12 - a02 * a10;
    const b2 = a01 * a12 - a02 * a11;
    const b3 = a20 * a31 - a21 * a30;
    const b4 = a20 * a32 - a22 * a30;
    const b5 = a21 * a32 - a22 * a31;
    const b6 = a00 * b5 - a01 * b4 + a02 * b3;
    const b7 = a10 * b5 - a11 * b4 + a12 * b3;
    const b8 = a20 * b2 - a21 * b1 + a22 * b0;
    const b9 = a30 * b2 - a31 * b1 + a32 * b0;
    return a13 * b6 - a03 * b7 + a33 * b8 - a23 * b9;
  }
  /**
   * Multiplies two {@link Mat4}s
   * @category Static
   *
   * @param out - The receiving Matrix
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static multiply(out, a, b) {
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const a30 = a[12];
    const a31 = a[13];
    const a32 = a[14];
    const a33 = a[15];
    let b0 = b[0];
    let b1 = b[1];
    let b2 = b[2];
    let b3 = b[3];
    out[0] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[1] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[2] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[3] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[4];
    b1 = b[5];
    b2 = b[6];
    b3 = b[7];
    out[4] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[5] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[6] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[7] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[8];
    b1 = b[9];
    b2 = b[10];
    b3 = b[11];
    out[8] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[9] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[10] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[11] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    b0 = b[12];
    b1 = b[13];
    b2 = b[14];
    b3 = b[15];
    out[12] = b0 * a00 + b1 * a10 + b2 * a20 + b3 * a30;
    out[13] = b0 * a01 + b1 * a11 + b2 * a21 + b3 * a31;
    out[14] = b0 * a02 + b1 * a12 + b2 * a22 + b3 * a32;
    out[15] = b0 * a03 + b1 * a13 + b2 * a23 + b3 * a33;
    return out;
  }
  /**
   * Alias for {@link Mat4.multiply}
   * @category Static
   */
  static mul(out, a, b) {
    return out;
  }
  /**
   * Translate a {@link Mat4} by the given vector
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to translate
   * @param v - vector to translate by
   * @returns `out`
   */
  static translate(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    if (a === out) {
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12];
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13];
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14];
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15];
    } else {
      const a00 = a[0];
      const a01 = a[1];
      const a02 = a[2];
      const a03 = a[3];
      const a10 = a[4];
      const a11 = a[5];
      const a12 = a[6];
      const a13 = a[7];
      const a20 = a[8];
      const a21 = a[9];
      const a22 = a[10];
      const a23 = a[11];
      out[0] = a00;
      out[1] = a01;
      out[2] = a02;
      out[3] = a03;
      out[4] = a10;
      out[5] = a11;
      out[6] = a12;
      out[7] = a13;
      out[8] = a20;
      out[9] = a21;
      out[10] = a22;
      out[11] = a23;
      out[12] = a00 * x + a10 * y + a20 * z + a[12];
      out[13] = a01 * x + a11 * y + a21 * z + a[13];
      out[14] = a02 * x + a12 * y + a22 * z + a[14];
      out[15] = a03 * x + a13 * y + a23 * z + a[15];
    }
    return out;
  }
  /**
   * Scales the {@link Mat4} by the dimensions in the given {@link Vec3} not using vectorization
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param v - the {@link Vec3} to scale the matrix by
   * @returns `out`
   **/
  static scale(out, a, v) {
    const x = v[0];
    const y = v[1];
    const z = v[2];
    out[0] = a[0] * x;
    out[1] = a[1] * x;
    out[2] = a[2] * x;
    out[3] = a[3] * x;
    out[4] = a[4] * y;
    out[5] = a[5] * y;
    out[6] = a[6] * y;
    out[7] = a[7] * y;
    out[8] = a[8] * z;
    out[9] = a[9] * z;
    out[10] = a[10] * z;
    out[11] = a[11] * z;
    out[12] = a[12];
    out[13] = a[13];
    out[14] = a[14];
    out[15] = a[15];
    return out;
  }
  /**
   * Rotates a {@link Mat4} by the given angle around the given axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out`
   */
  static rotate(out, a, rad, axis) {
    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x * x + y * y + z * z);
    if (len < EPSILON) {
      return null;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const t = 1 - c;
    const a00 = a[0];
    const a01 = a[1];
    const a02 = a[2];
    const a03 = a[3];
    const a10 = a[4];
    const a11 = a[5];
    const a12 = a[6];
    const a13 = a[7];
    const a20 = a[8];
    const a21 = a[9];
    const a22 = a[10];
    const a23 = a[11];
    const b00 = x * x * t + c;
    const b01 = y * x * t + z * s;
    const b02 = z * x * t - y * s;
    const b10 = x * y * t - z * s;
    const b11 = y * y * t + c;
    const b12 = z * y * t + x * s;
    const b20 = x * z * t + y * s;
    const b21 = y * z * t - x * s;
    const b22 = z * z * t + c;
    out[0] = a00 * b00 + a10 * b01 + a20 * b02;
    out[1] = a01 * b00 + a11 * b01 + a21 * b02;
    out[2] = a02 * b00 + a12 * b01 + a22 * b02;
    out[3] = a03 * b00 + a13 * b01 + a23 * b02;
    out[4] = a00 * b10 + a10 * b11 + a20 * b12;
    out[5] = a01 * b10 + a11 * b11 + a21 * b12;
    out[6] = a02 * b10 + a12 * b11 + a22 * b12;
    out[7] = a03 * b10 + a13 * b11 + a23 * b12;
    out[8] = a00 * b20 + a10 * b21 + a20 * b22;
    out[9] = a01 * b20 + a11 * b21 + a21 * b22;
    out[10] = a02 * b20 + a12 * b21 + a22 * b22;
    out[11] = a03 * b20 + a13 * b21 + a23 * b22;
    if (a !== out) {
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the X axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateX(out, a, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    let a10 = a[4];
    let a11 = a[5];
    let a12 = a[6];
    let a13 = a[7];
    let a20 = a[8];
    let a21 = a[9];
    let a22 = a[10];
    let a23 = a[11];
    if (a !== out) {
      out[0] = a[0];
      out[1] = a[1];
      out[2] = a[2];
      out[3] = a[3];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[4] = a10 * c + a20 * s;
    out[5] = a11 * c + a21 * s;
    out[6] = a12 * c + a22 * s;
    out[7] = a13 * c + a23 * s;
    out[8] = a20 * c - a10 * s;
    out[9] = a21 * c - a11 * s;
    out[10] = a22 * c - a12 * s;
    out[11] = a23 * c - a13 * s;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Y axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateY(out, a, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    let a00 = a[0];
    let a01 = a[1];
    let a02 = a[2];
    let a03 = a[3];
    let a20 = a[8];
    let a21 = a[9];
    let a22 = a[10];
    let a23 = a[11];
    if (a !== out) {
      out[4] = a[4];
      out[5] = a[5];
      out[6] = a[6];
      out[7] = a[7];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c - a20 * s;
    out[1] = a01 * c - a21 * s;
    out[2] = a02 * c - a22 * s;
    out[3] = a03 * c - a23 * s;
    out[8] = a00 * s + a20 * c;
    out[9] = a01 * s + a21 * c;
    out[10] = a02 * s + a22 * c;
    out[11] = a03 * s + a23 * c;
    return out;
  }
  /**
   * Rotates a matrix by the given angle around the Z axis
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to rotate
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static rotateZ(out, a, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    let a00 = a[0];
    let a01 = a[1];
    let a02 = a[2];
    let a03 = a[3];
    let a10 = a[4];
    let a11 = a[5];
    let a12 = a[6];
    let a13 = a[7];
    if (a !== out) {
      out[8] = a[8];
      out[9] = a[9];
      out[10] = a[10];
      out[11] = a[11];
      out[12] = a[12];
      out[13] = a[13];
      out[14] = a[14];
      out[15] = a[15];
    }
    out[0] = a00 * c + a10 * s;
    out[1] = a01 * c + a11 * s;
    out[2] = a02 * c + a12 * s;
    out[3] = a03 * c + a13 * s;
    out[4] = a10 * c - a00 * s;
    out[5] = a11 * c - a01 * s;
    out[6] = a12 * c - a02 * s;
    out[7] = a13 * c - a03 * s;
    return out;
  }
  /**
   * Creates a {@link Mat4} from a vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Translation vector
   * @returns `out`
   */
  static fromTranslation(out, v) {
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a {@link Mat4} from a vector scaling
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.scale(dest, dest, vec);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param v - Scaling vector
   * @returns `out`
   */
  static fromScaling(out, v) {
    out[0] = v[0];
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = v[1];
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = v[2];
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a {@link Mat4} from a given angle around a given axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotate(dest, dest, rad, axis);
   * @category Static
   *
   * @param out - {@link Mat4} receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @param axis - the axis to rotate around
   * @returns `out`
   */
  static fromRotation(out, rad, axis) {
    let x = axis[0];
    let y = axis[1];
    let z = axis[2];
    let len = Math.sqrt(x * x + y * y + z * z);
    if (len < EPSILON) {
      return null;
    }
    len = 1 / len;
    x *= len;
    y *= len;
    z *= len;
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    const t = 1 - c;
    out[0] = x * x * t + c;
    out[1] = y * x * t + z * s;
    out[2] = z * x * t - y * s;
    out[3] = 0;
    out[4] = x * y * t - z * s;
    out[5] = y * y * t + c;
    out[6] = z * y * t + x * s;
    out[7] = 0;
    out[8] = x * z * t + y * s;
    out[9] = y * z * t - x * s;
    out[10] = z * z * t + c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the X axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateX(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromXRotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    out[0] = 1;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = c;
    out[6] = s;
    out[7] = 0;
    out[8] = 0;
    out[9] = -s;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Y axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateY(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromYRotation(out, rad) {
    let s = Math.sin(rad);
    let c = Math.cos(rad);
    out[0] = c;
    out[1] = 0;
    out[2] = -s;
    out[3] = 0;
    out[4] = 0;
    out[5] = 1;
    out[6] = 0;
    out[7] = 0;
    out[8] = s;
    out[9] = 0;
    out[10] = c;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from the given angle around the Z axis
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.rotateZ(dest, dest, rad);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param rad - the angle to rotate the matrix by
   * @returns `out`
   */
  static fromZRotation(out, rad) {
    const s = Math.sin(rad);
    const c = Math.cos(rad);
    out[0] = c;
    out[1] = s;
    out[2] = 0;
    out[3] = 0;
    out[4] = -s;
    out[5] = c;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 1;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation and vector translation
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @returns `out`
   */
  static fromRotationTranslation(out, q, v) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    out[0] = 1 - (yy + zz);
    out[1] = xy + wz;
    out[2] = xz - wy;
    out[3] = 0;
    out[4] = xy - wz;
    out[5] = 1 - (xx + zz);
    out[6] = yz + wx;
    out[7] = 0;
    out[8] = xz + wy;
    out[9] = yz - wx;
    out[10] = 1 - (xx + yy);
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Sets a {@link Mat4} from a {@link Quat2}.
   * @category Static
   *
   * @param out - Matrix
   * @param a - Dual Quaternion
   * @returns `out`
   */
  static fromQuat2(out, a) {
    let translation = [0, 0, 0];
    const bx = -a[0];
    const by = -a[1];
    const bz = -a[2];
    const bw = a[3];
    const ax = a[4];
    const ay = a[5];
    const az = a[6];
    const aw = a[7];
    let magnitude = bx * bx + by * by + bz * bz + bw * bw;
    if (magnitude > 0) {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2 / magnitude;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2 / magnitude;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2 / magnitude;
    } else {
      translation[0] = (ax * bw + aw * bx + ay * bz - az * by) * 2;
      translation[1] = (ay * bw + aw * by + az * bx - ax * bz) * 2;
      translation[2] = (az * bw + aw * bz + ax * by - ay * bx) * 2;
    }
    Mat4.fromRotationTranslation(out, a, translation);
    return out;
  }
  /**
   * Returns the translation vector component of a transformation
   * matrix. If a matrix is built with fromRotationTranslation,
   * the returned vector will be the same as the translation vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive translation component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getTranslation(out, mat) {
    out[0] = mat[12];
    out[1] = mat[13];
    out[2] = mat[14];
    return out;
  }
  /**
   * Returns the scaling factor component of a transformation
   * matrix. If a matrix is built with fromRotationTranslationScale
   * with a normalized Quaternion paramter, the returned vector will be
   * the same as the scaling vector
   * originally supplied.
   * @category Static
   *
   * @param  {vec3} out Vector to receive scaling factor component
   * @param  {ReadonlyMat4} mat Matrix to be decomposed (input)
   * @return {vec3} out
   */
  static getScaling(out, mat) {
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    return out;
  }
  /**
   * Returns a quaternion representing the rotational component
   * of a transformation matrix. If a matrix is built with
   * fromRotationTranslation, the returned quaternion will be the
   * same as the quaternion originally supplied.
   * @category Static
   *
   * @param out - Quaternion to receive the rotation component
   * @param mat - Matrix to be decomposed (input)
   * @return `out`
   */
  static getRotation(out, mat) {
    Mat4.getScaling(tmpVec3$1, mat);
    const is1 = 1 / tmpVec3$1[0];
    const is2 = 1 / tmpVec3$1[1];
    const is3 = 1 / tmpVec3$1[2];
    const sm11 = mat[0] * is1;
    const sm12 = mat[1] * is2;
    const sm13 = mat[2] * is3;
    const sm21 = mat[4] * is1;
    const sm22 = mat[5] * is2;
    const sm23 = mat[6] * is3;
    const sm31 = mat[8] * is1;
    const sm32 = mat[9] * is2;
    const sm33 = mat[10] * is3;
    const trace2 = sm11 + sm22 + sm33;
    let S = 0;
    if (trace2 > 0) {
      S = Math.sqrt(trace2 + 1) * 2;
      out[3] = 0.25 * S;
      out[0] = (sm23 - sm32) / S;
      out[1] = (sm31 - sm13) / S;
      out[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out[3] = (sm23 - sm32) / S;
      out[0] = 0.25 * S;
      out[1] = (sm12 + sm21) / S;
      out[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out[3] = (sm31 - sm13) / S;
      out[0] = (sm12 + sm21) / S;
      out[1] = 0.25 * S;
      out[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out[3] = (sm12 - sm21) / S;
      out[0] = (sm31 + sm13) / S;
      out[1] = (sm23 + sm32) / S;
      out[2] = 0.25 * S;
    }
    return out;
  }
  /**
   * Decomposes a transformation matrix into its rotation, translation
   * and scale components. Returns only the rotation component
   * @category Static
   *
   * @param out_r - Quaternion to receive the rotation component
   * @param out_t - Vector to receive the translation vector
   * @param out_s - Vector to receive the scaling factor
   * @param mat - Matrix to be decomposed (input)
   * @returns `out_r`
   */
  static decompose(out_r, out_t, out_s, mat) {
    out_t[0] = mat[12];
    out_t[1] = mat[13];
    out_t[2] = mat[14];
    const m11 = mat[0];
    const m12 = mat[1];
    const m13 = mat[2];
    const m21 = mat[4];
    const m22 = mat[5];
    const m23 = mat[6];
    const m31 = mat[8];
    const m32 = mat[9];
    const m33 = mat[10];
    out_s[0] = Math.sqrt(m11 * m11 + m12 * m12 + m13 * m13);
    out_s[1] = Math.sqrt(m21 * m21 + m22 * m22 + m23 * m23);
    out_s[2] = Math.sqrt(m31 * m31 + m32 * m32 + m33 * m33);
    const is1 = 1 / out_s[0];
    const is2 = 1 / out_s[1];
    const is3 = 1 / out_s[2];
    const sm11 = m11 * is1;
    const sm12 = m12 * is2;
    const sm13 = m13 * is3;
    const sm21 = m21 * is1;
    const sm22 = m22 * is2;
    const sm23 = m23 * is3;
    const sm31 = m31 * is1;
    const sm32 = m32 * is2;
    const sm33 = m33 * is3;
    const trace2 = sm11 + sm22 + sm33;
    let S = 0;
    if (trace2 > 0) {
      S = Math.sqrt(trace2 + 1) * 2;
      out_r[3] = 0.25 * S;
      out_r[0] = (sm23 - sm32) / S;
      out_r[1] = (sm31 - sm13) / S;
      out_r[2] = (sm12 - sm21) / S;
    } else if (sm11 > sm22 && sm11 > sm33) {
      S = Math.sqrt(1 + sm11 - sm22 - sm33) * 2;
      out_r[3] = (sm23 - sm32) / S;
      out_r[0] = 0.25 * S;
      out_r[1] = (sm12 + sm21) / S;
      out_r[2] = (sm31 + sm13) / S;
    } else if (sm22 > sm33) {
      S = Math.sqrt(1 + sm22 - sm11 - sm33) * 2;
      out_r[3] = (sm31 - sm13) / S;
      out_r[0] = (sm12 + sm21) / S;
      out_r[1] = 0.25 * S;
      out_r[2] = (sm23 + sm32) / S;
    } else {
      S = Math.sqrt(1 + sm33 - sm11 - sm22) * 2;
      out_r[3] = (sm12 - sm21) / S;
      out_r[0] = (sm31 + sm13) / S;
      out_r[1] = (sm23 + sm32) / S;
      out_r[2] = 0.25 * S;
    }
    return out_r;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @returns `out`
   */
  static fromRotationTranslationScale(out, q, v, s) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    const sx = s[0];
    const sy = s[1];
    const sz = s[2];
    out[0] = (1 - (yy + zz)) * sx;
    out[1] = (xy + wz) * sx;
    out[2] = (xz - wy) * sx;
    out[3] = 0;
    out[4] = (xy - wz) * sy;
    out[5] = (1 - (xx + zz)) * sy;
    out[6] = (yz + wx) * sy;
    out[7] = 0;
    out[8] = (xz + wy) * sz;
    out[9] = (yz - wx) * sz;
    out[10] = (1 - (xx + yy)) * sz;
    out[11] = 0;
    out[12] = v[0];
    out[13] = v[1];
    out[14] = v[2];
    out[15] = 1;
    return out;
  }
  /**
   * Creates a matrix from a quaternion rotation, vector translation and vector scale, rotating and scaling around the given origin
   * This is equivalent to (but much faster than):
   *
   *     mat4.identity(dest);
   *     mat4.translate(dest, vec);
   *     mat4.translate(dest, origin);
   *     let quatMat = mat4.create();
   *     quat4.toMat4(quat, quatMat);
   *     mat4.multiply(dest, quatMat);
   *     mat4.scale(dest, scale)
   *     mat4.translate(dest, negativeOrigin);
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Rotation quaternion
   * @param v - Translation vector
   * @param s - Scaling vector
   * @param o - The origin vector around which to scale and rotate
   * @returns `out`
   */
  static fromRotationTranslationScaleOrigin(out, q, v, s, o) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const xy = x * y2;
    const xz = x * z2;
    const yy = y * y2;
    const yz = y * z2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    const sx = s[0];
    const sy = s[1];
    const sz = s[2];
    const ox = o[0];
    const oy = o[1];
    const oz = o[2];
    const out0 = (1 - (yy + zz)) * sx;
    const out1 = (xy + wz) * sx;
    const out2 = (xz - wy) * sx;
    const out4 = (xy - wz) * sy;
    const out5 = (1 - (xx + zz)) * sy;
    const out6 = (yz + wx) * sy;
    const out8 = (xz + wy) * sz;
    const out9 = (yz - wx) * sz;
    const out10 = (1 - (xx + yy)) * sz;
    out[0] = out0;
    out[1] = out1;
    out[2] = out2;
    out[3] = 0;
    out[4] = out4;
    out[5] = out5;
    out[6] = out6;
    out[7] = 0;
    out[8] = out8;
    out[9] = out9;
    out[10] = out10;
    out[11] = 0;
    out[12] = v[0] + ox - (out0 * ox + out4 * oy + out8 * oz);
    out[13] = v[1] + oy - (out1 * ox + out5 * oy + out9 * oz);
    out[14] = v[2] + oz - (out2 * ox + out6 * oy + out10 * oz);
    out[15] = 1;
    return out;
  }
  /**
   * Calculates a 4x4 matrix from the given quaternion
   * @category Static
   *
   * @param out - mat4 receiving operation result
   * @param q - Quaternion to create matrix from
   * @returns `out`
   */
  static fromQuat(out, q) {
    const x = q[0];
    const y = q[1];
    const z = q[2];
    const w = q[3];
    const x2 = x + x;
    const y2 = y + y;
    const z2 = z + z;
    const xx = x * x2;
    const yx = y * x2;
    const yy = y * y2;
    const zx = z * x2;
    const zy = z * y2;
    const zz = z * z2;
    const wx = w * x2;
    const wy = w * y2;
    const wz = w * z2;
    out[0] = 1 - yy - zz;
    out[1] = yx + wz;
    out[2] = zx - wy;
    out[3] = 0;
    out[4] = yx - wz;
    out[5] = 1 - xx - zz;
    out[6] = zy + wx;
    out[7] = 0;
    out[8] = zx + wy;
    out[9] = zy - wx;
    out[10] = 1 - xx - yy;
    out[11] = 0;
    out[12] = 0;
    out[13] = 0;
    out[14] = 0;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a frustum matrix with the given bounds
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static frustum(out, left, right, bottom, top, near, far) {
    const rl = 1 / (right - left);
    const tb = 1 / (top - bottom);
    const nf = 1 / (near - far);
    out[0] = near * 2 * rl;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = near * 2 * tb;
    out[6] = 0;
    out[7] = 0;
    out[8] = (right + left) * rl;
    out[9] = (top + bottom) * tb;
    out[10] = (far + near) * nf;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near * 2 * nf;
    out[15] = 0;
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveNO(out, fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = (far + near) * nf;
      out[14] = 2 * far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -2 * near;
    }
    return out;
  }
  /**
   * Alias for {@link Mat4.perspectiveNO}
   * @category Static
   * @deprecated Use {@link Mat4.perspectiveNO} or {@link Mat4.perspectiveZO} explicitly
   */
  static perspective(out, fovy, aspect, near, far) {
    return out;
  }
  /**
   * Generates a perspective projection matrix suitable for WebGPU with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * Passing null/undefined/no value for far will generate infinite projection matrix.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fovy - Vertical field of view in radians
   * @param aspect - Aspect ratio. typically viewport width/height
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum, can be null or Infinity
   * @returns `out`
   */
  static perspectiveZO(out, fovy, aspect, near, far) {
    const f = 1 / Math.tan(fovy / 2);
    out[0] = f / aspect;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = f;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[15] = 0;
    if (far != null && far !== Infinity) {
      const nf = 1 / (near - far);
      out[10] = far * nf;
      out[14] = far * near * nf;
    } else {
      out[10] = -1;
      out[14] = -near;
    }
    return out;
  }
  /**
   * Generates a perspective projection matrix with the given field of view.
   * This is primarily useful for generating projection matrices to be used
   * with the still experiemental WebVR API.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param fov - Object containing the following values: upDegrees, downDegrees, leftDegrees, rightDegrees
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   * @deprecated
   */
  static perspectiveFromFieldOfView(out, fov, near, far) {
    const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
    const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
    const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
    const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
    const xScale = 2 / (leftTan + rightTan);
    const yScale = 2 / (upTan + downTan);
    out[0] = xScale;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = yScale;
    out[6] = 0;
    out[7] = 0;
    out[8] = -((leftTan - rightTan) * xScale * 0.5);
    out[9] = (upTan - downTan) * yScale * 0.5;
    out[10] = far / (near - far);
    out[11] = -1;
    out[12] = 0;
    out[13] = 0;
    out[14] = far * near / (near - far);
    out[15] = 0;
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [-1, 1],
   * which matches WebGL/OpenGL's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoNO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = 2 * nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = (far + near) * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Alias for {@link Mat4.orthoNO}
   * @category Static
   * @deprecated Use {@link Mat4.orthoNO} or {@link Mat4.orthoZO} explicitly
   */
  static ortho(out, left, right, bottom, top, near, far) {
    return out;
  }
  /**
   * Generates a orthogonal projection matrix with the given bounds.
   * The near/far clip planes correspond to a normalized device coordinate Z range of [0, 1],
   * which matches WebGPU/Vulkan/DirectX/Metal's clip volume.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param left - Left bound of the frustum
   * @param right - Right bound of the frustum
   * @param bottom - Bottom bound of the frustum
   * @param top - Top bound of the frustum
   * @param near - Near bound of the frustum
   * @param far - Far bound of the frustum
   * @returns `out`
   */
  static orthoZO(out, left, right, bottom, top, near, far) {
    const lr = 1 / (left - right);
    const bt = 1 / (bottom - top);
    const nf = 1 / (near - far);
    out[0] = -2 * lr;
    out[1] = 0;
    out[2] = 0;
    out[3] = 0;
    out[4] = 0;
    out[5] = -2 * bt;
    out[6] = 0;
    out[7] = 0;
    out[8] = 0;
    out[9] = 0;
    out[10] = nf;
    out[11] = 0;
    out[12] = (left + right) * lr;
    out[13] = (top + bottom) * bt;
    out[14] = near * nf;
    out[15] = 1;
    return out;
  }
  /**
   * Generates a look-at matrix with the given eye position, focal point, and up axis.
   * If you want a matrix that actually makes an object look at another object, you should use targetTo instead.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param center - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static lookAt(out, eye, center, up) {
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    const centerx = center[0];
    const centery = center[1];
    const centerz = center[2];
    if (Math.abs(eyex - centerx) < EPSILON && Math.abs(eyey - centery) < EPSILON && Math.abs(eyez - centerz) < EPSILON) {
      return Mat4.identity(out);
    }
    let z0 = eyex - centerx;
    let z1 = eyey - centery;
    let z2 = eyez - centerz;
    let len = 1 / Math.sqrt(z0 * z0 + z1 * z1 + z2 * z2);
    z0 *= len;
    z1 *= len;
    z2 *= len;
    let x0 = upy * z2 - upz * z1;
    let x1 = upz * z0 - upx * z2;
    let x2 = upx * z1 - upy * z0;
    len = Math.sqrt(x0 * x0 + x1 * x1 + x2 * x2);
    if (!len) {
      x0 = 0;
      x1 = 0;
      x2 = 0;
    } else {
      len = 1 / len;
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    let y0 = z1 * x2 - z2 * x1;
    let y1 = z2 * x0 - z0 * x2;
    let y2 = z0 * x1 - z1 * x0;
    len = Math.sqrt(y0 * y0 + y1 * y1 + y2 * y2);
    if (!len) {
      y0 = 0;
      y1 = 0;
      y2 = 0;
    } else {
      len = 1 / len;
      y0 *= len;
      y1 *= len;
      y2 *= len;
    }
    out[0] = x0;
    out[1] = y0;
    out[2] = z0;
    out[3] = 0;
    out[4] = x1;
    out[5] = y1;
    out[6] = z1;
    out[7] = 0;
    out[8] = x2;
    out[9] = y2;
    out[10] = z2;
    out[11] = 0;
    out[12] = -(x0 * eyex + x1 * eyey + x2 * eyez);
    out[13] = -(y0 * eyex + y1 * eyey + y2 * eyez);
    out[14] = -(z0 * eyex + z1 * eyey + z2 * eyez);
    out[15] = 1;
    return out;
  }
  /**
   * Generates a matrix that makes something look at something else.
   * @category Static
   *
   * @param out - mat4 frustum matrix will be written into
   * @param eye - Position of the viewer
   * @param target - Point the viewer is looking at
   * @param up - vec3 pointing up
   * @returns `out`
   */
  static targetTo(out, eye, target, up) {
    const eyex = eye[0];
    const eyey = eye[1];
    const eyez = eye[2];
    const upx = up[0];
    const upy = up[1];
    const upz = up[2];
    let z0 = eyex - target[0];
    let z1 = eyey - target[1];
    let z2 = eyez - target[2];
    let len = z0 * z0 + z1 * z1 + z2 * z2;
    if (len > 0) {
      len = 1 / Math.sqrt(len);
      z0 *= len;
      z1 *= len;
      z2 *= len;
    }
    let x0 = upy * z2 - upz * z1;
    let x1 = upz * z0 - upx * z2;
    let x2 = upx * z1 - upy * z0;
    len = x0 * x0 + x1 * x1 + x2 * x2;
    if (len > 0) {
      len = 1 / Math.sqrt(len);
      x0 *= len;
      x1 *= len;
      x2 *= len;
    }
    out[0] = x0;
    out[1] = x1;
    out[2] = x2;
    out[3] = 0;
    out[4] = z1 * x2 - z2 * x1;
    out[5] = z2 * x0 - z0 * x2;
    out[6] = z0 * x1 - z1 * x0;
    out[7] = 0;
    out[8] = z0;
    out[9] = z1;
    out[10] = z2;
    out[11] = 0;
    out[12] = eyex;
    out[13] = eyey;
    out[14] = eyez;
    out[15] = 1;
    return out;
  }
  /**
   * Returns Frobenius norm of a {@link Mat4}
   * @category Static
   *
   * @param a - the matrix to calculate Frobenius norm of
   * @returns Frobenius norm
   */
  static frob(a) {
    return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2] + a[3] * a[3] + a[4] * a[4] + a[5] * a[5] + a[6] * a[6] + a[7] * a[7] + a[8] * a[8] + a[9] * a[9] + a[10] * a[10] + a[11] * a[11] + a[12] * a[12] + a[13] * a[13] + a[14] * a[14] + a[15] * a[15]);
  }
  /**
   * Adds two {@link Mat4}'s
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    out[3] = a[3] + b[3];
    out[4] = a[4] + b[4];
    out[5] = a[5] + b[5];
    out[6] = a[6] + b[6];
    out[7] = a[7] + b[7];
    out[8] = a[8] + b[8];
    out[9] = a[9] + b[9];
    out[10] = a[10] + b[10];
    out[11] = a[11] + b[11];
    out[12] = a[12] + b[12];
    out[13] = a[13] + b[13];
    out[14] = a[14] + b[14];
    out[15] = a[15] + b[15];
    return out;
  }
  /**
   * Subtracts matrix b from matrix a
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    out[3] = a[3] - b[3];
    out[4] = a[4] - b[4];
    out[5] = a[5] - b[5];
    out[6] = a[6] - b[6];
    out[7] = a[7] - b[7];
    out[8] = a[8] - b[8];
    out[9] = a[9] - b[9];
    out[10] = a[10] - b[10];
    out[11] = a[11] - b[11];
    out[12] = a[12] - b[12];
    out[13] = a[13] - b[13];
    out[14] = a[14] - b[14];
    out[15] = a[15] - b[15];
    return out;
  }
  /**
   * Alias for {@link Mat4.subtract}
   * @category Static
   */
  static sub(out, a, b) {
    return out;
  }
  /**
   * Multiply each element of the matrix by a scalar.
   * @category Static
   *
   * @param out - the receiving matrix
   * @param a - the matrix to scale
   * @param b - amount to scale the matrix's elements by
   * @returns `out`
   */
  static multiplyScalar(out, a, b) {
    out[0] = a[0] * b;
    out[1] = a[1] * b;
    out[2] = a[2] * b;
    out[3] = a[3] * b;
    out[4] = a[4] * b;
    out[5] = a[5] * b;
    out[6] = a[6] * b;
    out[7] = a[7] * b;
    out[8] = a[8] * b;
    out[9] = a[9] * b;
    out[10] = a[10] * b;
    out[11] = a[11] * b;
    out[12] = a[12] * b;
    out[13] = a[13] * b;
    out[14] = a[14] * b;
    out[15] = a[15] * b;
    return out;
  }
  /**
   * Adds two mat4's after multiplying each element of the second operand by a scalar value.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b's elements by before adding
   * @returns `out`
   */
  static multiplyScalarAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    out[3] = a[3] + b[3] * scale;
    out[4] = a[4] + b[4] * scale;
    out[5] = a[5] + b[5] * scale;
    out[6] = a[6] + b[6] * scale;
    out[7] = a[7] + b[7] * scale;
    out[8] = a[8] + b[8] * scale;
    out[9] = a[9] + b[9] * scale;
    out[10] = a[10] + b[10] * scale;
    out[11] = a[11] + b[11] * scale;
    out[12] = a[12] + b[12] * scale;
    out[13] = a[13] + b[13] * scale;
    out[14] = a[14] + b[14] * scale;
    out[15] = a[15] + b[15] * scale;
    return out;
  }
  /**
   * Returns whether or not two {@link Mat4}s have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2] && a[3] === b[3] && a[4] === b[4] && a[5] === b[5] && a[6] === b[6] && a[7] === b[7] && a[8] === b[8] && a[9] === b[9] && a[10] === b[10] && a[11] === b[11] && a[12] === b[12] && a[13] === b[13] && a[14] === b[14] && a[15] === b[15];
  }
  /**
   * Returns whether or not two {@link Mat4}s have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first matrix.
   * @param b - The second matrix.
   * @returns True if the matrices are equal, false otherwise.
   */
  static equals(a, b) {
    const a0 = a[0];
    const a1 = a[1];
    const a2 = a[2];
    const a3 = a[3];
    const a4 = a[4];
    const a5 = a[5];
    const a6 = a[6];
    const a7 = a[7];
    const a8 = a[8];
    const a9 = a[9];
    const a10 = a[10];
    const a11 = a[11];
    const a12 = a[12];
    const a13 = a[13];
    const a14 = a[14];
    const a15 = a[15];
    const b0 = b[0];
    const b1 = b[1];
    const b2 = b[2];
    const b3 = b[3];
    const b4 = b[4];
    const b5 = b[5];
    const b6 = b[6];
    const b7 = b[7];
    const b8 = b[8];
    const b9 = b[9];
    const b10 = b[10];
    const b11 = b[11];
    const b12 = b[12];
    const b13 = b[13];
    const b14 = b[14];
    const b15 = b[15];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2)) && Math.abs(a3 - b3) <= EPSILON * Math.max(1, Math.abs(a3), Math.abs(b3)) && Math.abs(a4 - b4) <= EPSILON * Math.max(1, Math.abs(a4), Math.abs(b4)) && Math.abs(a5 - b5) <= EPSILON * Math.max(1, Math.abs(a5), Math.abs(b5)) && Math.abs(a6 - b6) <= EPSILON * Math.max(1, Math.abs(a6), Math.abs(b6)) && Math.abs(a7 - b7) <= EPSILON * Math.max(1, Math.abs(a7), Math.abs(b7)) && Math.abs(a8 - b8) <= EPSILON * Math.max(1, Math.abs(a8), Math.abs(b8)) && Math.abs(a9 - b9) <= EPSILON * Math.max(1, Math.abs(a9), Math.abs(b9)) && Math.abs(a10 - b10) <= EPSILON * Math.max(1, Math.abs(a10), Math.abs(b10)) && Math.abs(a11 - b11) <= EPSILON * Math.max(1, Math.abs(a11), Math.abs(b11)) && Math.abs(a12 - b12) <= EPSILON * Math.max(1, Math.abs(a12), Math.abs(b12)) && Math.abs(a13 - b13) <= EPSILON * Math.max(1, Math.abs(a13), Math.abs(b13)) && Math.abs(a14 - b14) <= EPSILON * Math.max(1, Math.abs(a14), Math.abs(b14)) && Math.abs(a15 - b15) <= EPSILON * Math.max(1, Math.abs(a15), Math.abs(b15));
  }
  /**
   * Returns a string representation of a {@link Mat4}
   * @category Static
   *
   * @param a - matrix to represent as a string
   * @returns string representation of the matrix
   */
  static str(a) {
    return `Mat4(${a.join(", ")})`;
  }
}
const tmpVec3$1 = [0, 0, 0];
Mat4.prototype.mul = Mat4.prototype.multiply;
Mat4.sub = Mat4.subtract;
Mat4.mul = Mat4.multiply;
Mat4.perspective = Mat4.perspectiveNO;
Mat4.ortho = Mat4.orthoNO;
class Vec3 extends Float32Array {
  /**
  * The number of bytes in a {@link Vec3}.
  */
  static BYTE_LENGTH = 3 * Float32Array.BYTES_PER_ELEMENT;
  /**
  * Create a {@link Vec3}.
  */
  constructor(...values) {
    switch (values.length) {
      case 3:
        super(values);
        break;
      case 2:
        super(values[0], values[1], 3);
        break;
      case 1: {
        const v = values[0];
        if (typeof v === "number") {
          super([v, v, v]);
        } else {
          super(v, 0, 3);
        }
        break;
      }
      default:
        super(3);
        break;
    }
  }
  //============
  // Attributes
  //============
  // Getters and setters to make component access read better.
  // These are likely to be a little bit slower than direct array access.
  /**
   * The x component of the vector. Equivalent to `this[0];`
   * @category Vector components
   */
  get x() {
    return this[0];
  }
  set x(value) {
    this[0] = value;
  }
  /**
   * The y component of the vector. Equivalent to `this[1];`
   * @category Vector components
   */
  get y() {
    return this[1];
  }
  set y(value) {
    this[1] = value;
  }
  /**
   * The z component of the vector. Equivalent to `this[2];`
   * @category Vector components
   */
  get z() {
    return this[2];
  }
  set z(value) {
    this[2] = value;
  }
  // Alternate set of getters and setters in case this is being used to define
  // a color.
  /**
   * The r component of the vector. Equivalent to `this[0];`
   * @category Color components
   */
  get r() {
    return this[0];
  }
  set r(value) {
    this[0] = value;
  }
  /**
   * The g component of the vector. Equivalent to `this[1];`
   * @category Color components
   */
  get g() {
    return this[1];
  }
  set g(value) {
    this[1] = value;
  }
  /**
   * The b component of the vector. Equivalent to `this[2];`
   * @category Color components
   */
  get b() {
    return this[2];
  }
  set b(value) {
    this[2] = value;
  }
  /**
   * The magnitude (length) of this.
   * Equivalent to `Vec3.magnitude(this);`
   *
   * Magnitude is used because the `length` attribute is already defined by
   * `Float32Array` to mean the number of elements in the array.
   */
  get magnitude() {
    const x = this[0];
    const y = this[1];
    const z = this[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   */
  get mag() {
    return this.magnitude;
  }
  /**
   * The squared magnitude (length) of `this`.
   * Equivalent to `Vec3.squaredMagnitude(this);`
   */
  get squaredMagnitude() {
    const x = this[0];
    const y = this[1];
    const z = this[2];
    return x * x + y * y + z * z;
  }
  /**
   * Alias for {@link Vec3.squaredMagnitude}
   */
  get sqrMag() {
    return this.squaredMagnitude;
  }
  /**
   * A string representation of `this`
   * Equivalent to `Vec3.str(this);`
   */
  get str() {
    return Vec3.str(this);
  }
  //===================
  // Instances methods
  //===================
  /**
   * Copy the values from another {@link Vec3} into `this`.
   *
   * @param a the source vector
   * @returns `this`
   */
  copy(a) {
    this.set(a);
    return this;
  }
  /**
   * Adds a {@link Vec3} to `this`.
   * Equivalent to `Vec3.add(this, this, b);`
   *
   * @param b - The vector to add to `this`
   * @returns `this`
   */
  add(b) {
    this[0] += b[0];
    this[1] += b[1];
    this[2] += b[2];
    return this;
  }
  /**
   * Subtracts a {@link Vec3} from `this`.
   * Equivalent to `Vec3.subtract(this, this, b);`
   *
   * @param b - The vector to subtract from `this`
   * @returns `this`
   */
  subtract(b) {
    this[0] -= b[0];
    this[1] -= b[1];
    this[2] -= b[2];
    return this;
  }
  /**
   * Alias for {@link Vec3.subtract}
   */
  sub(b) {
    return this;
  }
  /**
   * Multiplies `this` by a {@link Vec3}.
   * Equivalent to `Vec3.multiply(this, this, b);`
   *
   * @param b - The vector to multiply `this` by
   * @returns `this`
   */
  multiply(b) {
    this[0] *= b[0];
    this[1] *= b[1];
    this[2] *= b[2];
    return this;
  }
  /**
   * Alias for {@link Vec3.multiply}
   */
  mul(b) {
    return this;
  }
  /**
   * Divides `this` by a {@link Vec3}.
   * Equivalent to `Vec3.divide(this, this, b);`
   *
   * @param b - The vector to divide `this` by
   * @returns `this`
   */
  divide(b) {
    this[0] /= b[0];
    this[1] /= b[1];
    this[2] /= b[2];
    return this;
  }
  /**
   * Alias for {@link Vec3.divide}
   */
  div(b) {
    return this;
  }
  /**
   * Scales `this` by a scalar number.
   * Equivalent to `Vec3.scale(this, this, b);`
   *
   * @param b - Amount to scale `this` by
   * @returns `this`
   */
  scale(b) {
    this[0] *= b;
    this[1] *= b;
    this[2] *= b;
    return this;
  }
  /**
   * Calculates `this` scaled by a scalar value then adds the result to `this`.
   * Equivalent to `Vec3.scaleAndAdd(this, this, b, scale);`
   *
   * @param b - The vector to add to `this`
   * @param scale - The amount to scale `b` by before adding
   * @returns `this`
   */
  scaleAndAdd(b, scale) {
    this[0] += b[0] * scale;
    this[1] += b[1] * scale;
    this[2] += b[2] * scale;
    return this;
  }
  /**
   * Calculates the euclidian distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.distance(this, b);`
   *
   * @param b - The vector to calculate the distance to
   * @returns Distance between `this` and `b`
   */
  distance(b) {
    return Vec3.distance(this, b);
  }
  /**
   * Alias for {@link Vec3.distance}
   */
  dist(b) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between another {@link Vec3} and `this`.
   * Equivalent to `Vec3.squaredDistance(this, b);`
   *
   * @param b The vector to calculate the squared distance to
   * @returns Squared distance between `this` and `b`
   */
  squaredDistance(b) {
    return Vec3.squaredDistance(this, b);
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   */
  sqrDist(b) {
    return 0;
  }
  /**
   * Negates the components of `this`.
   * Equivalent to `Vec3.negate(this, this);`
   *
   * @returns `this`
   */
  negate() {
    this[0] *= -1;
    this[1] *= -1;
    this[2] *= -1;
    return this;
  }
  /**
   * Inverts the components of `this`.
   * Equivalent to `Vec3.inverse(this, this);`
   *
   * @returns `this`
   */
  invert() {
    this[0] = 1 / this[0];
    this[1] = 1 / this[1];
    this[2] = 1 / this[2];
    return this;
  }
  /**
   * Calculates the dot product of this and another {@link Vec3}.
   * Equivalent to `Vec3.dot(this, b);`
   *
   * @param b - The second operand
   * @returns Dot product of `this` and `b`
   */
  dot(b) {
    return this[0] * b[0] + this[1] * b[1] + this[2] * b[2];
  }
  /**
   * Normalize `this`.
   * Equivalent to `Vec3.normalize(this, this);`
   *
   * @returns `this`
   */
  normalize() {
    return Vec3.normalize(this, this);
  }
  //================
  // Static methods
  //================
  /**
   * Creates a new, empty vec3
   * @category Static
   *
   * @returns a new 3D vector
   */
  static create() {
    return new Vec3();
  }
  /**
   * Creates a new vec3 initialized with values from an existing vector
   * @category Static
   *
   * @param a - vector to clone
   * @returns a new 3D vector
   */
  static clone(a) {
    return new Vec3(a);
  }
  /**
   * Calculates the magnitude (length) of a {@link Vec3}
   * @category Static
   *
   * @param a - Vector to calculate magnitude of
   * @returns Magnitude of a
   */
  static magnitude(a) {
    let x = a[0];
    let y = a[1];
    let z = a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   */
  static mag(a) {
    return 0;
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.magnitude} to avoid conflicts with builtin `length` methods/attribs
   *
   * @param a - vector to calculate length of
   * @returns length of a
   */
  // @ts-ignore: Length conflicts with Function.length
  static length(a) {
    return 0;
  }
  /**
   * Alias for {@link Vec3.magnitude}
   * @category Static
   * @deprecated Use {@link Vec3.mag}
   */
  static len(a) {
    return 0;
  }
  /**
   * Creates a new vec3 initialized with the given values
   * @category Static
   *
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns a new 3D vector
   */
  static fromValues(x, y, z) {
    return new Vec3(x, y, z);
  }
  /**
   * Copy the values from one vec3 to another
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the source vector
   * @returns `out`
   */
  static copy(out, a) {
    out[0] = a[0];
    out[1] = a[1];
    out[2] = a[2];
    return out;
  }
  /**
   * Set the components of a vec3 to the given values
   * @category Static
   *
   * @param out - the receiving vector
   * @param x - X component
   * @param y - Y component
   * @param z - Z component
   * @returns `out`
   */
  static set(out, x, y, z) {
    out[0] = x;
    out[1] = y;
    out[2] = z;
    return out;
  }
  /**
   * Adds two {@link Vec3}s
   * @category Static
   *
   * @param out - The receiving vector
   * @param a - The first operand
   * @param b - The second operand
   * @returns `out`
   */
  static add(out, a, b) {
    out[0] = a[0] + b[0];
    out[1] = a[1] + b[1];
    out[2] = a[2] + b[2];
    return out;
  }
  /**
   * Subtracts vector b from vector a
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static subtract(out, a, b) {
    out[0] = a[0] - b[0];
    out[1] = a[1] - b[1];
    out[2] = a[2] - b[2];
    return out;
  }
  /**
   * Alias for {@link Vec3.subtract}
   * @category Static
   */
  static sub(out, a, b) {
    return [0, 0, 0];
  }
  /**
   * Multiplies two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static multiply(out, a, b) {
    out[0] = a[0] * b[0];
    out[1] = a[1] * b[1];
    out[2] = a[2] * b[2];
    return out;
  }
  /**
   * Alias for {@link Vec3.multiply}
   * @category Static
   */
  static mul(out, a, b) {
    return [0, 0, 0];
  }
  /**
   * Divides two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static divide(out, a, b) {
    out[0] = a[0] / b[0];
    out[1] = a[1] / b[1];
    out[2] = a[2] / b[2];
    return out;
  }
  /**
   * Alias for {@link Vec3.divide}
   * @category Static
   */
  static div(out, a, b) {
    return [0, 0, 0];
  }
  /**
   * Math.ceil the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to ceil
   * @returns `out`
   */
  static ceil(out, a) {
    out[0] = Math.ceil(a[0]);
    out[1] = Math.ceil(a[1]);
    out[2] = Math.ceil(a[2]);
    return out;
  }
  /**
   * Math.floor the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to floor
   * @returns `out`
   */
  static floor(out, a) {
    out[0] = Math.floor(a[0]);
    out[1] = Math.floor(a[1]);
    out[2] = Math.floor(a[2]);
    return out;
  }
  /**
   * Returns the minimum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static min(out, a, b) {
    out[0] = Math.min(a[0], b[0]);
    out[1] = Math.min(a[1], b[1]);
    out[2] = Math.min(a[2], b[2]);
    return out;
  }
  /**
   * Returns the maximum of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static max(out, a, b) {
    out[0] = Math.max(a[0], b[0]);
    out[1] = Math.max(a[1], b[1]);
    out[2] = Math.max(a[2], b[2]);
    return out;
  }
  /**
   * symmetric round the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to round
   * @returns `out`
   */
  /*static round(out: Vec3Like, a: Readonly<Vec3Like>): Vec3Like {
    out[0] = glMatrix.round(a[0]);
    out[1] = glMatrix.round(a[1]);
    out[2] = glMatrix.round(a[2]);
    return out;
  }*/
  /**
   * Scales a vec3 by a scalar number
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to scale
   * @param scale - amount to scale the vector by
   * @returns `out`
   */
  static scale(out, a, scale) {
    out[0] = a[0] * scale;
    out[1] = a[1] * scale;
    out[2] = a[2] * scale;
    return out;
  }
  /**
   * Adds two vec3's after scaling the second operand by a scalar value
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param scale - the amount to scale b by before adding
   * @returns `out`
   */
  static scaleAndAdd(out, a, b, scale) {
    out[0] = a[0] + b[0] * scale;
    out[1] = a[1] + b[1] * scale;
    out[2] = a[2] + b[2] * scale;
    return out;
  }
  /**
   * Calculates the euclidian distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns distance between a and b
   */
  static distance(a, b) {
    const x = b[0] - a[0];
    const y = b[1] - a[1];
    const z = b[2] - a[2];
    return Math.sqrt(x * x + y * y + z * z);
  }
  /**
   * Alias for {@link Vec3.distance}
   */
  static dist(a, b) {
    return 0;
  }
  /**
   * Calculates the squared euclidian distance between two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns squared distance between a and b
   */
  static squaredDistance(a, b) {
    const x = b[0] - a[0];
    const y = b[1] - a[1];
    const z = b[2] - a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Alias for {@link Vec3.squaredDistance}
   */
  static sqrDist(a, b) {
    return 0;
  }
  /**
   * Calculates the squared length of a vec3
   * @category Static
   *
   * @param a - vector to calculate squared length of
   * @returns squared length of a
   */
  static squaredLength(a) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    return x * x + y * y + z * z;
  }
  /**
   * Alias for {@link Vec3.squaredLength}
   */
  static sqrLen(a, b) {
    return 0;
  }
  /**
   * Negates the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to negate
   * @returns `out`
   */
  static negate(out, a) {
    out[0] = -a[0];
    out[1] = -a[1];
    out[2] = -a[2];
    return out;
  }
  /**
   * Returns the inverse of the components of a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to invert
   * @returns `out`
   */
  static inverse(out, a) {
    out[0] = 1 / a[0];
    out[1] = 1 / a[1];
    out[2] = 1 / a[2];
    return out;
  }
  /**
   * Normalize a vec3
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - vector to normalize
   * @returns `out`
   */
  static normalize(out, a) {
    const x = a[0];
    const y = a[1];
    const z = a[2];
    let len = x * x + y * y + z * z;
    if (len > 0) {
      len = 1 / Math.sqrt(len);
    }
    out[0] = a[0] * len;
    out[1] = a[1] * len;
    out[2] = a[2] * len;
    return out;
  }
  /**
   * Calculates the dot product of two vec3's
   * @category Static
   *
   * @param a - the first operand
   * @param b - the second operand
   * @returns dot product of a and b
   */
  static dot(a, b) {
    return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
  }
  /**
   * Computes the cross product of two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @returns `out`
   */
  static cross(out, a, b) {
    const ax = a[0], ay = a[1], az = a[2];
    const bx = b[0], by = b[1], bz = b[2];
    out[0] = ay * bz - az * by;
    out[1] = az * bx - ax * bz;
    out[2] = ax * by - ay * bx;
    return out;
  }
  /**
   * Performs a linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static lerp(out, a, b, t) {
    const ax = a[0];
    const ay = a[1];
    const az = a[2];
    out[0] = ax + t * (b[0] - ax);
    out[1] = ay + t * (b[1] - ay);
    out[2] = az + t * (b[2] - az);
    return out;
  }
  /**
   * Performs a spherical linear interpolation between two vec3's
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static slerp(out, a, b, t) {
    const angle = Math.acos(Math.min(Math.max(Vec3.dot(a, b), -1), 1));
    const sinTotal = Math.sin(angle);
    const ratioA = Math.sin((1 - t) * angle) / sinTotal;
    const ratioB = Math.sin(t * angle) / sinTotal;
    out[0] = ratioA * a[0] + ratioB * b[0];
    out[1] = ratioA * a[1] + ratioB * b[1];
    out[2] = ratioA * a[2] + ratioB * b[2];
    return out;
  }
  /**
   * Performs a hermite interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static hermite(out, a, b, c, d, t) {
    const factorTimes2 = t * t;
    const factor1 = factorTimes2 * (2 * t - 3) + 1;
    const factor2 = factorTimes2 * (t - 2) + t;
    const factor3 = factorTimes2 * (t - 1);
    const factor4 = factorTimes2 * (3 - 2 * t);
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Performs a bezier interpolation with two control points
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the first operand
   * @param b - the second operand
   * @param c - the third operand
   * @param d - the fourth operand
   * @param t - interpolation amount, in the range [0-1], between the two inputs
   * @returns `out`
   */
  static bezier(out, a, b, c, d, t) {
    const inverseFactor = 1 - t;
    const inverseFactorTimesTwo = inverseFactor * inverseFactor;
    const factorTimes2 = t * t;
    const factor1 = inverseFactorTimesTwo * inverseFactor;
    const factor2 = 3 * t * inverseFactorTimesTwo;
    const factor3 = 3 * factorTimes2 * inverseFactor;
    const factor4 = factorTimes2 * t;
    out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;
    out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;
    out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;
    return out;
  }
  /**
   * Generates a random vector with the given scale
   * @category Static
   *
   * @param out - the receiving vector
   * @param {Number} [scale] Length of the resulting vector. If omitted, a unit vector will be returned
   * @returns `out`
   */
  /*static random(out: Vec3Like, scale) {
      scale = scale === undefined ? 1.0 : scale;
  
      let r = glMatrix.RANDOM() * 2.0 * Math.PI;
      let z = glMatrix.RANDOM() * 2.0 - 1.0;
      let zScale = Math.sqrt(1.0 - z * z) * scale;
  
      out[0] = Math.cos(r) * zScale;
      out[1] = Math.sin(r) * zScale;
      out[2] = z * scale;
      return out;
    }*/
  /**
   * Transforms the vec3 with a mat4.
   * 4th vector component is implicitly '1'
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - matrix to transform with
   * @returns `out`
   */
  static transformMat4(out, a, m) {
    const x = a[0], y = a[1], z = a[2];
    const w = m[3] * x + m[7] * y + m[11] * z + m[15] || 1;
    out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;
    out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;
    out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;
    return out;
  }
  /**
   * Transforms the vec3 with a mat3.
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param m - the 3x3 matrix to transform with
   * @returns `out`
   */
  static transformMat3(out, a, m) {
    let x = a[0], y = a[1], z = a[2];
    out[0] = x * m[0] + y * m[3] + z * m[6];
    out[1] = x * m[1] + y * m[4] + z * m[7];
    out[2] = x * m[2] + y * m[5] + z * m[8];
    return out;
  }
  /**
   * Transforms the vec3 with a quat
   * Can also be used for dual quaternions. (Multiply it with the real part)
   * @category Static
   *
   * @param out - the receiving vector
   * @param a - the vector to transform
   * @param q - quaternion to transform with
   * @returns `out`
   */
  static transformQuat(out, a, q) {
    const qx = q[0];
    const qy = q[1];
    const qz = q[2];
    const w2 = q[3] * 2;
    const x = a[0];
    const y = a[1];
    const z = a[2];
    const uvx = qy * z - qz * y;
    const uvy = qz * x - qx * z;
    const uvz = qx * y - qy * x;
    const uuvx = (qy * uvz - qz * uvy) * 2;
    const uuvy = (qz * uvx - qx * uvz) * 2;
    const uuvz = (qx * uvy - qy * uvx) * 2;
    out[0] = x + uvx * w2 + uuvx;
    out[1] = y + uvy * w2 + uuvy;
    out[2] = z + uvz * w2 + uuvz;
    return out;
  }
  /**
   * Rotate a 3D vector around the x-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateX(out, a, b, rad) {
    const by = b[1];
    const bz = b[2];
    const py = a[1] - by;
    const pz = a[2] - bz;
    out[0] = a[0];
    out[1] = py * Math.cos(rad) - pz * Math.sin(rad) + by;
    out[2] = py * Math.sin(rad) + pz * Math.cos(rad) + bz;
    return out;
  }
  /**
   * Rotate a 3D vector around the y-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateY(out, a, b, rad) {
    const bx = b[0];
    const bz = b[2];
    const px = a[0] - bx;
    const pz = a[2] - bz;
    out[0] = pz * Math.sin(rad) + px * Math.cos(rad) + bx;
    out[1] = a[1];
    out[2] = pz * Math.cos(rad) - px * Math.sin(rad) + bz;
    return out;
  }
  /**
   * Rotate a 3D vector around the z-axis
   * @param out - The receiving vec3
   * @param a - The vec3 point to rotate
   * @param b - The origin of the rotation
   * @param rad - The angle of rotation in radians
   * @returns `out`
   */
  static rotateZ(out, a, b, rad) {
    const bx = b[0];
    const by = b[1];
    const px = a[0] - bx;
    const py = a[1] - by;
    out[0] = px * Math.cos(rad) - py * Math.sin(rad) + bx;
    out[1] = px * Math.sin(rad) + py * Math.cos(rad) + by;
    out[2] = b[2];
    return out;
  }
  /**
   * Get the angle between two 3D vectors
   * @param a - The first operand
   * @param b - The second operand
   * @returns The angle in radians
   */
  static angle(a, b) {
    const ax = a[0];
    const ay = a[1];
    const az = a[2];
    const bx = b[0];
    const by = b[1];
    const bz = b[2];
    const mag = Math.sqrt((ax * ax + ay * ay + az * az) * (bx * bx + by * by + bz * bz));
    const cosine2 = mag && Vec3.dot(a, b) / mag;
    return Math.acos(Math.min(Math.max(cosine2, -1), 1));
  }
  /**
   * Set the components of a vec3 to zero
   * @category Static
   *
   * @param out - the receiving vector
   * @returns `out`
   */
  static zero(out) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
    return out;
  }
  /**
   * Returns a string representation of a vector
   * @category Static
   *
   * @param a - vector to represent as a string
   * @returns string representation of the vector
   */
  static str(a) {
    return `Vec3(${a.join(", ")})`;
  }
  /**
   * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static exactEquals(a, b) {
    return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];
  }
  /**
   * Returns whether or not the vectors have approximately the same elements in the same position.
   * @category Static
   *
   * @param a - The first vector.
   * @param b - The second vector.
   * @returns True if the vectors are equal, false otherwise.
   */
  static equals(a, b) {
    const a0 = a[0];
    const a1 = a[1];
    const a2 = a[2];
    const b0 = b[0];
    const b1 = b[1];
    const b2 = b[2];
    return Math.abs(a0 - b0) <= EPSILON * Math.max(1, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= EPSILON * Math.max(1, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= EPSILON * Math.max(1, Math.abs(a2), Math.abs(b2));
  }
}
Vec3.prototype.sub = Vec3.prototype.subtract;
Vec3.prototype.mul = Vec3.prototype.multiply;
Vec3.prototype.div = Vec3.prototype.divide;
Vec3.prototype.dist = Vec3.prototype.distance;
Vec3.prototype.sqrDist = Vec3.prototype.squaredDistance;
Vec3.sub = Vec3.subtract;
Vec3.mul = Vec3.multiply;
Vec3.div = Vec3.divide;
Vec3.dist = Vec3.distance;
Vec3.sqrDist = Vec3.squaredDistance;
Vec3.sqrLen = Vec3.squaredLength;
Vec3.mag = Vec3.magnitude;
Vec3.length = Vec3.magnitude;
Vec3.len = Vec3.magnitude;
async function nextAnimationFrame(cntr = 1) {
  if (!Number.isInteger(cntr) || cntr < 1) {
    throw new TypeError(`nextAnimationFrame error: 'cntr' must be a positive integer greater than 0.`);
  }
  let currentTime = performance.now();
  for (; --cntr >= 0; ) {
    currentTime = await new Promise((resolve2) => requestAnimationFrame(resolve2));
  }
  return currentTime;
}
function clamp$1(value = 0, min2 = 0, max2 = 0) {
  return Math.min(Math.max(value, min2), max2);
}
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
class AnimationControl {
  /** @type {object} */
  #animationData;
  /** @type {Promise<void>} */
  #finishedPromise;
  #willFinish;
  /**
   * Defines a static empty / void animation control.
   *
   * @type {AnimationControl}
   */
  static #voidControl = new AnimationControl(null);
  /**
   * Provides a static void / undefined AnimationControl that is automatically resolved.
   *
   * @returns {AnimationControl} Void AnimationControl
   */
  static get voidControl() {
    return this.#voidControl;
  }
  /**
   * @param {object|null} [animationData] - Animation data from {@link AnimationAPI}.
   *
   * @param {boolean}     [willFinish] - Promise that tracks animation finished state.
   */
  constructor(animationData, willFinish = false) {
    this.#animationData = animationData;
    this.#willFinish = willFinish;
    if (isObject$1(animationData)) {
      animationData.control = this;
    }
  }
  /**
   * Get a promise that resolves when animation is finished.
   *
   * @returns {Promise<void>}
   */
  get finished() {
    if (!(this.#finishedPromise instanceof Promise)) {
      this.#finishedPromise = this.#willFinish ? new Promise((resolve2) => this.#animationData.resolve = resolve2) : Promise.resolve();
    }
    return this.#finishedPromise;
  }
  /**
   * Returns whether this animation is currently active / animating.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationControl.isFinished} to determine
   * if an animation is actually finished.
   *
   * @returns {boolean} Animation active state.
   */
  get isActive() {
    return this.#animationData.active;
  }
  /**
   * Returns whether this animation is completely finished.
   *
   * @returns {boolean} Animation finished state.
   */
  get isFinished() {
    return this.#animationData.finished;
  }
  /**
   * Cancels the animation.
   */
  cancel() {
    const animationData = this.#animationData;
    if (animationData === null || animationData === void 0) {
      return;
    }
    animationData.cancelled = true;
  }
}
class AnimationManager {
  /**
   * @type {object[]}
   */
  static activeList = [];
  /**
   * @type {object[]}
   */
  static newList = [];
  /**
   * @type {number}
   */
  static current;
  /**
   * Add animation data.
   *
   * @param {object}   data -
   */
  static add(data) {
    const now2 = performance.now();
    data.start = now2 + (AnimationManager.current - now2);
    AnimationManager.newList.push(data);
  }
  /**
   * Manage all animation
   */
  static animate() {
    const current = AnimationManager.current = performance.now();
    if (AnimationManager.activeList.length === 0 && AnimationManager.newList.length === 0) {
      globalThis.requestAnimationFrame(AnimationManager.animate);
      return;
    }
    if (AnimationManager.newList.length) {
      for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
        const data = AnimationManager.newList[cntr];
        if (data.cancelled) {
          AnimationManager.newList.splice(cntr, 1);
          data.cleanup(data);
        }
        if (data.active) {
          AnimationManager.newList.splice(cntr, 1);
          AnimationManager.activeList.push(data);
        }
      }
    }
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.activeList[cntr];
      if (data.cancelled || data.el !== void 0 && !data.el.isConnected) {
        AnimationManager.activeList.splice(cntr, 1);
        data.cleanup(data);
        continue;
      }
      data.current = current - data.start;
      if (data.current >= data.duration) {
        for (let dataCntr = data.keys.length; --dataCntr >= 0; ) {
          const key = data.keys[dataCntr];
          data.newData[key] = data.destination[key];
        }
        data.position.set(data.newData);
        AnimationManager.activeList.splice(cntr, 1);
        data.cleanup(data);
        continue;
      }
      const easedTime = data.ease(data.current / data.duration);
      for (let dataCntr = data.keys.length; --dataCntr >= 0; ) {
        const key = data.keys[dataCntr];
        data.newData[key] = data.interpolate(data.initial[key], data.destination[key], easedTime);
      }
      data.position.set(data.newData);
    }
    globalThis.requestAnimationFrame(AnimationManager.animate);
  }
  /**
   * Cancels all animations for given TJSPosition instance.
   *
   * @param {import('../').TJSPosition} position - TJSPosition instance.
   */
  static cancel(position) {
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.activeList[cntr];
      if (data.position === position) {
        AnimationManager.activeList.splice(cntr, 1);
        data.cancelled = true;
        data.cleanup(data);
      }
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data = AnimationManager.newList[cntr];
      if (data.position === position) {
        AnimationManager.newList.splice(cntr, 1);
        data.cancelled = true;
        data.cleanup(data);
      }
    }
  }
  /**
   * Cancels all active and delayed animations.
   */
  static cancelAll() {
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.activeList[cntr];
      data.cancelled = true;
      data.cleanup(data);
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data = AnimationManager.newList[cntr];
      data.cancelled = true;
      data.cleanup(data);
    }
    AnimationManager.activeList.length = 0;
    AnimationManager.newList.length = 0;
  }
  /**
   * Gets all {@link AnimationControl} instances for a given TJSPosition instance.
   *
   * @param {import('../index.js').TJSPosition} position - TJSPosition instance.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation[]} All scheduled AnimationControl instances for the
   *          given TJSPosition instance.
   */
  static getScheduled(position) {
    const results = [];
    for (let cntr = AnimationManager.activeList.length; --cntr >= 0; ) {
      const data = AnimationManager.activeList[cntr];
      if (data.position === position) {
        results.push(data.control);
      }
    }
    for (let cntr = AnimationManager.newList.length; --cntr >= 0; ) {
      const data = AnimationManager.newList[cntr];
      if (data.position === position) {
        results.push(data.control);
      }
    }
    return results;
  }
}
AnimationManager.animate();
const animateKeys = /* @__PURE__ */ new Set([
  // Main keys
  "left",
  "top",
  "maxWidth",
  "maxHeight",
  "minWidth",
  "minHeight",
  "width",
  "height",
  "rotateX",
  "rotateY",
  "rotateZ",
  "scale",
  "translateX",
  "translateY",
  "translateZ",
  "zIndex",
  // Aliases
  "rotation"
]);
const transformKeys = ["rotateX", "rotateY", "rotateZ", "scale", "translateX", "translateY", "translateZ"];
Object.freeze(transformKeys);
const relativeRegex = /^([-+*])=(-?[\d]*\.?[\d]+)$/;
const numericDefaults = {
  // Other keys
  height: 0,
  left: 0,
  maxHeight: null,
  maxWidth: null,
  minHeight: null,
  minWidth: null,
  top: 0,
  transformOrigin: null,
  width: 0,
  zIndex: null,
  rotateX: 0,
  rotateY: 0,
  rotateZ: 0,
  scale: 1,
  translateX: 0,
  translateY: 0,
  translateZ: 0,
  rotation: 0
};
Object.freeze(numericDefaults);
function setNumericDefaults(data) {
  if (data.rotateX === null) {
    data.rotateX = 0;
  }
  if (data.rotateY === null) {
    data.rotateY = 0;
  }
  if (data.rotateZ === null) {
    data.rotateZ = 0;
  }
  if (data.translateX === null) {
    data.translateX = 0;
  }
  if (data.translateY === null) {
    data.translateY = 0;
  }
  if (data.translateZ === null) {
    data.translateZ = 0;
  }
  if (data.scale === null) {
    data.scale = 1;
  }
  if (data.rotation === null) {
    data.rotation = 0;
  }
}
const transformKeysBitwise = {
  rotateX: 1,
  rotateY: 2,
  rotateZ: 4,
  scale: 8,
  translateX: 16,
  translateY: 32,
  translateZ: 64
};
Object.freeze(transformKeysBitwise);
const transformOriginDefault = "top left";
const transformOrigins = [
  "top left",
  "top center",
  "top right",
  "center left",
  "center",
  "center right",
  "bottom left",
  "bottom center",
  "bottom right"
];
Object.freeze(transformOrigins);
function convertRelative(positionData, position) {
  for (const key in positionData) {
    if (animateKeys.has(key)) {
      const value = positionData[key];
      if (typeof value !== "string") {
        continue;
      }
      if (value === "auto" || value === "inherit") {
        continue;
      }
      const regexResults = relativeRegex.exec(value);
      if (!regexResults) {
        throw new Error(
          `convertRelative error: malformed relative key (${key}) with value (${value})`
        );
      }
      const current = position[key];
      switch (regexResults[1]) {
        case "-":
          positionData[key] = current - parseFloat(regexResults[2]);
          break;
        case "+":
          positionData[key] = current + parseFloat(regexResults[2]);
          break;
        case "*":
          positionData[key] = current * parseFloat(regexResults[2]);
          break;
      }
    }
  }
}
class AnimationAPI {
  /** @type {import('../').TJSPositionData} */
  #data;
  /** @type {import('../').TJSPosition} */
  #position;
  /**
   * Tracks the number of animation control instances that are active.
   *
   * @type {number}
   */
  #instanceCount = 0;
  /**
   * Provides a bound function to pass as data to AnimationManager to invoke `AnimationAPI.#cleanupInstance`.
   *
   * @type {Function}
   */
  #cleanup;
  /**
   * @param {import('../index.js').TJSPosition}       position -
   *
   * @param {import('../index.js').TJSPositionData}   data -
   */
  constructor(position, data) {
    this.#position = position;
    this.#data = data;
    this.#cleanup = this.#cleanupInstance.bind(this);
  }
  /**
   * Returns whether there are scheduled animations whether active or delayed for this TJSPosition.
   *
   * @returns {boolean} Are there active animation instances.
   */
  get isScheduled() {
    return this.#instanceCount > 0;
  }
  /**
   * Adds / schedules an animation w/ the AnimationManager. This contains the final steps common to all tweens.
   *
   * @param {object}      initial -
   *
   * @param {object}      destination -
   *
   * @param {number}      duration -
   *
   * @param {HTMLElement} el -
   *
   * @param {number}      delay -
   *
   * @param {Function}    ease -
   *
   * @param {Function}    interpolate -
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation} The associated animation control.
   */
  #addAnimation(initial, destination, duration, el, delay, ease, interpolate) {
    setNumericDefaults(initial);
    setNumericDefaults(destination);
    for (const key in initial) {
      if (!Number.isFinite(initial[key])) {
        delete initial[key];
      }
    }
    const keys = Object.keys(initial);
    const newData = Object.assign({ immediateElementUpdate: true }, initial);
    if (keys.length === 0) {
      return AnimationControl.voidControl;
    }
    const animationData = {
      active: true,
      cleanup: this.#cleanup,
      cancelled: false,
      control: void 0,
      current: 0,
      destination,
      duration: duration * 1e3,
      // Internally the AnimationManager works in ms.
      ease,
      el,
      finished: false,
      initial,
      interpolate,
      keys,
      newData,
      position: this.#position,
      resolve: void 0,
      start: void 0
    };
    if (delay > 0) {
      animationData.active = false;
      setTimeout(() => {
        if (!animationData.cancelled) {
          animationData.active = true;
          const now2 = performance.now();
          animationData.start = now2 + (AnimationManager.current - now2);
        }
      }, delay * 1e3);
    }
    this.#instanceCount++;
    AnimationManager.add(animationData);
    return new AnimationControl(animationData, true);
  }
  /**
   * Cancels all animation instances for this TJSPosition instance.
   */
  cancel() {
    AnimationManager.cancel(this.#position);
  }
  /**
   * Cleans up an animation instance.
   *
   * @param {object}   data - Animation data for an animation instance.
   */
  #cleanupInstance(data) {
    this.#instanceCount--;
    data.active = false;
    data.finished = true;
    if (typeof data.resolve === "function") {
      data.resolve(data.cancelled);
    }
  }
  /**
   * Returns all currently scheduled AnimationControl instances for this TJSPosition instance.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation[]} All currently scheduled animation controls for
   *          this TJSPosition instance.
   */
  getScheduled() {
    return AnimationManager.getScheduled(this.#position);
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {import('../index.js').TJSPositionDataExtended} fromData - The starting position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  from(fromData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp } = {}) {
    if (!isObject$1(fromData)) {
      throw new TypeError(`AnimationAPI.from error: 'fromData' is not an object.`);
    }
    const position = this.#position;
    const parent = position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.from error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.from error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.from error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.from error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key in fromData) {
      if (data[key] !== void 0 && fromData[key] !== data[key]) {
        initial[key] = fromData[key];
        destination[key] = data[key];
      }
    }
    convertRelative(initial, data);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  /**
   * Provides a tween from given position data to the current position.
   *
   * @param {import('../index.js').TJSPositionDataExtended} fromData - The starting position.
   *
   * @param {import('../index.js').TJSPositionDataExtended} toData - The ending position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  fromTo(fromData, toData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp } = {}) {
    if (!isObject$1(fromData)) {
      throw new TypeError(`AnimationAPI.fromTo error: 'fromData' is not an object.`);
    }
    if (!isObject$1(toData)) {
      throw new TypeError(`AnimationAPI.fromTo error: 'toData' is not an object.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.fromTo error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.fromTo error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.fromTo error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.fromTo error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key in fromData) {
      if (toData[key] === void 0) {
        console.warn(
          `AnimationAPI.fromTo warning: key ('${key}') from 'fromData' missing in 'toData'; skipping this key.`
        );
        continue;
      }
      if (data[key] !== void 0) {
        initial[key] = fromData[key];
        destination[key] = toData[key];
      }
    }
    convertRelative(initial, data);
    convertRelative(destination, data);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  /**
   * Provides a tween to given position data from the current position.
   *
   * @param {import('../index.js').TJSPositionDataExtended} toData - The destination position.
   *
   * @param {object}         [opts] - Optional parameters.
   *
   * @param {number}         [opts.delay=0] - Delay in seconds before animation starts.
   *
   * @param {number}         [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}       [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}       [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation}  A control object that can cancel animation and
   *          provides a `finished` Promise.
   */
  to(toData, { delay = 0, duration = 1, ease = cubicOut, interpolate = lerp } = {}) {
    if (!isObject$1(toData)) {
      throw new TypeError(`AnimationAPI.to error: 'toData' is not an object.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return AnimationControl.voidControl;
    }
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    if (!Number.isFinite(delay) || delay < 0) {
      throw new TypeError(`AnimationAPI.to error: 'delay' is not a positive number.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.to error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.to error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.to error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key in toData) {
      if (data[key] !== void 0 && toData[key] !== data[key]) {
        destination[key] = toData[key];
        initial[key] = data[key];
      }
    }
    convertRelative(destination, data);
    return this.#addAnimation(initial, destination, duration, el, delay, ease, interpolate);
  }
  /**
   * Returns a function that provides an optimized way to constantly update a to-tween.
   *
   * @param {Iterable<string>}  keys - The keys for quickTo.
   *
   * @param {object}            [opts] - Optional parameters.
   *
   * @param {number}            [opts.duration=1] - Duration in seconds.
   *
   * @param {Function}          [opts.ease=cubicOut] - Easing function.
   *
   * @param {Function}          [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {import('../index.js').quickToCallback} quick-to tween function.
   */
  quickTo(keys, { duration = 1, ease = cubicOut, interpolate = lerp } = {}) {
    if (!isIterable(keys)) {
      throw new TypeError(`AnimationAPI.quickTo error: 'keys' is not an iterable list.`);
    }
    const parent = this.#position.parent;
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      throw new Error(`AnimationAPI.quickTo error: 'parent' is not positionable.`);
    }
    if (!Number.isFinite(duration) || duration < 0) {
      throw new TypeError(`AnimationAPI.quickTo error: 'duration' is not a positive number.`);
    }
    if (typeof ease !== "function") {
      throw new TypeError(`AnimationAPI.quickTo error: 'ease' is not a function.`);
    }
    if (typeof interpolate !== "function") {
      throw new TypeError(`AnimationAPI.quickTo error: 'interpolate' is not a function.`);
    }
    const initial = {};
    const destination = {};
    const data = this.#data;
    for (const key of keys) {
      if (typeof key !== "string") {
        throw new TypeError(`AnimationAPI.quickTo error: key is not a string.`);
      }
      if (!animateKeys.has(key)) {
        throw new Error(`AnimationAPI.quickTo error: key ('${key}') is not animatable.`);
      }
      if (data[key] !== void 0) {
        destination[key] = data[key];
        initial[key] = data[key];
      }
    }
    const keysArray = [...keys];
    Object.freeze(keysArray);
    const newData = Object.assign({ immediateElementUpdate: true }, initial);
    const animationData = {
      active: true,
      cleanup: this.#cleanup,
      cancelled: false,
      control: void 0,
      current: 0,
      destination,
      duration: duration * 1e3,
      // Internally the AnimationManager works in ms.
      ease,
      el: void 0,
      finished: true,
      // Note: start in finished state to add to AnimationManager on first callback.
      initial,
      interpolate,
      keys,
      newData,
      position: this.#position,
      resolve: void 0,
      start: void 0
    };
    const quickToCB = (...args) => {
      const argsLength = args.length;
      if (argsLength === 0) {
        return;
      }
      for (let cntr = keysArray.length; --cntr >= 0; ) {
        const key = keysArray[cntr];
        if (data[key] !== void 0) {
          initial[key] = data[key];
        }
      }
      if (isObject$1(args[0])) {
        const objData = args[0];
        for (const key in objData) {
          if (destination[key] !== void 0) {
            destination[key] = objData[key];
          }
        }
      } else {
        for (let cntr = 0; cntr < argsLength && cntr < keysArray.length; cntr++) {
          const key = keysArray[cntr];
          if (destination[key] !== void 0) {
            destination[key] = args[cntr];
          }
        }
      }
      convertRelative(destination, data);
      setNumericDefaults(initial);
      setNumericDefaults(destination);
      const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
      animationData.el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
      if (animationData.finished) {
        animationData.finished = false;
        animationData.active = true;
        animationData.current = 0;
        this.#instanceCount++;
        AnimationManager.add(animationData);
      } else {
        const now2 = performance.now();
        animationData.start = now2 + (AnimationManager.current - now2);
        animationData.current = 0;
      }
    };
    quickToCB.keys = keysArray;
    quickToCB.options = ({ duration: duration2, ease: ease2, interpolate: interpolate2 } = {}) => {
      if (duration2 !== void 0 && (!Number.isFinite(duration2) || duration2 < 0)) {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'duration' is not a positive number.`);
      }
      if (ease2 !== void 0 && typeof ease2 !== "function") {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'ease' is not a function.`);
      }
      if (interpolate2 !== void 0 && typeof interpolate2 !== "function") {
        throw new TypeError(`AnimationAPI.quickTo.options error: 'interpolate' is not a function.`);
      }
      if (duration2 >= 0) {
        animationData.duration = duration2 * 1e3;
      }
      if (ease2) {
        animationData.ease = ease2;
      }
      if (interpolate2) {
        animationData.interpolate = interpolate2;
      }
      return quickToCB;
    };
    return quickToCB;
  }
}
class AnimationGroupControl {
  /** @type {import('./AnimationControl').AnimationControl[]} */
  #animationControls;
  /** @type {Promise<Awaited<unknown>[]>} */
  #finishedPromise;
  /**
   * Defines a static empty / void animation control.
   *
   * @type {AnimationGroupControl}
   */
  static #voidControl = new AnimationGroupControl(null);
  /**
   * Provides a static void / undefined AnimationGroupControl that is automatically resolved.
   *
   * @returns {AnimationGroupControl} Void AnimationGroupControl
   */
  static get voidControl() {
    return this.#voidControl;
  }
  /**
   * @param {import('./AnimationControl').AnimationControl[]} animationControls - An array of AnimationControl
   *        instances.
   */
  constructor(animationControls) {
    this.#animationControls = animationControls;
  }
  /**
   * Get a promise that resolves when all animations are finished.
   *
   * @returns {Promise<Awaited<unknown>[]>|Promise<void>} Finished Promise for all animations.
   */
  get finished() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return Promise.resolve();
    }
    if (!(this.#finishedPromise instanceof Promise)) {
      const promises = [];
      for (let cntr = animationControls.length; --cntr >= 0; ) {
        promises.push(animationControls[cntr].finished);
      }
      this.#finishedPromise = Promise.all(promises);
    }
    return this.#finishedPromise;
  }
  /**
   * Returns whether there are active animation instances for this group.
   *
   * Note: a delayed animation may not be started / active yet. Use {@link AnimationGroupControl.isFinished} to
   * determine if all animations in the group are finished.
   *
   * @returns {boolean} Are there active animation instances.
   */
  get isActive() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return false;
    }
    for (let cntr = animationControls.length; --cntr >= 0; ) {
      if (animationControls[cntr].isActive) {
        return true;
      }
    }
    return false;
  }
  /**
   * Returns whether all animations in the group are finished.
   *
   * @returns {boolean} Are all animation instances finished.
   */
  get isFinished() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return true;
    }
    for (let cntr = animationControls.length; --cntr >= 0; ) {
      if (!animationControls[cntr].isFinished) {
        return false;
      }
    }
    return false;
  }
  /**
   * Cancels the all animations.
   */
  cancel() {
    const animationControls = this.#animationControls;
    if (animationControls === null || animationControls === void 0) {
      return;
    }
    for (let cntr = this.#animationControls.length; --cntr >= 0; ) {
      this.#animationControls[cntr].cancel();
    }
  }
}
class AnimationGroupAPI {
  /**
   * Checks of the given object is a TJSPosition instance by checking for AnimationAPI.
   *
   * @param {*}  object - Any data.
   *
   * @returns {boolean} Is TJSPosition.
   */
  static #isPosition(object) {
    return isObject$1(object) && object.animate instanceof AnimationAPI;
  }
  /**
   * Cancels any animation for given TJSPosition data.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   */
  static cancel(position) {
    if (isIterable(position)) {
      let index2 = -1;
      for (const entry of position) {
        index2++;
        const actualPosition = this.#isPosition(entry) ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.cancel warning: No Position instance found at index: ${index2}.`);
          continue;
        }
        AnimationManager.cancel(actualPosition);
      }
    } else {
      const actualPosition = this.#isPosition(position) ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.cancel warning: No Position instance found.`);
        return;
      }
      AnimationManager.cancel(actualPosition);
    }
  }
  /**
   * Cancels all TJSPosition animation.
   */
  static cancelAll() {
    AnimationManager.cancelAll();
  }
  /**
   * Gets all animation controls for the given position data.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @returns {{ position: import('../').TJSPosition, data: object | void, controls: import('./AnimationControl').AnimationControl[]}[]} Results array.
   */
  static getScheduled(position) {
    const results = [];
    if (isIterable(position)) {
      let index2 = -1;
      for (const entry of position) {
        index2++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.getScheduled warning: No Position instance found at index: ${index2}.`);
          continue;
        }
        const controls = AnimationManager.getScheduled(actualPosition);
        results.push({ position: actualPosition, data: isPosition ? void 0 : entry, controls });
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.getScheduled warning: No Position instance found.`);
        return results;
      }
      const controls = AnimationManager.getScheduled(actualPosition);
      results.push({ position: actualPosition, data: isPosition ? void 0 : position, controls });
    }
    return results;
  }
  /**
   * Provides the `from` animation tween for one or more TJSPosition instances as a group.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @param {object|Function}   fromData -
   *
   * @param {object|Function}   options -
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation} Basic animation control.
   */
  static from(position, fromData, options) {
    if (!isObject$1(fromData) && typeof fromData !== "function") {
      throw new TypeError(`AnimationGroupAPI.from error: 'fromData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject$1(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.from error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index2 = -1;
    let callbackOptions;
    const hasDataCallback = typeof fromData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasDataCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index: index2, position: void 0, data: void 0 };
    }
    let actualFromData = fromData;
    let actualOptions = options;
    if (isIterable(position)) {
      for (const entry of position) {
        index2++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.from warning: No Position instance found at index: ${index2}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index2;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasDataCallback) {
          actualFromData = fromData(callbackOptions);
          if (actualFromData === null || actualFromData === void 0) {
            continue;
          }
          if (!isObject$1(actualFromData)) {
            throw new TypeError(`AnimationGroupAPI.from error: fromData callback function iteration(${index2}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (!isObject$1(actualOptions)) {
            throw new TypeError(`AnimationGroupAPI.from error: options callback function iteration(${index2}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.from(actualFromData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.from warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasDataCallback) {
        actualFromData = fromData(callbackOptions);
        if (!isObject$1(actualFromData)) {
          throw new TypeError(
            `AnimationGroupAPI.from error: fromData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (!isObject$1(actualOptions)) {
          throw new TypeError(
            `AnimationGroupAPI.from error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.from(actualFromData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `fromTo` animation tween for one or more TJSPosition instances as a group.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @param {object|Function}   fromData -
   *
   * @param {object|Function}   toData -
   *
   * @param {object|Function}   options -
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation} Basic animation control.
   */
  static fromTo(position, fromData, toData, options) {
    if (!isObject$1(fromData) && typeof fromData !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'fromData' is not an object or function.`);
    }
    if (!isObject$1(toData) && typeof toData !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'toData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject$1(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.fromTo error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index2 = -1;
    let callbackOptions;
    const hasFromCallback = typeof fromData === "function";
    const hasToCallback = typeof toData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasFromCallback || hasToCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index: index2, position: void 0, data: void 0 };
    }
    let actualFromData = fromData;
    let actualToData = toData;
    let actualOptions = options;
    if (isIterable(position)) {
      for (const entry of position) {
        index2++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.fromTo warning: No Position instance found at index: ${index2}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index2;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasFromCallback) {
          actualFromData = fromData(callbackOptions);
          if (actualFromData === null || actualFromData === void 0) {
            continue;
          }
          if (!isObject$1(actualFromData)) {
            throw new TypeError(`AnimationGroupAPI.fromTo error: fromData callback function iteration(${index2}) failed to return an object.`);
          }
        }
        if (hasToCallback) {
          actualToData = toData(callbackOptions);
          if (actualToData === null || actualToData === void 0) {
            continue;
          }
          if (!isObject$1(actualToData)) {
            throw new TypeError(`AnimationGroupAPI.fromTo error: toData callback function iteration(${index2}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (!isObject$1(actualOptions)) {
            throw new TypeError(`AnimationGroupAPI.fromTo error: options callback function iteration(${index2}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.fromTo(actualFromData, actualToData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.fromTo warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasFromCallback) {
        actualFromData = fromData(callbackOptions);
        if (!isObject$1(actualFromData)) {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: fromData callback function failed to return an object.`
          );
        }
      }
      if (hasToCallback) {
        actualToData = toData(callbackOptions);
        if (!isObject$1(actualToData)) {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: toData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (!isObject$1(actualOptions)) {
          throw new TypeError(
            `AnimationGroupAPI.fromTo error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.fromTo(actualFromData, actualToData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `to` animation tween for one or more TJSPosition instances as a group.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @param {object|Function}   toData -
   *
   * @param {object|Function}   options -
   *
   * @returns {import('#runtime/util/animate').TJSBasicAnimation} Basic animation control.
   */
  static to(position, toData, options) {
    if (!isObject$1(toData) && typeof toData !== "function") {
      throw new TypeError(`AnimationGroupAPI.to error: 'toData' is not an object or function.`);
    }
    if (options !== void 0 && !isObject$1(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.to error: 'options' is not an object or function.`);
    }
    const animationControls = [];
    let index2 = -1;
    let callbackOptions;
    const hasDataCallback = typeof toData === "function";
    const hasOptionCallback = typeof options === "function";
    const hasCallback = hasDataCallback || hasOptionCallback;
    if (hasCallback) {
      callbackOptions = { index: index2, position: void 0, data: void 0 };
    }
    let actualToData = toData;
    let actualOptions = options;
    if (isIterable(position)) {
      for (const entry of position) {
        index2++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.to warning: No Position instance found at index: ${index2}.`);
          continue;
        }
        if (hasCallback) {
          callbackOptions.index = index2;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : entry;
        }
        if (hasDataCallback) {
          actualToData = toData(callbackOptions);
          if (actualToData === null || actualToData === void 0) {
            continue;
          }
          if (!isObject$1(actualToData)) {
            throw new TypeError(`AnimationGroupAPI.to error: toData callback function iteration(${index2}) failed to return an object.`);
          }
        }
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (!isObject$1(actualOptions)) {
            throw new TypeError(`AnimationGroupAPI.to error: options callback function iteration(${index2}) failed to return an object.`);
          }
        }
        animationControls.push(actualPosition.animate.to(actualToData, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.to warning: No Position instance found.`);
        return AnimationGroupControl.voidControl;
      }
      if (hasCallback) {
        callbackOptions.index = 0;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : position;
      }
      if (hasDataCallback) {
        actualToData = toData(callbackOptions);
        if (!isObject$1(actualToData)) {
          throw new TypeError(
            `AnimationGroupAPI.to error: toData callback function failed to return an object.`
          );
        }
      }
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (!isObject$1(actualOptions)) {
          throw new TypeError(
            `AnimationGroupAPI.to error: options callback function failed to return an object.`
          );
        }
      }
      animationControls.push(actualPosition.animate.to(actualToData, actualOptions));
    }
    return new AnimationGroupControl(animationControls);
  }
  /**
   * Provides the `to` animation tween for one or more TJSPosition instances as a group.
   *
   * @param {import('../').TJSPosition | {position: import('../').TJSPosition} | Iterable<import('../').TJSPosition> | Iterable<{position: import('../').TJSPosition}>} position -
   *
   * @param {Iterable<string>}  keys -
   *
   * @param {object|Function}   options -
   *
   * @returns {import('../').quickToCallback} Basic animation control.
   */
  static quickTo(position, keys, options) {
    if (!isIterable(keys)) {
      throw new TypeError(`AnimationGroupAPI.quickTo error: 'keys' is not an iterable list.`);
    }
    if (options !== void 0 && !isObject$1(options) && typeof options !== "function") {
      throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' is not an object or function.`);
    }
    const quickToCallbacks = [];
    let index2 = -1;
    const hasOptionCallback = typeof options === "function";
    const callbackOptions = { index: index2, position: void 0, data: void 0 };
    let actualOptions = options;
    if (isIterable(position)) {
      for (const entry of position) {
        index2++;
        const isPosition = this.#isPosition(entry);
        const actualPosition = isPosition ? entry : entry.position;
        if (!this.#isPosition(actualPosition)) {
          console.warn(`AnimationGroupAPI.quickTo warning: No Position instance found at index: ${index2}.`);
          continue;
        }
        callbackOptions.index = index2;
        callbackOptions.position = position;
        callbackOptions.data = isPosition ? void 0 : entry;
        if (hasOptionCallback) {
          actualOptions = options(callbackOptions);
          if (actualOptions === null || actualOptions === void 0) {
            continue;
          }
          if (!isObject$1(actualOptions)) {
            throw new TypeError(`AnimationGroupAPI.quickTo error: options callback function iteration(${index2}) failed to return an object.`);
          }
        }
        quickToCallbacks.push(actualPosition.animate.quickTo(keys, actualOptions));
      }
    } else {
      const isPosition = this.#isPosition(position);
      const actualPosition = isPosition ? position : position.position;
      if (!this.#isPosition(actualPosition)) {
        console.warn(`AnimationGroupAPI.quickTo warning: No Position instance found.`);
        return () => null;
      }
      callbackOptions.index = 0;
      callbackOptions.position = position;
      callbackOptions.data = isPosition ? void 0 : position;
      if (hasOptionCallback) {
        actualOptions = options(callbackOptions);
        if (!isObject$1(actualOptions)) {
          throw new TypeError(
            `AnimationGroupAPI.quickTo error: options callback function failed to return an object.`
          );
        }
      }
      quickToCallbacks.push(actualPosition.animate.quickTo(keys, actualOptions));
    }
    const keysArray = [...keys];
    Object.freeze(keysArray);
    const quickToCB = (...args) => {
      const argsLength = args.length;
      if (argsLength === 0) {
        return;
      }
      if (typeof args[0] === "function") {
        const dataCallback = args[0];
        index2 = -1;
        let cntr = 0;
        if (isIterable(position)) {
          for (const entry of position) {
            index2++;
            const isPosition = this.#isPosition(entry);
            const actualPosition = isPosition ? entry : entry.position;
            if (!this.#isPosition(actualPosition)) {
              continue;
            }
            callbackOptions.index = index2;
            callbackOptions.position = position;
            callbackOptions.data = isPosition ? void 0 : entry;
            const toData = dataCallback(callbackOptions);
            if (toData === null || toData === void 0) {
              continue;
            }
            const toDataIterable = isIterable(toData);
            if (!Number.isFinite(toData) && !toDataIterable && !isObject$1(toData)) {
              throw new TypeError(`AnimationGroupAPI.quickTo error: toData callback function iteration(${index2}) failed to return a finite number, iterable list, or object.`);
            }
            if (toDataIterable) {
              quickToCallbacks[cntr++](...toData);
            } else {
              quickToCallbacks[cntr++](toData);
            }
          }
        } else {
          const isPosition = this.#isPosition(position);
          const actualPosition = isPosition ? position : position.position;
          if (!this.#isPosition(actualPosition)) {
            return;
          }
          callbackOptions.index = 0;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : position;
          const toData = dataCallback(callbackOptions);
          if (toData === null || toData === void 0) {
            return;
          }
          const toDataIterable = isIterable(toData);
          if (!Number.isFinite(toData) && !toDataIterable && !isObject$1(toData)) {
            throw new TypeError(`AnimationGroupAPI.quickTo error: toData callback function iteration(${index2}) failed to return a finite number, iterable list, or object.`);
          }
          if (toDataIterable) {
            quickToCallbacks[cntr++](...toData);
          } else {
            quickToCallbacks[cntr++](toData);
          }
        }
      } else {
        for (let cntr = quickToCallbacks.length; --cntr >= 0; ) {
          quickToCallbacks[cntr](...args);
        }
      }
    };
    quickToCB.keys = keysArray;
    quickToCB.options = (options2) => {
      if (options2 !== void 0 && !isObject$1(options2) && typeof options2 !== "function") {
        throw new TypeError(`AnimationGroupAPI.quickTo error: 'options' is not an object or function.`);
      }
      if (isObject$1(options2)) {
        for (let cntr = quickToCallbacks.length; --cntr >= 0; ) {
          quickToCallbacks[cntr].options(options2);
        }
      } else if (typeof options2 === "function") {
        if (isIterable(position)) {
          index2 = -1;
          let cntr = 0;
          for (const entry of position) {
            index2++;
            const isPosition = this.#isPosition(entry);
            const actualPosition = isPosition ? entry : entry.position;
            if (!this.#isPosition(actualPosition)) {
              console.warn(
                `AnimationGroupAPI.quickTo.options warning: No Position instance found at index: ${index2}.`
              );
              continue;
            }
            callbackOptions.index = index2;
            callbackOptions.position = position;
            callbackOptions.data = isPosition ? void 0 : entry;
            actualOptions = options2(callbackOptions);
            if (actualOptions === null || actualOptions === void 0) {
              continue;
            }
            if (!isObject$1(actualOptions)) {
              throw new TypeError(
                `AnimationGroupAPI.quickTo.options error: options callback function iteration(${index2}) failed to return an object.`
              );
            }
            quickToCallbacks[cntr++].options(actualOptions);
          }
        } else {
          const isPosition = this.#isPosition(position);
          const actualPosition = isPosition ? position : position.position;
          if (!this.#isPosition(actualPosition)) {
            console.warn(`AnimationGroupAPI.quickTo.options warning: No Position instance found.`);
            return quickToCB;
          }
          callbackOptions.index = 0;
          callbackOptions.position = position;
          callbackOptions.data = isPosition ? void 0 : position;
          actualOptions = options2(callbackOptions);
          if (!isObject$1(actualOptions)) {
            throw new TypeError(
              `AnimationGroupAPI.quickTo error: options callback function failed to return an object.`
            );
          }
          quickToCallbacks[0].options(actualOptions);
        }
      }
      return quickToCB;
    };
    return quickToCB;
  }
}
class Centered {
  /**
   * @type {HTMLElement}
   */
  #element;
  /**
   * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
   * performance oriented. If manually set this height is used instead of `offsetHeight`.
   *
   * @type {number}
   */
  #height;
  /**
   * Set from an optional value in the constructor to lock accessors preventing modification.
   */
  #lock;
  /**
   * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
   * performance oriented. If manually set this width is used instead of `offsetWidth`.
   *
   * @type {number}
   */
  #width;
  /**
   * @param {object}      [options] - Initial options.
   *
   * @param {HTMLElement} [options.element] - Target element.
   *
   * @param {boolean}     [options.lock=false] - Lock parameters from being set.
   *
   * @param {number}      [options.width] - Manual width.
   *
   * @param {number}      [options.height] - Manual height.
   */
  constructor({ element: element2, lock = false, width, height } = {}) {
    this.element = element2;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  /**
   * @returns {HTMLElement|undefined|null} Target element.
   */
  get element() {
    return this.#element;
  }
  /**
   * @returns {number} Get manual height.
   */
  get height() {
    return this.#height;
  }
  /**
   * @returns {number} Get manual width.
   */
  get width() {
    return this.#width;
  }
  /**
   * @param {HTMLElement|undefined|null} element - Set target element.
   */
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  /**
   * @param {number}   height - Set manual height.
   */
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  /**
   * @param {number}   width - Set manual width.
   */
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  /**
   * Set manual width & height.
   *
   * @param {number}   width - New manual width.
   *
   * @param {number}   height - New manual height.
   */
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  /**
   * Get the left constraint based on any manual target values or the browser inner width.
   *
   * @param {number}   width - Target width.
   *
   * @returns {number} Calculated left constraint.
   */
  getLeft(width) {
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    return (boundsWidth - width) / 2;
  }
  /**
   * Get the top constraint based on any manual target values or the browser inner height.
   *
   * @param {number}   height - Target height.
   *
   * @returns {number} Calculated top constraint.
   */
  getTop(height) {
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    return (boundsHeight - height) / 2;
  }
}
class PositionChangeSet {
  constructor() {
    this.left = false;
    this.top = false;
    this.width = false;
    this.height = false;
    this.maxHeight = false;
    this.maxWidth = false;
    this.minHeight = false;
    this.minWidth = false;
    this.zIndex = false;
    this.transform = false;
    this.transformOrigin = false;
  }
  hasChange() {
    return this.left || this.top || this.width || this.height || this.maxHeight || this.maxWidth || this.minHeight || this.minWidth || this.zIndex || this.transform || this.transformOrigin;
  }
  set(value) {
    this.left = value;
    this.top = value;
    this.width = value;
    this.height = value;
    this.maxHeight = value;
    this.maxWidth = value;
    this.minHeight = value;
    this.minWidth = value;
    this.zIndex = value;
    this.transform = value;
    this.transformOrigin = value;
  }
}
class TJSPositionData {
  constructor({
    height = null,
    left = null,
    maxHeight = null,
    maxWidth = null,
    minHeight = null,
    minWidth = null,
    rotateX = null,
    rotateY = null,
    rotateZ = null,
    scale = null,
    translateX = null,
    translateY = null,
    translateZ = null,
    top = null,
    transformOrigin = null,
    width = null,
    zIndex = null
  } = {}) {
    this.height = height;
    this.left = left;
    this.maxHeight = maxHeight;
    this.maxWidth = maxWidth;
    this.minHeight = minHeight;
    this.minWidth = minWidth;
    this.rotateX = rotateX;
    this.rotateY = rotateY;
    this.rotateZ = rotateZ;
    this.scale = scale;
    this.top = top;
    this.transformOrigin = transformOrigin;
    this.translateX = translateX;
    this.translateY = translateY;
    this.translateZ = translateZ;
    this.width = width;
    this.zIndex = zIndex;
    Object.seal(this);
  }
  /**
   * Copies given data to this instance.
   *
   * @param {TJSPositionData}   data - Copy from this instance.
   *
   * @returns {TJSPositionData} This instance.
   */
  copy(data) {
    this.height = data.height;
    this.left = data.left;
    this.maxHeight = data.maxHeight;
    this.maxWidth = data.maxWidth;
    this.minHeight = data.minHeight;
    this.minWidth = data.minWidth;
    this.rotateX = data.rotateX;
    this.rotateY = data.rotateY;
    this.rotateZ = data.rotateZ;
    this.scale = data.scale;
    this.top = data.top;
    this.transformOrigin = data.transformOrigin;
    this.translateX = data.translateX;
    this.translateY = data.translateY;
    this.translateZ = data.translateZ;
    this.width = data.width;
    this.zIndex = data.zIndex;
    return this;
  }
}
class PositionStateAPI {
  /** @type {import('./TJSPositionData').TJSPositionData} */
  #data;
  /**
   * @type {Map<string, import('./').TJSPositionDataExtended>}
   */
  #dataSaved = /* @__PURE__ */ new Map();
  /** @type {import('./').TJSPosition} */
  #position;
  /** @type {import('./transform').TJSTransforms} */
  #transforms;
  constructor(position, data, transforms) {
    this.#position = position;
    this.#data = data;
    this.#transforms = transforms;
  }
  /**
   * Returns any stored save state by name.
   *
   * @param {object}   options - Options
   *
   * @param {string}   options.name - Saved data set name.
   *
   * @returns {import('./').TJSPositionDataExtended} The saved data set.
   */
  get({ name: name2 }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`Position - getSave error: 'name' is not a string.`);
    }
    return this.#dataSaved.get(name2);
  }
  /**
   * Returns any associated default data.
   *
   * @returns {import('./').TJSPositionDataExtended} Associated default data.
   */
  getDefault() {
    return this.#dataSaved.get("#defaultData");
  }
  /**
   * Removes and returns any position state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {import('./').TJSPositionDataExtended} Saved position data.
   */
  remove({ name: name2 }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`Position - remove: 'name' is not a string.`);
    }
    const data = this.#dataSaved.get(name2);
    this.#dataSaved.delete(name2);
    return data;
  }
  /**
   * Resets data to default values and invokes set.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.keepZIndex=false] - When true keeps current z-index.
   *
   * @param {boolean}  [opts.invokeSet=true] - When true invokes set method.
   *
   * @returns {boolean} Operation successful.
   */
  reset({ keepZIndex = false, invokeSet = true } = {}) {
    const defaultData = this.#dataSaved.get("#defaultData");
    if (!isObject$1(defaultData)) {
      return false;
    }
    if (this.#position.animate.isScheduled) {
      this.#position.animate.cancel();
    }
    const zIndex = this.#position.zIndex;
    const data = Object.assign({}, defaultData);
    if (keepZIndex) {
      data.zIndex = zIndex;
    }
    this.#transforms.reset(data);
    if (this.#position.parent?.reactive?.minimized) {
      this.#position.parent?.maximize?.({ animate: false, duration: 0 });
    }
    if (invokeSet) {
      setTimeout(() => this.#position.set(data), 0);
    }
    return true;
  }
  /**
      * Restores a saved positional state returning the data. Several optional parameters are available
      * to control whether the restore action occurs silently (no store / inline styles updates), animates
  -   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to}
      * allows specification of the duration, easing, and interpolate functions along with configuring a Promise to be
      * returned if awaiting the end of the animation.
      *
      * @param {object}            params - Parameters
      *
      * @param {string}            params.name - Saved data set name.
      *
      * @param {boolean}           [params.remove=false] - Remove data set.
      *
      * @param {Iterable<string>}  [params.properties] - Specific properties to set / animate.
      *
      * @param {boolean}           [params.silent] - Set position data directly; no store or style updates.
      *
      * @param {boolean}           [params.async=false] - If animating return a Promise that resolves with any saved data.
      *
      * @param {boolean}           [params.animateTo=false] - Animate to restore data.
      *
      * @param {number}            [params.duration=0.1] - Duration in seconds.
      *
      * @param {Function}          [params.ease=linear] - Easing function.
      *
      * @param {Function}          [params.interpolate=lerp] - Interpolation function.
      *
      * @returns {import('./').TJSPositionDataExtended | Promise<import('./').TJSPositionDataExtended>} Saved position
      *          data.
      */
  restore({
    name: name2,
    remove = false,
    properties: properties2,
    silent = false,
    async = false,
    animateTo = false,
    duration = 0.1,
    ease = identity$1,
    interpolate = lerp
  }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`Position - restore error: 'name' is not a string.`);
    }
    const dataSaved = this.#dataSaved.get(name2);
    if (dataSaved) {
      if (remove) {
        this.#dataSaved.delete(name2);
      }
      let data = dataSaved;
      if (isIterable(properties2)) {
        data = {};
        for (const property of properties2) {
          data[property] = dataSaved[property];
        }
      }
      if (silent) {
        for (const property in data) {
          this.#data[property] = data[property];
        }
        return dataSaved;
      } else if (animateTo) {
        if (data.transformOrigin !== this.#position.transformOrigin) {
          this.#position.transformOrigin = data.transformOrigin;
        }
        if (async) {
          return this.#position.animate.to(data, { duration, ease, interpolate }).finished.then(() => dataSaved);
        } else {
          this.#position.animate.to(data, { duration, ease, interpolate });
        }
      } else {
        this.#position.set(data);
      }
    }
    return dataSaved;
  }
  /**
   * Saves current position state with the opportunity to add extra data to the saved state.
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.name - name to index this saved data.
   *
   * @param {...*}     [opts.extra] - Extra data to add to saved data.
   *
   * @returns {import('./').TJSPositionData} Current position data
   */
  save({ name: name2, ...extra }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`Position - save error: 'name' is not a string.`);
    }
    const data = this.#position.get(extra);
    this.#dataSaved.set(name2, data);
    return data;
  }
  /**
   * Directly sets a position state.
   *
   * @param {object}   opts - Options.
   *
   * @param {string}   opts.name - name to index this saved data.
   *
   * @param {...*}     [opts.data] - TJSPosition data to set.
   */
  set({ name: name2, ...data }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`Position - set error: 'name' is not a string.`);
    }
    this.#dataSaved.set(name2, data);
  }
}
class StyleCache {
  constructor() {
    this.el = void 0;
    this.computed = void 0;
    this.marginLeft = void 0;
    this.marginTop = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.minHeight = void 0;
    this.minWidth = void 0;
    this.hasWillChange = false;
    this.resizeObserved = {
      contentHeight: void 0,
      contentWidth: void 0,
      offsetHeight: void 0,
      offsetWidth: void 0
    };
    const storeResizeObserved = writable(this.resizeObserved);
    this.stores = {
      element: writable(this.el),
      resizeContentHeight: propertyStore(storeResizeObserved, "contentHeight"),
      resizeContentWidth: propertyStore(storeResizeObserved, "contentWidth"),
      resizeObserved: storeResizeObserved,
      resizeOffsetHeight: propertyStore(storeResizeObserved, "offsetHeight"),
      resizeOffsetWidth: propertyStore(storeResizeObserved, "offsetWidth")
    };
  }
  /**
   * Returns the cached offsetHeight from any attached `resizeObserver` action otherwise gets the offsetHeight from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetHeight() {
    if (this.el instanceof HTMLElement) {
      return this.resizeObserved.offsetHeight !== void 0 ? this.resizeObserved.offsetHeight : this.el.offsetHeight;
    }
    throw new Error(`StyleCache - get offsetHeight error: no element assigned.`);
  }
  /**
   * Returns the cached offsetWidth from any attached `resizeObserver` action otherwise gets the offsetWidth from
   * the element directly. The more optimized path is using `resizeObserver` as getting it from the element
   * directly is more expensive and alters the execution order of an animation frame.
   *
   * @returns {number} The element offsetHeight.
   */
  get offsetWidth() {
    if (this.el instanceof HTMLElement) {
      return this.resizeObserved.offsetWidth !== void 0 ? this.resizeObserved.offsetWidth : this.el.offsetWidth;
    }
    throw new Error(`StyleCache - get offsetWidth error: no element assigned.`);
  }
  /**
   * @param {HTMLElement} el -
   *
   * @returns {boolean} Does element match cached element.
   */
  hasData(el) {
    return this.el === el;
  }
  /**
   * Resets the style cache.
   */
  reset() {
    if (this.el instanceof HTMLElement && this.el.isConnected && !this.hasWillChange) {
      this.el.style.willChange = null;
    }
    this.el = void 0;
    this.computed = void 0;
    this.marginLeft = void 0;
    this.marginTop = void 0;
    this.maxHeight = void 0;
    this.maxWidth = void 0;
    this.minHeight = void 0;
    this.minWidth = void 0;
    this.hasWillChange = false;
    this.resizeObserved.contentHeight = void 0;
    this.resizeObserved.contentWidth = void 0;
    this.resizeObserved.offsetHeight = void 0;
    this.resizeObserved.offsetWidth = void 0;
    this.stores.element.set(void 0);
  }
  /**
   * Updates the style cache with new data from the given element.
   *
   * @param {HTMLElement} el - An HTML element.
   */
  update(el) {
    this.el = el;
    this.computed = globalThis.getComputedStyle(el);
    this.marginLeft = StyleParse.pixels(el.style.marginLeft) ?? StyleParse.pixels(this.computed.marginLeft);
    this.marginTop = StyleParse.pixels(el.style.marginTop) ?? StyleParse.pixels(this.computed.marginTop);
    this.maxHeight = StyleParse.pixels(el.style.maxHeight) ?? StyleParse.pixels(this.computed.maxHeight);
    this.maxWidth = StyleParse.pixels(el.style.maxWidth) ?? StyleParse.pixels(this.computed.maxWidth);
    this.minHeight = StyleParse.pixels(el.style.minHeight) ?? StyleParse.pixels(this.computed.minHeight);
    this.minWidth = StyleParse.pixels(el.style.minWidth) ?? StyleParse.pixels(this.computed.minWidth);
    const willChange = el.style.willChange !== "" ? el.style.willChange : this.computed.willChange;
    this.hasWillChange = willChange !== "" && willChange !== "auto";
    this.stores.element.set(el);
  }
}
class TJSTransformData {
  constructor() {
    Object.seal(this);
  }
  /**
   * Stores the calculated bounding rectangle.
   *
   * @type {DOMRect}
   */
  #boundingRect = new DOMRect();
  /**
   * Stores the individual transformed corner points of the window in screen space clockwise from:
   * top left -> top right -> bottom right -> bottom left.
   *
   * @type {import('#runtime/math/gl-matrix').Vec3[]}
   */
  #corners = [Vec3.create(), Vec3.create(), Vec3.create(), Vec3.create()];
  /**
   * Stores the current gl-matrix Mat4 data.
   *
   * @type {import('#runtime/math/gl-matrix').Mat4}
   */
  #mat4 = Mat4.create();
  /**
   * Stores the pre & post origin translations to apply to matrix transforms.
   *
   * @type {import('#runtime/math/gl-matrix').Mat4[]}
   */
  #originTranslations = [Mat4.create(), Mat4.create()];
  /**
   * @returns {DOMRect} The bounding rectangle.
   */
  get boundingRect() {
    return this.#boundingRect;
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Vec3[]} The transformed corner points as Vec3 in screen space.
   */
  get corners() {
    return this.#corners;
  }
  /**
   * @returns {string} Returns the CSS style string for the transform matrix.
   */
  get css() {
    return `matrix3d(${this.mat4.join(",")})`;
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Mat4} The transform matrix.
   */
  get mat4() {
    return this.#mat4;
  }
  /**
   * @returns {import('#runtime/math/gl-matrix').Mat4[]} The pre / post translation matrices for origin translation.
   */
  get originTranslations() {
    return this.#originTranslations;
  }
}
const s_SCALE_VECTOR = [1, 1, 1];
const s_TRANSLATE_VECTOR = [0, 0, 0];
const s_MAT4_RESULT = Mat4.create();
const s_MAT4_TEMP = Mat4.create();
const s_VEC3_TEMP = Vec3.create();
class TJSTransforms {
  /**
   * Stores the transform keys in the order added.
   *
   * @type {string[]}
   */
  #orderList = [];
  constructor() {
    this._data = {};
  }
  /**
   * @returns {boolean} Whether there are active transforms in local data.
   */
  get isActive() {
    return this.#orderList.length > 0;
  }
  /**
   * @returns {number|undefined} Any local rotateX data.
   */
  get rotateX() {
    return this._data.rotateX;
  }
  /**
   * @returns {number|undefined} Any local rotateY data.
   */
  get rotateY() {
    return this._data.rotateY;
  }
  /**
   * @returns {number|undefined} Any local rotateZ data.
   */
  get rotateZ() {
    return this._data.rotateZ;
  }
  /**
   * @returns {number|undefined} Any local rotateZ scale.
   */
  get scale() {
    return this._data.scale;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateX() {
    return this._data.translateX;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateY() {
    return this._data.translateY;
  }
  /**
   * @returns {number|undefined} Any local translateZ data.
   */
  get translateZ() {
    return this._data.translateZ;
  }
  /**
   * Sets the local rotateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateX(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateX === void 0) {
        this.#orderList.push("rotateX");
      }
      this._data.rotateX = value;
    } else {
      if (this._data.rotateX !== void 0) {
        const index2 = this.#orderList.findIndex((entry) => entry === "rotateX");
        if (index2 >= 0) {
          this.#orderList.splice(index2, 1);
        }
      }
      delete this._data.rotateX;
    }
  }
  /**
   * Sets the local rotateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateY(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateY === void 0) {
        this.#orderList.push("rotateY");
      }
      this._data.rotateY = value;
    } else {
      if (this._data.rotateY !== void 0) {
        const index2 = this.#orderList.findIndex((entry) => entry === "rotateY");
        if (index2 >= 0) {
          this.#orderList.splice(index2, 1);
        }
      }
      delete this._data.rotateY;
    }
  }
  /**
   * Sets the local rotateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set rotateZ(value) {
    if (Number.isFinite(value)) {
      if (this._data.rotateZ === void 0) {
        this.#orderList.push("rotateZ");
      }
      this._data.rotateZ = value;
    } else {
      if (this._data.rotateZ !== void 0) {
        const index2 = this.#orderList.findIndex((entry) => entry === "rotateZ");
        if (index2 >= 0) {
          this.#orderList.splice(index2, 1);
        }
      }
      delete this._data.rotateZ;
    }
  }
  /**
   * Sets the local scale data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set scale(value) {
    if (Number.isFinite(value)) {
      if (this._data.scale === void 0) {
        this.#orderList.push("scale");
      }
      this._data.scale = value;
    } else {
      if (this._data.scale !== void 0) {
        const index2 = this.#orderList.findIndex((entry) => entry === "scale");
        if (index2 >= 0) {
          this.#orderList.splice(index2, 1);
        }
      }
      delete this._data.scale;
    }
  }
  /**
   * Sets the local translateX data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateX(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateX === void 0) {
        this.#orderList.push("translateX");
      }
      this._data.translateX = value;
    } else {
      if (this._data.translateX !== void 0) {
        const index2 = this.#orderList.findIndex((entry) => entry === "translateX");
        if (index2 >= 0) {
          this.#orderList.splice(index2, 1);
        }
      }
      delete this._data.translateX;
    }
  }
  /**
   * Sets the local translateY data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateY(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateY === void 0) {
        this.#orderList.push("translateY");
      }
      this._data.translateY = value;
    } else {
      if (this._data.translateY !== void 0) {
        const index2 = this.#orderList.findIndex((entry) => entry === "translateY");
        if (index2 >= 0) {
          this.#orderList.splice(index2, 1);
        }
      }
      delete this._data.translateY;
    }
  }
  /**
   * Sets the local translateZ data if the value is a finite number otherwise removes the local data.
   *
   * @param {number|null|undefined}   value - A value to set.
   */
  set translateZ(value) {
    if (Number.isFinite(value)) {
      if (this._data.translateZ === void 0) {
        this.#orderList.push("translateZ");
      }
      this._data.translateZ = value;
    } else {
      if (this._data.translateZ !== void 0) {
        const index2 = this.#orderList.findIndex((entry) => entry === "translateZ");
        if (index2 >= 0) {
          this.#orderList.splice(index2, 1);
        }
      }
      delete this._data.translateZ;
    }
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSS(data = this._data) {
    return `matrix3d(${this.getMat4(data, s_MAT4_RESULT).join(",")})`;
  }
  /**
   * Returns the matrix3d CSS transform for the given position / transform data.
   *
   * @param {object} [data] - Optional position data otherwise use local stored transform data.
   *
   * @returns {string} The CSS matrix3d string.
   */
  getCSSOrtho(data = this._data) {
    return `matrix3d(${this.getMat4Ortho(data, s_MAT4_RESULT).join(",")})`;
  }
  /**
   * Collects all data including a bounding rect, transform matrix, and points array of the given
   * {@link TJSPositionData} instance with the applied local transform data.
   *
   * @param {import('../').TJSPositionData} position - The position data to process.
   *
   * @param {TJSTransformData} [output] - Optional TJSTransformData output instance.
   *
   * @param {object} [validationData] - Optional validation data for adjustment parameters.
   *
   * @returns {TJSTransformData} The output TJSTransformData instance.
   */
  getData(position, output = new TJSTransformData(), validationData = {}) {
    const valWidth = validationData.width ?? 0;
    const valHeight = validationData.height ?? 0;
    const valOffsetTop = validationData.offsetTop ?? validationData.marginTop ?? 0;
    const valOffsetLeft = validationData.offsetLeft ?? validationData.offsetLeft ?? 0;
    position.top += valOffsetTop;
    position.left += valOffsetLeft;
    const width = Number.isFinite(position.width) ? position.width : valWidth;
    const height = Number.isFinite(position.height) ? position.height : valHeight;
    const rect = output.corners;
    if (this.hasTransform(position)) {
      rect[0][0] = rect[0][1] = rect[0][2] = 0;
      rect[1][0] = width;
      rect[1][1] = rect[1][2] = 0;
      rect[2][0] = width;
      rect[2][1] = height;
      rect[2][2] = 0;
      rect[3][0] = 0;
      rect[3][1] = height;
      rect[3][2] = 0;
      const matrix2 = this.getMat4(position, output.mat4);
      const translate = s_GET_ORIGIN_TRANSLATION(position.transformOrigin, width, height, output.originTranslations);
      if (transformOriginDefault === position.transformOrigin) {
        Vec3.transformMat4(rect[0], rect[0], matrix2);
        Vec3.transformMat4(rect[1], rect[1], matrix2);
        Vec3.transformMat4(rect[2], rect[2], matrix2);
        Vec3.transformMat4(rect[3], rect[3], matrix2);
      } else {
        Vec3.transformMat4(rect[0], rect[0], translate[0]);
        Vec3.transformMat4(rect[0], rect[0], matrix2);
        Vec3.transformMat4(rect[0], rect[0], translate[1]);
        Vec3.transformMat4(rect[1], rect[1], translate[0]);
        Vec3.transformMat4(rect[1], rect[1], matrix2);
        Vec3.transformMat4(rect[1], rect[1], translate[1]);
        Vec3.transformMat4(rect[2], rect[2], translate[0]);
        Vec3.transformMat4(rect[2], rect[2], matrix2);
        Vec3.transformMat4(rect[2], rect[2], translate[1]);
        Vec3.transformMat4(rect[3], rect[3], translate[0]);
        Vec3.transformMat4(rect[3], rect[3], matrix2);
        Vec3.transformMat4(rect[3], rect[3], translate[1]);
      }
      rect[0][0] = position.left + rect[0][0];
      rect[0][1] = position.top + rect[0][1];
      rect[1][0] = position.left + rect[1][0];
      rect[1][1] = position.top + rect[1][1];
      rect[2][0] = position.left + rect[2][0];
      rect[2][1] = position.top + rect[2][1];
      rect[3][0] = position.left + rect[3][0];
      rect[3][1] = position.top + rect[3][1];
    } else {
      rect[0][0] = position.left;
      rect[0][1] = position.top;
      rect[1][0] = position.left + width;
      rect[1][1] = position.top;
      rect[2][0] = position.left + width;
      rect[2][1] = position.top + height;
      rect[3][0] = position.left;
      rect[3][1] = position.top + height;
      Mat4.identity(output.mat4);
    }
    let maxX = Number.MIN_SAFE_INTEGER;
    let maxY = Number.MIN_SAFE_INTEGER;
    let minX = Number.MAX_SAFE_INTEGER;
    let minY = Number.MAX_SAFE_INTEGER;
    for (let cntr = 4; --cntr >= 0; ) {
      if (rect[cntr][0] > maxX) {
        maxX = rect[cntr][0];
      }
      if (rect[cntr][0] < minX) {
        minX = rect[cntr][0];
      }
      if (rect[cntr][1] > maxY) {
        maxY = rect[cntr][1];
      }
      if (rect[cntr][1] < minY) {
        minY = rect[cntr][1];
      }
    }
    const boundingRect = output.boundingRect;
    boundingRect.x = minX;
    boundingRect.y = minY;
    boundingRect.width = maxX - minX;
    boundingRect.height = maxY - minY;
    position.top -= valOffsetTop;
    position.left -= valOffsetLeft;
    return output;
  }
  /**
   * Creates a transform matrix based on local data applied in order it was added.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {object}   [data] - TJSPositionData instance or local transform data.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4}  [output] - The output mat4 instance.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4} Transform matrix.
   */
  getMat4(data = this._data, output = Mat4.create()) {
    const matrix2 = Mat4.identity(output);
    let seenKeys = 0;
    const orderList = this.#orderList;
    for (let cntr = 0; cntr < orderList.length; cntr++) {
      const key = orderList[cntr];
      switch (key) {
        case "rotateX":
          seenKeys |= transformKeysBitwise.rotateX;
          Mat4.multiply(matrix2, matrix2, Mat4.fromXRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "rotateY":
          seenKeys |= transformKeysBitwise.rotateY;
          Mat4.multiply(matrix2, matrix2, Mat4.fromYRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "rotateZ":
          seenKeys |= transformKeysBitwise.rotateZ;
          Mat4.multiply(matrix2, matrix2, Mat4.fromZRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "scale":
          seenKeys |= transformKeysBitwise.scale;
          s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data[key];
          Mat4.multiply(matrix2, matrix2, Mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
          break;
        case "translateX":
          seenKeys |= transformKeysBitwise.translateX;
          s_TRANSLATE_VECTOR[0] = data.translateX;
          s_TRANSLATE_VECTOR[1] = 0;
          s_TRANSLATE_VECTOR[2] = 0;
          Mat4.multiply(matrix2, matrix2, Mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
        case "translateY":
          seenKeys |= transformKeysBitwise.translateY;
          s_TRANSLATE_VECTOR[0] = 0;
          s_TRANSLATE_VECTOR[1] = data.translateY;
          s_TRANSLATE_VECTOR[2] = 0;
          Mat4.multiply(matrix2, matrix2, Mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
        case "translateZ":
          seenKeys |= transformKeysBitwise.translateZ;
          s_TRANSLATE_VECTOR[0] = 0;
          s_TRANSLATE_VECTOR[1] = 0;
          s_TRANSLATE_VECTOR[2] = data.translateZ;
          Mat4.multiply(matrix2, matrix2, Mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
          break;
      }
    }
    if (data !== this._data) {
      for (let cntr = 0; cntr < transformKeys.length; cntr++) {
        const key = transformKeys[cntr];
        if (data[key] === null || (seenKeys & transformKeysBitwise[key]) > 0) {
          continue;
        }
        switch (key) {
          case "rotateX":
            Mat4.multiply(matrix2, matrix2, Mat4.fromXRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "rotateY":
            Mat4.multiply(matrix2, matrix2, Mat4.fromYRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "rotateZ":
            Mat4.multiply(matrix2, matrix2, Mat4.fromZRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "scale":
            s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data[key];
            Mat4.multiply(matrix2, matrix2, Mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
            break;
          case "translateX":
            s_TRANSLATE_VECTOR[0] = data[key];
            s_TRANSLATE_VECTOR[1] = 0;
            s_TRANSLATE_VECTOR[2] = 0;
            Mat4.multiply(matrix2, matrix2, Mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
          case "translateY":
            s_TRANSLATE_VECTOR[0] = 0;
            s_TRANSLATE_VECTOR[1] = data[key];
            s_TRANSLATE_VECTOR[2] = 0;
            Mat4.multiply(matrix2, matrix2, Mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
          case "translateZ":
            s_TRANSLATE_VECTOR[0] = 0;
            s_TRANSLATE_VECTOR[1] = 0;
            s_TRANSLATE_VECTOR[2] = data[key];
            Mat4.multiply(matrix2, matrix2, Mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
            break;
        }
      }
    }
    return matrix2;
  }
  /**
   * Provides an orthographic enhancement to convert left / top positional data to a translate operation.
   *
   * This transform matrix takes into account that the remaining operations are , but adds any left / top attributes from passed in data to
   * translate X / Y.
   *
   * If no data object is provided then the source is the local transform data. If another data object is supplied
   * then the stored local transform order is applied then all remaining transform keys are applied. This allows the
   * construction of a transform matrix in advance of setting local data and is useful in collision detection.
   *
   * @param {object}   [data] - TJSPositionData instance or local transform data.
   *
   * @param {import('#runtime/math/gl-matrix').Mat4}  [output] - The output mat4 instance.
   *
   * @returns {import('#runtime/math/gl-matrix').Mat4} Transform matrix.
   */
  getMat4Ortho(data = this._data, output = Mat4.create()) {
    const matrix2 = Mat4.identity(output);
    s_TRANSLATE_VECTOR[0] = (data.left ?? 0) + (data.translateX ?? 0);
    s_TRANSLATE_VECTOR[1] = (data.top ?? 0) + (data.translateY ?? 0);
    s_TRANSLATE_VECTOR[2] = data.translateZ ?? 0;
    Mat4.multiply(matrix2, matrix2, Mat4.fromTranslation(s_MAT4_TEMP, s_TRANSLATE_VECTOR));
    if (data.scale !== null) {
      s_SCALE_VECTOR[0] = s_SCALE_VECTOR[1] = data.scale;
      Mat4.multiply(matrix2, matrix2, Mat4.fromScaling(s_MAT4_TEMP, s_SCALE_VECTOR));
    }
    if (data.rotateX === null && data.rotateY === null && data.rotateZ === null) {
      return matrix2;
    }
    let seenKeys = 0;
    const orderList = this.#orderList;
    for (let cntr = 0; cntr < orderList.length; cntr++) {
      const key = orderList[cntr];
      switch (key) {
        case "rotateX":
          seenKeys |= transformKeysBitwise.rotateX;
          Mat4.multiply(matrix2, matrix2, Mat4.fromXRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "rotateY":
          seenKeys |= transformKeysBitwise.rotateY;
          Mat4.multiply(matrix2, matrix2, Mat4.fromYRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
        case "rotateZ":
          seenKeys |= transformKeysBitwise.rotateZ;
          Mat4.multiply(matrix2, matrix2, Mat4.fromZRotation(s_MAT4_TEMP, degToRad(data[key])));
          break;
      }
    }
    if (data !== this._data) {
      for (let cntr = 0; cntr < transformKeys.length; cntr++) {
        const key = transformKeys[cntr];
        if (data[key] === null || (seenKeys & transformKeysBitwise[key]) > 0) {
          continue;
        }
        switch (key) {
          case "rotateX":
            Mat4.multiply(matrix2, matrix2, Mat4.fromXRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "rotateY":
            Mat4.multiply(matrix2, matrix2, Mat4.fromYRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
          case "rotateZ":
            Mat4.multiply(matrix2, matrix2, Mat4.fromZRotation(s_MAT4_TEMP, degToRad(data[key])));
            break;
        }
      }
    }
    return matrix2;
  }
  /**
   * Tests an object if it contains transform keys and the values are finite numbers.
   *
   * @param {object} data - An object to test for transform data.
   *
   * @returns {boolean} Whether the given TJSPositionData has transforms.
   */
  hasTransform(data) {
    for (const key of transformKeys) {
      if (Number.isFinite(data[key])) {
        return true;
      }
    }
    return false;
  }
  /**
   * Resets internal data from the given object containing valid transform keys.
   *
   * @param {object}   data - An object with transform data.
   */
  reset(data) {
    for (const key in data) {
      if (transformKeys.includes(key)) {
        if (Number.isFinite(data[key])) {
          this._data[key] = data[key];
        } else {
          const index2 = this.#orderList.findIndex((entry) => entry === key);
          if (index2 >= 0) {
            this.#orderList.splice(index2, 1);
          }
          delete this._data[key];
        }
      }
    }
  }
}
function s_GET_ORIGIN_TRANSLATION(transformOrigin, width, height, output) {
  const vector = s_VEC3_TEMP;
  switch (transformOrigin) {
    case "top left":
      vector[0] = vector[1] = 0;
      Mat4.fromTranslation(output[0], vector);
      Mat4.fromTranslation(output[1], vector);
      break;
    case "top center":
      vector[0] = -width * 0.5;
      vector[1] = 0;
      Mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      Mat4.fromTranslation(output[1], vector);
      break;
    case "top right":
      vector[0] = -width;
      vector[1] = 0;
      Mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      Mat4.fromTranslation(output[1], vector);
      break;
    case "center left":
      vector[0] = 0;
      vector[1] = -height * 0.5;
      Mat4.fromTranslation(output[0], vector);
      vector[1] = height * 0.5;
      Mat4.fromTranslation(output[1], vector);
      break;
    case null:
    case "center":
      vector[0] = -width * 0.5;
      vector[1] = -height * 0.5;
      Mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      vector[1] = height * 0.5;
      Mat4.fromTranslation(output[1], vector);
      break;
    case "center right":
      vector[0] = -width;
      vector[1] = -height * 0.5;
      Mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      vector[1] = height * 0.5;
      Mat4.fromTranslation(output[1], vector);
      break;
    case "bottom left":
      vector[0] = 0;
      vector[1] = -height;
      Mat4.fromTranslation(output[0], vector);
      vector[1] = height;
      Mat4.fromTranslation(output[1], vector);
      break;
    case "bottom center":
      vector[0] = -width * 0.5;
      vector[1] = -height;
      Mat4.fromTranslation(output[0], vector);
      vector[0] = width * 0.5;
      vector[1] = height;
      Mat4.fromTranslation(output[1], vector);
      break;
    case "bottom right":
      vector[0] = -width;
      vector[1] = -height;
      Mat4.fromTranslation(output[0], vector);
      vector[0] = width;
      vector[1] = height;
      Mat4.fromTranslation(output[1], vector);
      break;
    default:
      Mat4.identity(output[0]);
      Mat4.identity(output[1]);
      break;
  }
  return output;
}
class AdapterValidators {
  /** @type {boolean} */
  #enabled = true;
  /**
   * @type {import('../').ValidatorData[]}
   */
  #validatorData;
  #mapUnsubscribe = /* @__PURE__ */ new Map();
  /**
   * @returns {[AdapterValidators, import('../').ValidatorData[]]} Returns this and internal storage for validator
   *          adapter.
   */
  constructor() {
    this.#validatorData = [];
    Object.seal(this);
    return [this, this.#validatorData];
  }
  /**
   * @returns {boolean} Returns the enabled state.s
   */
  get enabled() {
    return this.#enabled;
  }
  /**
   * @returns {number} Returns the length of the validators array.
   */
  get length() {
    return this.#validatorData.length;
  }
  /**
   * @param {boolean}  enabled - Sets enabled state.
   */
  set enabled(enabled) {
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  /**
   * Provides an iterator for validators.
   *
   * @yields {import('../').ValidatorData}
   */
  *[Symbol.iterator]() {
    if (this.#validatorData.length === 0) {
      return;
    }
    for (const entry of this.#validatorData) {
      yield { ...entry };
    }
  }
  /**
   * @param {...(import('../').ValidatorFn | import('../').ValidatorData)}   validators -
   */
  add(...validators) {
    for (const validator of validators) {
      const validatorType = typeof validator;
      if (validatorType !== "function" && validatorType !== "object" || validator === null) {
        throw new TypeError(`AdapterValidator error: 'validator' is not a function or object.`);
      }
      let data = void 0;
      let subscribeFn = void 0;
      switch (validatorType) {
        case "function":
          data = {
            id: void 0,
            validator,
            weight: 1
          };
          subscribeFn = validator.subscribe;
          break;
        case "object":
          if (typeof validator.validator !== "function") {
            throw new TypeError(`AdapterValidator error: 'validator' attribute is not a function.`);
          }
          if (validator.weight !== void 0 && typeof validator.weight !== "number" || (validator.weight < 0 || validator.weight > 1)) {
            throw new TypeError(
              `AdapterValidator error: 'weight' attribute is not a number between '0 - 1' inclusive.`
            );
          }
          data = {
            id: validator.id !== void 0 ? validator.id : void 0,
            validator: validator.validator.bind(validator),
            weight: validator.weight || 1,
            instance: validator
          };
          subscribeFn = validator.validator.subscribe ?? validator.subscribe;
          break;
      }
      const index2 = this.#validatorData.findIndex((value) => {
        return data.weight < value.weight;
      });
      if (index2 >= 0) {
        this.#validatorData.splice(index2, 0, data);
      } else {
        this.#validatorData.push(data);
      }
      if (typeof subscribeFn === "function") {
        const unsubscribe = subscribeFn();
        if (typeof unsubscribe !== "function") {
          throw new TypeError(
            "AdapterValidator error: Filter has subscribe function, but no unsubscribe function is returned."
          );
        }
        if (this.#mapUnsubscribe.has(data.validator)) {
          throw new Error(
            "AdapterValidator error: Filter added already has an unsubscribe function registered."
          );
        }
        this.#mapUnsubscribe.set(data.validator, unsubscribe);
      }
    }
  }
  clear() {
    this.#validatorData.length = 0;
    for (const unsubscribe of this.#mapUnsubscribe.values()) {
      unsubscribe();
    }
    this.#mapUnsubscribe.clear();
  }
  /**
   * @param {...(import('../').ValidatorFn | import('../').ValidatorData)}   validators -
   */
  remove(...validators) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    for (const data of validators) {
      const actualValidator = typeof data === "function" ? data : isObject$1(data) ? data.validator : void 0;
      if (!actualValidator) {
        continue;
      }
      for (let cntr = this.#validatorData.length; --cntr >= 0; ) {
        if (this.#validatorData[cntr].validator === actualValidator) {
          this.#validatorData.splice(cntr, 1);
          let unsubscribe = void 0;
          if (typeof (unsubscribe = this.#mapUnsubscribe.get(actualValidator)) === "function") {
            unsubscribe();
            this.#mapUnsubscribe.delete(actualValidator);
          }
        }
      }
    }
  }
  /**
   * Remove validators by the provided callback. The callback takes 3 parameters: `id`, `validator`, and `weight`.
   * Any truthy value returned will remove that validator.
   *
   * @param {function(*, import('../').ValidatorFn, number): boolean} callback - Callback function to evaluate each
   *        validator entry.
   */
  removeBy(callback) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    if (typeof callback !== "function") {
      throw new TypeError(`AdapterValidator error: 'callback' is not a function.`);
    }
    this.#validatorData = this.#validatorData.filter((data) => {
      const remove = callback.call(callback, { ...data });
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.validator)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.validator);
        }
      }
      return !remove;
    });
  }
  removeById(...ids) {
    const length = this.#validatorData.length;
    if (length === 0) {
      return;
    }
    this.#validatorData = this.#validatorData.filter((data) => {
      let remove = false;
      for (const id of ids) {
        remove |= data.id === id;
      }
      if (remove) {
        let unsubscribe;
        if (typeof (unsubscribe = this.#mapUnsubscribe.get(data.validator)) === "function") {
          unsubscribe();
          this.#mapUnsubscribe.delete(data.validator);
        }
      }
      return !remove;
    });
  }
}
class BasicBounds {
  /**
   * When true constrains the min / max width or height to element.
   *
   * @type {boolean}
   */
  #constrain;
  /**
   * @type {HTMLElement}
   */
  #element;
  /**
   * When true the validator is active.
   *
   * @type {boolean}
   */
  #enabled;
  /**
   * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
   * performance oriented. If manually set this height is used instead of `offsetHeight`.
   *
   * @type {number}
   */
  #height;
  /**
   * Set from an optional value in the constructor to lock accessors preventing modification.
   */
  #lock;
  /**
   * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
   * performance oriented. If manually set this width is used instead of `offsetWidth`.
   *
   * @type {number}
   */
  #width;
  constructor({ constrain = true, element: element2, enabled = true, lock = false, width, height } = {}) {
    this.element = element2;
    this.constrain = constrain;
    this.enabled = enabled;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  get constrain() {
    return this.#constrain;
  }
  get element() {
    return this.#element;
  }
  get enabled() {
    return this.#enabled;
  }
  get height() {
    return this.#height;
  }
  get width() {
    return this.#width;
  }
  set constrain(constrain) {
    if (this.#lock) {
      return;
    }
    if (typeof constrain !== "boolean") {
      throw new TypeError(`'constrain' is not a boolean.`);
    }
    this.#constrain = constrain;
  }
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  set enabled(enabled) {
    if (this.#lock) {
      return;
    }
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  /**
   * Provides a validator that respects transforms in positional data constraining the position to within the target
   * elements bounds.
   *
   * @param {import('../').ValidationData}   valData - The associated validation data for position updates.
   *
   * @returns {import('../').TJSPositionData} Potentially adjusted position data.
   */
  validator(valData) {
    if (!this.#enabled) {
      return valData.position;
    }
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    if (typeof valData.position.width === "number") {
      const maxW = valData.maxWidth ?? (this.#constrain ? boundsWidth : Number.MAX_SAFE_INTEGER);
      valData.position.width = valData.width = clamp$1(valData.position.width, valData.minWidth, maxW);
      if (valData.width + valData.position.left + valData.marginLeft > boundsWidth) {
        valData.position.left = boundsWidth - valData.width - valData.marginLeft;
      }
    }
    if (typeof valData.position.height === "number") {
      const maxH = valData.maxHeight ?? (this.#constrain ? boundsHeight : Number.MAX_SAFE_INTEGER);
      valData.position.height = valData.height = clamp$1(valData.position.height, valData.minHeight, maxH);
      if (valData.height + valData.position.top + valData.marginTop > boundsHeight) {
        valData.position.top = boundsHeight - valData.height - valData.marginTop;
      }
    }
    const maxL = Math.max(boundsWidth - valData.width - valData.marginLeft, 0);
    valData.position.left = Math.round(clamp$1(valData.position.left, 0, maxL));
    const maxT = Math.max(boundsHeight - valData.height - valData.marginTop, 0);
    valData.position.top = Math.round(clamp$1(valData.position.top, 0, maxT));
    return valData.position;
  }
}
const s_TRANSFORM_DATA = new TJSTransformData();
class TransformBounds {
  /**
   * When true constrains the min / max width or height to element.
   *
   * @type {boolean}
   */
  #constrain;
  /**
   * @type {HTMLElement}
   */
  #element;
  /**
   * When true the validator is active.
   *
   * @type {boolean}
   */
  #enabled;
  /**
   * Provides a manual setting of the element height. As things go `offsetHeight` causes a browser layout and is not
   * performance oriented. If manually set this height is used instead of `offsetHeight`.
   *
   * @type {number}
   */
  #height;
  /**
   * Set from an optional value in the constructor to lock accessors preventing modification.
   */
  #lock;
  /**
   * Provides a manual setting of the element width. As things go `offsetWidth` causes a browser layout and is not
   * performance oriented. If manually set this width is used instead of `offsetWidth`.
   *
   * @type {number}
   */
  #width;
  constructor({ constrain = true, element: element2, enabled = true, lock = false, width, height } = {}) {
    this.element = element2;
    this.constrain = constrain;
    this.enabled = enabled;
    this.width = width;
    this.height = height;
    this.#lock = typeof lock === "boolean" ? lock : false;
  }
  get constrain() {
    return this.#constrain;
  }
  get element() {
    return this.#element;
  }
  get enabled() {
    return this.#enabled;
  }
  get height() {
    return this.#height;
  }
  get width() {
    return this.#width;
  }
  set constrain(constrain) {
    if (this.#lock) {
      return;
    }
    if (typeof constrain !== "boolean") {
      throw new TypeError(`'constrain' is not a boolean.`);
    }
    this.#constrain = constrain;
  }
  set element(element2) {
    if (this.#lock) {
      return;
    }
    if (element2 === void 0 || element2 === null || element2 instanceof HTMLElement) {
      this.#element = element2;
    } else {
      throw new TypeError(`'element' is not a HTMLElement, undefined, or null.`);
    }
  }
  set enabled(enabled) {
    if (this.#lock) {
      return;
    }
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  set height(height) {
    if (this.#lock) {
      return;
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  set width(width) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
  }
  setDimension(width, height) {
    if (this.#lock) {
      return;
    }
    if (width === void 0 || Number.isFinite(width)) {
      this.#width = width;
    } else {
      throw new TypeError(`'width' is not a finite number or undefined.`);
    }
    if (height === void 0 || Number.isFinite(height)) {
      this.#height = height;
    } else {
      throw new TypeError(`'height' is not a finite number or undefined.`);
    }
  }
  /**
   * Provides a validator that respects transforms in positional data constraining the position to within the target
   * elements bounds.
   *
   * @param {import('../').ValidationData}   valData - The associated validation data for position updates.
   *
   * @returns {import('../').TJSPositionData} Potentially adjusted position data.
   */
  validator(valData) {
    if (!this.#enabled) {
      return valData.position;
    }
    const boundsWidth = this.#width ?? this.#element?.offsetWidth ?? globalThis.innerWidth;
    const boundsHeight = this.#height ?? this.#element?.offsetHeight ?? globalThis.innerHeight;
    if (typeof valData.position.width === "number") {
      const maxW = valData.maxWidth ?? (this.#constrain ? boundsWidth : Number.MAX_SAFE_INTEGER);
      valData.position.width = clamp$1(valData.width, valData.minWidth, maxW);
    }
    if (typeof valData.position.height === "number") {
      const maxH = valData.maxHeight ?? (this.#constrain ? boundsHeight : Number.MAX_SAFE_INTEGER);
      valData.position.height = clamp$1(valData.height, valData.minHeight, maxH);
    }
    const data = valData.transforms.getData(valData.position, s_TRANSFORM_DATA, valData);
    const initialX = data.boundingRect.x;
    const initialY = data.boundingRect.y;
    if (data.boundingRect.bottom + valData.marginTop > boundsHeight) {
      data.boundingRect.y += boundsHeight - data.boundingRect.bottom - valData.marginTop;
    }
    if (data.boundingRect.right + valData.marginLeft > boundsWidth) {
      data.boundingRect.x += boundsWidth - data.boundingRect.right - valData.marginLeft;
    }
    if (data.boundingRect.top - valData.marginTop < 0) {
      data.boundingRect.y += Math.abs(data.boundingRect.top - valData.marginTop);
    }
    if (data.boundingRect.left - valData.marginLeft < 0) {
      data.boundingRect.x += Math.abs(data.boundingRect.left - valData.marginLeft);
    }
    valData.position.left -= initialX - data.boundingRect.x;
    valData.position.top -= initialY - data.boundingRect.y;
    return valData.position;
  }
}
class UpdateElementData {
  constructor() {
    this.data = void 0;
    this.dataSubscribers = new TJSPositionData();
    this.dimensionData = { width: 0, height: 0 };
    this.changeSet = void 0;
    this.options = void 0;
    this.queued = false;
    this.styleCache = void 0;
    this.transforms = void 0;
    this.transformData = new TJSTransformData();
    this.subscriptions = void 0;
    this.storeDimension = writable(this.dimensionData);
    this.storeTransform = writable(this.transformData, () => {
      this.options.transformSubscribed = true;
      return () => this.options.transformSubscribed = false;
    });
    this.queued = false;
    Object.seal(this.dimensionData);
  }
}
class UpdateElementManager {
  static list = [];
  static listCntr = 0;
  static updatePromise;
  static get promise() {
    return this.updatePromise;
  }
  /**
   * Potentially adds the given element and internal updateData instance to the list.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {import('./UpdateElementData').UpdateElementData} updateData - An UpdateElementData instance.
   *
   * @returns {Promise<number>} The unified next frame update promise. Returns `currentTime`.
   */
  static add(el, updateData) {
    if (this.listCntr < this.list.length) {
      const entry = this.list[this.listCntr];
      entry[0] = el;
      entry[1] = updateData;
    } else {
      this.list.push([el, updateData]);
    }
    this.listCntr++;
    updateData.queued = true;
    if (!this.updatePromise) {
      this.updatePromise = this.wait();
    }
    return this.updatePromise;
  }
  /**
   * Await on `nextAnimationFrame` and iterate over list map invoking callback functions.
   *
   * @returns {Promise<number>} The next frame Promise / currentTime from nextAnimationFrame.
   */
  static async wait() {
    const currentTime = await nextAnimationFrame();
    this.updatePromise = void 0;
    for (let cntr = this.listCntr; --cntr >= 0; ) {
      const entry = this.list[cntr];
      const el = entry[0];
      const updateData = entry[1];
      entry[0] = void 0;
      entry[1] = void 0;
      updateData.queued = false;
      if (!el.isConnected) {
        continue;
      }
      if (updateData.options.ortho) {
        s_UPDATE_ELEMENT_ORTHO(el, updateData);
      } else {
        s_UPDATE_ELEMENT(el, updateData);
      }
      if (updateData.options.calculateTransform || updateData.options.transformSubscribed) {
        s_UPDATE_TRANSFORM(el, updateData);
      }
      this.updateSubscribers(updateData);
    }
    this.listCntr = 0;
    return currentTime;
  }
  /**
   * Potentially immediately updates the given element.
   *
   * @param {HTMLElement}       el - An HTMLElement instance.
   *
   * @param {import('./UpdateElementData').UpdateElementData} updateData - An UpdateElementData instance.
   */
  static immediate(el, updateData) {
    if (!el.isConnected) {
      return;
    }
    if (updateData.options.ortho) {
      s_UPDATE_ELEMENT_ORTHO(el, updateData);
    } else {
      s_UPDATE_ELEMENT(el, updateData);
    }
    if (updateData.options.calculateTransform || updateData.options.transformSubscribed) {
      s_UPDATE_TRANSFORM(el, updateData);
    }
    this.updateSubscribers(updateData);
  }
  /**
   * @param {import('./UpdateElementData').UpdateElementData} updateData - Data change set.
   */
  static updateSubscribers(updateData) {
    const data = updateData.data;
    const changeSet = updateData.changeSet;
    if (!changeSet.hasChange()) {
      return;
    }
    const output = updateData.dataSubscribers.copy(data);
    const subscriptions = updateData.subscriptions;
    if (subscriptions.length > 0) {
      for (let cntr = 0; cntr < subscriptions.length; cntr++) {
        subscriptions[cntr](output);
      }
    }
    if (changeSet.width || changeSet.height) {
      updateData.dimensionData.width = data.width;
      updateData.dimensionData.height = data.height;
      updateData.storeDimension.set(updateData.dimensionData);
    }
    changeSet.set(false);
  }
}
function s_UPDATE_ELEMENT(el, updateData) {
  const changeSet = updateData.changeSet;
  const data = updateData.data;
  if (changeSet.left) {
    el.style.left = `${data.left}px`;
  }
  if (changeSet.top) {
    el.style.top = `${data.top}px`;
  }
  if (changeSet.zIndex) {
    el.style.zIndex = typeof data.zIndex === "number" ? `${data.zIndex}` : null;
  }
  if (changeSet.width) {
    el.style.width = typeof data.width === "number" ? `${data.width}px` : data.width;
  }
  if (changeSet.height) {
    el.style.height = typeof data.height === "number" ? `${data.height}px` : data.height;
  }
  if (changeSet.transformOrigin) {
    el.style.transformOrigin = data.transformOrigin;
  }
  if (changeSet.transform) {
    el.style.transform = updateData.transforms.isActive ? updateData.transforms.getCSS() : null;
  }
}
function s_UPDATE_ELEMENT_ORTHO(el, updateData) {
  const changeSet = updateData.changeSet;
  const data = updateData.data;
  if (changeSet.zIndex) {
    el.style.zIndex = typeof data.zIndex === "number" ? `${data.zIndex}` : null;
  }
  if (changeSet.width) {
    el.style.width = typeof data.width === "number" ? `${data.width}px` : data.width;
  }
  if (changeSet.height) {
    el.style.height = typeof data.height === "number" ? `${data.height}px` : data.height;
  }
  if (changeSet.transformOrigin) {
    el.style.transformOrigin = data.transformOrigin;
  }
  if (changeSet.left || changeSet.top || changeSet.transform) {
    el.style.transform = updateData.transforms.getCSSOrtho(data);
  }
}
function s_UPDATE_TRANSFORM(el, updateData) {
  s_VALIDATION_DATA$1.height = updateData.data.height !== "auto" ? updateData.data.height : updateData.styleCache.offsetHeight;
  s_VALIDATION_DATA$1.width = updateData.data.width !== "auto" ? updateData.data.width : updateData.styleCache.offsetWidth;
  s_VALIDATION_DATA$1.marginLeft = updateData.styleCache.marginLeft;
  s_VALIDATION_DATA$1.marginTop = updateData.styleCache.marginTop;
  updateData.transforms.getData(updateData.data, updateData.transformData, s_VALIDATION_DATA$1);
  updateData.storeTransform.set(updateData.transformData);
}
const s_VALIDATION_DATA$1 = {
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0
};
class TJSPosition {
  /**
   * @type {{browserCentered: Centered, Centered: Centered}}
   */
  static #positionInitial = {
    browserCentered: new Centered({ lock: true }),
    Centered
  };
  /**
   * @type {{TransformBounds: TransformBounds, BasicBounds: BasicBounds, basicWindow: BasicBounds, transformWindow: TransformBounds}}
   */
  static #positionValidators = {
    basicWindow: new BasicBounds({ lock: true }),
    BasicBounds,
    transformWindow: new TransformBounds({ lock: true }),
    TransformBounds
  };
  /**
   * @type {TJSPositionData}
   */
  #data = new TJSPositionData();
  /**
   * Provides the animation API.
   *
   * @type {AnimationAPI}
   */
  #animate = new AnimationAPI(this, this.#data);
  /**
   * Provides a way to turn on / off the position handling.
   *
   * @type {boolean}
   */
  #enabled = true;
  /**
   * Stores ongoing options that are set in the constructor or by transform store subscription.
   *
   * @type {import('./').TJSPositionOptions}
   */
  #options = {
    calculateTransform: false,
    initialHelper: void 0,
    ortho: true,
    transformSubscribed: false
  };
  /**
   * The associated parent for positional data tracking. Used in validators.
   *
   * @type {import('./').TJSPositionParent}
   */
  #parent;
  /**
   * Stores the style attributes that changed on update.
   *
   * @type {PositionChangeSet}
   */
  #positionChangeSet = new PositionChangeSet();
  /**
   * @type {import('./').TJSPositionStores}
   */
  #stores;
  /**
   * Stores an instance of the computer styles for the target element.
   *
   * @type {StyleCache}
   */
  #styleCache;
  /**
   * Stores the subscribers.
   *
   * @type {import('svelte/store').Subscriber<TJSPositionData>[]}
   */
  #subscriptions = [];
  /**
   * @type {TJSTransforms}
   */
  #transforms = new TJSTransforms();
  /**
   * @type {UpdateElementData}
   */
  #updateElementData;
  /**
   * Stores the UpdateElementManager wait promise.
   *
   * @type {Promise}
   */
  #updateElementPromise;
  /**
   * @type {AdapterValidators}
   */
  #validators;
  /**
   * @type {import('./').ValidatorData[]}
   */
  #validatorData;
  /**
   * @type {PositionStateAPI}
   */
  #state = new PositionStateAPI(this, this.#data, this.#transforms);
  /**
   * @returns {AnimationGroupAPI} Public Animation API.
   */
  static get Animate() {
    return AnimationGroupAPI;
  }
  /**
   * @returns {{browserCentered: Centered, Centered: Centered}} TJSPosition initial API.
   */
  static get Initial() {
    return this.#positionInitial;
  }
  /**
   * Returns TJSTransformData class / constructor.
   *
   * @returns {TJSTransformData} TJSTransformData class / constructor.
   */
  static get TransformData() {
    return TJSTransformData;
  }
  /**
   * Returns default validators.
   *
   * Note: `basicWindow` and `BasicBounds` will eventually be removed.
   *
   * @returns {{TransformBounds: TransformBounds, BasicBounds: BasicBounds, basicWindow: BasicBounds, transformWindow: TransformBounds}}
   * Available validators.
   */
  static get Validators() {
    return this.#positionValidators;
  }
  /**
   * Returns a duplicate of a given position instance copying any options and validators.
   *
   * // TODO: Consider more safety over options processing.
   *
   * @param {TJSPosition}          position - A position instance.
   *
   * @param {import('./').TJSPositionOptions}   options - TJSPosition options.
   *
   * @returns {TJSPosition} A duplicate position instance.
   */
  static duplicate(position, options) {
    if (!(position instanceof TJSPosition)) {
      throw new TypeError(`'position' is not an instance of Position.`);
    }
    const newPosition = new TJSPosition(options);
    newPosition.#options = Object.assign({}, position.#options, options);
    newPosition.#validators.add(...position.#validators);
    newPosition.set(position.#data);
    return newPosition;
  }
  /**
   * @param {import('./').TJSPositionParent | import('./').TJSPositionOptionsAll}   [parent] - A
   *        potential parent element or object w/ `elementTarget` getter. May also be the TJSPositionOptions object
   *        w/ 1 argument.
   *
   * @param {import('./').TJSPositionOptionsAll}   [options] - Default values.
   */
  constructor(parent, options) {
    if (isPlainObject$1(parent)) {
      options = parent;
    } else {
      this.#parent = parent;
    }
    const data = this.#data;
    const transforms = this.#transforms;
    this.#styleCache = new StyleCache();
    const updateData = new UpdateElementData();
    updateData.changeSet = this.#positionChangeSet;
    updateData.data = this.#data;
    updateData.options = this.#options;
    updateData.styleCache = this.#styleCache;
    updateData.subscriptions = this.#subscriptions;
    updateData.transforms = this.#transforms;
    this.#updateElementData = updateData;
    if (isObject$1(options)) {
      if (typeof options.calculateTransform === "boolean") {
        this.#options.calculateTransform = options.calculateTransform;
      }
      if (typeof options.ortho === "boolean") {
        this.#options.ortho = options.ortho;
      }
      if (Number.isFinite(options.height) || options.height === "auto" || options.height === "inherit" || options.height === null) {
        data.height = updateData.dimensionData.height = typeof options.height === "number" ? Math.round(options.height) : options.height;
      }
      if (Number.isFinite(options.left) || options.left === null) {
        data.left = typeof options.left === "number" ? Math.round(options.left) : options.left;
      }
      if (Number.isFinite(options.maxHeight) || options.maxHeight === null) {
        data.maxHeight = typeof options.maxHeight === "number" ? Math.round(options.maxHeight) : options.maxHeight;
      }
      if (Number.isFinite(options.maxWidth) || options.maxWidth === null) {
        data.maxWidth = typeof options.maxWidth === "number" ? Math.round(options.maxWidth) : options.maxWidth;
      }
      if (Number.isFinite(options.minHeight) || options.minHeight === null) {
        data.minHeight = typeof options.minHeight === "number" ? Math.round(options.minHeight) : options.minHeight;
      }
      if (Number.isFinite(options.minWidth) || options.minWidth === null) {
        data.minWidth = typeof options.minWidth === "number" ? Math.round(options.minWidth) : options.minWidth;
      }
      if (Number.isFinite(options.rotateX) || options.rotateX === null) {
        transforms.rotateX = data.rotateX = options.rotateX;
      }
      if (Number.isFinite(options.rotateY) || options.rotateY === null) {
        transforms.rotateY = data.rotateY = options.rotateY;
      }
      if (Number.isFinite(options.rotateZ) || options.rotateZ === null) {
        transforms.rotateZ = data.rotateZ = options.rotateZ;
      }
      if (Number.isFinite(options.scale) || options.scale === null) {
        transforms.scale = data.scale = options.scale;
      }
      if (Number.isFinite(options.top) || options.top === null) {
        data.top = typeof options.top === "number" ? Math.round(options.top) : options.top;
      }
      if (typeof options.transformOrigin === "string" || options.transformOrigin === null) {
        data.transformOrigin = transformOrigins.includes(options.transformOrigin) ? options.transformOrigin : null;
      }
      if (Number.isFinite(options.translateX) || options.translateX === null) {
        transforms.translateX = data.translateX = options.translateX;
      }
      if (Number.isFinite(options.translateY) || options.translateY === null) {
        transforms.translateY = data.translateY = options.translateY;
      }
      if (Number.isFinite(options.translateZ) || options.translateZ === null) {
        transforms.translateZ = data.translateZ = options.translateZ;
      }
      if (Number.isFinite(options.width) || options.width === "auto" || options.width === "inherit" || options.width === null) {
        data.width = updateData.dimensionData.width = typeof options.width === "number" ? Math.round(options.width) : options.width;
      }
      if (Number.isFinite(options.zIndex) || options.zIndex === null) {
        data.zIndex = typeof options.zIndex === "number" ? Math.round(options.zIndex) : options.zIndex;
      }
    }
    this.#stores = {
      // The main properties for manipulating TJSPosition.
      height: propertyStore(this, "height"),
      left: propertyStore(this, "left"),
      rotateX: propertyStore(this, "rotateX"),
      rotateY: propertyStore(this, "rotateY"),
      rotateZ: propertyStore(this, "rotateZ"),
      scale: propertyStore(this, "scale"),
      top: propertyStore(this, "top"),
      transformOrigin: propertyStore(this, "transformOrigin"),
      translateX: propertyStore(this, "translateX"),
      translateY: propertyStore(this, "translateY"),
      translateZ: propertyStore(this, "translateZ"),
      width: propertyStore(this, "width"),
      zIndex: propertyStore(this, "zIndex"),
      // Stores that control validation when width / height is not `auto`.
      maxHeight: propertyStore(this, "maxHeight"),
      maxWidth: propertyStore(this, "maxWidth"),
      minHeight: propertyStore(this, "minHeight"),
      minWidth: propertyStore(this, "minWidth"),
      // Readable stores based on updates or from resize observer changes.
      dimension: { subscribe: updateData.storeDimension.subscribe },
      element: { subscribe: this.#styleCache.stores.element.subscribe },
      resizeContentHeight: { subscribe: this.#styleCache.stores.resizeContentHeight.subscribe },
      resizeContentWidth: { subscribe: this.#styleCache.stores.resizeContentWidth.subscribe },
      resizeOffsetHeight: { subscribe: this.#styleCache.stores.resizeOffsetHeight.subscribe },
      resizeOffsetWidth: { subscribe: this.#styleCache.stores.resizeOffsetWidth.subscribe },
      transform: { subscribe: updateData.storeTransform.subscribe },
      // Protected store that should only be set by resizeObserver action.
      resizeObserved: this.#styleCache.stores.resizeObserved
    };
    subscribeIgnoreFirst(this.#stores.resizeObserved, (resizeData) => {
      const parent2 = this.#parent;
      const el = parent2 instanceof HTMLElement ? parent2 : parent2?.elementTarget;
      if (el instanceof HTMLElement && Number.isFinite(resizeData?.offsetWidth) && Number.isFinite(resizeData?.offsetHeight)) {
        this.set(data);
      }
    });
    this.#stores.transformOrigin.values = transformOrigins;
    [this.#validators, this.#validatorData] = new AdapterValidators();
    if (options?.initial || options?.positionInitial) {
      const initialHelper = options.initial ?? options.positionInitial;
      if (typeof initialHelper?.getLeft !== "function" || typeof initialHelper?.getTop !== "function") {
        throw new Error(
          `'options.initial' position helper does not contain 'getLeft' and / or 'getTop' functions.`
        );
      }
      this.#options.initialHelper = options.initial;
    }
    if (options?.validator) {
      if (isIterable(options?.validator)) {
        this.validators.add(...options.validator);
      } else {
        this.validators.add(options.validator);
      }
    }
  }
  /**
   * Returns the animation API.
   *
   * @returns {AnimationAPI} Animation API.
   */
  get animate() {
    return this.#animate;
  }
  /**
   * Returns the dimension data for the readable store.
   *
   * @returns {{width: number | 'auto', height: number | 'auto'}} Dimension data.
   */
  get dimension() {
    return this.#updateElementData.dimensionData;
  }
  /**
   * Returns the enabled state.
   *
   * @returns {boolean} Enabled state.
   */
  get enabled() {
    return this.#enabled;
  }
  /**
   * Returns the current HTMLElement being positioned.
   *
   * @returns {HTMLElement|undefined} Current HTMLElement being positioned.
   */
  get element() {
    return this.#styleCache.el;
  }
  /**
   * Returns a promise that is resolved on the next element update with the time of the update.
   *
   * @returns {Promise<number>} Promise resolved on element update.
   */
  get elementUpdated() {
    return this.#updateElementPromise;
  }
  /**
   * Returns the associated {@link TJSPositionParent} instance.
   *
   * @returns {import('./').TJSPositionParent} The TJSPositionParent instance.
   */
  get parent() {
    return this.#parent;
  }
  /**
   * Returns the state API.
   *
   * @returns {import('./PositionStateAPI').PositionStateAPI} TJSPosition state API.
   */
  get state() {
    return this.#state;
  }
  /**
   * Returns the derived writable stores for individual data variables.
   *
   * @returns {import('./').TJSPositionStores} Derived / writable stores.
   */
  get stores() {
    return this.#stores;
  }
  /**
   * Returns the transform data for the readable store.
   *
   * @returns {TJSTransformData} Transform Data.
   */
  get transform() {
    return this.#updateElementData.transformData;
  }
  /**
   * Returns the validators.
   *
   * @returns {AdapterValidators} validators.
   */
  get validators() {
    return this.#validators;
  }
  /**
   * Sets the enabled state.
   *
   * @param {boolean}  enabled - New enabled state.
   */
  set enabled(enabled) {
    if (typeof enabled !== "boolean") {
      throw new TypeError(`'enabled' is not a boolean.`);
    }
    this.#enabled = enabled;
  }
  /**
   * Sets the associated {@link TJSPositionParent} instance. Resets the style cache and default data.
   *
   * @param {import('./').TJSPositionParent} parent - A TJSPositionParent instance.
   */
  set parent(parent) {
    if (parent !== void 0 && !(parent instanceof HTMLElement) && !isObject$1(parent)) {
      throw new TypeError(`'parent' is not an HTMLElement, object, or undefined.`);
    }
    this.#parent = parent;
    this.#state.remove({ name: "#defaultData" });
    this.#styleCache.reset();
    if (parent) {
      this.set(this.#data);
    }
  }
  // Data accessors ----------------------------------------------------------------------------------------------------
  /**
   * @returns {number|'auto'|'inherit'|null} height
   */
  get height() {
    return this.#data.height;
  }
  /**
   * @returns {number|null} left
   */
  get left() {
    return this.#data.left;
  }
  /**
   * @returns {number|null} maxHeight
   */
  get maxHeight() {
    return this.#data.maxHeight;
  }
  /**
   * @returns {number|null} maxWidth
   */
  get maxWidth() {
    return this.#data.maxWidth;
  }
  /**
   * @returns {number|null} minHeight
   */
  get minHeight() {
    return this.#data.minHeight;
  }
  /**
   * @returns {number|null} minWidth
   */
  get minWidth() {
    return this.#data.minWidth;
  }
  /**
   * @returns {number|null} rotateX
   */
  get rotateX() {
    return this.#data.rotateX;
  }
  /**
   * @returns {number|null} rotateY
   */
  get rotateY() {
    return this.#data.rotateY;
  }
  /**
   * @returns {number|null} rotateZ
   */
  get rotateZ() {
    return this.#data.rotateZ;
  }
  /**
   * @returns {number|null} alias for rotateZ
   */
  get rotation() {
    return this.#data.rotateZ;
  }
  /**
   * @returns {number|null} scale
   */
  get scale() {
    return this.#data.scale;
  }
  /**
   * @returns {number|null} top
   */
  get top() {
    return this.#data.top;
  }
  /**
   * @returns {import('./').TJSTransformOrigin} transformOrigin
   */
  get transformOrigin() {
    return this.#data.transformOrigin;
  }
  /**
   * @returns {number|null} translateX
   */
  get translateX() {
    return this.#data.translateX;
  }
  /**
   * @returns {number|null} translateY
   */
  get translateY() {
    return this.#data.translateY;
  }
  /**
   * @returns {number|null} translateZ
   */
  get translateZ() {
    return this.#data.translateZ;
  }
  /**
   * @returns {number|'auto'|'inherit'|null} width
   */
  get width() {
    return this.#data.width;
  }
  /**
   * @returns {number|null} z-index
   */
  get zIndex() {
    return this.#data.zIndex;
  }
  /**
   * @param {number|string|null} height -
   */
  set height(height) {
    this.#stores.height.set(height);
  }
  /**
   * @param {number|string|null} left -
   */
  set left(left) {
    this.#stores.left.set(left);
  }
  /**
   * @param {number|string|null} maxHeight -
   */
  set maxHeight(maxHeight) {
    this.#stores.maxHeight.set(maxHeight);
  }
  /**
   * @param {number|string|null} maxWidth -
   */
  set maxWidth(maxWidth) {
    this.#stores.maxWidth.set(maxWidth);
  }
  /**
   * @param {number|string|null} minHeight -
   */
  set minHeight(minHeight) {
    this.#stores.minHeight.set(minHeight);
  }
  /**
   * @param {number|string|null} minWidth -
   */
  set minWidth(minWidth) {
    this.#stores.minWidth.set(minWidth);
  }
  /**
   * @param {number|string|null} rotateX -
   */
  set rotateX(rotateX) {
    this.#stores.rotateX.set(rotateX);
  }
  /**
   * @param {number|string|null} rotateY -
   */
  set rotateY(rotateY) {
    this.#stores.rotateY.set(rotateY);
  }
  /**
   * @param {number|string|null} rotateZ -
   */
  set rotateZ(rotateZ) {
    this.#stores.rotateZ.set(rotateZ);
  }
  /**
   * @param {number|string|null} rotateZ - alias for rotateZ
   */
  set rotation(rotateZ) {
    this.#stores.rotateZ.set(rotateZ);
  }
  /**
   * @param {number|string|null} scale -
   */
  set scale(scale) {
    this.#stores.scale.set(scale);
  }
  /**
   * @param {number|string|null} top -
   */
  set top(top) {
    this.#stores.top.set(top);
  }
  /**
   * @param {import('./').TJSTransformOrigin} transformOrigin -
   */
  set transformOrigin(transformOrigin) {
    if (transformOrigins.includes(transformOrigin)) {
      this.#stores.transformOrigin.set(transformOrigin);
    }
  }
  /**
   * @param {number|string|null} translateX -
   */
  set translateX(translateX) {
    this.#stores.translateX.set(translateX);
  }
  /**
   * @param {number|string|null} translateY -
   */
  set translateY(translateY) {
    this.#stores.translateY.set(translateY);
  }
  /**
   * @param {number|string|null} translateZ -
   */
  set translateZ(translateZ) {
    this.#stores.translateZ.set(translateZ);
  }
  /**
   * @param {number|string|null} width -
   */
  set width(width) {
    this.#stores.width.set(width);
  }
  /**
   * @param {number|string|null} zIndex -
   */
  set zIndex(zIndex) {
    this.#stores.zIndex.set(zIndex);
  }
  /**
   * Assigns current position to object passed into method.
   *
   * @param {object|TJSPositionData}  [position] - Target to assign current position data.
   *
   * @param {import('./').TJSPositionGetOptions}   [options] - Defines options for specific keys and substituting null
   *        for numeric default values.
   *
   * @returns {TJSPositionData} Passed in object with current position data.
   */
  get(position = {}, options) {
    const keys = options?.keys;
    const excludeKeys = options?.exclude;
    const numeric3 = options?.numeric ?? false;
    if (isIterable(keys)) {
      if (numeric3) {
        for (const key of keys) {
          position[key] = this[key] ?? numericDefaults[key];
        }
      } else {
        for (const key of keys) {
          position[key] = this[key];
        }
      }
      if (isIterable(excludeKeys)) {
        for (const key of excludeKeys) {
          delete position[key];
        }
      }
      return position;
    } else {
      const data = Object.assign(position, this.#data);
      if (isIterable(excludeKeys)) {
        for (const key of excludeKeys) {
          delete data[key];
        }
      }
      if (numeric3) {
        setNumericDefaults(data);
      }
      return data;
    }
  }
  /**
   * @returns {TJSPositionData} Current position data.
   */
  toJSON() {
    return Object.assign({}, this.#data);
  }
  /**
   * All calculation and updates of position are implemented in {@link TJSPosition}. This allows position to be fully
   * reactive and in control of updating inline styles for the application.
   *
   * Note: the logic for updating position is improved and changes a few aspects from the default
   * {@link globalThis.Application.setPosition}. The gate on `popOut` is removed, so to ensure no positional
   * application occurs popOut applications can set `this.options.positionable` to false ensuring no positional inline
   * styles are applied.
   *
   * The initial set call on an application with a target element will always set width / height as this is
   * necessary for correct calculations.
   *
   * When a target element is present updated styles are applied after validation. To modify the behavior of set
   * implement one or more validator functions and add them from the application via
   * `this.position.validators.add(<Function>)`.
   *
   * Updates to any target element are decoupled from the underlying TJSPosition data. This method returns this instance
   * that you can then await on the target element inline style update by using {@link TJSPosition.elementUpdated}.
   *
   * @param {import('./').TJSPositionDataExtended} [position] - TJSPosition data to set.
   *
   * @returns {TJSPosition} This TJSPosition instance.
   */
  set(position = {}) {
    if (!isObject$1(position)) {
      throw new TypeError(`Position - set error: 'position' is not an object.`);
    }
    const parent = this.#parent;
    if (!this.#enabled) {
      return this;
    }
    if (parent !== void 0 && typeof parent?.options?.positionable === "boolean" && !parent?.options?.positionable) {
      return this;
    }
    const immediateElementUpdate = position.immediateElementUpdate === true;
    const data = this.#data;
    const transforms = this.#transforms;
    const targetEl = parent instanceof HTMLElement ? parent : parent?.elementTarget;
    const el = targetEl instanceof HTMLElement && targetEl.isConnected ? targetEl : void 0;
    const changeSet = this.#positionChangeSet;
    const styleCache = this.#styleCache;
    if (el) {
      if (!styleCache.hasData(el)) {
        styleCache.update(el);
        if (!styleCache.hasWillChange)
          ;
        changeSet.set(true);
        this.#updateElementData.queued = false;
      }
      convertRelative(position, this);
      position = this.#updatePosition(position, parent, el, styleCache);
      if (position === null) {
        return this;
      }
    }
    if (Number.isFinite(position.left)) {
      position.left = Math.round(position.left);
      if (data.left !== position.left) {
        data.left = position.left;
        changeSet.left = true;
      }
    }
    if (Number.isFinite(position.top)) {
      position.top = Math.round(position.top);
      if (data.top !== position.top) {
        data.top = position.top;
        changeSet.top = true;
      }
    }
    if (Number.isFinite(position.maxHeight) || position.maxHeight === null) {
      position.maxHeight = typeof position.maxHeight === "number" ? Math.round(position.maxHeight) : null;
      if (data.maxHeight !== position.maxHeight) {
        data.maxHeight = position.maxHeight;
        changeSet.maxHeight = true;
      }
    }
    if (Number.isFinite(position.maxWidth) || position.maxWidth === null) {
      position.maxWidth = typeof position.maxWidth === "number" ? Math.round(position.maxWidth) : null;
      if (data.maxWidth !== position.maxWidth) {
        data.maxWidth = position.maxWidth;
        changeSet.maxWidth = true;
      }
    }
    if (Number.isFinite(position.minHeight) || position.minHeight === null) {
      position.minHeight = typeof position.minHeight === "number" ? Math.round(position.minHeight) : null;
      if (data.minHeight !== position.minHeight) {
        data.minHeight = position.minHeight;
        changeSet.minHeight = true;
      }
    }
    if (Number.isFinite(position.minWidth) || position.minWidth === null) {
      position.minWidth = typeof position.minWidth === "number" ? Math.round(position.minWidth) : null;
      if (data.minWidth !== position.minWidth) {
        data.minWidth = position.minWidth;
        changeSet.minWidth = true;
      }
    }
    if (Number.isFinite(position.rotateX) || position.rotateX === null) {
      if (data.rotateX !== position.rotateX) {
        data.rotateX = transforms.rotateX = position.rotateX;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.rotateY) || position.rotateY === null) {
      if (data.rotateY !== position.rotateY) {
        data.rotateY = transforms.rotateY = position.rotateY;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.rotateZ) || position.rotateZ === null) {
      if (data.rotateZ !== position.rotateZ) {
        data.rotateZ = transforms.rotateZ = position.rotateZ;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.scale) || position.scale === null) {
      position.scale = typeof position.scale === "number" ? Math.max(0, Math.min(position.scale, 1e3)) : null;
      if (data.scale !== position.scale) {
        data.scale = transforms.scale = position.scale;
        changeSet.transform = true;
      }
    }
    if (typeof position.transformOrigin === "string" && transformOrigins.includes(
      position.transformOrigin
    ) || position.transformOrigin === null) {
      if (data.transformOrigin !== position.transformOrigin) {
        data.transformOrigin = position.transformOrigin;
        changeSet.transformOrigin = true;
      }
    }
    if (Number.isFinite(position.translateX) || position.translateX === null) {
      if (data.translateX !== position.translateX) {
        data.translateX = transforms.translateX = position.translateX;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.translateY) || position.translateY === null) {
      if (data.translateY !== position.translateY) {
        data.translateY = transforms.translateY = position.translateY;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.translateZ) || position.translateZ === null) {
      if (data.translateZ !== position.translateZ) {
        data.translateZ = transforms.translateZ = position.translateZ;
        changeSet.transform = true;
      }
    }
    if (Number.isFinite(position.zIndex)) {
      position.zIndex = Math.round(position.zIndex);
      if (data.zIndex !== position.zIndex) {
        data.zIndex = position.zIndex;
        changeSet.zIndex = true;
      }
    }
    if (Number.isFinite(position.width) || position.width === "auto" || position.width === "inherit" || position.width === null) {
      position.width = typeof position.width === "number" ? Math.round(position.width) : position.width;
      if (data.width !== position.width) {
        data.width = position.width;
        changeSet.width = true;
      }
    }
    if (Number.isFinite(position.height) || position.height === "auto" || position.height === "inherit" || position.height === null) {
      position.height = typeof position.height === "number" ? Math.round(position.height) : position.height;
      if (data.height !== position.height) {
        data.height = position.height;
        changeSet.height = true;
      }
    }
    if (el) {
      const defaultData = this.#state.getDefault();
      if (!isObject$1(defaultData)) {
        this.#state.save({ name: "#defaultData", ...Object.assign({}, data) });
      }
      if (immediateElementUpdate) {
        UpdateElementManager.immediate(el, this.#updateElementData);
        this.#updateElementPromise = Promise.resolve(performance.now());
      } else if (!this.#updateElementData.queued) {
        this.#updateElementPromise = UpdateElementManager.add(el, this.#updateElementData);
      }
    } else {
      UpdateElementManager.updateSubscribers(this.#updateElementData);
    }
    return this;
  }
  /**
   * @param {import('svelte/store').Subscriber<TJSPositionData>} handler - Callback function that is invoked on
   *        update / changes. Receives a copy of the TJSPositionData.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(Object.assign({}, this.#data));
    return () => {
      const index2 = this.#subscriptions.findIndex((sub2) => sub2 === handler);
      if (index2 >= 0) {
        this.#subscriptions.splice(index2, 1);
      }
    };
  }
  /**
   * @param {import('./').TJSPositionDataExtended} opts -
   *
   * @param {number|null} opts.left -
   *
   * @param {number|null} opts.top -
   *
   * @param {number|null} opts.maxHeight -
   *
   * @param {number|null} opts.maxWidth -
   *
   * @param {number|null} opts.minHeight -
   *
   * @param {number|null} opts.minWidth -
   *
   * @param {number|'auto'|null} opts.width -
   *
   * @param {number|'auto'|null} opts.height -
   *
   * @param {number|null} opts.rotateX -
   *
   * @param {number|null} opts.rotateY -
   *
   * @param {number|null} opts.rotateZ -
   *
   * @param {number|null} opts.scale -
   *
   * @param {string} opts.transformOrigin -
   *
   * @param {number|null} opts.translateX -
   *
   * @param {number|null} opts.translateY -
   *
   * @param {number|null} opts.translateZ -
   *
   * @param {number|null} opts.zIndex -
   *
   * @param {number|null} opts.rotation - alias for rotateZ
   *
   * @param {*} opts.rest -
   *
   * @param {object} parent -
   *
   * @param {HTMLElement} el -
   *
   * @param {StyleCache} styleCache -
   *
   * @returns {null|TJSPositionData} Updated position data or null if validation fails.
   */
  #updatePosition({
    // Directly supported parameters
    left,
    top,
    maxWidth,
    maxHeight,
    minWidth,
    minHeight,
    width,
    height,
    rotateX,
    rotateY,
    rotateZ,
    scale,
    transformOrigin,
    translateX,
    translateY,
    translateZ,
    zIndex,
    // Aliased parameters
    rotation,
    ...rest
  } = {}, parent, el, styleCache) {
    let currentPosition = s_DATA_UPDATE.copy(this.#data);
    if (el.style.width === "" || width !== void 0) {
      if (width === "auto" || currentPosition.width === "auto" && width !== null) {
        currentPosition.width = "auto";
        width = styleCache.offsetWidth;
      } else if (width === "inherit" || currentPosition.width === "inherit" && width !== null) {
        currentPosition.width = "inherit";
        width = styleCache.offsetWidth;
      } else {
        const newWidth = Number.isFinite(width) ? width : currentPosition.width;
        currentPosition.width = width = Number.isFinite(newWidth) ? Math.round(newWidth) : styleCache.offsetWidth;
      }
    } else {
      width = Number.isFinite(currentPosition.width) ? currentPosition.width : styleCache.offsetWidth;
    }
    if (el.style.height === "" || height !== void 0) {
      if (height === "auto" || currentPosition.height === "auto" && height !== null) {
        currentPosition.height = "auto";
        height = styleCache.offsetHeight;
      } else if (height === "inherit" || currentPosition.height === "inherit" && height !== null) {
        currentPosition.height = "inherit";
        height = styleCache.offsetHeight;
      } else {
        const newHeight = Number.isFinite(height) ? height : currentPosition.height;
        currentPosition.height = height = Number.isFinite(newHeight) ? Math.round(newHeight) : styleCache.offsetHeight;
      }
    } else {
      height = Number.isFinite(currentPosition.height) ? currentPosition.height : styleCache.offsetHeight;
    }
    if (Number.isFinite(left)) {
      currentPosition.left = left;
    } else if (!Number.isFinite(currentPosition.left)) {
      currentPosition.left = typeof this.#options.initialHelper?.getLeft === "function" ? this.#options.initialHelper.getLeft(width) : 0;
    }
    if (Number.isFinite(top)) {
      currentPosition.top = top;
    } else if (!Number.isFinite(currentPosition.top)) {
      currentPosition.top = typeof this.#options.initialHelper?.getTop === "function" ? this.#options.initialHelper.getTop(height) : 0;
    }
    if (Number.isFinite(maxHeight) || maxHeight === null) {
      currentPosition.maxHeight = Number.isFinite(maxHeight) ? Math.round(maxHeight) : null;
    }
    if (Number.isFinite(maxWidth) || maxWidth === null) {
      currentPosition.maxWidth = Number.isFinite(maxWidth) ? Math.round(maxWidth) : null;
    }
    if (Number.isFinite(minHeight) || minHeight === null) {
      currentPosition.minHeight = Number.isFinite(minHeight) ? Math.round(minHeight) : null;
    }
    if (Number.isFinite(minWidth) || minWidth === null) {
      currentPosition.minWidth = Number.isFinite(minWidth) ? Math.round(minWidth) : null;
    }
    if (Number.isFinite(rotateX) || rotateX === null) {
      currentPosition.rotateX = rotateX;
    }
    if (Number.isFinite(rotateY) || rotateY === null) {
      currentPosition.rotateY = rotateY;
    }
    if (rotateZ !== currentPosition.rotateZ && (Number.isFinite(rotateZ) || rotateZ === null)) {
      currentPosition.rotateZ = rotateZ;
    } else if (rotation !== currentPosition.rotateZ && (Number.isFinite(rotation) || rotation === null)) {
      currentPosition.rotateZ = rotation;
    }
    if (Number.isFinite(translateX) || translateX === null) {
      currentPosition.translateX = translateX;
    }
    if (Number.isFinite(translateY) || translateY === null) {
      currentPosition.translateY = translateY;
    }
    if (Number.isFinite(translateZ) || translateZ === null) {
      currentPosition.translateZ = translateZ;
    }
    if (Number.isFinite(scale) || scale === null) {
      currentPosition.scale = typeof scale === "number" ? Math.max(0, Math.min(scale, 1e3)) : null;
    }
    if (typeof transformOrigin === "string" || transformOrigin === null) {
      currentPosition.transformOrigin = transformOrigins.includes(transformOrigin) ? transformOrigin : null;
    }
    if (Number.isFinite(zIndex) || zIndex === null) {
      currentPosition.zIndex = typeof zIndex === "number" ? Math.round(zIndex) : zIndex;
    }
    const validatorData = this.#validatorData;
    if (this.#validators.enabled && validatorData.length) {
      s_VALIDATION_DATA.parent = parent;
      s_VALIDATION_DATA.el = el;
      s_VALIDATION_DATA.computed = styleCache.computed;
      s_VALIDATION_DATA.transforms = this.#transforms;
      s_VALIDATION_DATA.height = height;
      s_VALIDATION_DATA.width = width;
      s_VALIDATION_DATA.marginLeft = styleCache.marginLeft;
      s_VALIDATION_DATA.marginTop = styleCache.marginTop;
      s_VALIDATION_DATA.maxHeight = styleCache.maxHeight ?? currentPosition.maxHeight;
      s_VALIDATION_DATA.maxWidth = styleCache.maxWidth ?? currentPosition.maxWidth;
      const isMinimized = parent?.reactive?.minimized ?? false;
      s_VALIDATION_DATA.minHeight = isMinimized ? currentPosition.minHeight ?? 0 : styleCache.minHeight || (currentPosition.minHeight ?? 0);
      s_VALIDATION_DATA.minWidth = isMinimized ? currentPosition.minWidth ?? 0 : styleCache.minWidth || (currentPosition.minWidth ?? 0);
      for (let cntr = 0; cntr < validatorData.length; cntr++) {
        s_VALIDATION_DATA.position = currentPosition;
        s_VALIDATION_DATA.rest = rest;
        currentPosition = validatorData[cntr].validator(s_VALIDATION_DATA);
        if (currentPosition === null) {
          return null;
        }
      }
    }
    return currentPosition;
  }
}
const s_DATA_UPDATE = new TJSPositionData();
const s_VALIDATION_DATA = {
  position: void 0,
  parent: void 0,
  el: void 0,
  computed: void 0,
  transforms: void 0,
  height: void 0,
  width: void 0,
  marginLeft: void 0,
  marginTop: void 0,
  maxHeight: void 0,
  maxWidth: void 0,
  minHeight: void 0,
  minWidth: void 0,
  rest: void 0
};
Object.seal(s_VALIDATION_DATA);
function draggable(node, {
  position,
  active: active2 = true,
  button = 0,
  storeDragging = void 0,
  ease = false,
  easeOptions = { duration: 0.1, ease: cubicOut },
  hasTargetClassList,
  ignoreTargetClassList
}) {
  if (hasTargetClassList !== void 0 && !isIterable(hasTargetClassList)) {
    throw new TypeError(`'hasTargetClassList' is not iterable.`);
  }
  if (ignoreTargetClassList !== void 0 && !isIterable(ignoreTargetClassList)) {
    throw new TypeError(`'ignoreTargetClassList' is not iterable.`);
  }
  const positionData = { left: 0, top: 0 };
  let initialPosition = null;
  let initialDragPoint = {};
  let dragging = false;
  let quickTo = position.animate.quickTo(["top", "left"], easeOptions);
  const handlers = {
    dragDown: ["pointerdown", onDragPointerDown, false],
    dragMove: ["pointermove", onDragPointerChange, false],
    dragUp: ["pointerup", onDragPointerUp, false]
  };
  function activateListeners() {
    node.addEventListener(...handlers.dragDown);
    node.classList.add("draggable");
  }
  function removeListeners() {
    if (typeof storeDragging?.set === "function") {
      storeDragging.set(false);
    }
    node.removeEventListener(...handlers.dragDown);
    node.removeEventListener(...handlers.dragMove);
    node.removeEventListener(...handlers.dragUp);
    node.classList.remove("draggable");
  }
  if (active2) {
    activateListeners();
  }
  function onDragPointerDown(event) {
    if (event.button !== button || !event.isPrimary) {
      return;
    }
    if (!position.enabled) {
      return;
    }
    if (ignoreTargetClassList !== void 0 && event.target instanceof HTMLElement) {
      for (const targetClass of ignoreTargetClassList) {
        if (event.target.classList.contains(targetClass)) {
          return;
        }
      }
    }
    if (hasTargetClassList !== void 0 && event.target instanceof HTMLElement) {
      let foundTarget = false;
      for (const targetClass of hasTargetClassList) {
        if (event.target.classList.contains(targetClass)) {
          foundTarget = true;
          break;
        }
      }
      if (!foundTarget) {
        return;
      }
    }
    event.preventDefault();
    dragging = false;
    initialPosition = position.get();
    initialDragPoint = { x: event.clientX, y: event.clientY };
    node.addEventListener(...handlers.dragMove);
    node.addEventListener(...handlers.dragUp);
    node.setPointerCapture(event.pointerId);
  }
  function onDragPointerChange(event) {
    if ((event.buttons & 1) === 0) {
      onDragPointerUp(event);
      return;
    }
    if (event.button !== -1 || !event.isPrimary) {
      return;
    }
    event.preventDefault();
    if (!dragging && typeof storeDragging?.set === "function") {
      dragging = true;
      storeDragging.set(true);
    }
    const newLeft = initialPosition.left + (event.clientX - initialDragPoint.x);
    const newTop = initialPosition.top + (event.clientY - initialDragPoint.y);
    if (ease) {
      quickTo(newTop, newLeft);
    } else {
      positionData.left = newLeft;
      positionData.top = newTop;
      position.set(positionData);
    }
  }
  function onDragPointerUp(event) {
    event.preventDefault();
    dragging = false;
    if (typeof storeDragging?.set === "function") {
      storeDragging.set(false);
    }
    node.removeEventListener(...handlers.dragMove);
    node.removeEventListener(...handlers.dragUp);
  }
  return {
    // The default of active being true won't automatically add listeners twice.
    update: (options) => {
      if (typeof options.active === "boolean") {
        active2 = options.active;
        if (active2) {
          activateListeners();
        } else {
          removeListeners();
        }
      }
      if (typeof options.button === "number") {
        button = options.button;
      }
      if (options.position !== void 0 && options.position !== position) {
        position = options.position;
        quickTo = position.animate.quickTo(["top", "left"], easeOptions);
      }
      if (typeof options.ease === "boolean") {
        ease = options.ease;
      }
      if (isObject$1(options.easeOptions)) {
        easeOptions = options.easeOptions;
        quickTo.options(easeOptions);
      }
      if (options.hasTargetClassList !== void 0) {
        if (!isIterable(options.hasTargetClassList)) {
          throw new TypeError(`'hasTargetClassList' is not iterable.`);
        } else {
          hasTargetClassList = options.hasTargetClassList;
        }
      }
      if (options.ignoreTargetClassList !== void 0) {
        if (!isIterable(options.ignoreTargetClassList)) {
          throw new TypeError(`'ignoreTargetClassList' is not iterable.`);
        } else {
          ignoreTargetClassList = options.ignoreTargetClassList;
        }
      }
    },
    destroy: () => removeListeners()
  };
}
class DraggableOptions {
  #ease = false;
  /**
   * @type {{ duration: number, ease: (t: number) => number | string }}
   */
  #easeOptions = { duration: 0.1, ease: cubicOut };
  /**
   * Stores the subscribers.
   *
   * @type {import('svelte/store').Subscriber<DraggableOptions>[]}
   */
  #subscriptions = [];
  /**
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.ease] -
   *
   * @param {object}   [opts.easeOptions] -
   */
  constructor({ ease, easeOptions } = {}) {
    Object.defineProperty(this, "ease", {
      get: () => {
        return this.#ease;
      },
      set: (newEase) => {
        if (typeof newEase !== "boolean") {
          throw new TypeError(`'ease' is not a boolean.`);
        }
        this.#ease = newEase;
        this.#updateSubscribers();
      },
      enumerable: true
    });
    Object.defineProperty(this, "easeOptions", {
      get: () => {
        return this.#easeOptions;
      },
      set: (newEaseOptions) => {
        if (!isObject$1(newEaseOptions)) {
          throw new TypeError(`'easeOptions' is not an object.`);
        }
        if (newEaseOptions.duration !== void 0) {
          if (!Number.isFinite(newEaseOptions.duration)) {
            throw new TypeError(`'easeOptions.duration' is not a finite number.`);
          }
          if (newEaseOptions.duration < 0) {
            throw new Error(`'easeOptions.duration' is less than 0.`);
          }
          this.#easeOptions.duration = newEaseOptions.duration;
        }
        if (newEaseOptions.ease !== void 0) {
          if (typeof newEaseOptions.ease !== "function" && typeof newEaseOptions.ease !== "string") {
            throw new TypeError(`'easeOptions.ease' is not a function or string.`);
          }
          this.#easeOptions.ease = newEaseOptions.ease;
        }
        this.#updateSubscribers();
      },
      enumerable: true
    });
    if (ease !== void 0) {
      this.ease = ease;
    }
    if (easeOptions !== void 0) {
      this.easeOptions = easeOptions;
    }
  }
  /**
   * @returns {number} Get ease duration
   */
  get easeDuration() {
    return this.#easeOptions.duration;
  }
  /**
   * @returns {string|Function} Get easing function value.
   */
  get easeValue() {
    return this.#easeOptions.ease;
  }
  /**
   * @param {number}   duration - Set ease duration.
   */
  set easeDuration(duration) {
    if (!Number.isFinite(duration)) {
      throw new TypeError(`'duration' is not a finite number.`);
    }
    if (duration < 0) {
      throw new Error(`'duration' is less than 0.`);
    }
    this.#easeOptions.duration = duration;
    this.#updateSubscribers();
  }
  /**
   * @param {string|Function} value - Get easing function value.
   */
  set easeValue(value) {
    if (typeof value !== "function" && typeof value !== "string") {
      throw new TypeError(`'value' is not a function or string.`);
    }
    this.#easeOptions.ease = value;
    this.#updateSubscribers();
  }
  /**
   * Resets all options data to default values.
   */
  reset() {
    this.#ease = false;
    this.#easeOptions = { duration: 0.1, ease: cubicOut };
    this.#updateSubscribers();
  }
  /**
   * Resets easing options to default values.
   */
  resetEase() {
    this.#easeOptions = { duration: 0.1, ease: cubicOut };
    this.#updateSubscribers();
  }
  /**
   *
   * @param {import('svelte/store').Subscriber<DraggableOptions>} handler - Callback function that is invoked on
   *        update / changes. Receives the DraggableOptions object / instance.
   *
   * @returns {import('svelte/store').Unsubscriber} Unsubscribe function.
   */
  subscribe(handler) {
    this.#subscriptions.push(handler);
    handler(this);
    return () => {
      const index2 = this.#subscriptions.findIndex((sub2) => sub2 === handler);
      if (index2 >= 0) {
        this.#subscriptions.splice(index2, 1);
      }
    };
  }
  #updateSubscribers() {
    const subscriptions = this.#subscriptions;
    if (subscriptions.length > 0) {
      for (let cntr = 0; cntr < subscriptions.length; cntr++) {
        subscriptions[cntr](this);
      }
    }
  }
}
draggable.options = (options) => new DraggableOptions(options);
function isHMRProxy(comp) {
  const instanceName = comp?.constructor?.name;
  if (typeof instanceName === "string" && (instanceName.startsWith("Proxy<") || instanceName === "ProxyComponent")) {
    return true;
  }
  const prototypeName = comp?.prototype?.constructor?.name;
  return typeof prototypeName === "string" && (prototypeName.startsWith("Proxy<") || prototypeName === "ProxyComponent");
}
function isSvelteComponent(comp) {
  if (comp === null || comp === void 0 || typeof comp !== "function") {
    return false;
  }
  const prototypeName = comp?.prototype?.constructor?.name;
  if (typeof prototypeName === "string" && (prototypeName.startsWith("Proxy<") || prototypeName === "ProxyComponent")) {
    return true;
  }
  return typeof window !== "undefined" ? typeof comp.prototype.$destroy === "function" && typeof comp.prototype.$on === "function" : (
    // client-side
    typeof comp.render === "function"
  );
}
async function outroAndDestroy(instance2) {
  return new Promise((resolve2) => {
    if (instance2.$$.fragment && instance2.$$.fragment.o) {
      group_outros();
      transition_out(instance2.$$.fragment, 0, 0, () => {
        instance2.$destroy();
        resolve2();
      });
      check_outros();
    } else {
      instance2.$destroy();
      resolve2();
    }
  });
}
function parseTJSSvelteConfig(config3, thisArg = void 0) {
  if (!isObject$1(config3)) {
    throw new TypeError(`parseSvelteConfig - 'config' is not an object:
${JSON.stringify(config3)}.`);
  }
  if (!isSvelteComponent(config3.class)) {
    throw new TypeError(
      `parseSvelteConfig - 'class' is not a Svelte component constructor for config:
${JSON.stringify(config3)}.`
    );
  }
  if (config3.hydrate !== void 0 && typeof config3.hydrate !== "boolean") {
    throw new TypeError(
      `parseSvelteConfig - 'hydrate' is not a boolean for config:
${JSON.stringify(config3)}.`
    );
  }
  if (config3.intro !== void 0 && typeof config3.intro !== "boolean") {
    throw new TypeError(
      `parseSvelteConfig - 'intro' is not a boolean for config:
${JSON.stringify(config3)}.`
    );
  }
  if (config3.target !== void 0 && typeof config3.target !== "string" && !(config3.target instanceof HTMLElement) && !(config3.target instanceof ShadowRoot) && !(config3.target instanceof DocumentFragment)) {
    throw new TypeError(
      `parseSvelteConfig - 'target' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(config3)}.`
    );
  }
  if (config3.anchor !== void 0 && typeof config3.anchor !== "string" && !(config3.anchor instanceof HTMLElement) && !(config3.anchor instanceof ShadowRoot) && !(config3.anchor instanceof DocumentFragment)) {
    throw new TypeError(
      `parseSvelteConfig - 'anchor' is not a string, HTMLElement, ShadowRoot, or DocumentFragment for config:
${JSON.stringify(config3)}.`
    );
  }
  if (config3.context !== void 0 && typeof config3.context !== "function" && !(config3.context instanceof Map) && !isObject$1(config3.context)) {
    throw new TypeError(
      `parseSvelteConfig - 'context' is not a Map, function or object for config:
${JSON.stringify(config3)}.`
    );
  }
  if (config3.selectorTarget !== void 0 && typeof config3.selectorTarget !== "string") {
    throw new TypeError(
      `parseSvelteConfig - 'selectorTarget' is not a string for config:
${JSON.stringify(config3)}.`
    );
  }
  if (config3.options !== void 0 && !isObject$1(config3.options)) {
    throw new TypeError(
      `parseSvelteConfig - 'options' is not an object for config:
${JSON.stringify(config3)}.`
    );
  }
  if (config3.options !== void 0) {
    if (config3.options.injectApp !== void 0 && typeof config3.options.injectApp !== "boolean") {
      throw new TypeError(
        `parseSvelteConfig - 'options.injectApp' is not a boolean for config:
${JSON.stringify(config3)}.`
      );
    }
    if (config3.options.injectEventbus !== void 0 && typeof config3.options.injectEventbus !== "boolean") {
      throw new TypeError(
        `parseSvelteConfig - 'options.injectEventbus' is not a boolean for config:
${JSON.stringify(config3)}.`
      );
    }
    if (config3.options.selectorElement !== void 0 && typeof config3.options.selectorElement !== "string") {
      throw new TypeError(
        `parseSvelteConfig - 'selectorElement' is not a string for config:
${JSON.stringify(config3)}.`
      );
    }
  }
  const svelteConfig = { ...config3 };
  delete svelteConfig.options;
  let externalContext = {};
  if (typeof svelteConfig.context === "function") {
    const contextFunc = svelteConfig.context;
    delete svelteConfig.context;
    const result = contextFunc.call(thisArg);
    if (isObject$1(result)) {
      externalContext = { ...result };
    } else {
      throw new Error(`parseSvelteConfig - 'context' is a function that did not return an object for config:
${JSON.stringify(config3)}`);
    }
  } else if (svelteConfig.context instanceof Map) {
    externalContext = Object.fromEntries(svelteConfig.context);
    delete svelteConfig.context;
  } else if (isObject$1(svelteConfig.context)) {
    externalContext = svelteConfig.context;
    delete svelteConfig.context;
  }
  svelteConfig.props = s_PROCESS_PROPS(svelteConfig.props, thisArg, config3);
  if (Array.isArray(svelteConfig.children)) {
    const children2 = [];
    for (let cntr = 0; cntr < svelteConfig.children.length; cntr++) {
      const child = svelteConfig.children[cntr];
      if (!isSvelteComponent(child.class)) {
        throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for child[${cntr}] for config:
${JSON.stringify(config3)}`);
      }
      child.props = s_PROCESS_PROPS(child.props, thisArg, config3);
      children2.push(child);
    }
    if (children2.length > 0) {
      externalContext.children = children2;
    }
    delete svelteConfig.children;
  } else if (isObject$1(svelteConfig.children)) {
    if (!isSvelteComponent(svelteConfig.children.class)) {
      throw new Error(`parseSvelteConfig - 'class' is not a Svelte component for children object for config:
${JSON.stringify(config3)}`);
    }
    svelteConfig.children.props = s_PROCESS_PROPS(svelteConfig.children.props, thisArg, config3);
    externalContext.children = [svelteConfig.children];
    delete svelteConfig.children;
  }
  if (!(svelteConfig.context instanceof Map)) {
    svelteConfig.context = /* @__PURE__ */ new Map();
  }
  svelteConfig.context.set("#external", externalContext);
  return svelteConfig;
}
function s_PROCESS_PROPS(props, thisArg, config3) {
  if (typeof props === "function") {
    const result = props.call(thisArg);
    if (isObject$1(result)) {
      return result;
    } else {
      throw new Error(`parseSvelteConfig - 'props' is a function that did not return an object for config:
${JSON.stringify(config3)}`);
    }
  } else if (isObject$1(props)) {
    return props;
  } else if (props !== void 0) {
    throw new Error(
      `parseSvelteConfig - 'props' is not a function or an object for config:
${JSON.stringify(config3)}`
    );
  }
  return {};
}
class ApplicationState {
  /** @type {T} */
  #application;
  /** @type {Map<string, ApplicationStateData>} */
  #dataSaved = /* @__PURE__ */ new Map();
  /**
   * @param {T}   application - The application.
   */
  constructor(application) {
    this.#application = application;
    Object.seal(this);
  }
  /**
   * Returns current application state along with any extra data passed into method.
   *
   * @param {object} [extra] - Extra data to add to application state.
   *
   * @returns {ApplicationStateData} Passed in object with current application state.
   */
  get(extra = {}) {
    return Object.assign(extra, {
      position: this.#application?.position?.get(),
      beforeMinimized: this.#application?.position?.state.get({ name: "#beforeMinimized" }),
      options: Object.assign({}, this.#application?.options),
      ui: { minimized: this.#application?.reactive?.minimized }
    });
  }
  /**
   * Returns any stored save state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Saved data set name.
   *
   * @returns {ApplicationStateData} The saved data set.
   */
  getSave({ name: name2 }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`ApplicationState - getSave error: 'name' is not a string.`);
    }
    return this.#dataSaved.get(name2);
  }
  /**
   * Removes and returns any application state by name.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - Name to remove and retrieve.
   *
   * @returns {ApplicationStateData} Saved application data.
   */
  remove({ name: name2 }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`ApplicationState - remove: 'name' is not a string.`);
    }
    const data = this.#dataSaved.get(name2);
    this.#dataSaved.delete(name2);
    return data;
  }
  /**
   * Restores a saved application state returning the data. Several optional parameters are available
   * to control whether the restore action occurs silently (no store / inline styles updates), animates
   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to} allows
   * specification of the duration, easing, and interpolate functions along with configuring a Promise to be
   * returned if awaiting the end of the animation.
   *
   * @param {object}            params - Parameters
   *
   * @param {string}            params.name - Saved data set name.
   *
   * @param {boolean}           [params.remove=false] - Remove data set.
   *
   * @param {boolean}           [params.async=false] - If animating return a Promise that resolves with any saved data.
   *
   * @param {boolean}           [params.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [params.duration=0.1] - Duration in seconds.
   *
   * @param {Function}          [params.ease=linear] - Easing function.
   *
   * @param {Function}          [params.interpolate=lerp] - Interpolation function.
   *
   * @returns {ApplicationStateData|Promise<ApplicationStateData>} Saved application data.
   */
  restore({
    name: name2,
    remove = false,
    async = false,
    animateTo = false,
    duration = 0.1,
    ease = identity$1,
    interpolate = lerp
  }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`ApplicationState - restore error: 'name' is not a string.`);
    }
    const dataSaved = this.#dataSaved.get(name2);
    if (dataSaved) {
      if (remove) {
        this.#dataSaved.delete(name2);
      }
      if (async) {
        return this.set(dataSaved, { async, animateTo, duration, ease, interpolate }).then(() => dataSaved);
      } else {
        this.set(dataSaved, { async, animateTo, duration, ease, interpolate });
      }
    }
    return dataSaved;
  }
  /**
   * Saves current application state with the opportunity to add extra data to the saved state.
   *
   * @param {object}   options - Options.
   *
   * @param {string}   options.name - name to index this saved data.
   *
   * @param {...*}     [options.extra] - Extra data to add to saved data.
   *
   * @returns {ApplicationStateData} Current application data
   */
  save({ name: name2, ...extra }) {
    if (typeof name2 !== "string") {
      throw new TypeError(`ApplicationState - save error: 'name' is not a string.`);
    }
    const data = this.get(extra);
    this.#dataSaved.set(name2, data);
    return data;
  }
  /**
   * Restores a saved application state returning the data. Several optional parameters are available
   * to control whether the restore action occurs silently (no store / inline styles updates), animates
   * to the stored data, or simply sets the stored data. Restoring via {@link AnimationAPI.to} allows
   * specification of the duration, easing, and interpolate functions along with configuring a Promise to be
   * returned if awaiting the end of the animation.
   *
   * Note: If serializing application state any minimized apps will use the before minimized state on initial render
   * of the app as it is currently not possible to render apps with Foundry VTT core API in the minimized state.
   *
   * TODO: THIS METHOD NEEDS TO BE REFACTORED WHEN TRL IS MADE INTO A STANDALONE FRAMEWORK.
   *
   * @param {ApplicationStateData}   data - Saved data set name.
   *
   * @param {object}            [opts] - Optional parameters
   *
   * @param {boolean}           [opts.async=false] - If animating return a Promise that resolves with any saved data.
   *
   * @param {boolean}           [opts.animateTo=false] - Animate to restore data.
   *
   * @param {number}            [opts.duration=0.1] - Duration in seconds.
   *
   * @param {Function}          [opts.ease=linear] - Easing function.
   *
   * @param {Function}          [opts.interpolate=lerp] - Interpolation function.
   *
   * @returns {T | Promise<T>} When synchronous the application or Promise when animating resolving with application.
   */
  set(data, { async = false, animateTo = false, duration = 0.1, ease = identity$1, interpolate = lerp } = {}) {
    if (!isObject$1(data)) {
      throw new TypeError(`ApplicationState - restore error: 'data' is not an object.`);
    }
    const application = this.#application;
    if (!isObject$1(data?.position)) {
      console.warn(`ApplicationState.set warning: 'data.position' is not an object.`);
      return application;
    }
    const rendered = application.rendered;
    if (animateTo && !rendered) {
      console.warn(`ApplicationState.set warning: Application is not rendered and 'animateTo' is true.`);
      return application;
    }
    if (animateTo) {
      if (data.position.transformOrigin !== application.position.transformOrigin) {
        application.position.transformOrigin = data.position.transformOrigin;
      }
      if (isObject$1(data?.ui)) {
        const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
        if (application?.reactive?.minimized && !minimized) {
          application.maximize({ animate: false, duration: 0 });
        }
      }
      const promise2 = application.position.animate.to(
        data.position,
        { duration, ease, interpolate }
      ).finished.then((cancelled) => {
        if (cancelled) {
          return application;
        }
        if (isObject$1(data?.options)) {
          application?.reactive.mergeOptions(data.options);
        }
        if (isObject$1(data?.ui)) {
          const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
          if (!application?.reactive?.minimized && minimized) {
            application.minimize({ animate: false, duration: 0 });
          }
        }
        if (isObject$1(data?.beforeMinimized)) {
          application.position.state.set({ name: "#beforeMinimized", ...data.beforeMinimized });
        }
        return application;
      });
      if (async) {
        return promise2;
      }
    } else {
      if (rendered) {
        if (isObject$1(data?.options)) {
          application?.reactive.mergeOptions(data.options);
        }
        if (isObject$1(data?.ui)) {
          const minimized = typeof data.ui?.minimized === "boolean" ? data.ui.minimized : false;
          if (application?.reactive?.minimized && !minimized) {
            application.maximize({ animate: false, duration: 0 });
          } else if (!application?.reactive?.minimized && minimized) {
            application.minimize({ animate: false, duration });
          }
        }
        if (isObject$1(data?.beforeMinimized)) {
          application.position.state.set({ name: "#beforeMinimized", ...data.beforeMinimized });
        }
        application.position.set(data.position);
      } else {
        let positionData = data.position;
        if (isObject$1(data.beforeMinimized)) {
          positionData = data.beforeMinimized;
          positionData.left = data.position.left;
          positionData.top = data.position.top;
        }
        application.position.set(positionData);
      }
    }
    return application;
  }
}
class GetSvelteData {
  /** @type {import('./types').MountedAppShell[] | null[]} */
  #applicationShellHolder;
  /** @type {import('./types').SvelteData[]} */
  #svelteData;
  /**
   * Keep a direct reference to the SvelteData array in an associated {@link SvelteApplication}.
   *
   * @param {import('./types').MountedAppShell[] | null[]}  applicationShellHolder - A reference to the
   *        MountedAppShell array.
   *
   * @param {import('./types').SvelteData[]}  svelteData - A reference to the SvelteData array of mounted components.
   */
  constructor(applicationShellHolder, svelteData) {
    this.#applicationShellHolder = applicationShellHolder;
    this.#svelteData = svelteData;
  }
  /**
   * Returns any mounted {@link MountedAppShell}.
   *
   * @returns {import('./types').MountedAppShell | null} Any mounted application shell.
   */
  get applicationShell() {
    return this.#applicationShellHolder[0];
  }
  /**
   * Returns the indexed Svelte component.
   *
   * @param {number}   index -
   *
   * @returns {object} The loaded Svelte component.
   */
  component(index2) {
    const data = this.#svelteData[index2];
    return data?.component ?? void 0;
  }
  /**
   * Returns the Svelte component entries iterator.
   *
   * @returns {IterableIterator<[number, import('svelte').SvelteComponent]>} Svelte component entries iterator.
   * @yields
   */
  *componentEntries() {
    for (let cntr = 0; cntr < this.#svelteData.length; cntr++) {
      yield [cntr, this.#svelteData[cntr].component];
    }
  }
  /**
   * Returns the Svelte component values iterator.
   *
   * @returns {IterableIterator<import('svelte').SvelteComponent>} Svelte component values iterator.
   * @yields
   */
  *componentValues() {
    for (let cntr = 0; cntr < this.#svelteData.length; cntr++) {
      yield this.#svelteData[cntr].component;
    }
  }
  /**
   * Returns the indexed SvelteData entry.
   *
   * @param {number}   index - The index of SvelteData instance to retrieve.
   *
   * @returns {import('./types').SvelteData} The loaded Svelte config + component.
   */
  data(index2) {
    return this.#svelteData[index2];
  }
  /**
   * Returns the {@link SvelteData} instance for a given component.
   *
   * @param {import('svelte').SvelteComponent} component - Svelte component.
   *
   * @returns {import('./types').SvelteData} -  The loaded Svelte config + component.
   */
  dataByComponent(component) {
    for (const data of this.#svelteData) {
      if (data.component === component) {
        return data;
      }
    }
    return void 0;
  }
  /**
   * Returns the SvelteData entries iterator.
   *
   * @returns {IterableIterator<[number, import('./types').SvelteData]>} SvelteData entries iterator.
   */
  dataEntries() {
    return this.#svelteData.entries();
  }
  /**
   * Returns the SvelteData values iterator.
   *
   * @returns {IterableIterator<import('./types').SvelteData>} SvelteData values iterator.
   */
  dataValues() {
    return this.#svelteData.values();
  }
  /**
   * Returns the length of the mounted Svelte component list.
   *
   * @returns {number} Length of mounted Svelte component list.
   */
  get length() {
    return this.#svelteData.length;
  }
}
function storeGenerator({ storage, serialize = JSON.stringify, deserialize = JSON.parse }) {
  function isSimpleDeriver(deriver) {
    return deriver.length < 2;
  }
  function storageReadable(key, value, start) {
    return {
      subscribe: storageWritable(key, value, start).subscribe
    };
  }
  function storageWritable(key, value, start) {
    function wrap_start(ogSet) {
      return start(function wrap_set(new_value) {
        if (storage) {
          storage.setItem(key, serialize(new_value));
        }
        return ogSet(new_value);
      }, function wrap_update(fn) {
        set2(fn(get_store_value(ogStore)));
      });
    }
    if (storage) {
      const storageValue = storage.getItem(key);
      try {
        if (storageValue) {
          value = deserialize(storageValue);
        }
      } catch (err) {
      }
      storage.setItem(key, serialize(value));
    }
    const ogStore = writable(value, start ? wrap_start : void 0);
    function set2(new_value) {
      if (storage) {
        storage.setItem(key, serialize(new_value));
      }
      ogStore.set(new_value);
    }
    function update2(fn) {
      set2(fn(get_store_value(ogStore)));
    }
    function subscribe2(run2, invalidate) {
      return ogStore.subscribe(run2, invalidate);
    }
    return { set: set2, update: update2, subscribe: subscribe2 };
  }
  function storageDerived(key, stores, fn, initial_value) {
    const single = !Array.isArray(stores);
    const stores_array = single ? [stores] : stores;
    if (storage && storage.getItem(key)) {
      try {
        initial_value = deserialize(storage.getItem(key));
      } catch (err) {
      }
    }
    return storageReadable(key, initial_value, (set2, update2) => {
      let inited = false;
      const values = [];
      let pending = 0;
      let cleanup;
      const sync = () => {
        if (pending) {
          return;
        }
        cleanup?.();
        const input = single ? values[0] : values;
        if (isSimpleDeriver(fn)) {
          set2(fn(input));
        } else {
          const result = fn(input, set2, update2);
          if (typeof result === "function") {
            cleanup = result;
          }
        }
      };
      const unsubscribers = stores_array.map((store, i2) => store.subscribe((value) => {
        values[i2] = value;
        pending &= ~(1 << i2);
        if (inited) {
          sync();
        }
      }, () => {
        pending |= 1 << i2;
      }));
      inited = true;
      sync();
      return function stop() {
        unsubscribers.forEach((unsubscriber) => unsubscriber());
        cleanup?.();
      };
    });
  }
  return {
    readable: storageReadable,
    writable: storageWritable,
    derived: storageDerived,
    storage,
    serialize,
    deserialize
  };
}
const sessionStores = storeGenerator({ storage: globalThis?.sessionStorage });
class TJSWebStorage {
  /** @type {import('./').StorageStores} */
  #storageStores;
  /**
   * @type {(Map<string, {
   *    store: import('svelte/store').Writable,
   *    deserialize?: (value: string, ...rest: any[]) => any,
   *    serialize?: (value: any, ...rest: any[]) => string
   * }>)}
   */
  #stores = /* @__PURE__ */ new Map();
  /**
   * @param {import('./').StorageStores} storageStores - Provides a complete set of
   *        storage API store helper functions and the associated storage API instance and serializations strategy.
   */
  constructor(storageStores) {
    this.#storageStores = storageStores;
  }
  /**
   * @param {string}   key - Storage key.
   *
   * @returns {(value: string, ...rest: any[]) => any} Deserialize function.
   */
  #getDeserialize(key) {
    return this.#stores.get(key)?.deserialize ?? this.#storageStores.deserialize;
  }
  /**
   * @param {string}   key - Storage key.
   *
   * @returns {(value: any, ...rest: any[]) => string} Serialize function.
   */
  #getSerialize(key) {
    return this.#stores.get(key)?.serialize ?? this.#storageStores.serialize;
  }
  /**
   * Creates a new store for the given key.
   *
   * @template T
   *
   * @param {string}   key - Key to lookup in stores map.
   *
   * @param {T}        [defaultValue] - A default value to set for the store.
   *
   * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
   *
   * @returns {import('svelte/store').Writable<T>} The new store.
   */
  #createStore(key, defaultValue = void 0, storageStores) {
    try {
      const value = this.#storageStores.storage.getItem(key);
      if (value !== null) {
        const deserialize = storageStores?.deserialize ?? this.#storageStores.deserialize;
        defaultValue = deserialize(value);
      }
    } catch (err) {
    }
    const writable2 = storageStores?.writable ?? this.#storageStores.writable;
    return writable2(key, defaultValue);
  }
  /**
   * Gets a store from the `stores` Map or creates a new store for the key and a given default value.
   *
   * @template T
   *
   * @param {string}   key - Key to lookup in stores map.
   *
   * @param {T}        [defaultValue] - A default value to set for the store.
   *
   * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
   *
   * @returns {import('svelte/store').Writable<T>} The store for the given key.
   */
  #getStore(key, defaultValue = void 0, storageStores) {
    const storeEntry = this.#stores.get(key);
    if (storeEntry) {
      return storeEntry.store;
    }
    const store = this.#createStore(key, defaultValue, storageStores);
    this.#stores.set(key, {
      store,
      deserialize: storageStores?.deserialize,
      serialize: storageStores?.serialize
    });
    return store;
  }
  /**
   * Get value from the storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {*}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {*} Value from session storage or if not defined any default value provided.
   */
  getItem(key, defaultValue) {
    let value = defaultValue;
    const storageValue = this.#storageStores.storage.getItem(key);
    if (storageValue !== null) {
      try {
        value = this.#getDeserialize(key)(storageValue);
      } catch (err) {
        value = defaultValue;
      }
    } else if (defaultValue !== void 0) {
      try {
        const newValue = this.#getSerialize(key)(defaultValue);
        this.#storageStores.storage.setItem(key, newValue);
      } catch (err) {
      }
    }
    return value;
  }
  /**
   * Returns the backing Svelte store for the given key; potentially sets a default value if the key
   * is not already set.
   *
   * @template T
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {T}        [defaultValue] - A default value to return if key not present in session storage.
   *
   * @param {import('./').StorageStores} [storageStores] - Additional store creation options.
   *
   * @returns {import('svelte/store').Writable<T>} The Svelte store for this key.
   */
  getStore(key, defaultValue, storageStores) {
    return this.#getStore(key, defaultValue, storageStores);
  }
  /**
   * Sets the value for the given key in storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {*}        value - A value to set for this key.
   */
  setItem(key, value) {
    const store = this.#getStore(key);
    store.set(value);
  }
  /**
   * Convenience method to swap a boolean value stored in storage API.
   *
   * @param {string}   key - Key to lookup in storage API.
   *
   * @param {boolean}  [defaultValue] - A default value to return if key not present in session storage.
   *
   * @returns {boolean} The boolean swap for the given key.
   */
  swapItemBoolean(key, defaultValue) {
    const store = this.#getStore(key, defaultValue);
    let currentValue = false;
    try {
      currentValue = !!this.#getDeserialize(key)(this.#storageStores.storage.getItem(key));
    } catch (err) {
    }
    const newValue = typeof currentValue === "boolean" ? !currentValue : false;
    store.set(newValue);
    return newValue;
  }
}
class TJSSessionStorage extends TJSWebStorage {
  constructor() {
    super(sessionStores);
  }
}
class SvelteReactive {
  /**
   * @type {import('../SvelteApplication').SvelteApplication}
   */
  #application;
  /**
   * @type {boolean}
   */
  #initialized = false;
  /** @type {import('@typhonjs-fvtt/runtime/svelte/store/web-storage').TJSWebStorage} */
  #sessionStorage;
  /**
   * The Application option store which is injected into mounted Svelte component context under the `external` key.
   *
   * @type {import('./types').StoreAppOptions}
   */
  #storeAppOptions;
  /**
   * Stores the update function for `#storeAppOptions`.
   *
   * @type {(this: void, updater: import('svelte/store').Updater<object>) => void}
   */
  #storeAppOptionsUpdate;
  /**
   * Stores the UI state data to make it accessible via getters.
   *
   * @type {object}
   */
  #dataUIState;
  /**
   * The UI option store which is injected into mounted Svelte component context under the `external` key.
   *
   * @type {import('./types').StoreUIOptions}
   */
  #storeUIState;
  /**
   * Stores the update function for `#storeUIState`.
   *
   * @type {(this: void, updater: import('svelte/store').Updater<object>) => void}
   */
  #storeUIStateUpdate;
  /**
   * Stores the unsubscribe functions from local store subscriptions.
   *
   * @type {import('svelte/store').Unsubscriber[]}
   */
  #storeUnsubscribe = [];
  /**
   * @param {import('../SvelteApplication').SvelteApplication} application - The host Foundry application.
   */
  constructor(application) {
    this.#application = application;
    const optionsSessionStorage = application?.options?.sessionStorage;
    if (optionsSessionStorage !== void 0 && !(optionsSessionStorage instanceof TJSWebStorage)) {
      throw new TypeError(`'options.sessionStorage' is not an instance of TJSWebStorage.`);
    }
    this.#sessionStorage = optionsSessionStorage !== void 0 ? optionsSessionStorage : new TJSSessionStorage();
  }
  /**
   * Initializes reactive support. Package private for internal use.
   *
   * @returns {SvelteReactiveStores | undefined} Internal methods to interact with Svelte stores.
   * @package
   * @internal
   */
  initialize() {
    if (this.#initialized) {
      return;
    }
    this.#initialized = true;
    this.#storesInitialize();
    return {
      appOptionsUpdate: this.#storeAppOptionsUpdate,
      uiStateUpdate: this.#storeUIStateUpdate,
      subscribe: this.#storesSubscribe.bind(this),
      unsubscribe: this.#storesUnsubscribe.bind(this)
    };
  }
  // Store getters -----------------------------------------------------------------------------------------------------
  /**
   * @returns {import('@typhonjs-fvtt/runtime/svelte/store/web-storage').TJSWebStorage} Returns TJSWebStorage (session) instance.
   */
  get sessionStorage() {
    return this.#sessionStorage;
  }
  /**
   * Returns the store for app options.
   *
   * @returns {import('./types').StoreAppOptions} App options store.
   */
  get storeAppOptions() {
    return this.#storeAppOptions;
  }
  /**
   * Returns the store for UI options.
   *
   * @returns {import('./types').StoreUIOptions} UI options store.
   */
  get storeUIState() {
    return this.#storeUIState;
  }
  // Only reactive getters ---------------------------------------------------------------------------------------------
  /**
   * Returns the current dragging UI state.
   *
   * @returns {boolean} Dragging UI state.
   */
  get dragging() {
    return this.#dataUIState.dragging;
  }
  /**
   * Returns the current minimized UI state.
   *
   * @returns {boolean} Minimized UI state.
   */
  get minimized() {
    return this.#dataUIState.minimized;
  }
  /**
   * Returns the current resizing UI state.
   *
   * @returns {boolean} Resizing UI state.
   */
  get resizing() {
    return this.#dataUIState.resizing;
  }
  // Reactive getter / setters -----------------------------------------------------------------------------------------
  /**
   * Returns the draggable app option.
   *
   * @returns {boolean} Draggable app option.
   */
  get draggable() {
    return this.#application?.options?.draggable;
  }
  /**
   * Returns the focusAuto app option.
   *
   * @returns {boolean} When true auto-management of app focus is enabled.
   */
  get focusAuto() {
    return this.#application?.options?.focusAuto;
  }
  /**
   * Returns the focusKeep app option.
   *
   * @returns {boolean} When `focusAuto` and `focusKeep` is true; keeps internal focus.
   */
  get focusKeep() {
    return this.#application?.options?.focusKeep;
  }
  /**
   * Returns the focusTrap app option.
   *
   * @returns {boolean} When true focus trapping / wrapping is enabled keeping focus inside app.
   */
  get focusTrap() {
    return this.#application?.options?.focusTrap;
  }
  /**
   * Returns the headerButtonNoClose app option.
   *
   * @returns {boolean} Remove the close the button in header app option.
   */
  get headerButtonNoClose() {
    return this.#application?.options?.headerButtonNoClose;
  }
  /**
   * Returns the headerButtonNoLabel app option.
   *
   * @returns {boolean} Remove the labels from buttons in header app option.
   */
  get headerButtonNoLabel() {
    return this.#application?.options?.headerButtonNoLabel;
  }
  /**
   * Returns the headerIcon app option.
   *
   * @returns {string|void} URL for header app icon.
   */
  get headerIcon() {
    return this.#application?.options?.headerIcon;
  }
  /**
   * Returns the headerNoTitleMinimized app option.
   *
   * @returns {boolean} When true removes the header title when minimized.
   */
  get headerNoTitleMinimized() {
    return this.#application?.options?.headerNoTitleMinimized;
  }
  /**
   * Returns the minimizable app option.
   *
   * @returns {boolean} Minimizable app option.
   */
  get minimizable() {
    return this.#application?.options?.minimizable;
  }
  /**
   * Returns the Foundry popOut state; {@link Application.popOut}
   *
   * @returns {boolean} Positionable app option.
   */
  get popOut() {
    return this.#application.popOut;
  }
  /**
   * Returns the positionable app option; {@link SvelteApplicationOptions.positionable}
   *
   * @returns {boolean} Positionable app option.
   */
  get positionable() {
    return this.#application?.options?.positionable;
  }
  /**
   * Returns the resizable option.
   *
   * @returns {boolean} Resizable app option.
   */
  get resizable() {
    return this.#application?.options?.resizable;
  }
  /**
   * Returns the title accessor from the parent Application class; {@link Application.title}
   * TODO: Application v2; note that super.title localizes `this.options.title`; IMHO it shouldn't.
   *
   * @returns {string} Title.
   */
  get title() {
    return this.#application.title;
  }
  /**
   * Sets `this.options.draggable` which is reactive for application shells.
   *
   * @param {boolean}  draggable - Sets the draggable option.
   */
  set draggable(draggable2) {
    if (typeof draggable2 === "boolean") {
      this.setOptions("draggable", draggable2);
    }
  }
  /**
   * Sets `this.options.focusAuto` which is reactive for application shells.
   *
   * @param {boolean}  focusAuto - Sets the focusAuto option.
   */
  set focusAuto(focusAuto) {
    if (typeof focusAuto === "boolean") {
      this.setOptions("focusAuto", focusAuto);
    }
  }
  /**
   * Sets `this.options.focusKeep` which is reactive for application shells.
   *
   * @param {boolean}  focusKeep - Sets the focusKeep option.
   */
  set focusKeep(focusKeep) {
    if (typeof focusKeep === "boolean") {
      this.setOptions("focusKeep", focusKeep);
    }
  }
  /**
   * Sets `this.options.focusTrap` which is reactive for application shells.
   *
   * @param {boolean}  focusTrap - Sets the focusTrap option.
   */
  set focusTrap(focusTrap) {
    if (typeof focusTrap === "boolean") {
      this.setOptions("focusTrap", focusTrap);
    }
  }
  /**
   * Sets `this.options.headerButtonNoClose` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoClose - Sets the headerButtonNoClose option.
   */
  set headerButtonNoClose(headerButtonNoClose) {
    if (typeof headerButtonNoClose === "boolean") {
      this.setOptions("headerButtonNoClose", headerButtonNoClose);
    }
  }
  /**
   * Sets `this.options.headerButtonNoLabel` which is reactive for application shells.
   *
   * @param {boolean}  headerButtonNoLabel - Sets the headerButtonNoLabel option.
   */
  set headerButtonNoLabel(headerButtonNoLabel) {
    if (typeof headerButtonNoLabel === "boolean") {
      this.setOptions("headerButtonNoLabel", headerButtonNoLabel);
    }
  }
  /**
   * Sets `this.options.headerIcon` which is reactive for application shells.
   *
   * @param {string | undefined}  headerIcon - Sets the headerButtonNoLabel option.
   */
  set headerIcon(headerIcon) {
    if (headerIcon === void 0 || typeof headerIcon === "string") {
      this.setOptions("headerIcon", headerIcon);
    }
  }
  /**
   * Sets `this.options.headerNoTitleMinimized` which is reactive for application shells.
   *
   * @param {boolean}  headerNoTitleMinimized - Sets the headerNoTitleMinimized option.
   */
  set headerNoTitleMinimized(headerNoTitleMinimized) {
    if (typeof headerNoTitleMinimized === "boolean") {
      this.setOptions("headerNoTitleMinimized", headerNoTitleMinimized);
    }
  }
  /**
   * Sets `this.options.minimizable` which is reactive for application shells that are also pop out.
   *
   * @param {boolean}  minimizable - Sets the minimizable option.
   */
  set minimizable(minimizable) {
    if (typeof minimizable === "boolean") {
      this.setOptions("minimizable", minimizable);
    }
  }
  /**
   * Sets `this.options.popOut` which is reactive for application shells. This will add / remove this application
   * from `ui.windows`.
   *
   * @param {boolean}  popOut - Sets the popOut option.
   */
  set popOut(popOut) {
    if (typeof popOut === "boolean") {
      this.setOptions("popOut", popOut);
    }
  }
  /**
   * Sets `this.options.positionable` enabling / disabling {@link SvelteApplication.position}.
   *
   * @param {boolean}  positionable - Sets the positionable option.
   */
  set positionable(positionable) {
    if (typeof positionable === "boolean") {
      this.setOptions("positionable", positionable);
    }
  }
  /**
   * Sets `this.options.resizable` which is reactive for application shells.
   *
   * @param {boolean}  resizable - Sets the resizable option.
   */
  set resizable(resizable) {
    if (typeof resizable === "boolean") {
      this.setOptions("resizable", resizable);
    }
  }
  /**
   * Sets `this.options.title` which is reactive for application shells.
   *
   * Note: Will set empty string if title is undefined or null.
   *
   * @param {string | undefined | null}   title - Application title; will be localized, so a translation key is fine.
   */
  set title(title) {
    if (typeof title === "string") {
      this.setOptions("title", title);
    } else if (title === void 0 || title === null) {
      this.setOptions("title", "");
    }
  }
  // Reactive Options API -------------------------------------------------------------------------------------------
  /**
   * Provides a way to safely get this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {*}        [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {*} Value at the accessor.
   */
  getOptions(accessor, defaultValue) {
    return safeAccess(this.#application.options, accessor, defaultValue);
  }
  /**
   * Provides a way to merge `options` into this applications options and update the appOptions store.
   *
   * @param {object}   options - The options object to merge with `this.options`.
   */
  mergeOptions(options) {
    this.#storeAppOptionsUpdate((instanceOptions) => deepMerge(instanceOptions, options));
  }
  /**
   * Provides a way to safely set this applications options given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Additionally if an application shell Svelte component is mounted and exports the `appOptions` property then
   * the application options is set to `appOptions` potentially updating the application shell / Svelte component.
   *
   * // TODO DOCUMENT the accessor in more detail.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      value - Value to set.
   */
  setOptions(accessor, value) {
    const success = safeSet(this.#application.options, accessor, value);
    if (success) {
      this.#storeAppOptionsUpdate(() => this.#application.options);
    }
  }
  /**
   * Initializes the Svelte stores and derived stores for the application options and UI state.
   *
   * While writable stores are created the update method is stored in private variables locally and derived Readable
   * stores are provided for essential options which are commonly used.
   *
   * These stores are injected into all Svelte components mounted under the `external` context: `storeAppOptions` and
   * `storeUIState`.
   */
  #storesInitialize() {
    const writableAppOptions = writable(this.#application.options);
    this.#storeAppOptionsUpdate = writableAppOptions.update;
    const storeAppOptions = {
      subscribe: writableAppOptions.subscribe,
      draggable: propertyStore(writableAppOptions, "draggable"),
      focusAuto: propertyStore(writableAppOptions, "focusAuto"),
      focusKeep: propertyStore(writableAppOptions, "focusKeep"),
      focusTrap: propertyStore(writableAppOptions, "focusTrap"),
      headerButtonNoClose: propertyStore(writableAppOptions, "headerButtonNoClose"),
      headerButtonNoLabel: propertyStore(writableAppOptions, "headerButtonNoLabel"),
      headerIcon: propertyStore(writableAppOptions, "headerIcon"),
      headerNoTitleMinimized: propertyStore(writableAppOptions, "headerNoTitleMinimized"),
      minimizable: propertyStore(writableAppOptions, "minimizable"),
      popOut: propertyStore(writableAppOptions, "popOut"),
      positionable: propertyStore(writableAppOptions, "positionable"),
      resizable: propertyStore(writableAppOptions, "resizable"),
      title: propertyStore(writableAppOptions, "title")
    };
    Object.freeze(storeAppOptions);
    this.#storeAppOptions = storeAppOptions;
    this.#dataUIState = {
      dragging: false,
      headerButtons: [],
      minimized: this.#application._minimized,
      resizing: false
    };
    const writableUIOptions = writable(this.#dataUIState);
    this.#storeUIStateUpdate = writableUIOptions.update;
    const storeUIState = {
      subscribe: writableUIOptions.subscribe,
      dragging: propertyStore(writableUIOptions, "dragging"),
      headerButtons: derived(writableUIOptions, ($options, set2) => set2($options.headerButtons)),
      minimized: derived(writableUIOptions, ($options, set2) => set2($options.minimized)),
      resizing: propertyStore(writableUIOptions, "resizing")
    };
    Object.freeze(storeUIState);
    this.#storeUIState = storeUIState;
  }
  /**
   * Registers local store subscriptions for app options. `popOut` controls registering this app with `ui.windows`.
   *
   * @see SvelteApplication._injectHTML
   */
  #storesSubscribe() {
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.headerButtonNoClose, (value) => {
      this.updateHeaderButtons({ headerButtonNoClose: value });
    }));
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.headerButtonNoLabel, (value) => {
      this.updateHeaderButtons({ headerButtonNoLabel: value });
    }));
    this.#storeUnsubscribe.push(subscribeIgnoreFirst(this.#storeAppOptions.popOut, (value) => {
      if (value && this.#application.rendered) {
        globalThis.ui.windows[this.#application.appId] = this.#application;
      } else {
        delete globalThis.ui.windows[this.#application.appId];
      }
    }));
  }
  /**
   * Unsubscribes from any locally monitored stores.
   *
   * @see SvelteApplication.close
   */
  #storesUnsubscribe() {
    this.#storeUnsubscribe.forEach((unsubscribe) => unsubscribe());
    this.#storeUnsubscribe = [];
  }
  /**
   * Updates the UI Options store with the current header buttons. You may dynamically add / remove header buttons
   * if using an application shell Svelte component. In either overriding `_getHeaderButtons` or responding to the
   * Hooks fired return a new button array and the uiOptions store is updated and the application shell will render
   * the new buttons.
   *
   * Optionally you can set in the SvelteApplication app options {@link SvelteApplicationOptions.headerButtonNoClose}
   * to remove the close button and {@link SvelteApplicationOptions.headerButtonNoLabel} to true and labels will be
   * removed from the header buttons.
   *
   * @param {object} [opts] - Optional parameters (for internal use)
   *
   * @param {boolean} [opts.headerButtonNoClose] - The value for `headerButtonNoClose`.
   *
   * @param {boolean} [opts.headerButtonNoLabel] - The value for `headerButtonNoLabel`.
   */
  updateHeaderButtons({
    headerButtonNoClose = this.#application.options.headerButtonNoClose,
    headerButtonNoLabel = this.#application.options.headerButtonNoLabel
  } = {}) {
    let buttons = this.#application._getHeaderButtons();
    if (typeof headerButtonNoClose === "boolean" && headerButtonNoClose) {
      buttons = buttons.filter((button) => button.class !== "close");
    }
    if (typeof headerButtonNoLabel === "boolean" && headerButtonNoLabel) {
      for (const button of buttons) {
        button.label = void 0;
      }
    }
    this.#storeUIStateUpdate((options) => {
      options.headerButtons = buttons;
      return options;
    });
  }
}
const applicationShellContract = ["elementRoot"];
Object.freeze(applicationShellContract);
function isApplicationShell(component) {
  if (component === null || component === void 0) {
    return false;
  }
  let compHasContract = true;
  let protoHasContract = true;
  for (const accessor of applicationShellContract) {
    const descriptor = Object.getOwnPropertyDescriptor(component, accessor);
    if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) {
      compHasContract = false;
    }
  }
  const prototype = Object.getPrototypeOf(component);
  for (const accessor of applicationShellContract) {
    const descriptor = Object.getOwnPropertyDescriptor(prototype, accessor);
    if (descriptor === void 0 || descriptor.get === void 0 || descriptor.set === void 0) {
      protoHasContract = false;
    }
  }
  return compHasContract || protoHasContract;
}
function loadSvelteConfig({ app, template, config: config3, elementRootUpdate } = {}) {
  const svelteOptions = isObject$1(config3.options) ? config3.options : {};
  let target;
  if (config3.target instanceof HTMLElement) {
    target = config3.target;
  } else if (template instanceof HTMLElement && typeof config3.target === "string") {
    target = template.querySelector(config3.target);
  } else {
    target = document.createDocumentFragment();
  }
  if (target === void 0) {
    console.log(
      `%c[TRL] loadSvelteConfig error - could not find target selector, '${config3.target}', for config:
`,
      "background: rgb(57,34,34)",
      config3
    );
    throw new Error();
  }
  const NewSvelteComponent = config3.class;
  const svelteConfig = parseTJSSvelteConfig({ ...config3, target }, app);
  const externalContext = svelteConfig.context.get("#external");
  externalContext.application = app;
  externalContext.elementRootUpdate = elementRootUpdate;
  externalContext.sessionStorage = app.reactive.sessionStorage;
  let eventbus;
  if (isObject$1(app._eventbus) && typeof app._eventbus.createProxy === "function") {
    eventbus = app._eventbus.createProxy();
    externalContext.eventbus = eventbus;
  }
  Object.seal(externalContext);
  svelteConfig.context.set("external", new Proxy({}, {
    get(targetUnused, prop) {
      console.warn(`[TRL] Deprecation warning: Please change getContext('external') to getContext('#external').`);
      return externalContext[prop];
    }
  }));
  const component = new NewSvelteComponent(svelteConfig);
  svelteConfig.eventbus = eventbus;
  let element2;
  if (isApplicationShell(component)) {
    element2 = component.elementRoot;
  }
  if (target instanceof DocumentFragment && target.firstElementChild) {
    if (element2 === void 0) {
      element2 = target.firstElementChild;
    }
    template.append(target);
  } else if (config3.target instanceof HTMLElement && element2 === void 0) {
    if (config3.target instanceof HTMLElement && typeof svelteOptions.selectorElement !== "string") {
      console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with no 'selectorElement' defined.

Note: If configuring an application shell and directly targeting a HTMLElement did you bind an'elementRoot' and include '<svelte:options accessors={true}/>'?

Offending config:
`,
        "background: rgb(57,34,34)",
        config3
      );
      throw new Error();
    }
    element2 = target.querySelector(svelteOptions.selectorElement);
    if (element2 === null || element2 === void 0) {
      console.log(
        `%c[TRL] loadSvelteConfig error - HTMLElement target with 'selectorElement', '${svelteOptions.selectorElement}', not found for config:
`,
        "background: rgb(57,34,34)",
        config3
      );
      throw new Error();
    }
  }
  const injectHTML = !(config3.target instanceof HTMLElement);
  return { config: svelteConfig, component, element: element2, injectHTML };
}
class TJSAppIndex {
  /**
   * Stores all visible / rendered apps.
   *
   * @type {Map<string, import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication>}
   */
  static #visibleApps = /* @__PURE__ */ new Map();
  /**
   * Adds a SvelteApplication to all visible apps tracked.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} app - A SvelteApplication
   *
   * @package
   */
  static add(app) {
    this.#visibleApps.set(app.id, app);
  }
  /**
   * Removes a SvelteApplication from all visible apps tracked.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} app - A SvelteApplication
   *
   * @package
   */
  static delete(app) {
    this.#visibleApps.delete(app.id);
  }
  /**
   * Gets a particular app by ID.
   *
   * @param {string}   key - App ID.
   *
   * @returns {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication} Associated app.
   */
  static get(key) {
    return this.#visibleApps.get(key);
  }
  /**
   * Returns whether an associated app by ID is being tracked.
   *
   * @param {string}   key - App ID.
   *
   * @returns {boolean} The given App ID is visible.
   */
  static has(key) {
    return this.#visibleApps.has(key);
  }
  /**
   * @returns {IterableIterator<string>} All visible app IDs.
   */
  static keys() {
    return this.#visibleApps.keys();
  }
  /**
   * @returns {IterableIterator<import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplication>} All visible apps.
   */
  static values() {
    return this.#visibleApps.values();
  }
}
class SvelteApplication extends Application {
  /**
   * Stores the first mounted component which follows the application shell contract.
   *
   * @type {import('./internal/state-svelte/types').MountedAppShell[]|null[]} Application shell.
   */
  #applicationShellHolder = [null];
  /**
   * Stores and manages application state for saving / restoring / serializing.
   *
   * @type {ApplicationState<SvelteApplication>}
   */
  #applicationState;
  /**
   * Stores the target element which may not necessarily be the main element.
   *
   * @type {HTMLElement}
   */
  #elementTarget = null;
  /**
   * Stores the content element which is set for application shells.
   *
   * @type {HTMLElement}
   */
  #elementContent = null;
  /**
   * Stores initial z-index from `_renderOuter` to set to target element / Svelte component.
   *
   * @type {number}
   */
  #initialZIndex = 95;
  /**
   * Stores on mount state which is checked in _render to trigger onSvelteMount callback.
   *
   * @type {boolean}
   */
  #onMount = false;
  /**
   * The position store.
   *
   * @type {TJSPosition}
   */
  #position;
  /**
   * Contains the Svelte stores and reactive accessors.
   *
   * @type {SvelteReactive}
   */
  #reactive;
  /**
   * Stores SvelteData entries with instantiated Svelte components.
   *
   * @type {import('./internal/state-svelte/types').SvelteData[]}
   */
  #svelteData = [];
  /**
   * Provides a helper class that combines multiple methods for interacting with the mounted components tracked in
   * #svelteData.
   *
   * @type {GetSvelteData}
   */
  #getSvelteData = new GetSvelteData(this.#applicationShellHolder, this.#svelteData);
  /**
   * Contains methods to interact with the Svelte stores.
   *
   * @type {import('./internal/state-reactive/SvelteReactive').SvelteReactiveStores}
   */
  #stores;
  /**
   * @param {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplicationOptions} options - The options for the application.
   *
   * @inheritDoc
   */
  constructor(options = {}) {
    super(options);
    this.#applicationState = new ApplicationState(this);
    this.#position = new TJSPosition(this, {
      ...this.position,
      ...this.options,
      initial: this.options.positionInitial,
      ortho: this.options.positionOrtho,
      validator: this.options.positionValidator
    });
    delete this.position;
    Object.defineProperty(this, "position", {
      get: () => this.#position,
      set: (position) => {
        if (isObject$1(position)) {
          this.#position.set(position);
        }
      }
    });
    this.#reactive = new SvelteReactive(this);
    this.#stores = this.#reactive.initialize();
  }
  /**
   * Specifies the default options that SvelteApplication supports.
   *
   * @returns {import('@typhonjs-fvtt/runtime/svelte/application').SvelteApplicationOptions} options - Application options.
   * @see https://foundryvtt.com/api/interfaces/client.ApplicationOptions.html
   *
   * @internal
   */
  static get defaultOptions() {
    return deepMerge(super.defaultOptions, {
      defaultCloseAnimation: true,
      // If false the default slide close animation is not run.
      draggable: true,
      // If true then application shells are draggable.
      focusAuto: true,
      // When true auto-management of app focus is enabled.
      focusKeep: false,
      // When `focusAuto` and `focusKeep` is true; keeps internal focus.
      focusSource: void 0,
      // Stores any A11yFocusSource data that is applied when app is closed.
      focusTrap: true,
      // When true focus trapping / wrapping is enabled keeping focus inside app.
      headerButtonNoClose: false,
      // If true then the close header button is removed.
      headerButtonNoLabel: false,
      // If true then header button labels are removed for application shells.
      headerIcon: void 0,
      // Sets a header icon given an image URL.
      headerNoTitleMinimized: false,
      // If true then header title is hidden when application is minimized.
      minHeight: MIN_WINDOW_HEIGHT,
      // Assigned to position. Number specifying minimum window height.
      minWidth: MIN_WINDOW_WIDTH,
      // Assigned to position. Number specifying minimum window width.
      positionable: true,
      // If false then `position.set` does not take effect.
      positionInitial: TJSPosition.Initial.browserCentered,
      // A helper for initial position placement.
      positionOrtho: true,
      // When true TJSPosition is optimized for orthographic use.
      positionValidator: TJSPosition.Validators.transformWindow,
      // A function providing the default validator.
      sessionStorage: void 0,
      // An instance of TJSWebStorage (session) to share across SvelteApplications.
      svelte: void 0,
      // A Svelte configuration object.
      transformOrigin: "top left"
      // By default, 'top / left' respects rotation when minimizing.
    });
  }
  /**
   * Returns the content element if an application shell is mounted.
   *
   * @returns {HTMLElement} Content element.
   */
  get elementContent() {
    return this.#elementContent;
  }
  /**
   * Returns the target element or main element if no target defined.
   *
   * @returns {HTMLElement} Target element.
   */
  get elementTarget() {
    return this.#elementTarget;
  }
  /**
   * Returns the reactive accessors & Svelte stores for SvelteApplication.
   *
   * @returns {import('./internal/state-reactive/types').SvelteReactive} The reactive accessors & Svelte stores.
   */
  get reactive() {
    return this.#reactive;
  }
  /**
   * Returns the application state manager.
   *
   * @returns {import('./internal/state-app/types').ApplicationState<SvelteApplication>} The application state manager.
   */
  get state() {
    return this.#applicationState;
  }
  /**
   * Returns the Svelte helper class w/ various methods to access mounted Svelte components.
   *
   * @returns {import('./internal/state-svelte/types').GetSvelteData} GetSvelteData
   */
  get svelte() {
    return this.#getSvelteData;
  }
  /**
   * In this case of when a template is defined in app options `html` references the inner HTML / template. However,
   * to activate classic v1 tabs for a Svelte component the element target is passed as an array simulating JQuery as
   * the element is retrieved immediately and the core listeners use standard DOM queries.
   *
   * @protected
   * @ignore
   * @internal
   */
  _activateCoreListeners(html) {
    super._activateCoreListeners(typeof this.options.template === "string" ? html : [this.popOut ? this.#elementTarget?.firstChild : this.#elementTarget]);
  }
  /**
   * Provide an override to set this application as the active window regardless of z-index. Changes behaviour from
   * Foundry core. This is important / used for instance in dialog key handling for left / right button selection.
   *
   * @param {object} [opts] - Optional parameters.
   *
   * @param {boolean} [opts.force=false] - Force bring to top; will increment z-index by popOut order.
   *
   * @ignore
   * @internal
   */
  bringToTop({ force = false } = {}) {
    if (force || this.popOut) {
      super.bringToTop();
    }
    if (document.activeElement !== document.body && !this.elementTarget.contains(document.activeElement)) {
      if (document.activeElement instanceof HTMLElement) {
        document.activeElement.blur();
      }
      document.body.focus();
    }
    globalThis.ui.activeWindow = this;
  }
  /**
   * Note: This method is fully overridden and duplicated as Svelte components need to be destroyed manually and the
   * best visual result is to destroy them after the default slide up animation occurs, but before the element
   * is removed from the DOM.
   *
   * If you destroy the Svelte components before the slide up animation the Svelte elements are removed immediately
   * from the DOM. The purpose of overriding ensures the slide up animation is always completed before
   * the Svelte components are destroyed and then the element is removed from the DOM.
   *
   * Close the application and un-register references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>}    A Promise which resolves once the application is closed.
   *
   * @ignore
   * @internal
   */
  async close(options = {}) {
    const states = Application.RENDER_STATES;
    if (!options.force && ![states.RENDERED, states.ERROR].includes(this._state)) {
      return;
    }
    this.#stores.unsubscribe();
    this._state = states.CLOSING;
    const el = this.#elementTarget;
    if (!el) {
      return this._state = states.CLOSED;
    }
    const content = el.querySelector(".window-content");
    if (content) {
      content.style.overflow = "hidden";
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = "hidden";
      }
    }
    for (const cls of this.constructor._getInheritanceChain()) {
      Hooks.call(`close${cls.name}`, this, $(el));
    }
    const animate = typeof this.options.defaultCloseAnimation === "boolean" ? this.options.defaultCloseAnimation : true;
    if (animate) {
      el.style.minHeight = "0";
      const { paddingBottom, paddingTop } = globalThis.getComputedStyle(el);
      await el.animate([
        { maxHeight: `${el.clientHeight}px`, paddingTop, paddingBottom },
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: 250, easing: "ease-in", fill: "forwards" }).finished;
    }
    const svelteDestroyPromises = [];
    for (const entry of this.#svelteData) {
      svelteDestroyPromises.push(outroAndDestroy(entry.component));
      const eventbus = entry.config.eventbus;
      if (isObject$1(eventbus) && typeof eventbus.off === "function") {
        eventbus.off();
        entry.config.eventbus = void 0;
      }
    }
    await Promise.all(svelteDestroyPromises);
    TJSAppIndex.delete(this);
    this.#svelteData.length = 0;
    el.remove();
    this.position.state.restore({
      name: "#beforeMinimized",
      properties: ["width", "height"],
      silent: true,
      remove: true
    });
    this.#applicationShellHolder[0] = null;
    this._element = null;
    this.#elementContent = null;
    this.#elementTarget = null;
    delete globalThis.ui.windows[this.appId];
    this._minimized = false;
    this._scrollPositions = null;
    this._state = states.CLOSED;
    this.#onMount = false;
    this.#stores.uiStateUpdate((storeOptions) => deepMerge(storeOptions, { minimized: this._minimized }));
    A11yHelper.applyFocusSource(this.options.focusSource);
    delete this.options.focusSource;
  }
  /**
   * Inject the Svelte components defined in `this.options.svelte`. The Svelte component can attach to the existing
   * pop-out of Application or provide no template and render into a document fragment which is then attached to the
   * DOM.
   *
   * @protected
   * @ignore
   * @internal
   */
  _injectHTML(html) {
    if (this.popOut && html.length === 0 && isIterable(this.options.svelte)) {
      throw new Error(
        "SvelteApplication - _injectHTML - A popout app with no template can only support one Svelte component."
      );
    }
    this.reactive.updateHeaderButtons();
    const elementRootUpdate = () => {
      let cntr = 0;
      return (elementRoot) => {
        if (elementRoot !== null && elementRoot !== void 0 && cntr++ > 0) {
          this.#updateApplicationShell();
          return true;
        }
        return false;
      };
    };
    if (isIterable(this.options.svelte)) {
      for (const svelteConfig of this.options.svelte) {
        const svelteData = loadSvelteConfig({
          app: this,
          template: html[0],
          config: svelteConfig,
          elementRootUpdate
        });
        if (isApplicationShell(svelteData.component)) {
          if (this.svelte.applicationShell !== null) {
            throw new Error(
              `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                    ${JSON.stringify(svelteConfig)}`
            );
          }
          this.#applicationShellHolder[0] = svelteData.component;
          if (isHMRProxy(svelteData.component) && Array.isArray(svelteData.component?.$$?.on_hmr)) {
            svelteData.component.$$.on_hmr.push(() => () => this.#updateApplicationShell());
          }
        }
        this.#svelteData.push(svelteData);
      }
    } else if (isObject$1(this.options.svelte)) {
      const svelteData = loadSvelteConfig({
        app: this,
        template: html[0],
        config: this.options.svelte,
        elementRootUpdate
      });
      if (isApplicationShell(svelteData.component)) {
        if (this.svelte.applicationShell !== null) {
          throw new Error(
            `SvelteApplication - _injectHTML - An application shell is already mounted; offending config:
                 ${JSON.stringify(this.options.svelte)}`
          );
        }
        this.#applicationShellHolder[0] = svelteData.component;
        if (isHMRProxy(svelteData.component) && Array.isArray(svelteData.component?.$$?.on_hmr)) {
          svelteData.component.$$.on_hmr.push(() => () => this.#updateApplicationShell());
        }
      }
      this.#svelteData.push(svelteData);
    }
    const isDocumentFragment = html.length && html[0] instanceof DocumentFragment;
    let injectHTML = true;
    for (const svelteData of this.#svelteData) {
      if (!svelteData.injectHTML) {
        injectHTML = false;
        break;
      }
    }
    if (injectHTML) {
      super._injectHTML(html);
    }
    if (this.svelte.applicationShell !== null) {
      this._element = $(this.svelte.applicationShell.elementRoot);
      this.#elementContent = hasGetter(this.svelte.applicationShell, "elementContent") ? this.svelte.applicationShell.elementContent : null;
      this.#elementTarget = hasGetter(this.svelte.applicationShell, "elementTarget") ? this.svelte.applicationShell.elementTarget : null;
    } else if (isDocumentFragment) {
      for (const svelteData of this.#svelteData) {
        if (svelteData.element instanceof HTMLElement) {
          this._element = $(svelteData.element);
          break;
        }
      }
    }
    if (this.#elementTarget === null) {
      this.#elementTarget = typeof this.options.selectorTarget === "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0];
    }
    if (this.#elementTarget === null || this.#elementTarget === void 0) {
      throw new Error(`SvelteApplication - _injectHTML: Target element '${this.options.selectorTarget}' not found.`);
    }
    if (typeof this.options.positionable === "boolean" && this.options.positionable) {
      this.#elementTarget.style.zIndex = typeof this.options.zIndex === "number" ? this.options.zIndex : this.#initialZIndex ?? 95;
    }
    this.#stores.subscribe();
  }
  /**
   * Provides a mechanism to update the UI options store for maximized.
   *
   * Note: the sanity check is duplicated from {@link Application.maximize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters.
   *
   * @param {boolean}  [opts.animate=true] - When true perform default maximizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async maximize({ animate = true, duration = 0.1 } = {}) {
    if (!this.popOut || [false, null].includes(this._minimized)) {
      return;
    }
    this._minimized = null;
    const durationMS = duration * 1e3;
    const element2 = this.elementTarget;
    const header = element2.querySelector(".window-header");
    const content = element2.querySelector(".window-content");
    const positionBefore = this.position.state.get({ name: "#beforeMinimized" });
    if (animate) {
      await this.position.state.restore({
        name: "#beforeMinimized",
        async: true,
        animateTo: true,
        properties: ["width"],
        duration: 0.1
      });
    }
    element2.classList.remove("minimized");
    for (let cntr = header.children.length; --cntr >= 0; ) {
      header.children[cntr].style.display = null;
    }
    content.style.display = null;
    let constraints;
    if (animate) {
      ({ constraints } = this.position.state.restore({
        name: "#beforeMinimized",
        animateTo: true,
        properties: ["height"],
        remove: true,
        duration
      }));
    } else {
      ({ constraints } = this.position.state.remove({ name: "#beforeMinimized" }));
    }
    await content.animate([
      { maxHeight: 0, paddingTop: 0, paddingBottom: 0, offset: 0 },
      { ...constraints, offset: 1 },
      { maxHeight: "100%", offset: 1 }
    ], { duration: durationMS, fill: "forwards" }).finished;
    this.position.set({
      minHeight: positionBefore.minHeight ?? this.options?.minHeight ?? MIN_WINDOW_HEIGHT,
      minWidth: positionBefore.minWidth ?? this.options?.minWidth ?? MIN_WINDOW_WIDTH
    });
    element2.style.minWidth = null;
    element2.style.minHeight = null;
    this._minimized = false;
    setTimeout(() => {
      content.style.overflow = null;
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = null;
      }
    }, 50);
    this.#stores.uiStateUpdate((options) => deepMerge(options, { minimized: false }));
  }
  /**
   * Provides a mechanism to update the UI options store for minimized.
   *
   * Note: the sanity check is duplicated from {@link Application.minimize} the store is updated _before_
   * performing the rest of animations. This allows application shells to remove / show any resize handlers
   * correctly. Extra constraint data is stored in a saved position state in {@link SvelteApplication.minimize}
   * to animate the content area.
   *
   * @param {object}   [opts] - Optional parameters
   *
   * @param {boolean}  [opts.animate=true] - When true perform default minimizing animation.
   *
   * @param {number}   [opts.duration=0.1] - Controls content area animation duration in seconds.
   */
  async minimize({ animate = true, duration = 0.1 } = {}) {
    if (!this.rendered || !this.popOut || [true, null].includes(this._minimized)) {
      return;
    }
    this.#stores.uiStateUpdate((options) => deepMerge(options, { minimized: true }));
    this._minimized = null;
    const durationMS = duration * 1e3;
    const element2 = this.elementTarget;
    const header = element2.querySelector(".window-header");
    const content = element2.querySelector(".window-content");
    const beforeMinWidth = this.position.minWidth;
    const beforeMinHeight = this.position.minHeight;
    this.position.set({ minWidth: 100, minHeight: 30 });
    element2.style.minWidth = "100px";
    element2.style.minHeight = "30px";
    if (content) {
      content.style.overflow = "hidden";
      for (let cntr = content.children.length; --cntr >= 0; ) {
        content.children[cntr].style.overflow = "hidden";
      }
    }
    const { paddingBottom, paddingTop } = globalThis.getComputedStyle(content);
    const constraints = {
      maxHeight: `${content.clientHeight}px`,
      paddingTop,
      paddingBottom
    };
    if (animate) {
      const animation = content.animate([
        constraints,
        { maxHeight: 0, paddingTop: 0, paddingBottom: 0 }
      ], { duration: durationMS, fill: "forwards" });
      animation.finished.then(() => content.style.display = "none");
    } else {
      setTimeout(() => content.style.display = "none", durationMS);
    }
    const saved = this.position.state.save({ name: "#beforeMinimized", constraints });
    saved.minWidth = beforeMinWidth;
    saved.minHeight = beforeMinHeight;
    const headerOffsetHeight = header.offsetHeight;
    this.position.minHeight = headerOffsetHeight;
    if (animate) {
      await this.position.animate.to({ height: headerOffsetHeight }, { duration }).finished;
    }
    for (let cntr = header.children.length; --cntr >= 0; ) {
      const className = header.children[cntr].className;
      if (className.includes("window-title") || className.includes("close")) {
        continue;
      }
      if (className.includes("keep-minimized")) {
        header.children[cntr].style.display = "block";
        continue;
      }
      header.children[cntr].style.display = "none";
    }
    if (animate) {
      await this.position.animate.to({ width: MIN_WINDOW_WIDTH }, { duration: 0.1 }).finished;
    }
    element2.classList.add("minimized");
    this._minimized = true;
  }
  /**
   * Provides a callback after all Svelte components are initialized.
   *
   * @param {import('./internal/state-svelte/types').MountedAppShell} [mountedAppShell] - The mounted app shell
   *        elements.
   */
  onSvelteMount(mountedAppShell) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Provides a callback after the main application shell is remounted. This may occur during HMR / hot module
   * replacement or directly invoked from the `elementRootUpdate` callback passed to the application shell component
   * context.
   *
   * @param {import('./internal/state-svelte/types').MountedAppShell} [mountedAppShell] - The mounted app shell
   *        elements.
   */
  onSvelteRemount(mountedAppShell) {
  }
  // eslint-disable-line no-unused-vars
  /**
   * Override replacing HTML as Svelte components control the rendering process. Only potentially change the outer
   * application frame / title for pop-out applications.
   *
   * @protected
   * @ignore
   * @internal
   */
  _replaceHTML(element2, html) {
    if (!element2.length) {
      return;
    }
    this.reactive.updateHeaderButtons();
  }
  /**
   * Provides an override verifying that a new Application being rendered for the first time doesn't have a
   * corresponding DOM element already loaded. This is a check that only occurs when `this._state` is
   * `Application.RENDER_STATES.NONE`. It is useful in particular when SvelteApplication has a static ID
   * explicitly set in `this.options.id` and long intro / outro transitions are assigned. If a new application
   * sharing this static ID attempts to open / render for the first time while an existing DOM element sharing
   * this static ID exists then the initial render is cancelled below rather than crashing later in the render
   * cycle {@link TJSPosition.set}.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _render(force = false, options = {}) {
    if (isObject$1(options?.focusSource)) {
      this.options.focusSource = options.focusSource;
    }
    if (this._state === Application.RENDER_STATES.NONE && document.querySelector(`#${this.id}`) instanceof HTMLElement) {
      console.warn(`SvelteApplication - _render: A DOM element already exists for CSS ID '${this.id}'. Cancelling initial render for new application with appId '${this.appId}'.`);
      return;
    }
    await super._render(force, options);
    if ([Application.RENDER_STATES.CLOSING, Application.RENDER_STATES.RENDERING].includes(this._state)) {
      return;
    }
    if (!force && this._state <= Application.RENDER_STATES.NONE) {
      return;
    }
    if (!this._minimized) {
      this.#position.set(options);
    }
    if (!this.#onMount) {
      TJSAppIndex.add(this);
      this.onSvelteMount({ element: this._element[0], elementContent: this.#elementContent, elementTarget: this.#elementTarget });
      this.#onMount = true;
    }
  }
  /**
   * Render the inner application content. Only render a template if one is defined otherwise provide an empty
   * JQuery element per the core Foundry API.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _renderInner(data) {
    const html = typeof this.template === "string" ? await renderTemplate(this.template, data) : document.createDocumentFragment();
    return $(html);
  }
  /**
   * Stores the initial z-index set in `_renderOuter` which is used in `_injectHTML` to set the target element
   * z-index after the Svelte component is mounted.
   *
   * @protected
   * @ignore
   * @internal
   */
  async _renderOuter() {
    const html = await super._renderOuter();
    this.#initialZIndex = html[0].style.zIndex;
    return html;
  }
  /**
   * All calculation and updates of position are implemented in {@link TJSPosition.set}. This allows position to be fully
   * reactive and in control of updating inline styles for the application.
   *
   * This method remains for backward compatibility with Foundry. If you have a custom override quite likely you need
   * to update to using the {@link TJSPosition.validators} functionality.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/store/position').TJSPositionDataExtended}   [position] - TJSPosition data.
   *
   * @returns {TJSPosition} The updated position object for the application containing the new values.
   * @ignore
   */
  setPosition(position) {
    return this.position.set(position);
  }
  /**
   * This method is invoked by the `elementRootUpdate` callback that is added to the external context passed to
   * Svelte components. When invoked it updates the local element roots tracked by SvelteApplication.
   *
   * This method may also be invoked by HMR / hot module replacement via `svelte-hmr`.
   */
  #updateApplicationShell() {
    const applicationShell = this.svelte.applicationShell;
    if (applicationShell !== null) {
      this._element = $(applicationShell.elementRoot);
      this.#elementContent = hasGetter(applicationShell, "elementContent") ? applicationShell.elementContent : null;
      this.#elementTarget = hasGetter(applicationShell, "elementTarget") ? applicationShell.elementTarget : null;
      if (this.#elementTarget === null) {
        this.#elementTarget = typeof this.options.selectorTarget === "string" ? this._element[0].querySelector(this.options.selectorTarget) : this._element[0];
      }
      if (typeof this.options.positionable === "boolean" && this.options.positionable) {
        this.#elementTarget.style.zIndex = typeof this.options.zIndex === "number" ? this.options.zIndex : this.#initialZIndex ?? 95;
        super.bringToTop();
        this.position.set(this.position.get());
      }
      super._activateCoreListeners([this.popOut ? this.#elementTarget?.firstChild : this.#elementTarget]);
      this.onSvelteRemount({ element: this._element[0], elementContent: this.#elementContent, elementTarget: this.#elementTarget });
    }
  }
}
const cssVariables = new TJSStyleManager({ docKey: "#__trl-root-styles", version: 1 });
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);
class Timing {
  /**
   * Wraps a callback in a debounced timeout.
   *
   * Delay execution of the callback function until the function has not been called for the given delay in milliseconds.
   *
   * @param {Function} callback - A function to execute once the debounced threshold has been passed.
   *
   * @param {number}   delay - An amount of time in milliseconds to delay.
   *
   * @returns {Function} A wrapped function that can be called to debounce execution.
   */
  static debounce(callback, delay) {
    let timeoutId;
    return function(...args) {
      globalThis.clearTimeout(timeoutId);
      timeoutId = globalThis.setTimeout(() => {
        callback.apply(this, args);
      }, delay);
    };
  }
  /**
   * @param {object}   opts - Optional parameters.
   *
   * @param {Function} opts.single - Single click callback.
   *
   * @param {Function} opts.double - Double click callback.
   *
   * @param {number}   [opts.delay=400] - Double click delay.
   *
   * @returns {(event: Event) => void} The gated double-click handler.
   */
  static doubleClick({ single, double, delay = 400 }) {
    let clicks = 0;
    let timeoutId;
    return (event) => {
      clicks++;
      if (clicks === 1) {
        timeoutId = globalThis.setTimeout(() => {
          if (typeof single === "function") {
            single(event);
          }
          clicks = 0;
        }, delay);
      } else {
        globalThis.clearTimeout(timeoutId);
        if (typeof double === "function") {
          double(event);
        }
        clicks = 0;
      }
    };
  }
}
function resizeObserver(node, target) {
  ResizeObserverManager.add(node, target);
  return {
    /**
     * @param {ResizeObserverTarget} newTarget - An object or function to update with observed width & height changes.
     */
    update: (newTarget) => {
      ResizeObserverManager.remove(node, target);
      target = newTarget;
      ResizeObserverManager.add(node, target);
    },
    destroy: () => {
      ResizeObserverManager.remove(node, target);
    }
  };
}
resizeObserver.updateCache = function(el) {
  if (!(el instanceof HTMLElement)) {
    throw new TypeError(`resizeObserverUpdate error: 'el' is not an HTMLElement.`);
  }
  const subscribers = s_MAP.get(el);
  if (Array.isArray(subscribers)) {
    const computed = globalThis.getComputedStyle(el);
    const borderBottom = StyleParse.pixels(el.style.borderBottom) ?? StyleParse.pixels(computed.borderBottom) ?? 0;
    const borderLeft = StyleParse.pixels(el.style.borderLeft) ?? StyleParse.pixels(computed.borderLeft) ?? 0;
    const borderRight = StyleParse.pixels(el.style.borderRight) ?? StyleParse.pixels(computed.borderRight) ?? 0;
    const borderTop = StyleParse.pixels(el.style.borderTop) ?? StyleParse.pixels(computed.borderTop) ?? 0;
    const paddingBottom = StyleParse.pixels(el.style.paddingBottom) ?? StyleParse.pixels(computed.paddingBottom) ?? 0;
    const paddingLeft = StyleParse.pixels(el.style.paddingLeft) ?? StyleParse.pixels(computed.paddingLeft) ?? 0;
    const paddingRight = StyleParse.pixels(el.style.paddingRight) ?? StyleParse.pixels(computed.paddingRight) ?? 0;
    const paddingTop = StyleParse.pixels(el.style.paddingTop) ?? StyleParse.pixels(computed.paddingTop) ?? 0;
    const additionalWidth = borderLeft + borderRight + paddingLeft + paddingRight;
    const additionalHeight = borderTop + borderBottom + paddingTop + paddingBottom;
    for (const subscriber of subscribers) {
      subscriber.styles.additionalWidth = additionalWidth;
      subscriber.styles.additionalHeight = additionalHeight;
      s_UPDATE_SUBSCRIBER(subscriber, subscriber.contentWidth, subscriber.contentHeight);
    }
  }
};
const s_MAP = /* @__PURE__ */ new Map();
class ResizeObserverManager {
  /**
   * Add an HTMLElement and ResizeObserverTarget instance for monitoring. Create cached style attributes for the
   * given element include border & padding dimensions for offset width / height calculations.
   *
   * @param {HTMLElement}    el - The element to observe.
   *
   * @param {ResizeObserverTarget} target - A target that contains one of several mechanisms for updating resize data.
   */
  static add(el, target) {
    const updateType = s_GET_UPDATE_TYPE(target);
    if (updateType === 0) {
      throw new Error(`'target' does not match supported ResizeObserverManager update mechanisms.`);
    }
    const computed = globalThis.getComputedStyle(el);
    const borderBottom = StyleParse.pixels(el.style.borderBottom) ?? StyleParse.pixels(computed.borderBottom) ?? 0;
    const borderLeft = StyleParse.pixels(el.style.borderLeft) ?? StyleParse.pixels(computed.borderLeft) ?? 0;
    const borderRight = StyleParse.pixels(el.style.borderRight) ?? StyleParse.pixels(computed.borderRight) ?? 0;
    const borderTop = StyleParse.pixels(el.style.borderTop) ?? StyleParse.pixels(computed.borderTop) ?? 0;
    const paddingBottom = StyleParse.pixels(el.style.paddingBottom) ?? StyleParse.pixels(computed.paddingBottom) ?? 0;
    const paddingLeft = StyleParse.pixels(el.style.paddingLeft) ?? StyleParse.pixels(computed.paddingLeft) ?? 0;
    const paddingRight = StyleParse.pixels(el.style.paddingRight) ?? StyleParse.pixels(computed.paddingRight) ?? 0;
    const paddingTop = StyleParse.pixels(el.style.paddingTop) ?? StyleParse.pixels(computed.paddingTop) ?? 0;
    const data = {
      updateType,
      target,
      // Stores most recent contentRect.width and contentRect.height values from ResizeObserver.
      contentWidth: 0,
      contentHeight: 0,
      // Convenience data for total border & padding for offset width & height calculations.
      styles: {
        additionalWidth: borderLeft + borderRight + paddingLeft + paddingRight,
        additionalHeight: borderTop + borderBottom + paddingTop + paddingBottom
      }
    };
    if (s_MAP.has(el)) {
      const subscribers = s_MAP.get(el);
      subscribers.push(data);
    } else {
      s_MAP.set(el, [data]);
    }
    s_RESIZE_OBSERVER.observe(el);
  }
  /**
   * Removes all targets from monitoring when just an element is provided otherwise removes a specific target
   * from the monitoring map. If no more targets remain then the element is removed from monitoring.
   *
   * @param {HTMLElement}          el - Element to remove from monitoring.
   *
   * @param {ResizeObserverTarget} [target] - A specific target to remove from monitoring.
   */
  static remove(el, target = void 0) {
    const subscribers = s_MAP.get(el);
    if (Array.isArray(subscribers)) {
      const index2 = subscribers.findIndex((entry) => entry.target === target);
      if (index2 >= 0) {
        s_UPDATE_SUBSCRIBER(subscribers[index2], void 0, void 0);
        subscribers.splice(index2, 1);
      }
      if (subscribers.length === 0) {
        s_MAP.delete(el);
        s_RESIZE_OBSERVER.unobserve(el);
      }
    }
  }
}
const s_UPDATE_TYPES = {
  none: 0,
  attribute: 1,
  function: 2,
  resizeObserved: 3,
  setContentBounds: 4,
  setDimension: 5,
  storeObject: 6,
  storesObject: 7
};
const s_RESIZE_OBSERVER = new ResizeObserver((entries) => {
  for (const entry of entries) {
    const subscribers = s_MAP.get(entry?.target);
    if (Array.isArray(subscribers)) {
      const contentWidth = entry.contentRect.width;
      const contentHeight = entry.contentRect.height;
      for (const subscriber of subscribers) {
        s_UPDATE_SUBSCRIBER(subscriber, contentWidth, contentHeight);
      }
    }
  }
});
function s_GET_UPDATE_TYPE(target) {
  if (target?.resizeObserved instanceof Function) {
    return s_UPDATE_TYPES.resizeObserved;
  }
  if (target?.setDimension instanceof Function) {
    return s_UPDATE_TYPES.setDimension;
  }
  if (target?.setContentBounds instanceof Function) {
    return s_UPDATE_TYPES.setContentBounds;
  }
  const targetType = typeof target;
  if (targetType !== null && (targetType === "object" || targetType === "function")) {
    if (isUpdatableStore(target.resizeObserved)) {
      return s_UPDATE_TYPES.storeObject;
    }
    const stores = target?.stores;
    if (isObject$1(stores) || typeof stores === "function") {
      if (isUpdatableStore(stores.resizeObserved)) {
        return s_UPDATE_TYPES.storesObject;
      }
    }
  }
  if (targetType !== null && targetType === "object") {
    return s_UPDATE_TYPES.attribute;
  }
  if (targetType === "function") {
    return s_UPDATE_TYPES.function;
  }
  return s_UPDATE_TYPES.none;
}
function s_UPDATE_SUBSCRIBER(subscriber, contentWidth, contentHeight) {
  const styles = subscriber.styles;
  subscriber.contentWidth = contentWidth;
  subscriber.contentHeight = contentHeight;
  const offsetWidth = Number.isFinite(contentWidth) ? contentWidth + styles.additionalWidth : void 0;
  const offsetHeight = Number.isFinite(contentHeight) ? contentHeight + styles.additionalHeight : void 0;
  const target = subscriber.target;
  switch (subscriber.updateType) {
    case s_UPDATE_TYPES.attribute:
      target.contentWidth = contentWidth;
      target.contentHeight = contentHeight;
      target.offsetWidth = offsetWidth;
      target.offsetHeight = offsetHeight;
      break;
    case s_UPDATE_TYPES.function:
      target?.(offsetWidth, offsetHeight, contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.resizeObserved:
      target.resizeObserved?.(offsetWidth, offsetHeight, contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.setContentBounds:
      target.setContentBounds?.(contentWidth, contentHeight);
      break;
    case s_UPDATE_TYPES.setDimension:
      target.setDimension?.(offsetWidth, offsetHeight);
      break;
    case s_UPDATE_TYPES.storeObject:
      target.resizeObserved.update((object) => {
        object.contentHeight = contentHeight;
        object.contentWidth = contentWidth;
        object.offsetHeight = offsetHeight;
        object.offsetWidth = offsetWidth;
        return object;
      });
      break;
    case s_UPDATE_TYPES.storesObject:
      target.stores.resizeObserved.update((object) => {
        object.contentHeight = contentHeight;
        object.contentWidth = contentWidth;
        object.offsetHeight = offsetHeight;
        object.offsetWidth = offsetWidth;
        return object;
      });
      break;
  }
}
function applyStyles(node, properties2) {
  function setProperties() {
    if (!isObject$1(properties2)) {
      return;
    }
    for (const prop of Object.keys(properties2)) {
      node.style.setProperty(`${prop}`, properties2[prop]);
    }
  }
  setProperties();
  return {
    /**
     * @param {Record<string, string>}  newProperties - Key / value object of properties to set.
     */
    update: (newProperties) => {
      properties2 = newProperties;
      setProperties();
    }
  };
}
function fade(node, { delay = 0, duration = 400, easing = identity$1 } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}
function slide(node, { delay = 0, duration = 400, easing = cubicOut, axis = "y" } = {}) {
  const style = getComputedStyle(node);
  const opacity = +style.opacity;
  const primary_property = axis === "y" ? "height" : "width";
  const primary_property_value = parseFloat(style[primary_property]);
  const secondary_properties = axis === "y" ? ["top", "bottom"] : ["left", "right"];
  const capitalized_secondary_properties = secondary_properties.map(
    (e2) => `${e2[0].toUpperCase()}${e2.slice(1)}`
  );
  const padding_start_value = parseFloat(style[`padding${capitalized_secondary_properties[0]}`]);
  const padding_end_value = parseFloat(style[`padding${capitalized_secondary_properties[1]}`]);
  const margin_start_value = parseFloat(style[`margin${capitalized_secondary_properties[0]}`]);
  const margin_end_value = parseFloat(style[`margin${capitalized_secondary_properties[1]}`]);
  const border_width_start_value = parseFloat(
    style[`border${capitalized_secondary_properties[0]}Width`]
  );
  const border_width_end_value = parseFloat(
    style[`border${capitalized_secondary_properties[1]}Width`]
  );
  return {
    delay,
    duration,
    easing,
    css: (t) => `overflow: hidden;opacity: ${Math.min(t * 20, 1) * opacity};${primary_property}: ${t * primary_property_value}px;padding-${secondary_properties[0]}: ${t * padding_start_value}px;padding-${secondary_properties[1]}: ${t * padding_end_value}px;margin-${secondary_properties[0]}: ${t * margin_start_value}px;margin-${secondary_properties[1]}: ${t * margin_end_value}px;border-${secondary_properties[0]}-width: ${t * border_width_start_value}px;border-${secondary_properties[1]}-width: ${t * border_width_end_value}px;`
  };
}
class TJSDefaultTransition {
  static #options = {};
  static #default = () => void 0;
  /**
   * @returns {() => undefined} Default empty transition.
   */
  static get default() {
    return this.#default;
  }
  /**
   * @returns {{}} Default empty options.
   */
  static get options() {
    return this.#options;
  }
}
const TJSGlassPane_svelte_svelte_type_style_lang = "";
function create_else_block$8(ctx) {
  let div2;
  let applyStyles_action;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  return {
    c() {
      div2 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div2, "class", "tjs-glass-pane-background svelte-mobile-companion81nkluj30u9vsd-hqedxf");
      set_style(
        div2,
        "background",
        /*background*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      ctx[23](div2);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(applyStyles_action = applyStyles.call(
          null,
          div2,
          /*styles*/
          ctx[7]
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[19],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      128)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx[7]
        );
      if (dirty & /*background*/
      32) {
        set_style(
          div2,
          "background",
          /*background*/
          ctx[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(
          div2,
          /*inTransition*/
          ctx[1],
          /*inTransitionOptions*/
          ctx[3]
        );
        div_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(
        div2,
        /*outTransition*/
        ctx[2],
        /*outTransitionOptions*/
        ctx[4]
      );
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (default_slot)
        default_slot.d(detaching);
      ctx[23](null);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$U(ctx) {
  let div0;
  let applyStyles_action;
  let div0_intro;
  let div0_outro;
  let t;
  let div1;
  let current;
  let mounted;
  let dispose;
  const default_slot_template = (
    /*#slots*/
    ctx[20].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[19],
    null
  );
  return {
    c() {
      div0 = element("div");
      t = space();
      div1 = element("div");
      if (default_slot)
        default_slot.c();
      attr(div0, "class", "tjs-glass-pane-background svelte-mobile-companion81nkluj30u9vsd-hqedxf");
      set_style(
        div0,
        "background",
        /*background*/
        ctx[5]
      );
      attr(div1, "class", "tjs-glass-pane-container svelte-mobile-companion81nkluj30u9vsd-hqedxf");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      ctx[21](div0);
      insert(target, t, anchor);
      insert(target, div1, anchor);
      if (default_slot) {
        default_slot.m(div1, null);
      }
      ctx[22](div1);
      current = true;
      if (!mounted) {
        dispose = action_destroyer(applyStyles_action = applyStyles.call(
          null,
          div0,
          /*styles*/
          ctx[7]
        ));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      128)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx[7]
        );
      if (dirty & /*background*/
      32) {
        set_style(
          div0,
          "background",
          /*background*/
          ctx[5]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        524288)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[19],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[19]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[19],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      add_render_callback(() => {
        if (!current)
          return;
        if (div0_outro)
          div0_outro.end(1);
        div0_intro = create_in_transition(
          div0,
          /*inTransition*/
          ctx[1],
          /*inTransitionOptions*/
          ctx[3]
        );
        div0_intro.start();
      });
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      if (div0_intro)
        div0_intro.invalidate();
      div0_outro = create_out_transition(
        div0,
        /*outTransition*/
        ctx[2],
        /*outTransitionOptions*/
        ctx[4]
      );
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t);
        detach(div1);
      }
      ctx[21](null);
      if (detaching && div0_outro)
        div0_outro.end();
      if (default_slot)
        default_slot.d(detaching);
      ctx[22](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$1b(ctx) {
  let div2;
  let current_block_type_index;
  let if_block;
  let current;
  let mounted;
  let dispose;
  const if_block_creators = [create_if_block$U, create_else_block$8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*slotSeparate*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div2 = element("div");
      if_block.c();
      attr(
        div2,
        "id",
        /*id*/
        ctx[6]
      );
      attr(div2, "class", "tjs-glass-pane svelte-mobile-companion81nkluj30u9vsd-hqedxf");
      set_style(
        div2,
        "z-index",
        /*zIndex*/
        ctx[8]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if_blocks[current_block_type_index].m(div2, null);
      ctx[24](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "contextmenu",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "dblclick",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "keydown",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "keyup",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "mousedown",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "mousemove",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "mouseup",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "pointerdown",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "pointermove",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "pointerup",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "touchend",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "touchmove",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "touchstart",
            /*swallow*/
            ctx[12],
            true
          ),
          listen(
            window,
            "wheel",
            /*swallow*/
            ctx[12],
            true
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div2, null);
      }
      if (!current || dirty & /*id*/
      64) {
        attr(
          div2,
          "id",
          /*id*/
          ctx2[6]
        );
      }
      if (dirty & /*zIndex*/
      256) {
        set_style(
          div2,
          "z-index",
          /*zIndex*/
          ctx2[8]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_blocks[current_block_type_index].d();
      ctx[24](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$1b($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { background = "#50505080" } = $$props;
  let { captureInput = true } = $$props;
  let { closeOnInput = void 0 } = $$props;
  let { id = void 0 } = $$props;
  let { slotSeparate = void 0 } = $$props;
  let { styles = void 0 } = $$props;
  let { zIndex = Number.MAX_SAFE_INTEGER } = $$props;
  const dispatch2 = createEventDispatcher();
  let backgroundEl, containerEl, glassPaneEl;
  let { transition = void 0 } = $$props;
  let { inTransition = void 0 } = $$props;
  let { outTransition = void 0 } = $$props;
  let { transitionOptions = void 0 } = $$props;
  let { inTransitionOptions = TJSDefaultTransition.options } = $$props;
  let { outTransitionOptions = TJSDefaultTransition.options } = $$props;
  let oldTransition = void 0;
  let oldTransitionOptions = void 0;
  function swallow(event) {
    const targetEl = event.target;
    if (targetEl !== glassPaneEl && targetEl !== backgroundEl && targetEl !== containerEl && glassPaneEl.contains(targetEl)) {
      return;
    }
    if (captureInput) {
      event.preventDefault();
      event.stopImmediatePropagation();
    }
    if (event?.type === "pointerdown" && closeOnInput) {
      dispatch2("close:glasspane");
    }
  }
  function div0_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      backgroundEl = $$value;
      $$invalidate(9, backgroundEl);
    });
  }
  function div1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      containerEl = $$value;
      $$invalidate(10, containerEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      backgroundEl = $$value;
      $$invalidate(9, backgroundEl);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      glassPaneEl = $$value;
      $$invalidate(11, glassPaneEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("background" in $$props2)
      $$invalidate(5, background = $$props2.background);
    if ("captureInput" in $$props2)
      $$invalidate(13, captureInput = $$props2.captureInput);
    if ("closeOnInput" in $$props2)
      $$invalidate(14, closeOnInput = $$props2.closeOnInput);
    if ("id" in $$props2)
      $$invalidate(6, id = $$props2.id);
    if ("slotSeparate" in $$props2)
      $$invalidate(0, slotSeparate = $$props2.slotSeparate);
    if ("styles" in $$props2)
      $$invalidate(7, styles = $$props2.styles);
    if ("zIndex" in $$props2)
      $$invalidate(8, zIndex = $$props2.zIndex);
    if ("transition" in $$props2)
      $$invalidate(15, transition = $$props2.transition);
    if ("inTransition" in $$props2)
      $$invalidate(1, inTransition = $$props2.inTransition);
    if ("outTransition" in $$props2)
      $$invalidate(2, outTransition = $$props2.outTransition);
    if ("transitionOptions" in $$props2)
      $$invalidate(16, transitionOptions = $$props2.transitionOptions);
    if ("inTransitionOptions" in $$props2)
      $$invalidate(3, inTransitionOptions = $$props2.inTransitionOptions);
    if ("outTransitionOptions" in $$props2)
      $$invalidate(4, outTransitionOptions = $$props2.outTransitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(19, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*slotSeparate*/
    1) {
      $$invalidate(0, slotSeparate = typeof slotSeparate === "boolean" ? slotSeparate : false);
    }
    if ($$self.$$.dirty & /*oldTransition, transition*/
    163840) {
      if (oldTransition !== transition) {
        const newTransition = typeof transition === "function" ? transition : void 0;
        $$invalidate(1, inTransition = newTransition);
        $$invalidate(2, outTransition = newTransition);
        $$invalidate(17, oldTransition = newTransition);
      }
    }
    if ($$self.$$.dirty & /*oldTransitionOptions, transitionOptions*/
    327680) {
      if (oldTransitionOptions !== transitionOptions) {
        const newOptions = transitionOptions !== TJSDefaultTransition.options && isObject$1(transitionOptions) ? transitionOptions : TJSDefaultTransition.options;
        $$invalidate(3, inTransitionOptions = newOptions);
        $$invalidate(4, outTransitionOptions = newOptions);
        $$invalidate(18, oldTransitionOptions = newOptions);
      }
    }
    if ($$self.$$.dirty & /*inTransition*/
    2) {
      if (typeof inTransition !== "function") {
        $$invalidate(1, inTransition = void 0);
      }
    }
    if ($$self.$$.dirty & /*outTransition*/
    4) {
      if (typeof outTransition !== "function") {
        $$invalidate(2, outTransition = void 0);
      }
    }
    if ($$self.$$.dirty & /*inTransitionOptions*/
    8) {
      if (!isObject$1(inTransitionOptions)) {
        $$invalidate(3, inTransitionOptions = TJSDefaultTransition.options);
      }
    }
    if ($$self.$$.dirty & /*outTransitionOptions*/
    16) {
      if (!isObject$1(outTransitionOptions)) {
        $$invalidate(4, outTransitionOptions = TJSDefaultTransition.options);
      }
    }
  };
  return [
    slotSeparate,
    inTransition,
    outTransition,
    inTransitionOptions,
    outTransitionOptions,
    background,
    id,
    styles,
    zIndex,
    backgroundEl,
    containerEl,
    glassPaneEl,
    swallow,
    captureInput,
    closeOnInput,
    transition,
    transitionOptions,
    oldTransition,
    oldTransitionOptions,
    $$scope,
    slots,
    div0_binding,
    div1_binding,
    div_binding,
    div_binding_1
  ];
}
class TJSGlassPane extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$1b, create_fragment$1b, safe_not_equal, {
      background: 5,
      captureInput: 13,
      closeOnInput: 14,
      id: 6,
      slotSeparate: 0,
      styles: 7,
      zIndex: 8,
      transition: 15,
      inTransition: 1,
      outTransition: 2,
      transitionOptions: 16,
      inTransitionOptions: 3,
      outTransitionOptions: 4
    });
  }
}
const TJSGlassPane$1 = TJSGlassPane;
class AppShellContextInternal {
  /** @type {InternalAppStores} */
  #stores;
  constructor() {
    this.#stores = {
      elementContent: writable(void 0),
      elementRoot: writable(void 0)
    };
    Object.freeze(this.#stores);
    Object.seal(this);
  }
  /**
   * @returns {InternalAppStores} The internal context stores for elementContent / elementRoot
   */
  get stores() {
    return this.#stores;
  }
}
function localize(stringId, data) {
  const result = !isObject$1(data) ? globalThis.game.i18n.localize(stringId) : globalThis.game.i18n.format(stringId, data);
  return result !== void 0 ? result : "";
}
const TJSHeaderButton_svelte_svelte_type_style_lang = "";
function create_if_block$T(ctx) {
  let span;
  let t;
  return {
    c() {
      span = element("span");
      t = text(
        /*label*/
        ctx[3]
      );
      attr(span, "class", "svelte-mobile-companion81nkluj30u9vsd-166l8wd");
      toggle_class(
        span,
        "has-icon",
        /*icon*/
        ctx[4] !== void 0
      );
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*label*/
      8)
        set_data(
          t,
          /*label*/
          ctx2[3]
        );
      if (dirty & /*icon*/
      16) {
        toggle_class(
          span,
          "has-icon",
          /*icon*/
          ctx2[4] !== void 0
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$1a(ctx) {
  let a;
  let html_tag;
  let html_anchor;
  let a_class_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  let if_block = (
    /*label*/
    ctx[3] && create_if_block$T(ctx)
  );
  return {
    c() {
      a = element("a");
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      if (if_block)
        if_block.c();
      html_tag.a = html_anchor;
      attr(a, "class", a_class_value = "header-button " + /*button*/
      ctx[0].class + " svelte-mobile-companion81nkluj30u9vsd-166l8wd");
      attr(
        a,
        "aria-label",
        /*label*/
        ctx[3]
      );
      attr(a, "tabindex", "0");
      attr(a, "role", "button");
      toggle_class(
        a,
        "keep-minimized",
        /*keepMinimized*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, a, anchor);
      html_tag.m(
        /*icon*/
        ctx[4],
        a
      );
      append(a, html_anchor);
      if (if_block)
        if_block.m(a, null);
      if (!mounted) {
        dispose = [
          listen(a, "click", stop_propagation(prevent_default(
            /*onClick*/
            ctx[5]
          ))),
          listen(a, "contextmenu", stop_propagation(prevent_default(
            /*onContextMenu*/
            ctx[6]
          ))),
          listen(
            a,
            "keydown",
            /*onKeydown*/
            ctx[7]
          ),
          listen(
            a,
            "keyup",
            /*onKeyup*/
            ctx[8]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            a,
            /*styles*/
            ctx[1]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*icon*/
      16)
        html_tag.p(
          /*icon*/
          ctx2[4]
        );
      if (
        /*label*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$T(ctx2);
          if_block.c();
          if_block.m(a, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*button*/
      1 && a_class_value !== (a_class_value = "header-button " + /*button*/
      ctx2[0].class + " svelte-mobile-companion81nkluj30u9vsd-166l8wd")) {
        attr(a, "class", a_class_value);
      }
      if (dirty & /*label*/
      8) {
        attr(
          a,
          "aria-label",
          /*label*/
          ctx2[3]
        );
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*styles*/
      2)
        applyStyles_action.update.call(
          null,
          /*styles*/
          ctx2[1]
        );
      if (dirty & /*button, keepMinimized*/
      5) {
        toggle_class(
          a,
          "keep-minimized",
          /*keepMinimized*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(a);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
const s_REGEX_HTML$1 = /^\s*<.*>$/;
function instance$1a($$self, $$props, $$invalidate) {
  let title;
  let icon;
  let label;
  let keepMinimized;
  let keyCode;
  let styles;
  let { button = void 0 } = $$props;
  function onClick(event) {
    const invoke = button?.onPress ?? button?.onclick;
    if (typeof invoke === "function") {
      invoke.call(button, event);
      $$invalidate(0, button);
    }
  }
  function onContextMenu(event) {
    const invoke = button?.onContextMenu;
    if (typeof invoke === "function") {
      invoke.call(button, event);
      $$invalidate(0, button);
    }
  }
  function onKeydown(event) {
    if (event.code === keyCode) {
      event.preventDefault();
      event.stopPropagation();
    }
  }
  function onKeyup(event) {
    if (event.code === keyCode) {
      const invoke = button.onPress ?? button.onclick;
      if (typeof invoke === "function") {
        invoke.call(button, event);
        $$invalidate(0, button);
      }
      event.preventDefault();
      event.stopPropagation();
    }
  }
  $$self.$$set = ($$props2) => {
    if ("button" in $$props2)
      $$invalidate(0, button = $$props2.button);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(9, title = isObject$1(button) && typeof button.title === "string" ? localize(button.title) : "");
    }
    if ($$self.$$.dirty & /*button, title*/
    513) {
      $$invalidate(4, icon = isObject$1(button) && typeof button.icon !== "string" ? void 0 : s_REGEX_HTML$1.test(button.icon) ? button.icon : `<i class="${button.icon}" title="${title}"></i>`);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(3, label = isObject$1(button) && typeof button.label === "string" ? localize(button.label) : void 0);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(2, keepMinimized = isObject$1(button) && typeof button.keepMinimized === "boolean" ? button.keepMinimized : false);
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      keyCode = isObject$1(button) && typeof button.keyCode === "string" ? button.keyCode : "Enter";
    }
    if ($$self.$$.dirty & /*button*/
    1) {
      $$invalidate(1, styles = isObject$1(button) && isObject$1(button.styles) ? button.styles : void 0);
    }
  };
  return [
    button,
    styles,
    keepMinimized,
    label,
    icon,
    onClick,
    onContextMenu,
    onKeydown,
    onKeyup,
    title
  ];
}
class TJSHeaderButton extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$1a, create_fragment$1a, safe_not_equal, { button: 0 });
  }
  get button() {
    return this.$$.ctx[0];
  }
  set button(button) {
    this.$$set({ button });
    flush();
  }
}
const TJSHeaderButton$1 = TJSHeaderButton;
const TJSApplicationHeader_svelte_svelte_type_style_lang = "";
function get_each_context$h(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i2];
  return child_ctx;
}
function get_each_context_1$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i2];
  return child_ctx;
}
function create_if_block$S(ctx) {
  let img;
  let img_src_value;
  return {
    c() {
      img = element("img");
      attr(img, "class", "tjs-app-icon keep-minimized svelte-mobile-companion81nkluj30u9vsd-1wviwl9");
      if (!src_url_equal(img.src, img_src_value = /*$storeHeaderIcon*/
      ctx[6]))
        attr(img, "src", img_src_value);
      attr(img, "alt", "icon");
    },
    m(target, anchor) {
      insert(target, img, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$storeHeaderIcon*/
      64 && !src_url_equal(img.src, img_src_value = /*$storeHeaderIcon*/
      ctx2[6])) {
        attr(img, "src", img_src_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(img);
      }
    }
  };
}
function create_each_block_1$5(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*button*/
    ctx[31].props
  ];
  var switch_value = (
    /*button*/
    ctx[31].class
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty[0] & /*buttonsLeft*/
    2) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*button*/
        ctx2[31].props
      )]);
    } else {
      for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
      }
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*buttonsLeft*/
      2 && switch_value !== (switch_value = /*button*/
      ctx2[31].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*buttonsLeft*/
        2 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*button*/
          ctx2[31].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_each_block$h(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*button*/
    ctx[31].props
  ];
  var switch_value = (
    /*button*/
    ctx[31].class
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty[0] & /*buttonsRight*/
    4) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*button*/
        ctx2[31].props
      )]);
    } else {
      for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
      }
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*buttonsRight*/
      4 && switch_value !== (switch_value = /*button*/
      ctx2[31].class)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty[0] & /*buttonsRight*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*button*/
          ctx2[31].props
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_key_block(ctx) {
  let header;
  let t0;
  let h4;
  let t1_value = localize(
    /*$storeTitle*/
    ctx[7]
  ) + "";
  let t1;
  let t2;
  let t3;
  let span;
  let t4;
  let draggable_action;
  let minimizable_action;
  let current;
  let mounted;
  let dispose;
  let if_block = typeof /*$storeHeaderIcon*/
  ctx[6] === "string" && create_if_block$S(ctx);
  let each_value_1 = ensure_array_like(
    /*buttonsLeft*/
    ctx[1]
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_1$5(get_each_context_1$5(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks_1[i2], 1, 1, () => {
    each_blocks_1[i2] = null;
  });
  let each_value = ensure_array_like(
    /*buttonsRight*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$h(get_each_context$h(ctx, each_value, i2));
  }
  const out_1 = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      header = element("header");
      if (if_block)
        if_block.c();
      t0 = space();
      h4 = element("h4");
      t1 = text(t1_value);
      t2 = space();
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t3 = space();
      span = element("span");
      t4 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h4, "class", "window-title svelte-mobile-companion81nkluj30u9vsd-1wviwl9");
      set_style(
        h4,
        "display",
        /*displayHeaderTitle*/
        ctx[4]
      );
      attr(span, "class", "tjs-window-header-spacer keep-minimized svelte-mobile-companion81nkluj30u9vsd-1wviwl9");
      attr(header, "class", "window-header flexrow svelte-mobile-companion81nkluj30u9vsd-1wviwl9");
    },
    m(target, anchor) {
      insert(target, header, anchor);
      if (if_block)
        if_block.m(header, null);
      append(header, t0);
      append(header, h4);
      append(h4, t1);
      append(header, t2);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(header, null);
        }
      }
      append(header, t3);
      append(header, span);
      append(header, t4);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(header, null);
        }
      }
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(draggable_action = /*draggable*/
          ctx[0].call(
            null,
            header,
            /*dragOptions*/
            ctx[3]
          )),
          action_destroyer(minimizable_action = /*minimizable*/
          ctx[18].call(
            null,
            header,
            /*$storeMinimizable*/
            ctx[5]
          )),
          listen(
            header,
            "pointerdown",
            /*onPointerdown*/
            ctx[19]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (typeof /*$storeHeaderIcon*/
      ctx2[6] === "string") {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$S(ctx2);
          if_block.c();
          if_block.m(header, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if ((!current || dirty[0] & /*$storeTitle*/
      128) && t1_value !== (t1_value = localize(
        /*$storeTitle*/
        ctx2[7]
      ) + ""))
        set_data(t1, t1_value);
      if (dirty[0] & /*displayHeaderTitle*/
      16) {
        set_style(
          h4,
          "display",
          /*displayHeaderTitle*/
          ctx2[4]
        );
      }
      if (dirty[0] & /*buttonsLeft*/
      2) {
        each_value_1 = ensure_array_like(
          /*buttonsLeft*/
          ctx2[1]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$5(ctx2, each_value_1, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
            transition_in(each_blocks_1[i2], 1);
          } else {
            each_blocks_1[i2] = create_each_block_1$5(child_ctx);
            each_blocks_1[i2].c();
            transition_in(each_blocks_1[i2], 1);
            each_blocks_1[i2].m(header, t3);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks_1.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (dirty[0] & /*buttonsRight*/
      4) {
        each_value = ensure_array_like(
          /*buttonsRight*/
          ctx2[2]
        );
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$h(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$h(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(header, null);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out_1(i2);
        }
        check_outros();
      }
      if (draggable_action && is_function(draggable_action.update) && dirty[0] & /*dragOptions*/
      8)
        draggable_action.update.call(
          null,
          /*dragOptions*/
          ctx2[3]
        );
      if (minimizable_action && is_function(minimizable_action.update) && dirty[0] & /*$storeMinimizable*/
      32)
        minimizable_action.update.call(
          null,
          /*$storeMinimizable*/
          ctx2[5]
        );
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks_1[i2]);
      }
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        transition_out(each_blocks_1[i2]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(header);
      }
      if (if_block)
        if_block.d();
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$19(ctx) {
  let previous_key = (
    /*draggable*/
    ctx[0]
  );
  let key_block_anchor;
  let current;
  let key_block = create_key_block(ctx);
  return {
    c() {
      key_block.c();
      key_block_anchor = empty();
    },
    m(target, anchor) {
      key_block.m(target, anchor);
      insert(target, key_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*draggable*/
      1 && safe_not_equal(previous_key, previous_key = /*draggable*/
      ctx2[0])) {
        group_outros();
        transition_out(key_block, 1, 1, noop);
        check_outros();
        key_block = create_key_block(ctx2);
        key_block.c();
        transition_in(key_block, 1);
        key_block.m(key_block_anchor.parentNode, key_block_anchor);
      } else {
        key_block.p(ctx2, dirty);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(key_block);
      current = true;
    },
    o(local) {
      transition_out(key_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(key_block_anchor);
      }
      key_block.d(detaching);
    }
  };
}
function instance$19($$self, $$props, $$invalidate) {
  let $focusKeep;
  let $focusAuto;
  let $elementRoot;
  let $storeHeaderButtons;
  let $storeMinimized;
  let $storeHeaderNoTitleMinimized;
  let $storeDraggable;
  let $storeMinimizable;
  let $storeHeaderIcon;
  let $storeTitle;
  let { draggable: draggable$1 = void 0 } = $$props;
  let { draggableOptions = void 0 } = $$props;
  const { application } = getContext("#external");
  const { focusAuto, focusKeep } = application.reactive.storeAppOptions;
  component_subscribe($$self, focusAuto, (value) => $$invalidate(26, $focusAuto = value));
  component_subscribe($$self, focusKeep, (value) => $$invalidate(25, $focusKeep = value));
  const { elementRoot } = getContext("#internal").stores;
  component_subscribe($$self, elementRoot, (value) => $$invalidate(27, $elementRoot = value));
  const storeTitle = application.reactive.storeAppOptions.title;
  component_subscribe($$self, storeTitle, (value) => $$invalidate(7, $storeTitle = value));
  const storeDraggable = application.reactive.storeAppOptions.draggable;
  component_subscribe($$self, storeDraggable, (value) => $$invalidate(24, $storeDraggable = value));
  const storeDragging = application.reactive.storeUIState.dragging;
  const storeHeaderButtons = application.reactive.storeUIState.headerButtons;
  component_subscribe($$self, storeHeaderButtons, (value) => $$invalidate(21, $storeHeaderButtons = value));
  const storeHeaderIcon = application.reactive.storeAppOptions.headerIcon;
  component_subscribe($$self, storeHeaderIcon, (value) => $$invalidate(6, $storeHeaderIcon = value));
  const storeHeaderNoTitleMinimized = application.reactive.storeAppOptions.headerNoTitleMinimized;
  component_subscribe($$self, storeHeaderNoTitleMinimized, (value) => $$invalidate(23, $storeHeaderNoTitleMinimized = value));
  const storeMinimizable = application.reactive.storeAppOptions.minimizable;
  component_subscribe($$self, storeMinimizable, (value) => $$invalidate(5, $storeMinimizable = value));
  const storeMinimized = application.reactive.storeUIState.minimized;
  component_subscribe($$self, storeMinimized, (value) => $$invalidate(22, $storeMinimized = value));
  const s_DRAG_TARGET_CLASSLIST = Object.freeze(["tjs-app-icon", "tjs-window-header-spacer", "window-header", "window-title"]);
  let dragOptions;
  let displayHeaderTitle;
  let buttonsLeft;
  let buttonsRight;
  function minimizable(node, booleanStore) {
    const callback = (event) => {
      if (event.target.classList.contains("window-title") || event.target.classList.contains("window-header") || event.target.classList.contains("keep-minimized")) {
        application._onToggleMinimize(event);
      }
    };
    function activateListeners() {
      node.addEventListener("dblclick", callback);
    }
    function removeListeners() {
      node.removeEventListener("dblclick", callback);
    }
    if (booleanStore) {
      activateListeners();
    }
    return {
      update: (booleanStore2) => {
        if (booleanStore2) {
          activateListeners();
        } else {
          removeListeners();
        }
      },
      destroy: () => removeListeners()
    };
  }
  function onPointerdown(event) {
    const rootEl = $elementRoot;
    if ($focusAuto && rootEl instanceof HTMLElement && rootEl?.isConnected) {
      if ($focusKeep) {
        const focusOutside = document.activeElement instanceof HTMLElement && !rootEl.contains(document.activeElement);
        if (focusOutside) {
          rootEl.focus();
        } else {
          event.preventDefault();
        }
      } else {
        rootEl.focus();
      }
    }
  }
  $$self.$$set = ($$props2) => {
    if ("draggable" in $$props2)
      $$invalidate(0, draggable$1 = $$props2.draggable);
    if ("draggableOptions" in $$props2)
      $$invalidate(20, draggableOptions = $$props2.draggableOptions);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*draggable*/
    1) {
      $$invalidate(0, draggable$1 = typeof draggable$1 === "function" ? draggable$1 : draggable);
    }
    if ($$self.$$.dirty[0] & /*draggableOptions, $storeDraggable*/
    17825792) {
      $$invalidate(3, dragOptions = Object.assign(
        {},
        {
          ease: true,
          easeOptions: { duration: 0.06, ease: cubicOut }
        },
        isObject$1(draggableOptions) ? draggableOptions : {},
        {
          position: application.position,
          active: $storeDraggable,
          storeDragging,
          hasTargetClassList: s_DRAG_TARGET_CLASSLIST
        }
      ));
    }
    if ($$self.$$.dirty[0] & /*$storeHeaderNoTitleMinimized, $storeMinimized*/
    12582912) {
      $$invalidate(4, displayHeaderTitle = $storeHeaderNoTitleMinimized && $storeMinimized ? "none" : null);
    }
    if ($$self.$$.dirty[0] & /*$storeHeaderButtons, buttonsLeft, buttonsRight*/
    2097158) {
      {
        $$invalidate(1, buttonsLeft = []);
        $$invalidate(2, buttonsRight = []);
        for (const button of $storeHeaderButtons) {
          const buttonsList = typeof button?.alignLeft === "boolean" && button?.alignLeft ? buttonsLeft : buttonsRight;
          buttonsList.push(isSvelteComponent(button) ? { class: button, props: {} } : {
            class: TJSHeaderButton$1,
            props: { button }
          });
        }
      }
    }
  };
  return [
    draggable$1,
    buttonsLeft,
    buttonsRight,
    dragOptions,
    displayHeaderTitle,
    $storeMinimizable,
    $storeHeaderIcon,
    $storeTitle,
    focusAuto,
    focusKeep,
    elementRoot,
    storeTitle,
    storeDraggable,
    storeHeaderButtons,
    storeHeaderIcon,
    storeHeaderNoTitleMinimized,
    storeMinimizable,
    storeMinimized,
    minimizable,
    onPointerdown,
    draggableOptions,
    $storeHeaderButtons,
    $storeMinimized,
    $storeHeaderNoTitleMinimized,
    $storeDraggable
  ];
}
class TJSApplicationHeader extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$19, create_fragment$19, safe_not_equal, { draggable: 0, draggableOptions: 20 }, null, [-1, -1]);
  }
}
const TJSApplicationHeader$1 = TJSApplicationHeader;
const TJSFocusWrap_svelte_svelte_type_style_lang = "";
function create_fragment$18(ctx) {
  let div2;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      attr(div2, "class", "tjs-focus-wrap svelte-mobile-companion81nkluj30u9vsd-kjcljd");
      attr(div2, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      ctx[4](div2);
      if (!mounted) {
        dispose = listen(
          div2,
          "focus",
          /*onFocus*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[4](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$18($$self, $$props, $$invalidate) {
  let { elementRoot = void 0 } = $$props;
  let { enabled = true } = $$props;
  let ignoreElements, wrapEl;
  function onFocus() {
    if (!enabled) {
      return;
    }
    if (elementRoot instanceof HTMLElement) {
      const firstFocusEl = A11yHelper.getFirstFocusableElement(elementRoot, ignoreElements);
      if (firstFocusEl instanceof HTMLElement && firstFocusEl !== wrapEl) {
        firstFocusEl.focus();
      } else {
        elementRoot.focus();
      }
    }
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      wrapEl = $$value;
      $$invalidate(0, wrapEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(2, elementRoot = $$props2.elementRoot);
    if ("enabled" in $$props2)
      $$invalidate(3, enabled = $$props2.enabled);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*wrapEl*/
    1) {
      if (wrapEl) {
        ignoreElements = /* @__PURE__ */ new Set([wrapEl]);
      }
    }
  };
  return [wrapEl, onFocus, elementRoot, enabled, div_binding];
}
class TJSFocusWrap extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$18, create_fragment$18, safe_not_equal, { elementRoot: 2, enabled: 3 });
  }
}
const TJSFocusWrap$1 = TJSFocusWrap;
const ResizableHandle_svelte_svelte_type_style_lang = "";
function create_fragment$17(ctx) {
  let div2;
  let resizable_action;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      div2.innerHTML = `<i class="fas fa-arrows-alt-h svelte-mobile-companion81nkluj30u9vsd-14lnpz8"></i>`;
      attr(div2, "class", "window-resizable-handle svelte-mobile-companion81nkluj30u9vsd-14lnpz8");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      ctx[10](div2);
      if (!mounted) {
        dispose = action_destroyer(resizable_action = /*resizable*/
        ctx[6].call(null, div2, {
          active: (
            /*$storeResizable*/
            ctx[1]
          ),
          storeResizing: (
            /*storeResizing*/
            ctx[5]
          )
        }));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (resizable_action && is_function(resizable_action.update) && dirty & /*$storeResizable*/
      2)
        resizable_action.update.call(null, {
          active: (
            /*$storeResizable*/
            ctx2[1]
          ),
          storeResizing: (
            /*storeResizing*/
            ctx2[5]
          )
        });
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      ctx[10](null);
      mounted = false;
      dispose();
    }
  };
}
function instance$17($$self, $$props, $$invalidate) {
  let $storeElementRoot;
  let $storeMinimized;
  let $storeResizable;
  let { isResizable = false } = $$props;
  const application = getContext("#external").application;
  const storeElementRoot = getContext("#internal").stores.elementRoot;
  component_subscribe($$self, storeElementRoot, (value) => $$invalidate(8, $storeElementRoot = value));
  const storeResizable = application.reactive.storeAppOptions.resizable;
  component_subscribe($$self, storeResizable, (value) => $$invalidate(1, $storeResizable = value));
  const storeMinimized = application.reactive.storeUIState.minimized;
  component_subscribe($$self, storeMinimized, (value) => $$invalidate(9, $storeMinimized = value));
  const storeResizing = application.reactive.storeUIState.resizing;
  let elementResize;
  function resizable(node, { active: active2 = true, storeResizing: storeResizing2 = void 0 } = {}) {
    let position = null;
    let initialPosition = {};
    let resizing = false;
    const handlers = {
      resizeDown: ["pointerdown", (e2) => onResizePointerDown(e2), false],
      resizeMove: ["pointermove", (e2) => onResizePointerMove(e2), false],
      resizeUp: ["pointerup", (e2) => onResizePointerUp(e2), false]
    };
    function activateListeners() {
      node.addEventListener(...handlers.resizeDown);
      $$invalidate(7, isResizable = true);
      node.style.display = "block";
    }
    function removeListeners() {
      if (typeof storeResizing2?.set === "function") {
        storeResizing2.set(false);
      }
      node.removeEventListener(...handlers.resizeDown);
      node.removeEventListener(...handlers.resizeMove);
      node.removeEventListener(...handlers.resizeUp);
      node.style.display = "none";
      $$invalidate(7, isResizable = false);
    }
    if (active2) {
      activateListeners();
    } else {
      node.style.display = "none";
    }
    function onResizePointerDown(event) {
      event.preventDefault();
      resizing = false;
      position = application.position.get();
      if (position.height === "auto") {
        position.height = $storeElementRoot.clientHeight;
      }
      if (position.width === "auto") {
        position.width = $storeElementRoot.clientWidth;
      }
      initialPosition = { x: event.clientX, y: event.clientY };
      node.addEventListener(...handlers.resizeMove);
      node.addEventListener(...handlers.resizeUp);
      node.setPointerCapture(event.pointerId);
    }
    function onResizePointerMove(event) {
      event.preventDefault();
      if (!resizing && typeof storeResizing2?.set === "function") {
        resizing = true;
        storeResizing2.set(true);
      }
      application.position.set({
        width: position.width + (event.clientX - initialPosition.x),
        height: position.height + (event.clientY - initialPosition.y)
      });
    }
    function onResizePointerUp(event) {
      resizing = false;
      if (typeof storeResizing2?.set === "function") {
        storeResizing2.set(false);
      }
      event.preventDefault();
      node.removeEventListener(...handlers.resizeMove);
      node.removeEventListener(...handlers.resizeUp);
      application?._onResize?.(event);
    }
    return {
      update: ({ active: active3 }) => {
        if (active3) {
          activateListeners();
        } else {
          removeListeners();
        }
      },
      destroy: () => removeListeners()
    };
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementResize = $$value;
      $$invalidate(0, elementResize), $$invalidate(7, isResizable), $$invalidate(9, $storeMinimized), $$invalidate(8, $storeElementRoot);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("isResizable" in $$props2)
      $$invalidate(7, isResizable = $$props2.isResizable);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*elementResize, isResizable, $storeMinimized, $storeElementRoot*/
    897) {
      if (elementResize) {
        $$invalidate(0, elementResize.style.display = isResizable && !$storeMinimized ? "block" : "none", elementResize);
        const elementRoot = $storeElementRoot;
        if (elementRoot) {
          elementRoot.classList[isResizable ? "add" : "remove"]("resizable");
        }
      }
    }
  };
  return [
    elementResize,
    $storeResizable,
    storeElementRoot,
    storeResizable,
    storeMinimized,
    storeResizing,
    resizable,
    isResizable,
    $storeElementRoot,
    $storeMinimized,
    div_binding
  ];
}
class ResizableHandle extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$17, create_fragment$17, safe_not_equal, { isResizable: 7 });
  }
}
const ResizableHandle$1 = ResizableHandle;
const ApplicationShell_svelte_svelte_type_style_lang = "";
function create_else_block$7(ctx) {
  let div2;
  let tjsapplicationheader;
  let t0;
  let section;
  let applyStyles_action;
  let t1;
  let resizablehandle;
  let t2;
  let tjsfocuswrap;
  let div_id_value;
  let div_class_value;
  let div_data_appid_value;
  let applyStyles_action_1;
  let current;
  let mounted;
  let dispose;
  tjsapplicationheader = new TJSApplicationHeader$1({
    props: {
      draggable: (
        /*draggable*/
        ctx[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        ctx[7]
      )
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[36].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  resizablehandle = new ResizableHandle$1({});
  tjsfocuswrap = new TJSFocusWrap$1({
    props: {
      elementRoot: (
        /*elementRoot*/
        ctx[1]
      ),
      enabled: (
        /*focusWrapEnabled*/
        ctx[11]
      )
    }
  });
  return {
    c() {
      div2 = element("div");
      create_component(tjsapplicationheader.$$.fragment);
      t0 = space();
      section = element("section");
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(resizablehandle.$$.fragment);
      t2 = space();
      create_component(tjsfocuswrap.$$.fragment);
      attr(section, "class", "window-content svelte-mobile-companion81nkluj30u9vsd-oz81f7");
      attr(section, "tabindex", "-1");
      attr(div2, "id", div_id_value = /*application*/
      ctx[10].id);
      attr(div2, "class", div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-mobile-companion81nkluj30u9vsd-oz81f7");
      attr(div2, "data-appid", div_data_appid_value = /*application*/
      ctx[10].appId);
      attr(div2, "role", "application");
      attr(div2, "tabindex", "-1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(tjsapplicationheader, div2, null);
      append(div2, t0);
      append(div2, section);
      if (default_slot) {
        default_slot.m(section, null);
      }
      ctx[39](section);
      append(div2, t1);
      mount_component(resizablehandle, div2, null);
      append(div2, t2);
      mount_component(tjsfocuswrap, div2, null);
      ctx[40](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            section,
            "pointerdown",
            /*onPointerdownContent*/
            ctx[21]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            section,
            /*stylesContent*/
            ctx[9]
          )),
          action_destroyer(
            /*contentResizeObserver*/
            ctx[13].call(
              null,
              section,
              /*resizeObservedContent*/
              ctx[22]
            )
          ),
          listen(div2, "close:popup", stop_propagation(prevent_default(
            /*onClosePopup*/
            ctx[18]
          ))),
          listen(
            div2,
            "keydown",
            /*onKeydown*/
            ctx[19],
            true
          ),
          listen(
            div2,
            "pointerdown",
            /*onPointerdownApp*/
            ctx[20]
          ),
          action_destroyer(applyStyles_action_1 = applyStyles.call(
            null,
            div2,
            /*stylesApp*/
            ctx[8]
          )),
          action_destroyer(
            /*appResizeObserver*/
            ctx[12].call(
              null,
              div2,
              /*resizeObservedApp*/
              ctx[23]
            )
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      const tjsapplicationheader_changes = {};
      if (dirty[0] & /*draggable*/
      64)
        tjsapplicationheader_changes.draggable = /*draggable*/
        ctx2[6];
      if (dirty[0] & /*draggableOptions*/
      128)
        tjsapplicationheader_changes.draggableOptions = /*draggableOptions*/
        ctx2[7];
      tjsapplicationheader.$set(tjsapplicationheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[35],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty[0] & /*stylesContent*/
      512)
        applyStyles_action.update.call(
          null,
          /*stylesContent*/
          ctx2[9]
        );
      const tjsfocuswrap_changes = {};
      if (dirty[0] & /*elementRoot*/
      2)
        tjsfocuswrap_changes.elementRoot = /*elementRoot*/
        ctx2[1];
      if (dirty[0] & /*focusWrapEnabled*/
      2048)
        tjsfocuswrap_changes.enabled = /*focusWrapEnabled*/
        ctx2[11];
      tjsfocuswrap.$set(tjsfocuswrap_changes);
      if (!current || dirty[0] & /*application*/
      1024 && div_id_value !== (div_id_value = /*application*/
      ctx2[10].id)) {
        attr(div2, "id", div_id_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_class_value !== (div_class_value = "app window-app " + /*application*/
      ctx2[10].options.classes.join(" ") + " svelte-mobile-companion81nkluj30u9vsd-oz81f7")) {
        attr(div2, "class", div_class_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_data_appid_value !== (div_data_appid_value = /*application*/
      ctx2[10].appId)) {
        attr(div2, "data-appid", div_data_appid_value);
      }
      if (applyStyles_action_1 && is_function(applyStyles_action_1.update) && dirty[0] & /*stylesApp*/
      256)
        applyStyles_action_1.update.call(
          null,
          /*stylesApp*/
          ctx2[8]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsapplicationheader.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(resizablehandle.$$.fragment, local);
      transition_in(tjsfocuswrap.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsapplicationheader.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(resizablehandle.$$.fragment, local);
      transition_out(tjsfocuswrap.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(tjsapplicationheader);
      if (default_slot)
        default_slot.d(detaching);
      ctx[39](null);
      destroy_component(resizablehandle);
      destroy_component(tjsfocuswrap);
      ctx[40](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block$R(ctx) {
  let div2;
  let tjsapplicationheader;
  let t0;
  let section;
  let applyStyles_action;
  let t1;
  let resizablehandle;
  let t2;
  let tjsfocuswrap;
  let div_id_value;
  let div_class_value;
  let div_data_appid_value;
  let applyStyles_action_1;
  let div_intro;
  let div_outro;
  let current;
  let mounted;
  let dispose;
  tjsapplicationheader = new TJSApplicationHeader$1({
    props: {
      draggable: (
        /*draggable*/
        ctx[6]
      ),
      draggableOptions: (
        /*draggableOptions*/
        ctx[7]
      )
    }
  });
  const default_slot_template = (
    /*#slots*/
    ctx[36].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[35],
    null
  );
  resizablehandle = new ResizableHandle$1({});
  tjsfocuswrap = new TJSFocusWrap$1({
    props: { elementRoot: (
      /*elementRoot*/
      ctx[1]
    ) }
  });
  return {
    c() {
      div2 = element("div");
      create_component(tjsapplicationheader.$$.fragment);
      t0 = space();
      section = element("section");
      if (default_slot)
        default_slot.c();
      t1 = space();
      create_component(resizablehandle.$$.fragment);
      t2 = space();
      create_component(tjsfocuswrap.$$.fragment);
      attr(section, "class", "window-content svelte-mobile-companion81nkluj30u9vsd-oz81f7");
      attr(section, "tabindex", "-1");
      attr(div2, "id", div_id_value = /*application*/
      ctx[10].id);
      attr(div2, "class", div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-mobile-companion81nkluj30u9vsd-oz81f7");
      attr(div2, "data-appid", div_data_appid_value = /*application*/
      ctx[10].appId);
      attr(div2, "role", "application");
      attr(div2, "tabindex", "-1");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(tjsapplicationheader, div2, null);
      append(div2, t0);
      append(div2, section);
      if (default_slot) {
        default_slot.m(section, null);
      }
      ctx[37](section);
      append(div2, t1);
      mount_component(resizablehandle, div2, null);
      append(div2, t2);
      mount_component(tjsfocuswrap, div2, null);
      ctx[38](div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            section,
            "pointerdown",
            /*onPointerdownContent*/
            ctx[21]
          ),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            section,
            /*stylesContent*/
            ctx[9]
          )),
          action_destroyer(
            /*contentResizeObserver*/
            ctx[13].call(
              null,
              section,
              /*resizeObservedContent*/
              ctx[22]
            )
          ),
          listen(div2, "close:popup", stop_propagation(prevent_default(
            /*onClosePopup*/
            ctx[18]
          ))),
          listen(
            div2,
            "keydown",
            /*onKeydown*/
            ctx[19],
            true
          ),
          listen(
            div2,
            "pointerdown",
            /*onPointerdownApp*/
            ctx[20]
          ),
          action_destroyer(applyStyles_action_1 = applyStyles.call(
            null,
            div2,
            /*stylesApp*/
            ctx[8]
          )),
          action_destroyer(
            /*appResizeObserver*/
            ctx[12].call(
              null,
              div2,
              /*resizeObservedApp*/
              ctx[23]
            )
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const tjsapplicationheader_changes = {};
      if (dirty[0] & /*draggable*/
      64)
        tjsapplicationheader_changes.draggable = /*draggable*/
        ctx[6];
      if (dirty[0] & /*draggableOptions*/
      128)
        tjsapplicationheader_changes.draggableOptions = /*draggableOptions*/
        ctx[7];
      tjsapplicationheader.$set(tjsapplicationheader_changes);
      if (default_slot) {
        if (default_slot.p && (!current || dirty[1] & /*$$scope*/
        16)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx,
            /*$$scope*/
            ctx[35],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[35]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx[35],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty[0] & /*stylesContent*/
      512)
        applyStyles_action.update.call(
          null,
          /*stylesContent*/
          ctx[9]
        );
      const tjsfocuswrap_changes = {};
      if (dirty[0] & /*elementRoot*/
      2)
        tjsfocuswrap_changes.elementRoot = /*elementRoot*/
        ctx[1];
      tjsfocuswrap.$set(tjsfocuswrap_changes);
      if (!current || dirty[0] & /*application*/
      1024 && div_id_value !== (div_id_value = /*application*/
      ctx[10].id)) {
        attr(div2, "id", div_id_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_class_value !== (div_class_value = "app window-app " + /*application*/
      ctx[10].options.classes.join(" ") + " svelte-mobile-companion81nkluj30u9vsd-oz81f7")) {
        attr(div2, "class", div_class_value);
      }
      if (!current || dirty[0] & /*application*/
      1024 && div_data_appid_value !== (div_data_appid_value = /*application*/
      ctx[10].appId)) {
        attr(div2, "data-appid", div_data_appid_value);
      }
      if (applyStyles_action_1 && is_function(applyStyles_action_1.update) && dirty[0] & /*stylesApp*/
      256)
        applyStyles_action_1.update.call(
          null,
          /*stylesApp*/
          ctx[8]
        );
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsapplicationheader.$$.fragment, local);
      transition_in(default_slot, local);
      transition_in(resizablehandle.$$.fragment, local);
      transition_in(tjsfocuswrap.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (div_outro)
          div_outro.end(1);
        div_intro = create_in_transition(
          div2,
          /*inTransition*/
          ctx[2],
          /*inTransitionOptions*/
          ctx[4]
        );
        div_intro.start();
      });
      current = true;
    },
    o(local) {
      transition_out(tjsapplicationheader.$$.fragment, local);
      transition_out(default_slot, local);
      transition_out(resizablehandle.$$.fragment, local);
      transition_out(tjsfocuswrap.$$.fragment, local);
      if (div_intro)
        div_intro.invalidate();
      div_outro = create_out_transition(
        div2,
        /*outTransition*/
        ctx[3],
        /*outTransitionOptions*/
        ctx[5]
      );
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(tjsapplicationheader);
      if (default_slot)
        default_slot.d(detaching);
      ctx[37](null);
      destroy_component(resizablehandle);
      destroy_component(tjsfocuswrap);
      ctx[38](null);
      if (detaching && div_outro)
        div_outro.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$16(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$R, create_else_block$7];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*inTransition*/
      ctx2[2] !== TJSDefaultTransition.default || /*outTransition*/
      ctx2[3] !== TJSDefaultTransition.default
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function instance$16($$self, $$props, $$invalidate) {
  let $focusKeep;
  let $focusAuto;
  let $minimized;
  let $focusTrap;
  let { $$slots: slots = {}, $$scope } = $$props;
  let { elementContent = void 0 } = $$props;
  let { elementRoot = void 0 } = $$props;
  let { draggable: draggable2 = void 0 } = $$props;
  let { draggableOptions = void 0 } = $$props;
  let { stylesApp = void 0 } = $$props;
  let { stylesContent = void 0 } = $$props;
  let { appOffsetHeight = false } = $$props;
  let { appOffsetWidth = false } = $$props;
  const appResizeObserver = !!appOffsetHeight || !!appOffsetWidth ? resizeObserver : () => null;
  let { contentOffsetHeight = false } = $$props;
  let { contentOffsetWidth = false } = $$props;
  const contentResizeObserver = !!contentOffsetHeight || !!contentOffsetWidth ? resizeObserver : () => null;
  const internal = new AppShellContextInternal();
  const s_IGNORE_CLASSES = { ignoreClasses: ["tjs-focus-wrap"] };
  setContext("#internal", internal);
  const { application } = getContext("#external");
  const { focusAuto, focusKeep, focusTrap } = application.reactive.storeAppOptions;
  component_subscribe($$self, focusAuto, (value) => $$invalidate(32, $focusAuto = value));
  component_subscribe($$self, focusKeep, (value) => $$invalidate(41, $focusKeep = value));
  component_subscribe($$self, focusTrap, (value) => $$invalidate(34, $focusTrap = value));
  const { minimized } = application.reactive.storeUIState;
  component_subscribe($$self, minimized, (value) => $$invalidate(33, $minimized = value));
  let focusWrapEnabled;
  let { transition = TJSDefaultTransition.default } = $$props;
  let { inTransition = TJSDefaultTransition.default } = $$props;
  let { outTransition = TJSDefaultTransition.default } = $$props;
  let { transitionOptions = void 0 } = $$props;
  let { inTransitionOptions = TJSDefaultTransition.options } = $$props;
  let { outTransitionOptions = TJSDefaultTransition.options } = $$props;
  let oldTransition = TJSDefaultTransition.default;
  let oldTransitionOptions = void 0;
  onMount(() => elementRoot.focus());
  function onClosePopup(event) {
    if (!$focusAuto) {
      return;
    }
    const targetEl = event?.detail?.target;
    if (!(targetEl instanceof HTMLElement)) {
      return;
    }
    if (A11yHelper.isFocusable(targetEl)) {
      return;
    }
    const elementRootContains = elementRoot.contains(targetEl);
    if (targetEl === elementRoot) {
      elementRoot.focus();
    } else if (targetEl === elementContent) {
      elementContent.focus();
    } else if (elementRootContains) {
      if (elementContent.contains(targetEl)) {
        elementContent.focus();
      } else {
        elementRoot.focus();
      }
    }
  }
  function onKeydown(event) {
    if ((event.target === elementRoot || event.target === elementContent) && KeyboardManager && KeyboardManager?._getMatchingActions?.(KeyboardManager?.getKeyboardEventContext?.(event))?.length) {
      event.target?.blur();
      return;
    }
    if (focusWrapEnabled && event.shiftKey && event.code === "Tab") {
      const allFocusable = A11yHelper.getFocusableElements(elementRoot, s_IGNORE_CLASSES);
      const firstFocusEl = allFocusable.length > 0 ? allFocusable[0] : void 0;
      const lastFocusEl = allFocusable.length > 0 ? allFocusable[allFocusable.length - 1] : void 0;
      if (elementRoot === document.activeElement || firstFocusEl === document.activeElement) {
        if (lastFocusEl instanceof HTMLElement && firstFocusEl !== lastFocusEl) {
          lastFocusEl.focus();
        }
        event.preventDefault();
        event.stopPropagation();
      }
    }
    if (typeof application?.options?.popOut === "boolean" && application.options.popOut && application !== globalThis.ui?.activeWindow) {
      application.bringToTop.call(application);
    }
  }
  function onPointerdownApp() {
    if (typeof application?.options?.popOut === "boolean" && application.options.popOut && application !== globalThis.ui?.activeWindow) {
      application.bringToTop.call(application);
    }
  }
  function onPointerdownContent(event) {
    const focusable = A11yHelper.isFocusable(event.target);
    if (!focusable && $focusAuto) {
      if ($focusKeep) {
        const focusOutside = document.activeElement instanceof HTMLElement && !elementRoot.contains(document.activeElement);
        if (focusOutside) {
          elementContent.focus();
        } else {
          event.preventDefault();
        }
      } else {
        elementContent.focus();
      }
    }
  }
  function resizeObservedContent(offsetWidth, offsetHeight) {
    $$invalidate(27, contentOffsetWidth = offsetWidth);
    $$invalidate(26, contentOffsetHeight = offsetHeight);
  }
  function resizeObservedApp(offsetWidth, offsetHeight, contentWidth, contentHeight) {
    application.position.stores.resizeObserved.update((object) => {
      object.contentWidth = contentWidth;
      object.contentHeight = contentHeight;
      object.offsetWidth = offsetWidth;
      object.offsetHeight = offsetHeight;
      return object;
    });
    $$invalidate(24, appOffsetHeight = offsetHeight);
    $$invalidate(25, appOffsetWidth = offsetWidth);
  }
  function section_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementContent = $$value;
      $$invalidate(0, elementContent);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRoot = $$value;
      $$invalidate(1, elementRoot);
    });
  }
  function section_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementContent = $$value;
      $$invalidate(0, elementContent);
    });
  }
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      elementRoot = $$value;
      $$invalidate(1, elementRoot);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("elementContent" in $$props2)
      $$invalidate(0, elementContent = $$props2.elementContent);
    if ("elementRoot" in $$props2)
      $$invalidate(1, elementRoot = $$props2.elementRoot);
    if ("draggable" in $$props2)
      $$invalidate(6, draggable2 = $$props2.draggable);
    if ("draggableOptions" in $$props2)
      $$invalidate(7, draggableOptions = $$props2.draggableOptions);
    if ("stylesApp" in $$props2)
      $$invalidate(8, stylesApp = $$props2.stylesApp);
    if ("stylesContent" in $$props2)
      $$invalidate(9, stylesContent = $$props2.stylesContent);
    if ("appOffsetHeight" in $$props2)
      $$invalidate(24, appOffsetHeight = $$props2.appOffsetHeight);
    if ("appOffsetWidth" in $$props2)
      $$invalidate(25, appOffsetWidth = $$props2.appOffsetWidth);
    if ("contentOffsetHeight" in $$props2)
      $$invalidate(26, contentOffsetHeight = $$props2.contentOffsetHeight);
    if ("contentOffsetWidth" in $$props2)
      $$invalidate(27, contentOffsetWidth = $$props2.contentOffsetWidth);
    if ("transition" in $$props2)
      $$invalidate(28, transition = $$props2.transition);
    if ("inTransition" in $$props2)
      $$invalidate(2, inTransition = $$props2.inTransition);
    if ("outTransition" in $$props2)
      $$invalidate(3, outTransition = $$props2.outTransition);
    if ("transitionOptions" in $$props2)
      $$invalidate(29, transitionOptions = $$props2.transitionOptions);
    if ("inTransitionOptions" in $$props2)
      $$invalidate(4, inTransitionOptions = $$props2.inTransitionOptions);
    if ("outTransitionOptions" in $$props2)
      $$invalidate(5, outTransitionOptions = $$props2.outTransitionOptions);
    if ("$$scope" in $$props2)
      $$invalidate(35, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*elementContent*/
    1) {
      if (elementContent !== void 0 && elementContent !== null) {
        getContext("#internal").stores.elementContent.set(elementContent);
      }
    }
    if ($$self.$$.dirty[0] & /*elementRoot*/
    2) {
      if (elementRoot !== void 0 && elementRoot !== null) {
        getContext("#internal").stores.elementRoot.set(elementRoot);
      }
    }
    if ($$self.$$.dirty[1] & /*$focusAuto, $focusTrap, $minimized*/
    14) {
      $$invalidate(11, focusWrapEnabled = $focusAuto && $focusTrap && !$minimized);
    }
    if ($$self.$$.dirty[0] & /*oldTransition, transition*/
    1342177280) {
      if (oldTransition !== transition) {
        const newTransition = typeof transition === "function" ? transition : TJSDefaultTransition.default;
        $$invalidate(2, inTransition = newTransition);
        $$invalidate(3, outTransition = newTransition);
        $$invalidate(30, oldTransition = newTransition);
      }
    }
    if ($$self.$$.dirty[0] & /*transitionOptions*/
    536870912 | $$self.$$.dirty[1] & /*oldTransitionOptions*/
    1) {
      if (oldTransitionOptions !== transitionOptions) {
        const newOptions = transitionOptions !== TJSDefaultTransition.options && isObject$1(transitionOptions) ? transitionOptions : TJSDefaultTransition.options;
        $$invalidate(4, inTransitionOptions = newOptions);
        $$invalidate(5, outTransitionOptions = newOptions);
        $$invalidate(31, oldTransitionOptions = newOptions);
      }
    }
    if ($$self.$$.dirty[0] & /*inTransition*/
    4) {
      if (typeof inTransition !== "function") {
        $$invalidate(2, inTransition = TJSDefaultTransition.default);
      }
    }
    if ($$self.$$.dirty[0] & /*outTransition, application*/
    1032) {
      {
        if (typeof outTransition !== "function") {
          $$invalidate(3, outTransition = TJSDefaultTransition.default);
        }
        const defaultCloseAnimation = application?.options?.defaultCloseAnimation;
        if (typeof defaultCloseAnimation === "boolean" && defaultCloseAnimation && outTransition !== TJSDefaultTransition.default) {
          $$invalidate(10, application.options.defaultCloseAnimation = false, application);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*inTransitionOptions*/
    16) {
      if (!isObject$1(inTransitionOptions)) {
        $$invalidate(4, inTransitionOptions = TJSDefaultTransition.options);
      }
    }
    if ($$self.$$.dirty[0] & /*outTransitionOptions*/
    32) {
      if (!isObject$1(outTransitionOptions)) {
        $$invalidate(5, outTransitionOptions = TJSDefaultTransition.options);
      }
    }
  };
  return [
    elementContent,
    elementRoot,
    inTransition,
    outTransition,
    inTransitionOptions,
    outTransitionOptions,
    draggable2,
    draggableOptions,
    stylesApp,
    stylesContent,
    application,
    focusWrapEnabled,
    appResizeObserver,
    contentResizeObserver,
    focusAuto,
    focusKeep,
    focusTrap,
    minimized,
    onClosePopup,
    onKeydown,
    onPointerdownApp,
    onPointerdownContent,
    resizeObservedContent,
    resizeObservedApp,
    appOffsetHeight,
    appOffsetWidth,
    contentOffsetHeight,
    contentOffsetWidth,
    transition,
    transitionOptions,
    oldTransition,
    oldTransitionOptions,
    $focusAuto,
    $minimized,
    $focusTrap,
    $$scope,
    slots,
    section_binding,
    div_binding,
    section_binding_1,
    div_binding_1
  ];
}
class ApplicationShell extends SvelteComponent {
  constructor(options) {
    super();
    init$3(
      this,
      options,
      instance$16,
      create_fragment$16,
      safe_not_equal,
      {
        elementContent: 0,
        elementRoot: 1,
        draggable: 6,
        draggableOptions: 7,
        stylesApp: 8,
        stylesContent: 9,
        appOffsetHeight: 24,
        appOffsetWidth: 25,
        contentOffsetHeight: 26,
        contentOffsetWidth: 27,
        transition: 28,
        inTransition: 2,
        outTransition: 3,
        transitionOptions: 29,
        inTransitionOptions: 4,
        outTransitionOptions: 5
      },
      null,
      [-1, -1]
    );
  }
  get elementContent() {
    return this.$$.ctx[0];
  }
  set elementContent(elementContent) {
    this.$$set({ elementContent });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[1];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get draggable() {
    return this.$$.ctx[6];
  }
  set draggable(draggable2) {
    this.$$set({ draggable: draggable2 });
    flush();
  }
  get draggableOptions() {
    return this.$$.ctx[7];
  }
  set draggableOptions(draggableOptions) {
    this.$$set({ draggableOptions });
    flush();
  }
  get stylesApp() {
    return this.$$.ctx[8];
  }
  set stylesApp(stylesApp) {
    this.$$set({ stylesApp });
    flush();
  }
  get stylesContent() {
    return this.$$.ctx[9];
  }
  set stylesContent(stylesContent) {
    this.$$set({ stylesContent });
    flush();
  }
  get appOffsetHeight() {
    return this.$$.ctx[24];
  }
  set appOffsetHeight(appOffsetHeight) {
    this.$$set({ appOffsetHeight });
    flush();
  }
  get appOffsetWidth() {
    return this.$$.ctx[25];
  }
  set appOffsetWidth(appOffsetWidth) {
    this.$$set({ appOffsetWidth });
    flush();
  }
  get contentOffsetHeight() {
    return this.$$.ctx[26];
  }
  set contentOffsetHeight(contentOffsetHeight) {
    this.$$set({ contentOffsetHeight });
    flush();
  }
  get contentOffsetWidth() {
    return this.$$.ctx[27];
  }
  set contentOffsetWidth(contentOffsetWidth) {
    this.$$set({ contentOffsetWidth });
    flush();
  }
  get transition() {
    return this.$$.ctx[28];
  }
  set transition(transition) {
    this.$$set({ transition });
    flush();
  }
  get inTransition() {
    return this.$$.ctx[2];
  }
  set inTransition(inTransition) {
    this.$$set({ inTransition });
    flush();
  }
  get outTransition() {
    return this.$$.ctx[3];
  }
  set outTransition(outTransition) {
    this.$$set({ outTransition });
    flush();
  }
  get transitionOptions() {
    return this.$$.ctx[29];
  }
  set transitionOptions(transitionOptions) {
    this.$$set({ transitionOptions });
    flush();
  }
  get inTransitionOptions() {
    return this.$$.ctx[4];
  }
  set inTransitionOptions(inTransitionOptions) {
    this.$$set({ inTransitionOptions });
    flush();
  }
  get outTransitionOptions() {
    return this.$$.ctx[5];
  }
  set outTransitionOptions(outTransitionOptions) {
    this.$$set({ outTransitionOptions });
    flush();
  }
}
const ApplicationShell$1 = ApplicationShell;
const DialogContent_svelte_svelte_type_style_lang = "";
function get_each_context$g(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i2];
  return child_ctx;
}
function create_if_block_3$c(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*dialogProps*/
    ctx[7]
  ];
  var switch_value = (
    /*dialogClass*/
    ctx[6]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*dialogProps*/
    128) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*dialogProps*/
        ctx2[7]
      )]);
    } else {
      for (let i2 = 0; i2 < switch_instance_spread_levels.length; i2 += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i2]);
      }
    }
    return { props: switch_instance_props };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component(switch_value, switch_props(ctx));
    ctx[16](switch_instance);
  }
  return {
    c() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert(target, switch_instance_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*dialogClass*/
      64 && switch_value !== (switch_value = /*dialogClass*/
      ctx2[6])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component(switch_value, switch_props(ctx2, dirty));
          ctx2[16](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*dialogProps*/
        128 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*dialogProps*/
          ctx2[7]
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(switch_instance_anchor);
      }
      ctx[16](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
}
function create_if_block_2$f(ctx) {
  let html_tag;
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(
        /*content*/
        ctx[3],
        target,
        anchor
      );
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*content*/
      8)
        html_tag.p(
          /*content*/
          ctx2[3]
        );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_if_block$Q(ctx) {
  let div2;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ensure_array_like(
    /*buttons*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*button*/
    ctx2[26].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$g(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$g(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(div2, "class", "dialog-buttons tjs-dialog-buttons svelte-mobile-companion81nkluj30u9vsd-1ez4adq");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      ctx[20](div2);
    },
    p(ctx2, dirty) {
      if (dirty & /*buttons, onClick, currentButtonId*/
      530) {
        each_value = ensure_array_like(
          /*buttons*/
          ctx2[1]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div2, destroy_block, create_each_block$g, null, get_each_context$g);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      ctx[20](null);
    }
  };
}
function create_if_block_1$o(ctx) {
  let html_tag;
  let raw_value = (
    /*button*/
    ctx[26].icon + ""
  );
  let html_anchor;
  return {
    c() {
      html_tag = new HtmlTag(false);
      html_anchor = empty();
      html_tag.a = html_anchor;
    },
    m(target, anchor) {
      html_tag.m(raw_value, target, anchor);
      insert(target, html_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*buttons*/
      2 && raw_value !== (raw_value = /*button*/
      ctx2[26].icon + ""))
        html_tag.p(raw_value);
    },
    d(detaching) {
      if (detaching) {
        detach(html_anchor);
        html_tag.d();
      }
    }
  };
}
function create_each_block$g(key_1, ctx) {
  let button_1;
  let span;
  let t0_value = (
    /*button*/
    ctx[26].label + ""
  );
  let t0;
  let span_title_value;
  let t1;
  let button_1_class_value;
  let button_1_disabled_value;
  let applyStyles_action;
  let mounted;
  let dispose;
  let if_block = (
    /*button*/
    ctx[26].icon && create_if_block_1$o(ctx)
  );
  function click_handler() {
    return (
      /*click_handler*/
      ctx[18](
        /*button*/
        ctx[26]
      )
    );
  }
  function focus_handler() {
    return (
      /*focus_handler*/
      ctx[19](
        /*button*/
        ctx[26]
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      button_1 = element("button");
      span = element("span");
      if (if_block)
        if_block.c();
      t0 = text(t0_value);
      t1 = space();
      attr(span, "title", span_title_value = /*button*/
      ctx[26].title);
      attr(button_1, "class", button_1_class_value = "dialog-button tjs-dialog-button " + /*button*/
      ctx[26].id + " svelte-mobile-companion81nkluj30u9vsd-1ez4adq");
      button_1.disabled = button_1_disabled_value = /*button*/
      ctx[26].disabled;
      this.first = button_1;
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, span);
      if (if_block)
        if_block.m(span, null);
      append(span, t0);
      append(button_1, t1);
      if (!mounted) {
        dispose = [
          listen(button_1, "click", stop_propagation(prevent_default(click_handler))),
          listen(button_1, "focus", focus_handler),
          action_destroyer(applyStyles_action = applyStyles.call(
            null,
            button_1,
            /*button*/
            ctx[26].styles
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*button*/
        ctx[26].icon
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_1$o(ctx);
          if_block.c();
          if_block.m(span, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*buttons*/
      2 && t0_value !== (t0_value = /*button*/
      ctx[26].label + ""))
        set_data(t0, t0_value);
      if (dirty & /*buttons*/
      2 && span_title_value !== (span_title_value = /*button*/
      ctx[26].title)) {
        attr(span, "title", span_title_value);
      }
      if (dirty & /*buttons*/
      2 && button_1_class_value !== (button_1_class_value = "dialog-button tjs-dialog-button " + /*button*/
      ctx[26].id + " svelte-mobile-companion81nkluj30u9vsd-1ez4adq")) {
        attr(button_1, "class", button_1_class_value);
      }
      if (dirty & /*buttons*/
      2 && button_1_disabled_value !== (button_1_disabled_value = /*button*/
      ctx[26].disabled)) {
        button_1.disabled = button_1_disabled_value;
      }
      if (applyStyles_action && is_function(applyStyles_action.update) && dirty & /*buttons*/
      2)
        applyStyles_action.update.call(
          null,
          /*button*/
          ctx[26].styles
        );
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$15(ctx) {
  let main2;
  let div2;
  let current_block_type_index;
  let if_block0;
  let t;
  let current;
  const if_block_creators = [create_if_block_2$f, create_if_block_3$c];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (typeof /*content*/
    ctx2[3] === "string")
      return 0;
    if (
      /*dialogClass*/
      ctx2[6]
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block1 = (
    /*buttons*/
    ctx[1].length && create_if_block$Q(ctx)
  );
  return {
    c() {
      main2 = element("main");
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      attr(div2, "class", "dialog-content");
    },
    m(target, anchor) {
      insert(target, main2, anchor);
      append(main2, div2);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div2, null);
      }
      ctx[17](div2);
      append(main2, t);
      if (if_block1)
        if_block1.m(main2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block0) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block0 = if_blocks[current_block_type_index];
          if (!if_block0) {
            if_block0 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block0.c();
          } else {
            if_block0.p(ctx2, dirty);
          }
          transition_in(if_block0, 1);
          if_block0.m(div2, null);
        } else {
          if_block0 = null;
        }
      }
      if (
        /*buttons*/
        ctx2[1].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$Q(ctx2);
          if_block1.c();
          if_block1.m(main2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(main2);
      }
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      ctx[17](null);
      if (if_block1)
        if_block1.d();
    }
  };
}
const s_REGEX_HTML = /^\s*<.*>$/;
function instance$15($$self, $$props, $$invalidate) {
  let autoClose;
  let focusFirst;
  let resolveId;
  let $elementRoot;
  let { data = void 0 } = $$props;
  let { preventDefault = false } = $$props;
  let { stopPropagation = false } = $$props;
  let { dialogComponent = void 0 } = $$props;
  let buttons;
  let contentEl;
  let buttonsEl;
  let content = void 0;
  let dialogClass;
  let dialogProps = {};
  let { elementRoot } = getContext("#internal").stores;
  component_subscribe($$self, elementRoot, (value) => $$invalidate(15, $elementRoot = value));
  let { application } = getContext("#external");
  let managedPromise = getContext("#managedPromise");
  let currentButtonId = data.default;
  onDestroy(() => {
    const rootEl = $elementRoot;
    if (rootEl instanceof HTMLElement) {
      rootEl.removeEventListener("keydown", onKeydown);
      rootEl.removeEventListener("keyup", onKeyup);
    }
  });
  onMount(() => {
    if (focusFirst) {
      const focusEl = A11yHelper.getFirstFocusableElement(contentEl);
      if (focusEl instanceof HTMLElement) {
        setTimeout(() => focusEl.focus(), 0);
      }
    }
  });
  function onClick(button) {
    try {
      let result = void 0;
      const callback = button?.onPress;
      switch (typeof callback) {
        case "function":
          result = callback(application);
          break;
        case "string":
          if (dialogComponent !== void 0 && typeof dialogComponent[callback] === "function") {
            result = dialogComponent[callback](application);
          } else {
            if (dialogComponent === void 0) {
              console.warn(`[TRL] TJSDialog warning: 'onPress' defined as a string with no associated content Svelte component.`);
            } else if (typeof dialogComponent?.[callback] !== "function") {
              console.warn(`[TRL] TJSDialog warning: The content Svelte component does not contain an associated function '${callback}'. Did you remember to add '<svelte:options accessors={true} />' and export the function?`);
            }
          }
          break;
      }
      if (button.autoClose && autoClose) {
        if (resolveId && result === void 0) {
          result = button.id;
        }
        managedPromise.resolve(result);
      }
    } catch (err) {
      const notifyError = typeof data.notifyError === "boolean" ? data.notifyError : true;
      if (notifyError) {
        globalThis.ui.notifications.error(err, { console: false });
      }
      if (!managedPromise.reject(err)) {
        throw err;
      }
    } finally {
      if (button.autoClose && autoClose) {
        application.close();
      }
    }
  }
  function onKeydown(event) {
    switch (event.code) {
      case "ArrowLeft":
      case "ArrowRight":
      case "Enter":
        event.stopPropagation();
        break;
      case "Tab":
        event.stopPropagation();
        setTimeout(
          () => {
            const activeElement = document.activeElement;
            if (activeElement instanceof HTMLElement && buttonsEl instanceof HTMLElement && buttonsEl.contains(activeElement)) {
              for (let cntr = 0; cntr < activeElement.classList.length; cntr++) {
                const item = activeElement.classList.item(cntr);
                if (item !== "dialog-button" && item !== "default" && typeof data.buttons[item] !== void 0) {
                  $$invalidate(4, currentButtonId = item);
                  break;
                }
              }
            }
          },
          0
        );
        break;
      default:
        if (preventDefault) {
          event.preventDefault();
        }
        if (stopPropagation) {
          event.stopPropagation();
        }
        break;
    }
  }
  function onKeyup(event) {
    switch (event.code) {
      case "ArrowLeft": {
        event.preventDefault();
        event.stopPropagation();
        const activeEl = document.activeElement;
        if (buttonsEl instanceof HTMLElement) {
          if (activeEl instanceof HTMLElement && buttonsEl.contains(activeEl)) {
            const currentIndex = buttons.findIndex((button) => button.id === currentButtonId);
            if (buttons.length && currentIndex > 0) {
              $$invalidate(4, currentButtonId = buttons[currentIndex - 1].id);
            }
          }
          const buttonEl = buttonsEl.querySelector(`.${currentButtonId}`);
          if (buttonEl instanceof HTMLElement) {
            buttonEl.focus();
          }
        }
        break;
      }
      case "ArrowRight": {
        event.preventDefault();
        event.stopPropagation();
        const activeEl = document.activeElement;
        if (buttonsEl instanceof HTMLElement) {
          if (activeEl instanceof HTMLElement && (buttonsEl.contains(activeEl) || currentButtonId === void 0)) {
            const currentIndex = buttons.findIndex((button) => button.id === currentButtonId);
            if (buttons.length && currentIndex < buttons.length - 1) {
              $$invalidate(4, currentButtonId = buttons[currentIndex + 1].id);
            }
          }
          const buttonEl = buttonsEl.querySelector(`.${currentButtonId}`);
          if (buttonEl instanceof HTMLElement) {
            buttonEl.focus();
          }
        }
        break;
      }
      case "Enter":
        event.preventDefault();
        event.stopPropagation();
        break;
      default:
        if (preventDefault) {
          event.preventDefault();
        }
        if (stopPropagation) {
          event.stopPropagation();
        }
        break;
    }
  }
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      dialogComponent = $$value;
      $$invalidate(0, dialogComponent);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      contentEl = $$value;
      $$invalidate(5, contentEl);
    });
  }
  const click_handler = (button) => onClick(button);
  const focus_handler = (button) => $$invalidate(4, currentButtonId = button.id);
  function div_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonsEl = $$value;
      $$invalidate(2, buttonsEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("data" in $$props2)
      $$invalidate(10, data = $$props2.data);
    if ("preventDefault" in $$props2)
      $$invalidate(11, preventDefault = $$props2.preventDefault);
    if ("stopPropagation" in $$props2)
      $$invalidate(12, stopPropagation = $$props2.stopPropagation);
    if ("dialogComponent" in $$props2)
      $$invalidate(0, dialogComponent = $$props2.dialogComponent);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$elementRoot*/
    32768) {
      if ($elementRoot) {
        const rootEl = $elementRoot;
        if (rootEl instanceof HTMLElement) {
          rootEl.addEventListener("keydown", onKeydown);
          rootEl.addEventListener("keyup", onKeyup);
        }
      }
    }
    if ($$self.$$.dirty & /*data*/
    1024) {
      $$invalidate(13, autoClose = typeof data.autoClose === "boolean" ? data.autoClose : true);
    }
    if ($$self.$$.dirty & /*data*/
    1024) {
      $$invalidate(14, focusFirst = typeof data.focusFirst === "boolean" ? data.focusFirst : false);
    }
    if ($$self.$$.dirty & /*data*/
    1024) {
      {
        $$invalidate(1, buttons = !isObject$1(data.buttons) ? [] : Object.keys(data.buttons).reduce(
          (array, key) => {
            const b = data.buttons[key];
            const icon = typeof b.icon !== "string" ? void 0 : s_REGEX_HTML.test(b.icon) ? b.icon : `<i class="${b.icon}"></i>`;
            const autoClose2 = typeof b.autoClose === "boolean" ? b.autoClose : true;
            const disabled = typeof b.disabled === "boolean" ? b.disabled : false;
            const label = typeof b.label === "string" ? `${icon !== void 0 ? " " : ""}${localize(b.label)}` : "";
            const title = typeof b.title === "string" ? localize(b.title) : void 0;
            const condition = typeof b.condition === "function" ? b.condition.call(b) : b.condition ?? true;
            if (condition) {
              array.push({
                ...b,
                id: key,
                autoClose: autoClose2,
                icon,
                label,
                title,
                disabled
              });
            }
            return array;
          },
          []
        ));
      }
    }
    if ($$self.$$.dirty & /*buttons, currentButtonId*/
    18) {
      if (!buttons.find((button) => button.id === currentButtonId)) {
        $$invalidate(4, currentButtonId = void 0);
      }
    }
    if ($$self.$$.dirty & /*focusFirst, buttonsEl, currentButtonId*/
    16404) {
      if (!focusFirst && buttonsEl instanceof HTMLElement) {
        const buttonEl = buttonsEl.querySelector(`.${currentButtonId}`);
        if (buttonEl instanceof HTMLElement) {
          buttonEl.focus();
        }
      }
    }
    if ($$self.$$.dirty & /*data*/
    1024) {
      resolveId = typeof data.resolveId === "boolean" ? data.resolveId : false;
    }
    if ($$self.$$.dirty & /*content, data*/
    1032) {
      if (content !== data.content) {
        $$invalidate(
          3,
          content = data.content
        );
        try {
          if (isSvelteComponent(content)) {
            $$invalidate(6, dialogClass = content);
            $$invalidate(7, dialogProps = {});
          } else if (isObject$1(content)) {
            const svelteConfig = parseTJSSvelteConfig(content, application);
            $$invalidate(6, dialogClass = svelteConfig.class);
            $$invalidate(7, dialogProps = svelteConfig.props ?? {});
            const children2 = svelteConfig?.context?.get("external")?.children;
            if (Array.isArray(children2)) {
              $$invalidate(7, dialogProps.children = children2, dialogProps);
            }
          } else {
            $$invalidate(6, dialogClass = void 0);
            $$invalidate(7, dialogProps = {});
          }
        } catch (err) {
          $$invalidate(6, dialogClass = void 0);
          $$invalidate(7, dialogProps = {});
          $$invalidate(3, content = err.message);
          console.error(err);
        }
      }
    }
  };
  return [
    dialogComponent,
    buttons,
    buttonsEl,
    content,
    currentButtonId,
    contentEl,
    dialogClass,
    dialogProps,
    elementRoot,
    onClick,
    data,
    preventDefault,
    stopPropagation,
    autoClose,
    focusFirst,
    $elementRoot,
    switch_instance_binding,
    div_binding,
    click_handler,
    focus_handler,
    div_binding_1
  ];
}
class DialogContent extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$15, create_fragment$15, safe_not_equal, {
      data: 10,
      preventDefault: 11,
      stopPropagation: 12,
      dialogComponent: 0
    });
  }
}
const DialogContent$1 = DialogContent;
function create_else_block$6(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let updating_elementContent;
  let current;
  const applicationshell_spread_levels = [
    /*appProps*/
    ctx[6],
    { appOffsetHeight: true }
  ];
  function applicationshell_elementRoot_binding_1(value) {
    ctx[15](value);
  }
  function applicationshell_elementContent_binding_1(value) {
    ctx[16](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot_2$1] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < applicationshell_spread_levels.length; i2 += 1) {
    applicationshell_props = assign(applicationshell_props, applicationshell_spread_levels[i2]);
  }
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  if (
    /*elementContent*/
    ctx[1] !== void 0
  ) {
    applicationshell_props.elementContent = /*elementContent*/
    ctx[1];
  }
  applicationshell = new ApplicationShell$1({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding_1));
  binding_callbacks.push(() => bind(applicationshell, "elementContent", applicationshell_elementContent_binding_1));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = dirty & /*appProps*/
      64 ? get_spread_update(applicationshell_spread_levels, [
        get_spread_object(
          /*appProps*/
          ctx2[6]
        ),
        applicationshell_spread_levels[1]
      ]) : {};
      if (dirty & /*$$scope, data, dialogComponent*/
      4194316) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      if (!updating_elementContent && dirty & /*elementContent*/
      2) {
        updating_elementContent = true;
        applicationshell_changes.elementContent = /*elementContent*/
        ctx2[1];
        add_flush_callback(() => updating_elementContent = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function create_if_block$P(ctx) {
  let tjsglasspane;
  let current;
  const tjsglasspane_spread_levels = [
    {
      id: `${/*application*/
      ctx[4].id}-glasspane`
    },
    /*modalProps*/
    ctx[7],
    { zIndex: (
      /*zIndex*/
      ctx[8]
    ) }
  ];
  let tjsglasspane_props = {
    $$slots: { default: [create_default_slot$5] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < tjsglasspane_spread_levels.length; i2 += 1) {
    tjsglasspane_props = assign(tjsglasspane_props, tjsglasspane_spread_levels[i2]);
  }
  tjsglasspane = new TJSGlassPane$1({ props: tjsglasspane_props });
  tjsglasspane.$on(
    "close:glasspane",
    /*close_glasspane_handler*/
    ctx[13]
  );
  return {
    c() {
      create_component(tjsglasspane.$$.fragment);
    },
    m(target, anchor) {
      mount_component(tjsglasspane, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const tjsglasspane_changes = dirty & /*application, modalProps, zIndex*/
      400 ? get_spread_update(tjsglasspane_spread_levels, [
        dirty & /*application*/
        16 && {
          id: `${/*application*/
          ctx2[4].id}-glasspane`
        },
        dirty & /*modalProps*/
        128 && get_spread_object(
          /*modalProps*/
          ctx2[7]
        ),
        dirty & /*zIndex*/
        256 && { zIndex: (
          /*zIndex*/
          ctx2[8]
        ) }
      ]) : {};
      if (dirty & /*$$scope, appProps, elementRoot, elementContent, data, dialogComponent*/
      4194383) {
        tjsglasspane_changes.$$scope = { dirty, ctx: ctx2 };
      }
      tjsglasspane.$set(tjsglasspane_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(tjsglasspane.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(tjsglasspane.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(tjsglasspane, detaching);
    }
  };
}
function create_default_slot_2$1(ctx) {
  let dialogcontent;
  let updating_dialogComponent;
  let current;
  function dialogcontent_dialogComponent_binding_1(value) {
    ctx[14](value);
  }
  let dialogcontent_props = { data: (
    /*data*/
    ctx[3]
  ) };
  if (
    /*dialogComponent*/
    ctx[2] !== void 0
  ) {
    dialogcontent_props.dialogComponent = /*dialogComponent*/
    ctx[2];
  }
  dialogcontent = new DialogContent$1({ props: dialogcontent_props });
  binding_callbacks.push(() => bind(dialogcontent, "dialogComponent", dialogcontent_dialogComponent_binding_1));
  return {
    c() {
      create_component(dialogcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dialogcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dialogcontent_changes = {};
      if (dirty & /*data*/
      8)
        dialogcontent_changes.data = /*data*/
        ctx2[3];
      if (!updating_dialogComponent && dirty & /*dialogComponent*/
      4) {
        updating_dialogComponent = true;
        dialogcontent_changes.dialogComponent = /*dialogComponent*/
        ctx2[2];
        add_flush_callback(() => updating_dialogComponent = false);
      }
      dialogcontent.$set(dialogcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dialogcontent, detaching);
    }
  };
}
function create_default_slot_1$1(ctx) {
  let dialogcontent;
  let updating_dialogComponent;
  let current;
  function dialogcontent_dialogComponent_binding(value) {
    ctx[10](value);
  }
  let dialogcontent_props = {
    data: (
      /*data*/
      ctx[3]
    ),
    stopPropagation: true
  };
  if (
    /*dialogComponent*/
    ctx[2] !== void 0
  ) {
    dialogcontent_props.dialogComponent = /*dialogComponent*/
    ctx[2];
  }
  dialogcontent = new DialogContent$1({ props: dialogcontent_props });
  binding_callbacks.push(() => bind(dialogcontent, "dialogComponent", dialogcontent_dialogComponent_binding));
  return {
    c() {
      create_component(dialogcontent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dialogcontent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dialogcontent_changes = {};
      if (dirty & /*data*/
      8)
        dialogcontent_changes.data = /*data*/
        ctx2[3];
      if (!updating_dialogComponent && dirty & /*dialogComponent*/
      4) {
        updating_dialogComponent = true;
        dialogcontent_changes.dialogComponent = /*dialogComponent*/
        ctx2[2];
        add_flush_callback(() => updating_dialogComponent = false);
      }
      dialogcontent.$set(dialogcontent_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dialogcontent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dialogcontent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dialogcontent, detaching);
    }
  };
}
function create_default_slot$5(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let updating_elementContent;
  let current;
  const applicationshell_spread_levels = [
    /*appProps*/
    ctx[6],
    { appOffsetHeight: true }
  ];
  function applicationshell_elementRoot_binding(value) {
    ctx[11](value);
  }
  function applicationshell_elementContent_binding(value) {
    ctx[12](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot_1$1] },
    $$scope: { ctx }
  };
  for (let i2 = 0; i2 < applicationshell_spread_levels.length; i2 += 1) {
    applicationshell_props = assign(applicationshell_props, applicationshell_spread_levels[i2]);
  }
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  if (
    /*elementContent*/
    ctx[1] !== void 0
  ) {
    applicationshell_props.elementContent = /*elementContent*/
    ctx[1];
  }
  applicationshell = new ApplicationShell$1({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  binding_callbacks.push(() => bind(applicationshell, "elementContent", applicationshell_elementContent_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const applicationshell_changes = dirty & /*appProps*/
      64 ? get_spread_update(applicationshell_spread_levels, [
        get_spread_object(
          /*appProps*/
          ctx2[6]
        ),
        applicationshell_spread_levels[1]
      ]) : {};
      if (dirty & /*$$scope, data, dialogComponent*/
      4194316) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      if (!updating_elementContent && dirty & /*elementContent*/
      2) {
        updating_elementContent = true;
        applicationshell_changes.elementContent = /*elementContent*/
        ctx2[1];
        add_flush_callback(() => updating_elementContent = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function create_fragment$14(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block$P, create_else_block$6];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*modal*/
      ctx2[5]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
const s_MODAL_BACKGROUND = "#50505080";
function instance$14($$self, $$props, $$invalidate) {
  let { elementContent = void 0 } = $$props;
  let { elementRoot = void 0 } = $$props;
  let { data = {} } = $$props;
  let { dialogComponent = void 0 } = $$props;
  let { managedPromise = void 0 } = $$props;
  const application = getContext("#external").application;
  const dialogOptions = writable({});
  setContext("#managedPromise", managedPromise);
  setContext("#dialogOptions", dialogOptions);
  const s_MODAL_TRANSITION = fade;
  const s_MODAL_TRANSITION_OPTIONS = { duration: 200 };
  let modal = void 0;
  const appProps = {
    // Stores any transition functions.
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    // Stores properties to set for options for any transitions.
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0,
    // Stores any style overrides for application shell.
    stylesApp: void 0,
    stylesContent: void 0
  };
  const modalProps = {
    // Background CSS style string.
    background: void 0,
    slotSeparate: void 0,
    styles: void 0,
    // Close modal on glasspane input.
    closeOnInput: void 0,
    // Stores any transition functions.
    transition: void 0,
    inTransition: void 0,
    outTransition: void 0,
    // Stores properties to set for options for any transitions.
    transitionOptions: void 0,
    inTransitionOptions: void 0,
    outTransitionOptions: void 0
  };
  let zIndex = void 0;
  if (modal === void 0) {
    modal = typeof data?.modal === "boolean" ? data.modal : false;
  }
  if (modal) {
    onDestroy(() => window.removeEventListener("keydown", onKeydownModal, { capture: true }));
    onMount(() => window.addEventListener("keydown", onKeydownModal, { capture: true }));
  } else {
    onDestroy(() => document.removeEventListener("keydown", onKeydown));
    onMount(() => document.addEventListener("keydown", onKeydown));
  }
  function onKeydown(event) {
    if (event.code === "Escape") {
      event.preventDefault();
      event.stopPropagation();
      application.close();
    }
  }
  function onKeydownModal(event) {
    if (event.code === "Escape") {
      event.preventDefault();
      event.stopImmediatePropagation();
      application.close();
    }
  }
  function dialogcontent_dialogComponent_binding(value) {
    dialogComponent = value;
    $$invalidate(2, dialogComponent);
  }
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  function applicationshell_elementContent_binding(value) {
    elementContent = value;
    $$invalidate(1, elementContent);
  }
  const close_glasspane_handler = () => application.close();
  function dialogcontent_dialogComponent_binding_1(value) {
    dialogComponent = value;
    $$invalidate(2, dialogComponent);
  }
  function applicationshell_elementRoot_binding_1(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  function applicationshell_elementContent_binding_1(value) {
    elementContent = value;
    $$invalidate(1, elementContent);
  }
  $$self.$$set = ($$props2) => {
    if ("elementContent" in $$props2)
      $$invalidate(1, elementContent = $$props2.elementContent);
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("data" in $$props2)
      $$invalidate(3, data = $$props2.data);
    if ("dialogComponent" in $$props2)
      $$invalidate(2, dialogComponent = $$props2.dialogComponent);
    if ("managedPromise" in $$props2)
      $$invalidate(9, managedPromise = $$props2.managedPromise);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*elementRoot, modal*/
    33) {
      if (elementRoot instanceof HTMLElement) {
        elementRoot.setAttribute("role", "dialog");
        if (modal) {
          elementRoot.setAttribute("aria-modal", "true");
        }
      }
    }
    if ($$self.$$.dirty & /*data, modal, zIndex, application*/
    312) {
      if (isObject$1(data)) {
        dialogOptions.set(klona(data));
        const newZIndex = Number.isInteger(data.zIndex) || data.zIndex === null ? data.zIndex : modal ? Number.MAX_SAFE_INTEGER : Number.MAX_SAFE_INTEGER - 1;
        if (zIndex !== newZIndex) {
          $$invalidate(8, zIndex = newZIndex);
        }
        const newDraggable = typeof data.draggable === "boolean" ? data.draggable : void 0;
        if (newDraggable !== void 0 && application.reactive.draggable !== newDraggable) {
          $$invalidate(4, application.reactive.draggable = newDraggable, application);
        }
        const newFocusAuto = typeof data.focusAuto === "boolean" ? data.focusAuto : void 0;
        if (newFocusAuto !== void 0 && application.reactive.focusAuto !== newFocusAuto) {
          $$invalidate(4, application.reactive.focusAuto = newFocusAuto, application);
        }
        const newFocusKeep = typeof data.focusKeep === "boolean" ? data.focusKeep : void 0;
        if (newFocusKeep !== void 0 && application.reactive.focusKeep !== newFocusKeep) {
          $$invalidate(4, application.reactive.focusKeep = newFocusKeep, application);
        }
        const newFocusTrap = typeof data.focusTrap === "boolean" ? data.focusTrap : void 0;
        if (newFocusTrap !== void 0 && application.reactive.focusTrap !== newFocusTrap) {
          $$invalidate(4, application.reactive.focusTrap = newFocusTrap, application);
        }
        const newMinimizable = typeof data.minimizable === "boolean" ? data.minimizable : void 0;
        if (newMinimizable !== void 0 && application.reactive.minimizable !== newMinimizable) {
          $$invalidate(4, application.reactive.minimizable = newMinimizable, application);
        }
        const newResizable = typeof data.resizable === "boolean" ? data.resizable : void 0;
        if (newResizable !== void 0 && application.reactive.resizable !== newResizable) {
          $$invalidate(4, application.reactive.resizable = newResizable, application);
        }
        const newTitle = data.title ?? "Dialog";
        if (newTitle !== application?.options?.title) {
          $$invalidate(4, application.reactive.title = newTitle, application);
        }
        if (application.position.zIndex !== zIndex) {
          $$invalidate(4, application.position.zIndex = zIndex, application);
        }
      }
    }
    if ($$self.$$.dirty & /*data, appProps*/
    72) {
      if (isObject$1(data?.transition)) {
        const d = data.transition;
        if (d?.transition !== appProps.transition) {
          $$invalidate(6, appProps.transition = d.transition, appProps);
        }
        if (d?.inTransition !== appProps.inTransition) {
          $$invalidate(6, appProps.inTransition = d.inTransition, appProps);
        }
        if (d?.outTransition !== appProps.outTransition) {
          $$invalidate(6, appProps.outTransition = d.outTransition, appProps);
        }
        if (d?.transitionOptions !== appProps.transitionOptions) {
          $$invalidate(6, appProps.transitionOptions = d.transitionOptions, appProps);
        }
        if (d?.inTransitionOptions !== appProps.inTransitionOptions) {
          $$invalidate(6, appProps.inTransitionOptions = d.inTransitionOptions, appProps);
        }
        if (d?.outTransitionOptions !== appProps.outTransitionOptions) {
          $$invalidate(6, appProps.outTransitionOptions = d.outTransitionOptions, appProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      {
        const newModalBackground = typeof data?.modalOptions?.background === "string" ? data.modalOptions.background : s_MODAL_BACKGROUND;
        if (newModalBackground !== modalProps.background) {
          $$invalidate(7, modalProps.background = newModalBackground, modalProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      {
        const newModalSlotSeparate = typeof data?.modalOptions?.slotSeparate === "boolean" ? data.modalOptions.slotSeparate : void 0;
        if (newModalSlotSeparate !== modalProps.slotSeparate) {
          $$invalidate(7, modalProps.slotSeparate = newModalSlotSeparate, modalProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      {
        const newModalStyles = isObject$1(data?.modalOptions?.styles) ? data.modalOptions.styles : void 0;
        if (newModalStyles !== modalProps.styles) {
          $$invalidate(7, modalProps.styles = newModalStyles, modalProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      {
        const newModalCloseOnInput = typeof data?.modalOptions?.closeOnInput === "boolean" ? data.modalOptions.closeOnInput : void 0;
        if (newModalCloseOnInput !== modalProps.closeOnInput) {
          $$invalidate(7, modalProps.closeOnInput = newModalCloseOnInput, modalProps);
        }
      }
    }
    if ($$self.$$.dirty & /*data, modalProps*/
    136) {
      if (isObject$1(data?.modalOptions?.transition)) {
        const d = data.modalOptions.transition;
        if (d?.transition !== modalProps.transition) {
          $$invalidate(
            7,
            modalProps.transition = typeof d?.transition === "function" ? d.transition : s_MODAL_TRANSITION,
            modalProps
          );
        }
        if (d?.inTransition !== modalProps.inTransition) {
          $$invalidate(7, modalProps.inTransition = d.inTransition, modalProps);
        }
        if (d?.outTransition !== modalProps.outTransition) {
          $$invalidate(7, modalProps.outTransition = d.outTransition, modalProps);
        }
        if (d?.transitionOptions !== modalProps.transitionOptions) {
          $$invalidate(
            7,
            modalProps.transitionOptions = isObject$1(d?.transitionOptions) ? d.transitionOptions : s_MODAL_TRANSITION_OPTIONS,
            modalProps
          );
        }
        if (d?.inTransitionOptions !== modalProps.inTransitionOptions) {
          $$invalidate(7, modalProps.inTransitionOptions = d.inTransitionOptions, modalProps);
        }
        if (d?.outTransitionOptions !== modalProps.outTransitionOptions) {
          $$invalidate(7, modalProps.outTransitionOptions = d.outTransitionOptions, modalProps);
        }
      } else {
        const newModalTransition = typeof data?.modalOptions?.transition?.transition === "function" ? data.modalOptions.transition.transition : s_MODAL_TRANSITION;
        if (newModalTransition !== modalProps.transition) {
          $$invalidate(7, modalProps.transition = newModalTransition, modalProps);
        }
        const newModalTransitionOptions = isObject$1(data?.modalOptions?.transitionOptions) ? data.modalOptions.transitionOptions : s_MODAL_TRANSITION_OPTIONS;
        if (newModalTransitionOptions !== modalProps.transitionOptions) {
          $$invalidate(7, modalProps.transitionOptions = newModalTransitionOptions, modalProps);
        }
      }
    }
  };
  return [
    elementRoot,
    elementContent,
    dialogComponent,
    data,
    application,
    modal,
    appProps,
    modalProps,
    zIndex,
    managedPromise,
    dialogcontent_dialogComponent_binding,
    applicationshell_elementRoot_binding,
    applicationshell_elementContent_binding,
    close_glasspane_handler,
    dialogcontent_dialogComponent_binding_1,
    applicationshell_elementRoot_binding_1,
    applicationshell_elementContent_binding_1
  ];
}
class DialogShell extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$14, create_fragment$14, safe_not_equal, {
      elementContent: 1,
      elementRoot: 0,
      data: 3,
      dialogComponent: 2,
      managedPromise: 9
    });
  }
  get elementContent() {
    return this.$$.ctx[1];
  }
  set elementContent(elementContent) {
    this.$$set({ elementContent });
    flush();
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get data() {
    return this.$$.ctx[3];
  }
  set data(data) {
    this.$$set({ data });
    flush();
  }
  get dialogComponent() {
    return this.$$.ctx[2];
  }
  set dialogComponent(dialogComponent) {
    this.$$set({ dialogComponent });
    flush();
  }
  get managedPromise() {
    return this.$$.ctx[9];
  }
  set managedPromise(managedPromise) {
    this.$$set({ managedPromise });
    flush();
  }
}
const DialogShell$1 = DialogShell;
cssVariables.setProperties({
  // Anchor text shadow / header buttons
  "--tjs-default-text-shadow-focus-hover": "0 0 8px var(--color-shadow-primary)",
  // TJSApplicationShell app background.
  "--tjs-app-background": `url("${globalThis.foundry.utils.getRoute("/ui/denim075.png")}")`
}, false);
class ManagedPromise {
  /** @type {boolean} */
  static #logging = false;
  /** @type {{ isProcessing?: boolean, promise?: Promise, reject: Function, resolve: Function }} */
  #current;
  /**
   * @returns {boolean} Whether global logging is enabled.
   */
  static get logging() {
    return this.#logging;
  }
  /**
   * @returns {boolean} Whether there is an active managed Promise.
   */
  get isActive() {
    return this.#current !== void 0;
  }
  /**
   * @returns {boolean} Whether there is an active managed Promise and resolution is currently being processed.
   */
  get isProcessing() {
    return this.#current !== void 0 ? this.#current.isProcessing : false;
  }
  /**
   * Sets global logging enabled state.
   *
   * @param {boolean}  logging - New logging enabled state.
   */
  static set logging(logging) {
    if (typeof logging !== "boolean") {
      throw new TypeError(`[TRL] ManagedPromise.logging error: 'logging' is not a boolean.`);
    }
    this.#logging = logging;
  }
  // ----------------------------------------------------------------------------------------------------------------
  /**
   * Resolves any current Promise with undefined and creates a new current Promise.
   *
   * @template T
   *
   * @param {object} opts - Options.
   *
   * @param {boolean}  [opts.reuse=false] - When true if there is an existing live Promise it is returned immediately.
   *
   * @returns {Promise<T>} The new current managed Promise.
   */
  create({ reuse = false } = {}) {
    if (typeof reuse !== "boolean") {
      throw new TypeError(`[TRL] ManagedPromise.create error: 'reuse' is not a boolean.`);
    }
    if (reuse && this.#current !== void 0 && this.#current.promise instanceof Promise) {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.create info: Reusing / returning existing managed Promise.`);
      }
      return this.#current.promise;
    }
    if (this.#current !== void 0) {
      if (ManagedPromise.#logging) {
        console.warn(
          `[TRL] ManagedPromise.create info: Creating a new Promise and resolving existing immediately.`
        );
      }
      this.#current.resolve(void 0);
      this.#current = void 0;
    }
    const promise2 = new Promise((resolve2, reject) => {
      this.#current = {
        isProcessing: false,
        reject,
        resolve: resolve2
      };
    });
    this.#current.promise = promise2;
    return promise2;
  }
  /**
   * Gets the current Promise if any.
   *
   * @returns {Promise<any>} Current Promise.
   */
  get() {
    return this.#current ? this.#current.promise : void 0;
  }
  /**
   * Rejects the current Promise if applicable.
   *
   * @param {*}  [result] - Result to reject.
   *
   * @returns {boolean} Was the promise rejected.
   */
  reject(result = void 0) {
    if (this.#current !== void 0 && this.#current.isProcessing) {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.reject info: Currently processing promise.`);
      }
      return true;
    }
    if (this.#current !== void 0) {
      this.#current.isProcessing = true;
      if (result instanceof Promise) {
        result.then((value) => {
          this.#current.reject(value);
          this.#current = void 0;
        }).catch((err) => {
          this.#current.reject(err);
          this.#current = void 0;
        });
      } else {
        this.#current.reject(result);
        this.#current = void 0;
      }
      return true;
    } else {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.reject warning: No current managed Promise to reject.`);
      }
      return false;
    }
  }
  /**
   * Resolves the current Promise if applicable.
   *
   * @param {*}  [result] - Result to resolve.
   *
   * @returns {boolean} Was the promise resolved.
   */
  resolve(result = void 0) {
    if (this.#current !== void 0 && this.#current.isProcessing) {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.resolve info: Currently processing promise.`);
      }
      return true;
    }
    if (this.#current !== void 0) {
      if (result instanceof Promise) {
        this.#current.isProcessing = true;
        result.then((value) => {
          this.#current.resolve(value);
          this.#current = void 0;
        }).catch((err) => {
          this.#current.reject(err);
          this.#current = void 0;
        });
      } else {
        this.#current.resolve(result);
        this.#current = void 0;
      }
      return true;
    } else {
      if (ManagedPromise.#logging) {
        console.warn(`[TRL] ManagedPromise.resolve warning: No current managed Promise to resolve.`);
      }
      return false;
    }
  }
}
class TJSDialogData {
  /**
   * @type {import('../../index.js').SvelteApplication}
   */
  #application;
  /**
   * Stores the dialog options data.
   *
   * @type {import('./types').TJSDialogOptions}
   */
  #internal = {};
  /**
   * @param {import('../../index.js').SvelteApplication} application - The host Foundry application.
   */
  constructor(application) {
    this.#application = application;
  }
  /**
   * @returns {Record<string, import('./types').TJSDialogButtonData>} The dialog button configuration.
   */
  get buttons() {
    return this.#internal.buttons;
  }
  /**
   * Set the dialog button configuration.
   *
   * @param {string} buttons - New dialog button configuration.
   */
  set buttons(buttons) {
    this.#internal.buttons = buttons;
    this.#updateComponent();
  }
  /**
   * @returns {import('@typhonjs-fvtt/runtime/svelte/util').TJSSvelteConfig | string} The Svelte configuration object or HTML string
   *          content.
   */
  get content() {
    return this.#internal.content;
  }
  /**
   * Set the Svelte configuration object or HTML string content.
   *
   * @param {import('@typhonjs-fvtt/runtime/svelte/util').TJSSvelteConfig | string} content - New Svelte configuration object or
   *        HTML string content.
   */
  set content(content) {
    this.#internal.content = content;
    this.#updateComponent();
  }
  /**
   * @returns {string} The default button ID to focus initially.
   */
  get default() {
    return this.#internal.default;
  }
  /**
   * Set the default button ID to focus initially.
   *
   * @param {string} newDefault - New default button ID to focus initially.
   */
  set default(newDefault) {
    this.#internal.default = newDefault;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} The dialog draggable state; draggable when true.
   */
  get draggable() {
    return this.#internal.draggable;
  }
  /**
   * Set the dialog state; draggable when true.
   *
   * @param {boolean} draggable - New dialog draggable state; draggable when true.
   */
  set draggable(draggable2) {
    this.#internal.draggable = draggable2;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} When true auto-management of app focus is enabled.
   */
  get focusAuto() {
    return this.#internal.focusAuto;
  }
  /**
   * Set the dialog auto-management of app focus.
   *
   * @param {boolean} focusAuto - New dialog auto-management of app focus.
   */
  set focusAuto(focusAuto) {
    this.#internal.focusAuto = focusAuto;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} When true the first focusable element that isn't a button is focused.
   */
  get focusFirst() {
    return this.#internal.focusFirst;
  }
  /**
   * Set the dialog first focusable element state.
   *
   * @param {boolean} focusFirst - New dialog first focusable element state.
   */
  set focusFirst(focusFirst) {
    this.#internal.focusFirst = focusFirst;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} When `focusAuto` and `focusKeep` is true; keeps internal focus.
   */
  get focusKeep() {
    return this.#internal.focusKeep;
  }
  /**
   * Set the dialog `focusKeep` state. When `focusAuto` and `focusKeep` is true; keeps internal focus.
   *
   * @param {boolean} focusKeep - New dialog `focusKeep` state.
   */
  set focusKeep(focusKeep) {
    this.#internal.focusKeep = focusKeep;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} When true the dialog is minimizable.
   */
  get minimizable() {
    return this.#internal.minimizable;
  }
  /**
   * Set the dialog `minimizable` state. When true the dialog is minimizable.
   *
   * @param {boolean} minimizable - New dialog `minimizable` state.
   */
  set minimizable(minimizable) {
    this.#internal.minimizable = minimizable;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} When true a modal dialog is displayed.
   */
  get modal() {
    return this.#internal.modal;
  }
  /**
   * Set the dialog `modal` state. When true a modal dialog is displayed.
   *
   * @param {boolean} modal - New dialog `modal` state.
   */
  set modal(modal) {
    this.#internal.modal = modal;
    this.#updateComponent();
  }
  /**
   * @returns {import('./types').TJSDialogModalOptions} Additional options for modal dialog display.
   */
  get modalOptions() {
    return this.#internal.modalOptions;
  }
  /**
   * Set additional options for modal dialog display.
   *
   * @param {import('./types').TJSDialogModalOptions} modalOptions - New additional options for modal dialog display.
   */
  set modalOptions(modalOptions) {
    this.#internal.modalOptions = modalOptions;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} When true and an error is raised in dialog callback functions post a UI error notification.
   */
  get notifyError() {
    return this.#internal.notifyError;
  }
  /**
   * Set the dialog `notifyError` state. When true and an error is raised in dialog callback functions post a UI error
   * notification.
   *
   * @param {boolean} notifyError - New dialog `notifyError` state.
   */
  set notifyError(notifyError) {
    this.#internal.notifyError = notifyError;
    this.#updateComponent();
  }
  /**
   * @returns {string | ((application: import('../../index.js').TJSDialog) => any)} Callback invoked when dialog is
   *          closed; no button option selected. When defined as a string any matching function by name exported from
   *          content Svelte component is invoked.
   */
  get onClose() {
    return this.#internal.onClose;
  }
  /**
   * Set callback invoked when dialog is closed; no button option selected. When defined as a string any matching
   * function by name exported from content Svelte component is invoked..
   *
   * @param {string | ((application: import('../../index.js').TJSDialog) => any)} onClose - New dialog `onClose` state.
   */
  set onClose(onClose) {
    this.#internal.onClose = onClose;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} Dialog `rejectClose` state. When true and a Promise has been created by {@link TJSDialog.wait}
   *          and the Promise is not in the process of being resolved or rejected on close of the dialog any `onClose`
   *          function is invoked and any result that is undefined will cause the Promise to then be rejected..
   */
  get rejectClose() {
    return this.#internal.rejectClose;
  }
  /**
   * Set the dialog `rejectClose` state.
   *
   * @param {boolean} rejectClose - New dialog `rejectClose` state.
   */
  set rejectClose(rejectClose) {
    this.#internal.rejectClose = rejectClose;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} When true the dialog is resizable.
   */
  get resizable() {
    return this.#internal.resizable;
  }
  /**
   * Set the dialog `resizable` state. When true the dialog is resizable.
   *
   * @param {boolean} resizable - New dialog `resizable` state.
   */
  set resizable(resizable) {
    this.#internal.resizable = resizable;
    this.#updateComponent();
  }
  /**
   * @returns {boolean} When true and resolving any Promises and there are undefined results from any button callbacks
   *          the button ID is resolved.
   */
  get resolveId() {
    return this.#internal.resolveId;
  }
  /**
   * Set the dialog `resolveId` state. When true and resolving any Promises and there are undefined results from any
   * button callbacks the button ID is resolved.
   *
   * @param {boolean} resolveId - New dialog `resolveId` state.
   */
  set resolveId(resolveId) {
    this.#internal.resolveId = resolveId;
    this.#updateComponent();
  }
  /**
   * @returns {string} The dialog window title.
   */
  get title() {
    return this.#internal.title;
  }
  /**
   * Set the dialog window title.
   *
   * @param {string} title - New dialog window title.
   */
  set title(title) {
    this.#internal.title = title;
    this.#updateComponent();
  }
  /**
   * @returns {import('./types').TJSDialogTransitionOptions} Transition options for the dialog.
   */
  get transition() {
    return this.#internal.transition;
  }
  /**
   * Set transition options for the dialog.
   *
   * @param {import('./types').TJSDialogTransitionOptions} transition - New transition options for the dialog.
   */
  set transition(transition) {
    this.#internal.transition = transition;
    this.#updateComponent();
  }
  /**
   * @returns {number | null} A specific z-index for the dialog. Pass null for the dialog to act like other
   *          applications in regard bringing to top when activated.
   */
  get zIndex() {
    return this.#internal.zIndex;
  }
  /**
   * Set specific z-index for the dialog.
   *
   * @param {number | null} zIndex - New z-index for the dialog.
   */
  set zIndex(zIndex) {
    this.#internal.zIndex = zIndex;
    this.#updateComponent();
  }
  /**
   * Provides a way to safely get this dialogs data given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      [defaultValue] - A default value returned if the accessor is not found.
   *
   * @returns {any} Value at the accessor.
   */
  get(accessor, defaultValue) {
    return safeAccess(this.#internal, accessor, defaultValue);
  }
  /**
   * @param {import('./types').TJSDialogOptions} data - Merge provided data object into Dialog data.
   */
  merge(data) {
    deepMerge(this.#internal, data);
    this.#updateComponent();
  }
  /**
   * Sets the dialog data; this is reactive.
   *
   * @param {import('./types').TJSDialogOptions}   data - Dialog data.
   */
  replace(data) {
    if (!isObject$1(data)) {
      throw new TypeError(`TJSDialogData replace error: 'data' is not an object'.`);
    }
    this.#internal = {};
    this.merge(data);
  }
  /**
   * Provides a way to safely set this dialogs data given an accessor string which describes the
   * entries to walk. To access deeper entries into the object format the accessor string with `.` between entries
   * to walk.
   *
   * Automatically the dialog data will be updated in the associated DialogShell Svelte component.
   *
   * @param {string}   accessor - The path / key to set. You can set multiple levels.
   *
   * @param {any}      value - Value to set.
   *
   * @returns {boolean} True if successful.
   */
  set(accessor, value) {
    const success = safeSet(this.#internal, accessor, value);
    if (success) {
      this.#updateComponent();
    }
    return success;
  }
  /**
   * Updates the data in the Svelte dialog component.
   */
  #updateComponent() {
    const component = this.#application.svelte.component(0);
    if (component?.data) {
      component.data = this.#internal;
    }
  }
}
class TJSDialog extends SvelteApplication {
  /** @type {TJSDialogData} */
  #data;
  /** @type {ManagedPromise} */
  #managedPromise;
  /**
   * @param {import('./internal/state-dialog/types').TJSDialogOptions}           data - Dialog options.
   *
   * @param {import('./').SvelteApplicationOptions}   [options] - SvelteApplication options.
   */
  constructor(data, options = {}) {
    super(options);
    this.#managedPromise = new ManagedPromise();
    this.#data = new TJSDialogData(this);
    this.#data.replace(data);
    Object.defineProperty(this.svelte, "dialogComponent", {
      get: () => this.svelte?.applicationShell?.dialogComponent
    });
  }
  /**
   * Default options for TJSDialog. Provides a default width and setting `height` to `auto` to always display dialog
   * content even if it changes. The default `DialogShell` / `svelte` options should not be changed and instead mount
   * the dialog content component by supplying a Svelte configuration object to dialog data `content` field.
   *
   * @returns {import('./').SvelteApplicationOptions} Default options
   */
  static get defaultOptions() {
    return deepMerge(super.defaultOptions, {
      classes: ["dialog", "tjs-dialog"],
      width: 400,
      height: "auto",
      svelte: {
        class: DialogShell$1,
        intro: true,
        target: document.body,
        props: function() {
          return {
            data: this.#data,
            managedPromise: this.#managedPromise
          };
        }
      }
    });
  }
  /**
   * Returns the dialog data.
   *
   * @returns {import('./internal/state-dialog/types').TJSDialogData} Dialog data.
   */
  get data() {
    return this.#data;
  }
  /**
   * @returns {import('@typhonjs-fvtt/runtime/util/async').ManagedPromise} Returns the managed promise.
   */
  get managedPromise() {
    return this.#managedPromise;
  }
  /**
   * Close the dialog and un-register references to it within UI mappings.
   * This function returns a Promise which resolves once the window closing animation concludes.
   *
   * @param {object}   [options] - Optional parameters.
   *
   * @param {boolean}  [options.force] - Force close regardless of render state.
   *
   * @returns {Promise<void>} A Promise which resolves once the application is closed with the callback value or
   *                          `true`.
   */
  async close(options) {
    try {
      if (this.#managedPromise.isActive && !this.#managedPromise.isProcessing) {
        const result = TJSDialog.#invokeFn(this.#data.onClose, this, null);
        const rejectClose = typeof this.#data.rejectClose === "boolean" ? this.#data.rejectClose : false;
        if (rejectClose && result === null) {
          this.#managedPromise.reject(new Error("TJSDialog was closed without a choice being made."));
        } else {
          this.#managedPromise.resolve(result);
        }
      }
    } catch (err) {
      const notifyError = typeof this.#data.notifyError === "boolean" ? this.#data.notifyError : true;
      if (notifyError) {
        globalThis.ui.notifications.error(err, { console: false });
      }
      if (!this.#managedPromise.reject(err)) {
        throw err;
      }
    } finally {
      await super.close(options);
    }
  }
  /**
   * Brings to top or renders this dialog returning a Promise that is resolved any button pressed or when the dialog
   * is closed.
   *
   * Creates an anonymous data defined TJSDialog returning a Promise that can be awaited upon for the user to make a
   * choice.
   *
   * Note: `null` is returned if the dialog is closed without a user making a choice.
   *
   * @template T
   *
   * @param {object}   [options] - Options.
   *
   * @param {boolean}  [options.reuse=false] - When true if there is an existing managed Promise this allows multiple
   *        sources to await on the same result.
   *
   * @returns {Promise<T>} A promise for dialog resolution.
   */
  async wait(options) {
    if (this.rendered) {
      this.bringToTop();
    } else {
      this.render(true, { focus: true });
    }
    return this.#managedPromise.create(options);
  }
  // ---------------------------------------------------------------------------------------------------------------
  /**
   * A helper factory method to create simple confirmation dialog windows which consist of simple yes / no prompts.
   * If you require more flexibility, a custom TJSDialog instance is preferred. The default focused button is 'yes'.
   * You can change the default focused button by setting `default` to `yes` or `no`.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions & {
   *    onYes?: string|((application: TJSDialog) => any),
   *    onNo?: string|((application: TJSDialog) => any)
   * }} [data] - Confirm dialog options.
   *
   * @param {string|((application: TJSDialog) => any)} [data.onYes] - Callback function upon `yes`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {string|((application: TJSDialog) => any)} [data.onNo] - Callback function upon `no`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} A promise which resolves with result of yes / no callbacks or true / false.
   *
   * @example
   * const result = await TJSDialog.confirm({
   *  title: 'A Yes or No Question',
   *  content: '<p>Choose wisely.</p>',
   *  onYes: () => 'YES Result'
   *  onNo: () => 'NO Result'
   * });
   *
   * // Logs 'YES result', 'NO Result', or null if the user closed the dialog without making a selection.
   * console.log(result);
   */
  static async confirm({ onYes, onNo, ...data } = {}, options = {}) {
    const mergedButtons = deepMerge({
      yes: {
        icon: "fas fa-check",
        label: "Yes"
      },
      no: {
        icon: "fas fa-times",
        label: "No"
      }
    }, data.buttons ?? {});
    return this.wait({
      ...data,
      buttons: deepMerge(mergedButtons, {
        yes: {
          onPress: (application) => this.#invokeFn(onYes, application, true)
        },
        no: {
          onPress: (application) => this.#invokeFn(onNo, application, false)
        }
      }),
      default: data.default ?? "yes"
    }, options);
  }
  /**
   * A helper method to invoke a callback function directly or lookup an exported function with the same name from any
   * content Svelte component to invoke. This is used internally to apply default values for `confirm` and `prompt`.
   *
   * @param {string|((application: TJSDialog) => any)} callback - Callback function to invoke; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {TJSDialog} application - TJSDialog instance passed to callback.
   *
   * @param {*} [defaultResult] - An optional default result to return; undefined if not specified.
   *
   * @returns {*} Result.
   *
   * @internal
   */
  static #invokeFn(callback, application, defaultResult = void 0) {
    let result = defaultResult;
    switch (typeof callback) {
      case "function":
        result = callback(application);
        break;
      case "string": {
        const dialogComponent = application?.svelte?.dialogComponent;
        if (dialogComponent !== void 0 && typeof dialogComponent?.[callback] === "function") {
          result = dialogComponent?.[callback](application);
        } else {
          if (dialogComponent === void 0) {
            console.warn(`[TRL] TJSDialog warning: 'onPress' defined as a string with no associated content Svelte component.`);
          } else if (typeof dialogComponent?.[callback] !== "function") {
            console.warn(`[TRL] TJSDialog warning: The content Svelte component does not contain an associated function '${callback}'. Did you remember to add '<svelte:options accessors={true} />' and export the function?`);
          }
        }
        break;
      }
    }
    return result;
  }
  /**
   * A helper factory method to display a basic "prompt" style TJSDialog with a single button.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions & {
   *    onOk?: string|((application: TJSDialog) => any),
   *    label?: string,
   *    icon?: string
   * }} [data] - Prompt dialog options that includes any TJSDialog options along with the following optional fields:
   *
   * @param {string|((application: TJSDialog) => any)} [data.onOk] - Callback function upon `ok`; may be an async
   *        function. When defined as a string any matching function by name exported from content Svelte component is
   *        invoked.
   *
   * @param {string}   [data.label] - The OK prompt button text.
   *
   * @param {string}   [data.icon="fas fa-check"] - Set another icon besides `fas fa-check` for button.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} The returned value from the provided callback function or `true` if the button
   *          is pressed.
   *
   * @example
   * const result = await TJSDialog.prompt({
   *  title: 'Are you OK?',
   *  content: '<p>Are you OK?.</p>',
   *  label: 'Feeling Fine!'
   *  onOk: () => 'OK'
   * });
   *
   * // Logs 'OK' or null if the user closed the dialog without making a selection.
   * console.log(result);
   */
  static async prompt({ onOk, label, icon = "fas fa-check", ...data } = {}, options = {}) {
    return this.wait({
      ...data,
      buttons: {
        ok: {
          icon,
          label,
          onPress: (application) => this.#invokeFn(onOk, application, true)
        }
      },
      default: "ok"
    }, options);
  }
  /**
   * Creates an anonymous data defined TJSDialog returning a Promise that can be awaited upon for the user to make a
   * choice.
   *
   * Note: By default `null` is returned if the dialog is closed without a user making a choice.
   *
   * @template T
   *
   * @param {import('./internal/state-dialog/types').TJSDialogOptions}  data - Dialog data passed to the TJSDialog constructor.
   *
   * @param {import('./').SvelteApplicationOptions}  [options]  SvelteApplication options passed to the TJSDialog
   *        constructor.
   *
   * @returns {Promise<T>} A Promise that resolves to the chosen result.
   */
  static async wait(data, options = {}) {
    if (!isObject$1(data)) {
      throw new TypeError(`TJSDialog.wait error: 'data' is not an object'.`);
    }
    return new this({ ...data }, options).wait();
  }
}
Hooks.on("PopOut:loading", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = false;
  }
});
Hooks.on("PopOut:popin", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = true;
  }
});
Hooks.on("PopOut:close", (app) => {
  if (app instanceof SvelteApplication) {
    app.position.enabled = true;
  }
});
function enable() {
  const element2 = document.body;
  const requestMethod = element2.requestFullscreen || element2.webkitRequestFullscreen || element2.mozRequestFullScreen || element2.msRequestFullscreen;
  if (requestMethod) {
    requestMethod.call(element2);
  } else if (typeof window.ActiveXObject !== "undefined") {
    const wscript = new ActiveXObject("WScript.Shell");
    if (wscript !== null) {
      wscript.SendKeys("{F11}");
    }
  }
}
function disable() {
  const element2 = document;
  const exitMethod = element2.exitFullscreen || element2.webkitExitFullscreen || element2.mozCancelFullScreen || element2.msExitFullscreen;
  if (exitMethod) {
    exitMethod.call(document);
  } else if (typeof window.ActiveXObject !== "undefined") {
    const wscript = new ActiveXObject("WScript.Shell");
    if (wscript !== null) {
      wscript.SendKeys("{F11}");
    }
  }
}
function toggleFullscreen() {
  const dmc = document;
  const isInFullScreen = dmc.fullscreenElement || dmc.webkitFullscreenElement || dmc.mozFullScreenElement || dmc.msFullscreenElement;
  if (isInFullScreen) {
    disable();
  } else {
    enable();
  }
}
const Header_svelte_svelte_type_style_lang = "";
function get_each_context$f(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block$f(key_1, ctx) {
  let button_1;
  let i2;
  let i_class_value;
  let t;
  let button_1_class_value;
  let button_1_aria_label_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[7](
        /*button*/
        ctx[8]
      )
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      button_1 = element("button");
      i2 = element("i");
      t = space();
      attr(i2, "class", i_class_value = null_to_empty(
        /*button*/
        ctx[8].iconClass
      ) + " svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(i2, "aria-hidden", "true");
      toggle_class(
        i2,
        "active",
        /*button*/
        ctx[8].id === /*activeFilter*/
        ctx[2]
      );
      attr(button_1, "class", button_1_class_value = "icon-button " + /*button*/
      ctx[8].buttonClass + " svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(button_1, "aria-label", button_1_aria_label_value = /*button*/
      ctx[8].label ? (
        /*button*/
        ctx[8].label
      ) : null);
      toggle_class(
        button_1,
        "active",
        /*button*/
        ctx[8].id === /*activeFilter*/
        ctx[2]
      );
      this.first = button_1;
    },
    m(target, anchor) {
      insert(target, button_1, anchor);
      append(button_1, i2);
      append(button_1, t);
      if (!mounted) {
        dispose = listen(button_1, "click", prevent_default(click_handler));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*customButtons*/
      1 && i_class_value !== (i_class_value = null_to_empty(
        /*button*/
        ctx[8].iconClass
      ) + " svelte-mobile-companion81nkluj30u9vsd-1ol6608")) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & /*customButtons, customButtons, activeFilter*/
      5) {
        toggle_class(
          i2,
          "active",
          /*button*/
          ctx[8].id === /*activeFilter*/
          ctx[2]
        );
      }
      if (dirty & /*customButtons*/
      1 && button_1_class_value !== (button_1_class_value = "icon-button " + /*button*/
      ctx[8].buttonClass + " svelte-mobile-companion81nkluj30u9vsd-1ol6608")) {
        attr(button_1, "class", button_1_class_value);
      }
      if (dirty & /*customButtons*/
      1 && button_1_aria_label_value !== (button_1_aria_label_value = /*button*/
      ctx[8].label ? (
        /*button*/
        ctx[8].label
      ) : null)) {
        attr(button_1, "aria-label", button_1_aria_label_value);
      }
      if (dirty & /*customButtons, customButtons, activeFilter*/
      5) {
        toggle_class(
          button_1,
          "active",
          /*button*/
          ctx[8].id === /*activeFilter*/
          ctx[2]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button_1);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$O(ctx) {
  let div3;
  let div0;
  let t1;
  let div1;
  let t3;
  let div2;
  let div3_transition;
  let current;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      div0.innerHTML = `<i class="fas fa-maximize"></i>Fullscreen`;
      t1 = space();
      div1 = element("div");
      div1.innerHTML = `<i class="fas fa-gears"></i>Settings`;
      t3 = space();
      div2 = element("div");
      div2.innerHTML = `<i class="fas fa-sign-out-alt"></i>Logout`;
      attr(div0, "class", "menu-button svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(div0, "aria-hidden", "true");
      attr(div1, "class", "menu-button svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(div1, "aria-hidden", "true");
      attr(div2, "class", "menu-button svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(div2, "aria-hidden", "true");
      attr(div3, "class", "context-menu svelte-mobile-companion81nkluj30u9vsd-1ol6608");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div0);
      append(div3, t1);
      append(div3, div1);
      append(div3, t3);
      append(div3, div2);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div0, "click", toggleFullscreen),
          listen(
            div1,
            "click",
            /*openSettings*/
            ctx[6]
          ),
          listen(div2, "click", handleLogout)
        ];
        mounted = true;
      }
    },
    p: noop,
    i(local) {
      if (current)
        return;
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div3_transition)
            div3_transition = create_bidirectional_transition(div3, slide, {}, true);
          div3_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      if (local) {
        if (!div3_transition)
          div3_transition = create_bidirectional_transition(div3, slide, {}, false);
        div3_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (detaching && div3_transition)
        div3_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$13(ctx) {
  let t0;
  let header;
  let div0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let div1;
  let button_1;
  let i2;
  let i_class_value;
  let button_1_class_value;
  let t2;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*customButtons*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*button*/
    ctx2[8].id
  );
  for (let i3 = 0; i3 < each_value.length; i3 += 1) {
    let child_ctx = get_each_context$f(ctx, each_value, i3);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i3] = create_each_block$f(key, child_ctx));
  }
  let if_block = (
    /*isContextOpen*/
    ctx[3] && create_if_block$O(ctx)
  );
  return {
    c() {
      t0 = space();
      header = element("header");
      div0 = element("div");
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].c();
      }
      t1 = space();
      div1 = element("div");
      button_1 = element("button");
      i2 = element("i");
      t2 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "custom-buttons svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(i2, "class", i_class_value = "fa-solid fa-bars " + /*menuButtons*/
      ctx[1]?.iconClass + " svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(i2, "aria-hidden", "true");
      attr(button_1, "class", button_1_class_value = "icon-button " + /*menuButtons*/
      ctx[1]?.buttonClass + " svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(button_1, "aria-label", "Menu");
      attr(div1, "class", "main-buttons svelte-mobile-companion81nkluj30u9vsd-1ol6608");
      attr(header, "class", "header svelte-mobile-companion81nkluj30u9vsd-1ol6608");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, header, anchor);
      append(header, div0);
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        if (each_blocks[i3]) {
          each_blocks[i3].m(div0, null);
        }
      }
      append(header, t1);
      append(header, div1);
      append(div1, button_1);
      append(button_1, i2);
      append(header, t2);
      if (if_block)
        if_block.m(header, null);
      if (!mounted) {
        dispose = [
          listen(
            document.body,
            "click",
            /*handleBodyClick*/
            ctx[4]
          ),
          listen(
            button_1,
            "click",
            /*toggleMenu*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*customButtons, activeFilter, handleButtonClick*/
      5) {
        each_value = ensure_array_like(
          /*customButtons*/
          ctx2[0]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div0, destroy_block, create_each_block$f, null, get_each_context$f);
      }
      if (dirty & /*menuButtons*/
      2 && i_class_value !== (i_class_value = "fa-solid fa-bars " + /*menuButtons*/
      ctx2[1]?.iconClass + " svelte-mobile-companion81nkluj30u9vsd-1ol6608")) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & /*menuButtons*/
      2 && button_1_class_value !== (button_1_class_value = "icon-button " + /*menuButtons*/
      ctx2[1]?.buttonClass + " svelte-mobile-companion81nkluj30u9vsd-1ol6608")) {
        attr(button_1, "class", button_1_class_value);
      }
      if (
        /*isContextOpen*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isContextOpen*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$O(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(header, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      transition_in(if_block);
    },
    o(local) {
      transition_out(if_block);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(header);
      }
      for (let i3 = 0; i3 < each_blocks.length; i3 += 1) {
        each_blocks[i3].d();
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function handleLogout() {
  ui.menu.items.logout.onClick();
}
function handleButtonClick(button) {
  button.onClick();
}
function instance$13($$self, $$props, $$invalidate) {
  let { customButtons = [] } = $$props;
  let { menuButtons: menuButtons2 } = $$props;
  let { activeFilter } = $$props;
  let isContextOpen = false;
  function handleBodyClick() {
    if (isContextOpen) {
      $$invalidate(3, isContextOpen = false);
    }
  }
  function toggleMenu(event) {
    event.stopPropagation();
    $$invalidate(3, isContextOpen = !isContextOpen);
  }
  function openSettings(event) {
    event.stopPropagation();
    if (game.settings.sheet) {
      game.settings.sheet.close();
    }
    $$invalidate(3, isContextOpen = false);
    game.settings.sheet.render(true, { focus: true });
  }
  const click_handler = (button) => handleButtonClick(button);
  $$self.$$set = ($$props2) => {
    if ("customButtons" in $$props2)
      $$invalidate(0, customButtons = $$props2.customButtons);
    if ("menuButtons" in $$props2)
      $$invalidate(1, menuButtons2 = $$props2.menuButtons);
    if ("activeFilter" in $$props2)
      $$invalidate(2, activeFilter = $$props2.activeFilter);
  };
  return [
    customButtons,
    menuButtons2,
    activeFilter,
    isContextOpen,
    handleBodyClick,
    toggleMenu,
    openSettings,
    click_handler
  ];
}
class Header extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$13, create_fragment$13, safe_not_equal, {
      customButtons: 0,
      menuButtons: 1,
      activeFilter: 2
    });
  }
}
var Filters$2 = /* @__PURE__ */ ((Filters2) => {
  Filters2["Inventory"] = "object";
  Filters2["Spell"] = "spell";
  return Filters2;
})(Filters$2 || {});
const actorStore$2 = writable({});
const activeFilterStore$2 = writable(
  "object"
  /* Inventory */
);
function init$2(props) {
  actorStore$2.set(props);
}
const handleUpdate = async (item) => {
  let actor = get_store_value(actorStore$2);
  if (item.parent?.id === actor.id) {
    actor = game.actors.find((a) => a.id === actor.id);
    actorStore$2.set(actor);
    switchFilter$2(get_store_value(activeFilterStore$2));
  }
};
const handleActorUpdate = async (changedActor) => {
  let actor = get_store_value(actorStore$2);
  if (actor.id === changedActor.id) {
    actor = changedActor;
    actorStore$2.set(actor);
    switchFilter$2(get_store_value(activeFilterStore$2));
  }
};
const handleEffectChange = async (effect) => {
  await handleActorUpdate(effect.parent);
};
function handleOnMount$2() {
  Hooks.on("createItem", handleUpdate);
  Hooks.on("deleteItem", handleUpdate);
  Hooks.on("updateItem", handleUpdate);
  Hooks.on("updateActor", handleActorUpdate);
  Hooks.on("deleteActiveEffect", handleEffectChange);
  Hooks.on("createActiveEffect", handleEffectChange);
  switchFilter$2(get_store_value(activeFilterStore$2));
}
function handleOffMount() {
  Hooks.off("createItem", handleUpdate);
  Hooks.off("deleteItem", handleUpdate);
  Hooks.off("updateItem", handleUpdate);
  Hooks.off("updateActor", handleActorUpdate);
  Hooks.off("deleteActiveEffect", handleEffectChange);
  Hooks.off("createActiveEffect", handleEffectChange);
}
const headerButtons$2 = [
  {
    id: "object",
    iconClass: "fas fa-box-open",
    buttonClass: "dnd-button",
    label: "Inventory",
    onClick: () => switchFilter$2(
      "object"
      /* Inventory */
    )
  },
  {
    id: "spell",
    iconClass: "fas fa-wand-sparkles",
    buttonClass: "dnd-button",
    label: "Spells",
    onClick: () => switchFilter$2(
      "spell"
      /* Spell */
    )
  }
];
const menuButtons$2 = {
  buttonClass: "dnd-button",
  iconClass: ""
};
function switchFilter$2(newFilter) {
  activeFilterStore$2.set(newFilter);
}
function ripple({
  duration = 600,
  background = "rgba(255, 255, 255, 0.7)",
  events = ["click", "keyup"],
  keyCode = "Enter",
  debounce
} = {}) {
  return (element2) => {
    function createRipple(e2) {
      const elementRect = element2.getBoundingClientRect();
      const diameter = Math.max(elementRect.width, elementRect.height);
      const radius = diameter / 2;
      const left = e2.clientX ? `${e2.clientX - (elementRect.left + radius)}px` : "0";
      const top = e2.clientY ? `${e2.clientY - (elementRect.top + radius)}px` : "0";
      const span = document.createElement("span");
      span.style.position = "absolute";
      span.style.width = `${diameter}px`;
      span.style.height = `${diameter}px`;
      span.style.left = left;
      span.style.top = top;
      span.style.background = `var(--tjs-action-ripple-background, ${background})`;
      span.style.borderRadius = "50%";
      span.style.pointerEvents = "none";
      span.style.transform = "translateZ(-1px)";
      element2.prepend(span);
      const animation = span.animate(
        [
          {
            // from
            transform: "scale(.7)",
            opacity: 0.5,
            filter: "blur(2px)"
          },
          {
            // to
            transform: "scale(4)",
            opacity: 0,
            filter: "blur(5px)"
          }
        ],
        duration
      );
      animation.onfinish = () => {
        if (span && span.isConnected) {
          span.remove();
        }
      };
    }
    function keyHandler(event) {
      if (event?.code === keyCode) {
        createRipple(event);
      }
    }
    const eventFn = Number.isInteger(debounce) && debounce > 0 ? Timing.debounce(createRipple, debounce) : createRipple;
    const keyEventFn = Number.isInteger(debounce) && debounce > 0 ? Timing.debounce(keyHandler, debounce) : keyHandler;
    for (const event of events) {
      if (["keydown", "keyup"].includes(event)) {
        element2.addEventListener(event, keyEventFn);
      } else {
        element2.addEventListener(event, eventFn);
      }
    }
    return {
      destroy: () => {
        for (const event of events) {
          if (["keydown", "keyup"].includes(event)) {
            element2.removeEventListener(event, keyEventFn);
          } else {
            element2.removeEventListener(event, eventFn);
          }
        }
      }
    };
  };
}
function rippleFocus({ duration = 300, background = "rgba(255, 255, 255, 0.7)", selectors } = {}) {
  return (element2) => {
    const targetEl = typeof selectors === "string" ? element2.querySelector(selectors) : element2.firstChild instanceof HTMLElement ? element2.firstChild : element2;
    let span = void 0;
    let clientX = -1;
    let clientY = -1;
    function blurRipple() {
      if (!(span instanceof HTMLElement) || document.activeElement === targetEl) {
        return;
      }
      const animation = span.animate(
        [
          {
            // from
            transform: "scale(3)",
            opacity: 0.3
          },
          {
            // to
            transform: "scale(.7)",
            opacity: 0
          }
        ],
        {
          duration,
          fill: "forwards"
        }
      );
      animation.onfinish = () => {
        clientX = clientY = -1;
        if (span && span.isConnected) {
          span.remove();
        }
        span = void 0;
      };
    }
    function focusRipple() {
      if (span instanceof HTMLElement) {
        return;
      }
      const elementRect = element2.getBoundingClientRect();
      const actualX = clientX >= 0 ? clientX : elementRect.left + elementRect.width / 2;
      const actualY = clientX >= 0 ? clientY : elementRect.top + elementRect.height / 2;
      const diameter = Math.max(elementRect.width, elementRect.height);
      const radius = diameter / 2;
      const left = `${actualX - (elementRect.left + radius)}px`;
      const top = `${actualY - (elementRect.top + radius)}px`;
      span = document.createElement("span");
      span.style.position = "absolute";
      span.style.width = `${diameter}px`;
      span.style.height = `${diameter}px`;
      span.style.left = left;
      span.style.top = top;
      span.style.background = `var(--tjs-action-ripple-background-focus, var(--tjs-action-ripple-background, ${background}))`;
      span.style.borderRadius = "50%";
      span.style.pointerEvents = "none";
      span.style.transform = "translateZ(-1px)";
      element2.prepend(span);
      span.animate(
        [
          {
            // from
            transform: "scale(.7)",
            opacity: 0.5
          },
          {
            // to
            transform: "scale(3)",
            opacity: 0.3
          }
        ],
        {
          duration,
          fill: "forwards"
        }
      );
    }
    function onPointerDown(e2) {
      clientX = e2.clientX;
      clientY = e2.clientY;
    }
    targetEl.addEventListener("pointerdown", onPointerDown);
    targetEl.addEventListener("blur", blurRipple);
    targetEl.addEventListener("focus", focusRipple);
    return {
      destroy: () => {
        targetEl.removeEventListener("pointerdown", onPointerDown);
        targetEl.removeEventListener("blur", blurRipple);
        targetEl.removeEventListener("focus", focusRipple);
      }
    };
  };
}
class UIControl {
  /** @type {import('./types').TJSSettingsCustomSection[]} */
  #sections = [];
  /** @type {import('./').TJSGameSettings} */
  #settings;
  /** @type {boolean} */
  #showSettings = false;
  /** @type {Function} */
  #showSettingsSet;
  /** @type {{showSettings: import('svelte/store').Readable<boolean>}} */
  #stores;
  /**
   * @param {import('./').TJSGameSettings}   settings -
   */
  constructor(settings2) {
    this.#settings = settings2;
    const showSettings = writable(this.#showSettings);
    this.#showSettingsSet = showSettings.set;
    this.#stores = {
      showSettings: { subscribe: showSettings.subscribe }
    };
    Object.freeze(this.#stores);
  }
  /**
   * @returns {boolean} Current `showSettings` state.
   */
  get showSettings() {
    return this.#showSettings;
  }
  /**
   * @returns {{ showSettings: import('svelte/store').Readable<boolean> }} Returns the managed stores.
   */
  get stores() {
    return this.#stores;
  }
  /**
   * Sets current `showSettings` state.
   *
   * @param {boolean}  showSettings - New `showSettings` state.
   */
  set showSettings(showSettings) {
    this.#showSettings = showSettings;
    this.#showSettingsSet(this.#showSettings);
  }
  /**
   * Adds a custom section / folder defined by the provided TJSSettingsCustomSection options object.
   *
   * @param {import('./types').TJSSettingsCustomSection} options - The configuration object for the custom section.
   */
  addSection(options) {
    if (!isObject$1(options)) {
      throw new TypeError(`'options' is not an object.`);
    }
    if (!isSvelteComponent(options.class)) {
      throw new TypeError(`'options.class' is not a Svelte component.`);
    }
    if (options.props !== void 0 && !isObject$1(options.props)) {
      throw new TypeError(`'options.props' is not an object.`);
    }
    if (options.folder !== void 0) {
      const folder = options.folder;
      if (typeof folder !== "string" && !isObject$1(folder)) {
        throw new TypeError(`'options.folder' is not a string or object.`);
      }
      if (isObject$1(folder)) {
        if (typeof folder.label !== "string") {
          throw new TypeError(`'options.folder.label' is not a string.`);
        }
        if (folder.summaryEnd !== void 0) {
          if (!isObject$1(folder.summaryEnd)) {
            throw new TypeError(`'options.folder.summaryEnd' is not an object.`);
          }
          if (!isSvelteComponent(folder.summaryEnd.class)) {
            throw new TypeError(`'options.folder.summaryEnd.class' is not a Svelte component.`);
          }
          if (folder.summaryEnd.props !== void 0 && !isObject$1(folder.summaryEnd.props)) {
            throw new TypeError(`'options.folder.summaryEnd.props' is not an object.`);
          }
        }
        if (folder.styles !== void 0 && !isObject$1(folder.styles)) {
          throw new TypeError(`'options.folder.styles' is not an object.`);
        }
      }
    }
    if (options.styles !== void 0 && !isObject$1(options.styles)) {
      throw new TypeError(`'options.styles' is not an object.`);
    }
    this.#sections.push(options);
  }
  /**
   * Creates the UISettingsData object by parsing stored settings in
   *
   * @param {import('./types').TJSSettingsCreateOptions} [options] - Optional parameters.
   *
   * @returns {import('./types').TJSSettingsUIData} Parsed UI settings data.
   */
  create(options) {
    const settings2 = this.#parseSettings(options);
    const destroy = () => this.#destroy(settings2);
    return {
      ...settings2,
      destroy
    };
  }
  /**
   * Destroy callback. Checks for any `requiresReload` parameter in each setting comparing against initial value
   * when `settings` is created and current value. If there is a difference then show a modal dialog asking the user
   * if they want to reload for those settings to take effect.
   *
   * @param {import('./types').TJSSettingsUIData}   settings - The UI data object initiated w/ `create`.
   */
  #destroy(settings2) {
    let requiresClientReload = false;
    let requiresWorldReload = false;
    if (Array.isArray(settings2.topLevel)) {
      for (const setting of settings2.topLevel) {
        const current = globalThis.game.settings.get(setting.namespace, setting.key);
        if (current === setting.initialValue) {
          continue;
        }
        requiresClientReload ||= setting.scope === "client" && setting.requiresReload;
        requiresWorldReload ||= setting.scope === "world" && setting.requiresReload;
      }
    }
    if (Array.isArray(settings2.folders)) {
      for (const folder of settings2.folders) {
        if (Array.isArray(folder.settings)) {
          for (const setting of folder.settings) {
            const current = globalThis.game.settings.get(setting.namespace, setting.key);
            if (current === setting.initialValue) {
              continue;
            }
            requiresClientReload ||= setting.scope === "client" && setting.requiresReload;
            requiresWorldReload ||= setting.scope === "world" && setting.requiresReload;
          }
        }
      }
    }
    if (requiresClientReload || requiresWorldReload) {
      this.#reloadConfirm({ world: requiresWorldReload });
    }
    this.#showSettings = false;
    this.#showSettingsSet(this.#showSettings);
  }
  /**
   * @param {import('./types').TJSSettingsCreateOptions} [options] - Optional parameters.
   *
   * @returns {import('./types').TJSSettingsUIData} Parsed UI settings data.
   */
  #parseSettings({ efx = "ripple", storage } = {}) {
    const namespace = this.#settings.namespace;
    if (storage && typeof namespace !== "string") {
      console.warn(
        `TJSGameSettings warning: 'options.storage' defined, but 'namespace' not defined in TJSGameSettings.`
      );
    }
    const hasStorage = storage && typeof namespace === "string";
    const uiSettings = [];
    const canConfigure = globalThis.game.user.can("SETTINGS_MODIFY");
    for (const setting of this.#settings) {
      if (!setting.config || !canConfigure && setting.scope !== "client") {
        continue;
      }
      let options;
      if (isObject$1(setting.choices)) {
        options = Object.entries(setting.choices).map((entry) => ({ value: entry[0], label: localize(entry[1]) }));
      }
      let range2;
      if (isObject$1(setting.range)) {
        range2 = {};
        if (typeof setting.range.min !== "number") {
          throw new TypeError(`Setting 'range.min' is not a number.`);
        }
        if (typeof setting.range.max !== "number") {
          throw new TypeError(`Setting 'range.max' is not a number.`);
        }
        if (setting.range.step !== void 0 && typeof setting.range.step !== "number") {
          throw new TypeError(`Setting 'range.step' is not a number.`);
        }
        range2.min = setting.range.min;
        range2.max = setting.range.max;
        range2.step = setting.range.step ? setting.range.step : 1;
      }
      const type = setting.type instanceof Function ? setting.type.name : "String";
      let filePicker;
      if (type === "String") {
        filePicker = setting.filePicker === true ? "any" : setting.filePicker;
      }
      let buttonData;
      if (filePicker) {
        buttonData = {
          icon: "fas fa-file-import fa-fw",
          efx: efx === "ripple" ? ripple() : void 0,
          title: "FILES.BrowseTooltip",
          styles: { "margin-left": "0.25em" }
        };
      }
      const store = this.#settings.getStore(setting.key);
      let selectData;
      let componentType = "text";
      if (setting.type === Boolean) {
        componentType = "checkbox";
      } else if (options !== void 0) {
        componentType = "select";
        selectData = {
          store,
          efx: efx === "ripple" ? rippleFocus() : void 0,
          type: componentType,
          options
        };
      } else if (setting.type === Number) {
        componentType = isObject$1(setting.range) ? "range" : "number";
      }
      let inputData;
      if (componentType === "text" || componentType === "number") {
        inputData = {
          store,
          efx: efx === "ripple" ? rippleFocus() : void 0,
          type: componentType
        };
      }
      uiSettings.push({
        id: `${setting.namespace}.${setting.key}`,
        namespace: setting.namespace,
        folder: setting.folder,
        key: setting.key,
        name: localize(setting.name),
        hint: localize(setting.hint),
        type,
        componentType,
        filePicker,
        range: range2,
        store,
        initialValue: globalThis.game.settings.get(setting.namespace, setting.key),
        scope: setting.scope,
        requiresReload: typeof setting.requiresReload === "boolean" ? setting.requiresReload : false,
        buttonData,
        inputData,
        selectData
      });
    }
    const storeScrollbar = hasStorage ? storage.getStore(`${namespace}-settings-scrollbar`) : writable(0);
    const topLevel = [];
    const folderData = {};
    for (const setting of uiSettings) {
      if (typeof setting.folder === "string") {
        const folderName = localize(setting.folder);
        if (!Array.isArray(folderData[folderName])) {
          folderData[folderName] = [];
        }
        folderData[folderName].push(setting);
      } else {
        topLevel.push(setting);
      }
    }
    const folders = Object.entries(folderData).map((entry) => {
      return {
        label: entry[0],
        store: hasStorage ? storage.getStore(`${namespace}-settings-folder-${entry[0]}`) : void 0,
        settings: entry[1]
      };
    });
    const sections = [];
    for (const section of this.#sections) {
      const parsedSection = {
        class: section.class,
        props: section.props,
        styles: section.styles
      };
      if (typeof section.folder === "string") {
        const label = localize(section.folder);
        parsedSection.folder = {
          label,
          store: hasStorage ? storage.getStore(`${namespace}-settings-folder-${label}`) : void 0
        };
      } else if (isObject$1(section.folder)) {
        const label = localize(section.folder.label);
        parsedSection.folder = {
          label,
          store: hasStorage ? storage.getStore(`${namespace}-settings-folder-${label}`) : void 0,
          summaryEnd: section.folder.summaryEnd,
          styles: section.folder.styles
        };
      }
      sections.push(parsedSection);
    }
    return {
      storeScrollbar,
      topLevel,
      folders,
      sections
    };
  }
  async #reloadConfirm({ world = false } = {}) {
    let title = localize("SETTINGS.ReloadPromptTitle");
    let label = localize("SETTINGS.ReloadPromptBody");
    title = title !== "SETTINGS.ReloadPromptTitle" ? title : "Reload Application?";
    label = label !== "SETTINGS.ReloadPromptBody" ? label : "Some of the changed settings require a reload of the application to take effect. Would you like to reload now?";
    const reload = await TJSDialog.confirm({
      modal: true,
      draggable: false,
      title,
      content: `<p>${label}</p>`
    });
    if (!reload) {
      return;
    }
    if (world && globalThis.game.user.isGM) {
      globalThis.game.socket.emit("reload");
    }
    window.location.reload();
  }
  /**
   * Convenience method to swap `showSettings`.
   *
   * @returns {boolean} New `showSettings` state.
   */
  swapShowSettings() {
    this.#showSettings = !this.#showSettings;
    this.#showSettingsSet(this.#showSettings);
    return this.#showSettings;
  }
}
class TJSGameSettings {
  /** @type {string} */
  #namespace;
  /** @type {GameSettingData[]} */
  #settings = [];
  /**
   * @type {Map<string, import('svelte/store').Writable>}
   */
  #stores = /* @__PURE__ */ new Map();
  /** @type {import('./types').UIControl} */
  #uiControl;
  /**
   * Creates the TJSGameSettings instance.
   *
   * @param {string}   namespace - The namespace for all settings.
   */
  constructor(namespace) {
    if (typeof namespace !== "string") {
      throw new TypeError(`'namespace' is not a string.`);
    }
    this.#namespace = namespace;
    this.#uiControl = new UIControl(this);
  }
  /**
   * Creates a new writable for the given key.
   *
   * @param {*}  initialValue - An initial value to set to new stores.
   *
   * @returns {import('svelte/store').Writable} The new writable.
   */
  static #createStore(initialValue) {
    return writable(initialValue);
  }
  /**
   * Provides an iterator / generator to return stored settings data.
   *
   * @returns {IterableIterator<GameSettingData>} An iterator of all game setting data.
   * @yields {GameSettingData}
   */
  *[Symbol.iterator]() {
    for (const setting of this.#settings) {
      yield setting;
    }
  }
  /**
   * @returns {string} Returns namespace set in constructor.
   */
  get namespace() {
    return this.#namespace;
  }
  /**
   * @returns {import('./types').UIControl} The associated UIControl.
   */
  get uiControl() {
    return this.#uiControl;
  }
  /**
   * Gets a store from the `stores` Map or creates a new store for the key.
   *
   * @param {string}   key - Key to lookup in stores map.
   *
   * @param {string}   [initialValue] - An initial value to set to new stores.
   *
   * @returns {import('svelte/store').Writable} The store for the given key.
   */
  #getStore(key, initialValue) {
    let store = this.#stores.get(key);
    if (store === void 0) {
      store = TJSGameSettings.#createStore(initialValue);
      this.#stores.set(key, store);
    }
    return store;
  }
  /**
   * Returns a readable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Readable | undefined} The associated store for the given game setting key.
   */
  getReadableStore(key) {
    if (!this.#stores.has(key)) {
      console.warn(`TJSGameSettings - getReadableStore: '${key}' is not a registered setting.`);
      return;
    }
    const store = this.#getStore(key);
    return { subscribe: store.subscribe };
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable | undefined} The associated store for the given game setting key.
   */
  getStore(key) {
    return this.getWritableStore(key);
  }
  /**
   * Returns a writable Game Settings store for the associated key.
   *
   * @param {string}   key - Game setting key.
   *
   * @returns {import('svelte/store').Writable | undefined} The associated store for the given game setting key.
   */
  getWritableStore(key) {
    if (!this.#stores.has(key)) {
      console.warn(`TJSGameSettings - getWritableStore: '${key}' is not a registered setting.`);
      return;
    }
    return this.#getStore(key);
  }
  /**
   * Registers a setting with TJSGameSettings and Foundry core.
   *
   * Note: The specific store subscription handler assigned to the passed in store or store created for the setting
   * internally is returned from this function. In some cases when setting up custom stores particularly of object
   * types with several child property stores (`propertyStore`) it is necessary to only update the setting store and
   * not all subscribers to the custom store as the `propertyStore` instances are also subscribers to the custom store.
   *
   * This allows the custom store in the `set` implementation to mainly only trigger the TJSGameSettings subscriber
   * handler on updates and not all the connected `propertyStore` instances.
   *
   * @param {GameSetting} setting - A GameSetting instance to set to Foundry game settings.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns {Function} The specific store subscription handler assigned to the passed in store.
   */
  register(setting, coreConfig = true) {
    if (!isObject$1(setting)) {
      throw new TypeError(`TJSGameSettings - register: setting is not an object.`);
    }
    if (!isObject$1(setting.options)) {
      throw new TypeError(`TJSGameSettings - register: 'setting.options' attribute is not an object.`);
    }
    if (typeof coreConfig !== "boolean") {
      throw new TypeError(`TJSGameSettings - register: 'coreConfig' is not an boolean.`);
    }
    if (setting.store !== void 0 && !isWritableStore(setting.store)) {
      throw new TypeError(
        `TJSGameSettings - register: 'setting.store' attribute is not a writable store.`
      );
    }
    const namespace = setting.namespace;
    const key = setting.key;
    const folder = setting.folder;
    const foundryConfig = coreConfig ? setting.options.config : false;
    if (typeof namespace !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'namespace' attribute is not a string.`);
    }
    if (typeof key !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'key' attribute is not a string.`);
    }
    if (folder !== void 0 && typeof folder !== "string") {
      throw new TypeError(`TJSGameSettings - register: 'folder' attribute is not a string.`);
    }
    const store = setting.store;
    const options = setting.options;
    const onchangeFunctions = [];
    let gateSet = false;
    onchangeFunctions.push((value) => {
      const callbackStore = this.#getStore(key);
      if (callbackStore && !gateSet) {
        gateSet = true;
        callbackStore.set(value);
        gateSet = false;
      }
    });
    if (isIterable(options?.onChange)) {
      for (const entry of options.onChange) {
        if (typeof entry === "function") {
          onchangeFunctions.push(entry);
        }
      }
    } else if (typeof options.onChange === "function") {
      onchangeFunctions.push(options.onChange);
    }
    const onChange = (value) => {
      for (const entry of onchangeFunctions) {
        entry(value);
      }
    };
    globalThis.game.settings.register(namespace, key, { ...options, config: foundryConfig, onChange });
    const targetStore = store ? store : this.#getStore(key, globalThis.game.settings.get(namespace, key));
    if (store) {
      this.#stores.set(key, targetStore);
      store.set(globalThis.game.settings.get(namespace, key));
    }
    const storeHandler = async (value) => {
      if (!gateSet && globalThis.game.settings.get(namespace, key) !== value) {
        gateSet = true;
        await globalThis.game.settings.set(namespace, key, value);
      }
      gateSet = false;
    };
    subscribeIgnoreFirst(targetStore, storeHandler);
    this.#settings.push({
      namespace,
      key,
      folder,
      ...options
    });
    return storeHandler;
  }
  /**
   * Registers multiple settings.
   *
   * Please refer to the note in {@link TJSGameSettings.register} about the returned object of store subscriber handler
   * functions.
   *
   * @param {Iterable<GameSetting>} settings - An iterable list of game setting configurations to register.
   *
   * @param {boolean}     coreConfig - When false this overrides the `setting.options.config` parameter when
   *                                   registering the setting with Foundry. This allows the settings to be displayed
   *                                   in the app itself, but removed from the standard Foundry configuration location.
   *
   * @returns { {[key: string]: Function} } An object containing all TJSGameSetting store subscriber handlers for each
   *          setting `key` added.
   */
  registerAll(settings2, coreConfig) {
    const storeHandlers = {};
    if (!isIterable(settings2)) {
      throw new TypeError(`TJSGameSettings - registerAll: settings is not iterable.`);
    }
    for (const entry of settings2) {
      if (!isObject$1(entry)) {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings is not an object.`);
      }
      if (typeof entry.namespace !== "string") {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'namespace' attribute.`);
      }
      if (typeof entry.key !== "string") {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'key' attribute.`);
      }
      if (!isObject$1(entry.options)) {
        throw new TypeError(`TJSGameSettings - registerAll: entry in settings missing 'options' attribute.`);
      }
      storeHandlers[entry.key] = this.register(entry, coreConfig);
    }
    return storeHandlers;
  }
}
const UserSetupShell_svelte_svelte_type_style_lang = "";
function get_each_context$e(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  child_ctx[10] = list;
  child_ctx[11] = i2;
  return child_ctx;
}
function create_each_block$e(key_1, ctx) {
  let li;
  let div0;
  let h4;
  let t0_value = (
    /*player*/
    ctx[9].name + ""
  );
  let t0;
  let t1;
  let div1;
  let input0;
  let t2;
  let div2;
  let input1;
  let input1_disabled_value;
  let t3;
  let mounted;
  let dispose;
  function input0_change_handler() {
    ctx[4].call(
      input0,
      /*each_value*/
      ctx[10],
      /*player_index*/
      ctx[11]
    );
  }
  function input1_input_handler() {
    ctx[5].call(
      input1,
      /*each_value*/
      ctx[10],
      /*player_index*/
      ctx[11]
    );
  }
  return {
    key: key_1,
    first: null,
    c() {
      li = element("li");
      div0 = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      input0 = element("input");
      t2 = space();
      div2 = element("div");
      input1 = element("input");
      t3 = space();
      attr(input0, "type", "checkbox");
      attr(input1, "type", "number");
      input1.disabled = input1_disabled_value = !/*player*/
      ctx[9].enabled;
      attr(li, "class", "item svelte-mobile-companion81nkluj30u9vsd-1cwgvgb");
      attr(li, "data-item-id", this.id);
      this.first = li;
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, div0);
      append(div0, h4);
      append(h4, t0);
      append(li, t1);
      append(li, div1);
      append(div1, input0);
      input0.checked = /*player*/
      ctx[9].enabled;
      append(li, t2);
      append(li, div2);
      append(div2, input1);
      set_input_value(
        input1,
        /*player*/
        ctx[9].screenWidth
      );
      append(li, t3);
      if (!mounted) {
        dispose = [
          listen(input0, "change", input0_change_handler),
          listen(input1, "input", input1_input_handler)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*players*/
      2 && t0_value !== (t0_value = /*player*/
      ctx[9].name + ""))
        set_data(t0, t0_value);
      if (dirty & /*players*/
      2) {
        input0.checked = /*player*/
        ctx[9].enabled;
      }
      if (dirty & /*players*/
      2 && input1_disabled_value !== (input1_disabled_value = !/*player*/
      ctx[9].enabled)) {
        input1.disabled = input1_disabled_value;
      }
      if (dirty & /*players*/
      2 && to_number(input1.value) !== /*player*/
      ctx[9].screenWidth) {
        set_input_value(
          input1,
          /*player*/
          ctx[9].screenWidth
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot$4(ctx) {
  let form;
  let div3;
  let ol1;
  let li;
  let t5;
  let ol0;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t6;
  let button0;
  let t8;
  let button1;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*players*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*player*/
    ctx2[9].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$e(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$e(key, child_ctx));
  }
  return {
    c() {
      form = element("form");
      div3 = element("div");
      ol1 = element("ol");
      li = element("li");
      li.innerHTML = `<div>Player</div> <div>Enable</div> <div>Activation screen width</div>`;
      t5 = space();
      ol0 = element("ol");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t6 = space();
      button0 = element("button");
      button0.textContent = "Save";
      t8 = space();
      button1 = element("button");
      button1.textContent = "Cancel";
      attr(li, "class", "table-header svelte-mobile-companion81nkluj30u9vsd-1cwgvgb");
      attr(ol0, "class", "item-list svelte-mobile-companion81nkluj30u9vsd-1cwgvgb");
      attr(ol1, "class", "svelte-mobile-companion81nkluj30u9vsd-1cwgvgb");
      attr(div3, "class", "settings svelte-mobile-companion81nkluj30u9vsd-1cwgvgb");
      attr(button1, "type", "reset");
      set_style(form, "height", "100%");
      attr(form, "class", "svelte-mobile-companion81nkluj30u9vsd-1cwgvgb");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append(form, div3);
      append(div3, ol1);
      append(ol1, li);
      append(ol1, t5);
      append(ol1, ol0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(ol0, null);
        }
      }
      append(form, t6);
      append(form, button0);
      append(form, t8);
      append(form, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", prevent_default(
            /*saveData*/
            ctx[3]
          )),
          listen(button1, "click", prevent_default(
            /*click_handler*/
            ctx[6]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*players*/
      2) {
        each_value = ensure_array_like(
          /*players*/
          ctx2[1]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, ol0, destroy_block, create_each_block$e, null, get_each_context$e);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment$12(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[7](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$4] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell$1({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, players*/
      4098) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function instance$12($$self, $$props, $$invalidate) {
  let { elementRoot } = $$props;
  const { application } = getContext("#external");
  const playerData = game.settings.get(moduleId, settings.users);
  let players = game.users.filter((u) => !u.isGM).map((u) => {
    let data = playerData[u.id] || {};
    return mergeObject(
      {
        id: u.id,
        name: u.name,
        enabled: false,
        screenWidth: 0
      },
      data
    );
  });
  function saveData() {
    players.forEach((player) => {
      let data = playerData[player.id] || {};
      data.enabled = player.enabled;
      data.screenWidth = player.screenWidth || 0;
      playerData[player.id] = data;
    });
    game.settings.set(moduleId, settings.users, playerData);
    application.close();
  }
  function input0_change_handler(each_value, player_index) {
    each_value[player_index].enabled = this.checked;
    $$invalidate(1, players);
  }
  function input1_input_handler(each_value, player_index) {
    each_value[player_index].screenWidth = to_number(this.value);
    $$invalidate(1, players);
  }
  const click_handler = () => application.close();
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
  };
  return [
    elementRoot,
    players,
    application,
    saveData,
    input0_change_handler,
    input1_input_handler,
    click_handler,
    applicationshell_elementRoot_binding
  ];
}
let UserSetupShell$1 = class UserSetupShell extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$12, create_fragment$12, safe_not_equal, { elementRoot: 0 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
};
class UserSetupShell2 extends SvelteApplication {
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "Settings",
      width: "auto",
      height: "auto",
      resizable: false,
      // The other options...
      svelte: {
        class: UserSetupShell$1,
        target: document.body
      }
    });
  }
}
class SettingsUser extends FormApplication {
  static #settingsApp;
  static showSettings() {
    this.#settingsApp = this.#settingsApp ? this.#settingsApp : new UserSetupShell2();
    this.#settingsApp.render(true, { focus: true });
    return this.#settingsApp;
  }
  /**
   * @inheritDoc
   */
  constructor(options = {}) {
    super({}, options);
    SettingsUser.showSettings();
  }
  async _updateObject(event, formData) {
    await super._updateObject(event, formData);
  }
  render() {
    this.close();
  }
}
function i18n(key) {
  return game.i18n.localize(key);
}
function myi18n(key) {
  return i18n("Mobile-Companion.".concat(key));
}
function i18nFormat(key, data) {
  return game.i18n.format(key, data);
}
async function enrichText(text2, replaceOptionsBefore = []) {
  let result = text2;
  for (const option of replaceOptionsBefore) {
    const regex = new RegExp(option.find, "g");
    result = result.replace(regex, option.replace);
  }
  result = await TextEditor.enrichHTML(result);
  return result;
}
function getDnd5eSettings() {
  const setting = [];
  setting.push({
    namespace: moduleId,
    key: settings.dnd5e.useCurrency,
    options: {
      name: myi18n("Settings.UseCurrency.Name"),
      hint: myi18n("Settings.UseCurrency.Hint"),
      scope: "client",
      config: true,
      type: Boolean,
      default: true
    }
  });
  setting.push({
    namespace: moduleId,
    key: settings.dnd5e.useEncumbrance,
    options: {
      name: myi18n("Settings.UseEncumbrance.Name"),
      hint: myi18n("Settings.UseEncumbrance.Hint"),
      scope: "client",
      config: true,
      type: Boolean,
      default: true
    }
  });
  return setting;
}
function getA5eSettings() {
  const setting = [];
  setting.push({
    namespace: moduleId,
    key: settings.a5e.useCurrency,
    options: {
      name: myi18n("Settings.UseCurrency.Name"),
      hint: myi18n("Settings.UseCurrency.Hint"),
      scope: "client",
      config: true,
      type: Boolean,
      default: true
    }
  });
  setting.push({
    namespace: moduleId,
    key: settings.a5e.useEncumbrance,
    options: {
      name: myi18n("Settings.UseEncumbrance.Name"),
      hint: myi18n("Settings.UseEncumbrance.Hint"),
      scope: "client",
      config: true,
      type: Boolean,
      default: true
    }
  });
  return setting;
}
function getPf2eSettings() {
  const setting = [];
  setting.push({
    namespace: moduleId,
    key: settings.pf2e.useCurrency,
    options: {
      name: myi18n("Settings.UseCurrency.Name"),
      hint: myi18n("Settings.UseCurrency.Hint"),
      scope: "client",
      config: true,
      type: Boolean,
      default: true
    }
  });
  setting.push({
    namespace: moduleId,
    key: settings.pf2e.useEncumbrance,
    options: {
      name: myi18n("Settings.UseEncumbrance.Name"),
      hint: myi18n("Settings.UseEncumbrance.Hint"),
      scope: "client",
      config: true,
      type: Boolean,
      default: true
    }
  });
  return setting;
}
class MobileCompanionGameSettings extends TJSGameSettings {
  constructor() {
    super(moduleId);
  }
  getWritableStore(storeName) {
    return super.getWritableStore(storeName);
  }
  init() {
    const namespace = this.namespace;
    const scope = {
      client: "client",
      world: "world"
    };
    game.settings.registerMenu(namespace, settings.usersMenu, {
      name: "Set users",
      label: "Users",
      hint: "Set up users who use mobile companion",
      type: SettingsUser,
      icon: "fas fa-users",
      restricted: true
    });
    game.settings.register(moduleId, settings.users, {
      scope: scope.world,
      config: false,
      default: {},
      type: Object
    });
    game.settings.register(moduleId, "lastActorId", {
      scope: "client",
      config: false,
      type: String,
      default: ""
    });
    if (game.system.id === system.DND5E) {
      this.registerAll(getDnd5eSettings(), true);
    } else if (game.system.id === system.A5E) {
      this.registerAll(getA5eSettings(), true);
    } else if (game.system.id === system.PF2E) {
      this.registerAll(getPf2eSettings(), true);
      game.user.settings.showCheckDialogs = false;
    }
  }
}
const mobileCompanionGameSettings = new MobileCompanionGameSettings();
const Dnd5eEncumbrance_svelte_svelte_type_style_lang = "";
function create_if_block$N(ctx) {
  let div2;
  let div1;
  let div0;
  let i0;
  let t0;
  let span0;
  let t1_value = (
    /*encumbrance*/
    ctx[0].value + ""
  );
  let t1;
  let t2;
  let span1;
  let t4;
  let span2;
  let t5_value = (
    /*encumbrance*/
    ctx[0].max + ""
  );
  let t5;
  let t6;
  let i1;
  let t7;
  let i2;
  let t8;
  let i3;
  let t9;
  let i4;
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      i0 = element("i");
      t0 = space();
      span0 = element("span");
      t1 = text(t1_value);
      t2 = space();
      span1 = element("span");
      span1.textContent = "/";
      t4 = space();
      span2 = element("span");
      t5 = text(t5_value);
      t6 = space();
      i1 = element("i");
      t7 = space();
      i2 = element("i");
      t8 = space();
      i3 = element("i");
      t9 = space();
      i4 = element("i");
      attr(i0, "class", "fas fa-weight-hanging svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(span0, "class", "value svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(span1, "class", "separator svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(span2, "class", "max svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(div0, "class", "label svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(i1, "class", "breakpoint encumbrance-low arrow-up svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(i2, "class", "breakpoint encumbrance-low arrow-down svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(i3, "class", "breakpoint encumbrance-high arrow-up svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(i4, "class", "breakpoint encumbrance-high arrow-down svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      attr(div1, "class", "meter progress svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
      set_style(
        div1,
        "--bar-percentage",
        /*encumbrance*/
        ctx[0].pct + "%"
      );
      set_style(
        div1,
        "--encumbrance-low",
        /*encumbrance*/
        ctx[0].stops.encumbered + "%"
      );
      set_style(
        div1,
        "--encumbrance-high",
        /*encumbrance*/
        ctx[0].stops.heavilyEncumbered + "%"
      );
      attr(div2, "class", "encumbrance svelte-mobile-companion81nkluj30u9vsd-19tcx0w");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, i0);
      append(div0, t0);
      append(div0, span0);
      append(span0, t1);
      append(div0, t2);
      append(div0, span1);
      append(div0, t4);
      append(div0, span2);
      append(span2, t5);
      append(div1, t6);
      append(div1, i1);
      append(div1, t7);
      append(div1, i2);
      append(div1, t8);
      append(div1, i3);
      append(div1, t9);
      append(div1, i4);
    },
    p(ctx2, dirty) {
      if (dirty & /*encumbrance*/
      1 && t1_value !== (t1_value = /*encumbrance*/
      ctx2[0].value + ""))
        set_data(t1, t1_value);
      if (dirty & /*encumbrance*/
      1 && t5_value !== (t5_value = /*encumbrance*/
      ctx2[0].max + ""))
        set_data(t5, t5_value);
      if (dirty & /*encumbrance*/
      1) {
        set_style(
          div1,
          "--bar-percentage",
          /*encumbrance*/
          ctx2[0].pct + "%"
        );
      }
      if (dirty & /*encumbrance*/
      1) {
        set_style(
          div1,
          "--encumbrance-low",
          /*encumbrance*/
          ctx2[0].stops.encumbered + "%"
        );
      }
      if (dirty & /*encumbrance*/
      1) {
        set_style(
          div1,
          "--encumbrance-high",
          /*encumbrance*/
          ctx2[0].stops.heavilyEncumbered + "%"
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_fragment$11(ctx) {
  let if_block_anchor;
  let if_block = (
    /*isUsingEncumbrance*/
    ctx[1] && create_if_block$N(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*isUsingEncumbrance*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$N(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$11($$self, $$props, $$invalidate) {
  let { actor } = $$props;
  let encumbrance = actor.system.attributes.encumbrance;
  let isUsingEncumbrance = true;
  const unsubscribe = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useEncumbrance).subscribe((value) => {
    $$invalidate(1, isUsingEncumbrance = value);
  });
  onDestroy(() => {
    unsubscribe();
  });
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(2, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    4) {
      $$invalidate(0, encumbrance = actor.system.attributes.encumbrance);
    }
  };
  return [encumbrance, isUsingEncumbrance, actor];
}
class Dnd5eEncumbrance extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$11, create_fragment$11, safe_not_equal, { actor: 2 });
  }
}
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n) {
    for (var e2 = 1; e2 < arguments.length; e2++) {
      var t = arguments[e2];
      for (var r in t)
        ({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);
    }
    return n;
  }, _extends$1.apply(null, arguments);
}
var DEFAULT_CONFIG = {
  // minimum relative difference between two compared values,
  // used by all comparison functions
  epsilon: 1e-12,
  // type of default matrix output. Choose 'matrix' (default) or 'array'
  matrix: "Matrix",
  // type of default number output. Choose 'number' (default) 'BigNumber', or 'Fraction
  number: "number",
  // number of significant digits in BigNumbers
  precision: 64,
  // predictable output type of functions. When true, output type depends only
  // on the input types. When false (default), output type can vary depending
  // on input values. For example `math.sqrt(-4)` returns `complex('2i')` when
  // predictable is false, and returns `NaN` when true.
  predictable: false,
  // random seed for seeded pseudo random number generation
  // null = randomly seed
  randomSeed: null
};
function isNumber(x) {
  return typeof x === "number";
}
function isBigNumber(x) {
  if (!x || typeof x !== "object" || typeof x.constructor !== "function") {
    return false;
  }
  if (x.isBigNumber === true && typeof x.constructor.prototype === "object" && x.constructor.prototype.isBigNumber === true) {
    return true;
  }
  if (typeof x.constructor.isDecimal === "function" && x.constructor.isDecimal(x) === true) {
    return true;
  }
  return false;
}
function isComplex(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isComplex === true || false;
}
function isFraction(x) {
  return x && typeof x === "object" && Object.getPrototypeOf(x).isFraction === true || false;
}
function isUnit(x) {
  return x && x.constructor.prototype.isUnit === true || false;
}
function isString(x) {
  return typeof x === "string";
}
var isArray = Array.isArray;
function isMatrix(x) {
  return x && x.constructor.prototype.isMatrix === true || false;
}
function isCollection(x) {
  return Array.isArray(x) || isMatrix(x);
}
function isDenseMatrix(x) {
  return x && x.isDenseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isSparseMatrix(x) {
  return x && x.isSparseMatrix && x.constructor.prototype.isMatrix === true || false;
}
function isRange(x) {
  return x && x.constructor.prototype.isRange === true || false;
}
function isIndex(x) {
  return x && x.constructor.prototype.isIndex === true || false;
}
function isBoolean(x) {
  return typeof x === "boolean";
}
function isResultSet(x) {
  return x && x.constructor.prototype.isResultSet === true || false;
}
function isHelp(x) {
  return x && x.constructor.prototype.isHelp === true || false;
}
function isFunction(x) {
  return typeof x === "function";
}
function isDate(x) {
  return x instanceof Date;
}
function isRegExp(x) {
  return x instanceof RegExp;
}
function isObject(x) {
  return !!(x && typeof x === "object" && x.constructor === Object && !isComplex(x) && !isFraction(x));
}
function isNull(x) {
  return x === null;
}
function isUndefined(x) {
  return x === void 0;
}
function isAccessorNode(x) {
  return x && x.isAccessorNode === true && x.constructor.prototype.isNode === true || false;
}
function isArrayNode(x) {
  return x && x.isArrayNode === true && x.constructor.prototype.isNode === true || false;
}
function isAssignmentNode(x) {
  return x && x.isAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isBlockNode(x) {
  return x && x.isBlockNode === true && x.constructor.prototype.isNode === true || false;
}
function isConditionalNode(x) {
  return x && x.isConditionalNode === true && x.constructor.prototype.isNode === true || false;
}
function isConstantNode(x) {
  return x && x.isConstantNode === true && x.constructor.prototype.isNode === true || false;
}
function rule2Node(node) {
  return isConstantNode(node) || isOperatorNode(node) && node.args.length === 1 && isConstantNode(node.args[0]) && "-+~".includes(node.op);
}
function isFunctionAssignmentNode(x) {
  return x && x.isFunctionAssignmentNode === true && x.constructor.prototype.isNode === true || false;
}
function isFunctionNode(x) {
  return x && x.isFunctionNode === true && x.constructor.prototype.isNode === true || false;
}
function isIndexNode(x) {
  return x && x.isIndexNode === true && x.constructor.prototype.isNode === true || false;
}
function isNode(x) {
  return x && x.isNode === true && x.constructor.prototype.isNode === true || false;
}
function isObjectNode(x) {
  return x && x.isObjectNode === true && x.constructor.prototype.isNode === true || false;
}
function isOperatorNode(x) {
  return x && x.isOperatorNode === true && x.constructor.prototype.isNode === true || false;
}
function isParenthesisNode(x) {
  return x && x.isParenthesisNode === true && x.constructor.prototype.isNode === true || false;
}
function isRangeNode(x) {
  return x && x.isRangeNode === true && x.constructor.prototype.isNode === true || false;
}
function isRelationalNode(x) {
  return x && x.isRelationalNode === true && x.constructor.prototype.isNode === true || false;
}
function isSymbolNode(x) {
  return x && x.isSymbolNode === true && x.constructor.prototype.isNode === true || false;
}
function isChain(x) {
  return x && x.constructor.prototype.isChain === true || false;
}
function typeOf$1(x) {
  var t = typeof x;
  if (t === "object") {
    if (x === null)
      return "null";
    if (isBigNumber(x))
      return "BigNumber";
    if (x.constructor && x.constructor.name)
      return x.constructor.name;
    return "Object";
  }
  return t;
}
function clone$3(x) {
  var type = typeof x;
  if (type === "number" || type === "string" || type === "boolean" || x === null || x === void 0) {
    return x;
  }
  if (typeof x.clone === "function") {
    return x.clone();
  }
  if (Array.isArray(x)) {
    return x.map(function(value) {
      return clone$3(value);
    });
  }
  if (x instanceof Date)
    return new Date(x.valueOf());
  if (isBigNumber(x))
    return x;
  if (isObject(x)) {
    return mapObject(x, clone$3);
  }
  throw new TypeError("Cannot clone: unknown type of value (value: ".concat(x, ")"));
}
function mapObject(object, callback) {
  var clone2 = {};
  for (var key in object) {
    if (hasOwnProperty(object, key)) {
      clone2[key] = callback(object[key]);
    }
  }
  return clone2;
}
function extend(a, b) {
  for (var prop in b) {
    if (hasOwnProperty(b, prop)) {
      a[prop] = b[prop];
    }
  }
  return a;
}
function deepStrictEqual(a, b) {
  var prop, i2, len;
  if (Array.isArray(a)) {
    if (!Array.isArray(b)) {
      return false;
    }
    if (a.length !== b.length) {
      return false;
    }
    for (i2 = 0, len = a.length; i2 < len; i2++) {
      if (!deepStrictEqual(a[i2], b[i2])) {
        return false;
      }
    }
    return true;
  } else if (typeof a === "function") {
    return a === b;
  } else if (a instanceof Object) {
    if (Array.isArray(b) || !(b instanceof Object)) {
      return false;
    }
    for (prop in a) {
      if (!(prop in b) || !deepStrictEqual(a[prop], b[prop])) {
        return false;
      }
    }
    for (prop in b) {
      if (!(prop in a)) {
        return false;
      }
    }
    return true;
  } else {
    return a === b;
  }
}
function lazy(object, prop, valueResolver) {
  var _uninitialized = true;
  var _value;
  Object.defineProperty(object, prop, {
    get: function get() {
      if (_uninitialized) {
        _value = valueResolver();
        _uninitialized = false;
      }
      return _value;
    },
    set: function set2(value) {
      _value = value;
      _uninitialized = false;
    },
    configurable: true,
    enumerable: true
  });
}
function hasOwnProperty(object, property) {
  return object && Object.hasOwnProperty.call(object, property);
}
function pickShallow(object, properties2) {
  var copy = {};
  for (var i2 = 0; i2 < properties2.length; i2++) {
    var key = properties2[i2];
    var value = object[key];
    if (value !== void 0) {
      copy[key] = value;
    }
  }
  return copy;
}
var MATRIX_OPTIONS = ["Matrix", "Array"];
var NUMBER_OPTIONS = ["number", "BigNumber", "Fraction"];
var config$1 = function config(options) {
  if (options) {
    throw new Error("The global config is readonly. \nPlease create a mathjs instance if you want to change the default configuration. \nExample:\n\n  import { create, all } from 'mathjs';\n  const mathjs = create(all);\n  mathjs.config({ number: 'BigNumber' });\n");
  }
  return Object.freeze(DEFAULT_CONFIG);
};
_extends$1(config$1, DEFAULT_CONFIG, {
  MATRIX_OPTIONS,
  NUMBER_OPTIONS
});
function ok() {
  return true;
}
function notOk() {
  return false;
}
function undef() {
  return void 0;
}
const NOT_TYPED_FUNCTION = "Argument is not a typed-function.";
function create() {
  function isPlainObject2(x) {
    return typeof x === "object" && x !== null && x.constructor === Object;
  }
  const _types = [{
    name: "number",
    test: function(x) {
      return typeof x === "number";
    }
  }, {
    name: "string",
    test: function(x) {
      return typeof x === "string";
    }
  }, {
    name: "boolean",
    test: function(x) {
      return typeof x === "boolean";
    }
  }, {
    name: "Function",
    test: function(x) {
      return typeof x === "function";
    }
  }, {
    name: "Array",
    test: Array.isArray
  }, {
    name: "Date",
    test: function(x) {
      return x instanceof Date;
    }
  }, {
    name: "RegExp",
    test: function(x) {
      return x instanceof RegExp;
    }
  }, {
    name: "Object",
    test: isPlainObject2
  }, {
    name: "null",
    test: function(x) {
      return x === null;
    }
  }, {
    name: "undefined",
    test: function(x) {
      return x === void 0;
    }
  }];
  const anyType = {
    name: "any",
    test: ok,
    isAny: true
  };
  let typeMap;
  let typeList;
  let nConversions = 0;
  let typed2 = {
    createCount: 0
  };
  function findType(typeName) {
    const type = typeMap.get(typeName);
    if (type) {
      return type;
    }
    let message = 'Unknown type "' + typeName + '"';
    const name2 = typeName.toLowerCase();
    let otherName;
    for (otherName of typeList) {
      if (otherName.toLowerCase() === name2) {
        message += '. Did you mean "' + otherName + '" ?';
        break;
      }
    }
    throw new TypeError(message);
  }
  function addTypes(types) {
    let beforeSpec = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "any";
    const beforeIndex = beforeSpec ? findType(beforeSpec).index : typeList.length;
    const newTypes = [];
    for (let i2 = 0; i2 < types.length; ++i2) {
      if (!types[i2] || typeof types[i2].name !== "string" || typeof types[i2].test !== "function") {
        throw new TypeError("Object with properties {name: string, test: function} expected");
      }
      const typeName = types[i2].name;
      if (typeMap.has(typeName)) {
        throw new TypeError('Duplicate type name "' + typeName + '"');
      }
      newTypes.push(typeName);
      typeMap.set(typeName, {
        name: typeName,
        test: types[i2].test,
        isAny: types[i2].isAny,
        index: beforeIndex + i2,
        conversionsTo: []
        // Newly added type can't have any conversions to it
      });
    }
    const affectedTypes = typeList.slice(beforeIndex);
    typeList = typeList.slice(0, beforeIndex).concat(newTypes).concat(affectedTypes);
    for (let i2 = beforeIndex + newTypes.length; i2 < typeList.length; ++i2) {
      typeMap.get(typeList[i2]).index = i2;
    }
  }
  function clear() {
    typeMap = /* @__PURE__ */ new Map();
    typeList = [];
    nConversions = 0;
    addTypes([anyType], false);
  }
  clear();
  addTypes(_types);
  function clearConversions() {
    let typeName;
    for (typeName of typeList) {
      typeMap.get(typeName).conversionsTo = [];
    }
    nConversions = 0;
  }
  function findTypeNames(value) {
    const matches = typeList.filter((name2) => {
      const type = typeMap.get(name2);
      return !type.isAny && type.test(value);
    });
    if (matches.length) {
      return matches;
    }
    return ["any"];
  }
  function isTypedFunction(entity) {
    return entity && typeof entity === "function" && "_typedFunctionData" in entity;
  }
  function findSignature(fn, signature, options) {
    if (!isTypedFunction(fn)) {
      throw new TypeError(NOT_TYPED_FUNCTION);
    }
    const exact = options && options.exact;
    const stringSignature = Array.isArray(signature) ? signature.join(",") : signature;
    const params = parseSignature(stringSignature);
    const canonicalSignature = stringifyParams(params);
    if (!exact || canonicalSignature in fn.signatures) {
      const match = fn._typedFunctionData.signatureMap.get(canonicalSignature);
      if (match) {
        return match;
      }
    }
    const nParams = params.length;
    let remainingSignatures;
    if (exact) {
      remainingSignatures = [];
      let name2;
      for (name2 in fn.signatures) {
        remainingSignatures.push(fn._typedFunctionData.signatureMap.get(name2));
      }
    } else {
      remainingSignatures = fn._typedFunctionData.signatures;
    }
    for (let i2 = 0; i2 < nParams; ++i2) {
      const want = params[i2];
      const filteredSignatures = [];
      let possibility;
      for (possibility of remainingSignatures) {
        const have = getParamAtIndex(possibility.params, i2);
        if (!have || want.restParam && !have.restParam) {
          continue;
        }
        if (!have.hasAny) {
          const haveTypes = paramTypeSet(have);
          if (want.types.some((wtype) => !haveTypes.has(wtype.name))) {
            continue;
          }
        }
        filteredSignatures.push(possibility);
      }
      remainingSignatures = filteredSignatures;
      if (remainingSignatures.length === 0)
        break;
    }
    let candidate;
    for (candidate of remainingSignatures) {
      if (candidate.params.length <= nParams) {
        return candidate;
      }
    }
    throw new TypeError("Signature not found (signature: " + (fn.name || "unnamed") + "(" + stringifyParams(params, ", ") + "))");
  }
  function find(fn, signature, options) {
    return findSignature(fn, signature, options).implementation;
  }
  function convert(value, typeName) {
    const type = findType(typeName);
    if (type.test(value)) {
      return value;
    }
    const conversions = type.conversionsTo;
    if (conversions.length === 0) {
      throw new Error("There are no conversions to " + typeName + " defined.");
    }
    for (let i2 = 0; i2 < conversions.length; i2++) {
      const fromType = findType(conversions[i2].from);
      if (fromType.test(value)) {
        return conversions[i2].convert(value);
      }
    }
    throw new Error("Cannot convert " + value + " to " + typeName);
  }
  function stringifyParams(params) {
    let separator = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : ",";
    return params.map((p) => p.name).join(separator);
  }
  function parseParam(param) {
    const restParam = param.indexOf("...") === 0;
    const types = !restParam ? param : param.length > 3 ? param.slice(3) : "any";
    const typeDefs = types.split("|").map((s) => findType(s.trim()));
    let hasAny = false;
    let paramName = restParam ? "..." : "";
    const exactTypes = typeDefs.map(function(type) {
      hasAny = type.isAny || hasAny;
      paramName += type.name + "|";
      return {
        name: type.name,
        typeIndex: type.index,
        test: type.test,
        isAny: type.isAny,
        conversion: null,
        conversionIndex: -1
      };
    });
    return {
      types: exactTypes,
      name: paramName.slice(0, -1),
      // remove trailing '|' from above
      hasAny,
      hasConversion: false,
      restParam
    };
  }
  function expandParam(param) {
    const typeNames = param.types.map((t) => t.name);
    const matchingConversions = availableConversions(typeNames);
    let hasAny = param.hasAny;
    let newName = param.name;
    const convertibleTypes = matchingConversions.map(function(conversion) {
      const type = findType(conversion.from);
      hasAny = type.isAny || hasAny;
      newName += "|" + conversion.from;
      return {
        name: conversion.from,
        typeIndex: type.index,
        test: type.test,
        isAny: type.isAny,
        conversion,
        conversionIndex: conversion.index
      };
    });
    return {
      types: param.types.concat(convertibleTypes),
      name: newName,
      hasAny,
      hasConversion: convertibleTypes.length > 0,
      restParam: param.restParam
    };
  }
  function paramTypeSet(param) {
    if (!param.typeSet) {
      param.typeSet = /* @__PURE__ */ new Set();
      param.types.forEach((type) => param.typeSet.add(type.name));
    }
    return param.typeSet;
  }
  function parseSignature(rawSignature) {
    const params = [];
    if (typeof rawSignature !== "string") {
      throw new TypeError("Signatures must be strings");
    }
    const signature = rawSignature.trim();
    if (signature === "") {
      return params;
    }
    const rawParams = signature.split(",");
    for (let i2 = 0; i2 < rawParams.length; ++i2) {
      const parsedParam = parseParam(rawParams[i2].trim());
      if (parsedParam.restParam && i2 !== rawParams.length - 1) {
        throw new SyntaxError('Unexpected rest parameter "' + rawParams[i2] + '": only allowed for the last parameter');
      }
      if (parsedParam.types.length === 0) {
        return null;
      }
      params.push(parsedParam);
    }
    return params;
  }
  function hasRestParam(params) {
    const param = last(params);
    return param ? param.restParam : false;
  }
  function compileTest(param) {
    if (!param || param.types.length === 0) {
      return ok;
    } else if (param.types.length === 1) {
      return findType(param.types[0].name).test;
    } else if (param.types.length === 2) {
      const test0 = findType(param.types[0].name).test;
      const test1 = findType(param.types[1].name).test;
      return function or2(x) {
        return test0(x) || test1(x);
      };
    } else {
      const tests = param.types.map(function(type) {
        return findType(type.name).test;
      });
      return function or2(x) {
        for (let i2 = 0; i2 < tests.length; i2++) {
          if (tests[i2](x)) {
            return true;
          }
        }
        return false;
      };
    }
  }
  function compileTests(params) {
    let tests, test0, test1;
    if (hasRestParam(params)) {
      tests = initial(params).map(compileTest);
      const varIndex = tests.length;
      const lastTest = compileTest(last(params));
      const testRestParam = function(args) {
        for (let i2 = varIndex; i2 < args.length; i2++) {
          if (!lastTest(args[i2])) {
            return false;
          }
        }
        return true;
      };
      return function testArgs(args) {
        for (let i2 = 0; i2 < tests.length; i2++) {
          if (!tests[i2](args[i2])) {
            return false;
          }
        }
        return testRestParam(args) && args.length >= varIndex + 1;
      };
    } else {
      if (params.length === 0) {
        return function testArgs(args) {
          return args.length === 0;
        };
      } else if (params.length === 1) {
        test0 = compileTest(params[0]);
        return function testArgs(args) {
          return test0(args[0]) && args.length === 1;
        };
      } else if (params.length === 2) {
        test0 = compileTest(params[0]);
        test1 = compileTest(params[1]);
        return function testArgs(args) {
          return test0(args[0]) && test1(args[1]) && args.length === 2;
        };
      } else {
        tests = params.map(compileTest);
        return function testArgs(args) {
          for (let i2 = 0; i2 < tests.length; i2++) {
            if (!tests[i2](args[i2])) {
              return false;
            }
          }
          return args.length === tests.length;
        };
      }
    }
  }
  function getParamAtIndex(params, index2) {
    return index2 < params.length ? params[index2] : hasRestParam(params) ? last(params) : null;
  }
  function getTypeSetAtIndex(params, index2) {
    const param = getParamAtIndex(params, index2);
    if (!param) {
      return /* @__PURE__ */ new Set();
    }
    return paramTypeSet(param);
  }
  function isExactType(type) {
    return type.conversion === null || type.conversion === void 0;
  }
  function mergeExpectedParams(signatures, index2) {
    const typeSet = /* @__PURE__ */ new Set();
    signatures.forEach((signature) => {
      const paramSet = getTypeSetAtIndex(signature.params, index2);
      let name2;
      for (name2 of paramSet) {
        typeSet.add(name2);
      }
    });
    return typeSet.has("any") ? ["any"] : Array.from(typeSet);
  }
  function createError(name2, args, signatures) {
    let err, expected;
    const _name = name2 || "unnamed";
    let matchingSignatures = signatures;
    let index2;
    for (index2 = 0; index2 < args.length; index2++) {
      const nextMatchingDefs = [];
      matchingSignatures.forEach((signature) => {
        const param = getParamAtIndex(signature.params, index2);
        const test = compileTest(param);
        if ((index2 < signature.params.length || hasRestParam(signature.params)) && test(args[index2])) {
          nextMatchingDefs.push(signature);
        }
      });
      if (nextMatchingDefs.length === 0) {
        expected = mergeExpectedParams(matchingSignatures, index2);
        if (expected.length > 0) {
          const actualTypes = findTypeNames(args[index2]);
          err = new TypeError("Unexpected type of argument in function " + _name + " (expected: " + expected.join(" or ") + ", actual: " + actualTypes.join(" | ") + ", index: " + index2 + ")");
          err.data = {
            category: "wrongType",
            fn: _name,
            index: index2,
            actual: actualTypes,
            expected
          };
          return err;
        }
      } else {
        matchingSignatures = nextMatchingDefs;
      }
    }
    const lengths = matchingSignatures.map(function(signature) {
      return hasRestParam(signature.params) ? Infinity : signature.params.length;
    });
    if (args.length < Math.min.apply(null, lengths)) {
      expected = mergeExpectedParams(matchingSignatures, index2);
      err = new TypeError("Too few arguments in function " + _name + " (expected: " + expected.join(" or ") + ", index: " + args.length + ")");
      err.data = {
        category: "tooFewArgs",
        fn: _name,
        index: args.length,
        expected
      };
      return err;
    }
    const maxLength = Math.max.apply(null, lengths);
    if (args.length > maxLength) {
      err = new TypeError("Too many arguments in function " + _name + " (expected: " + maxLength + ", actual: " + args.length + ")");
      err.data = {
        category: "tooManyArgs",
        fn: _name,
        index: args.length,
        expectedLength: maxLength
      };
      return err;
    }
    const argTypes = [];
    for (let i2 = 0; i2 < args.length; ++i2) {
      argTypes.push(findTypeNames(args[i2]).join("|"));
    }
    err = new TypeError('Arguments of type "' + argTypes.join(", ") + '" do not match any of the defined signatures of function ' + _name + ".");
    err.data = {
      category: "mismatch",
      actual: argTypes
    };
    return err;
  }
  function getLowestTypeIndex(param) {
    let min2 = typeList.length + 1;
    for (let i2 = 0; i2 < param.types.length; i2++) {
      if (isExactType(param.types[i2])) {
        min2 = Math.min(min2, param.types[i2].typeIndex);
      }
    }
    return min2;
  }
  function getLowestConversionIndex(param) {
    let min2 = nConversions + 1;
    for (let i2 = 0; i2 < param.types.length; i2++) {
      if (!isExactType(param.types[i2])) {
        min2 = Math.min(min2, param.types[i2].conversionIndex);
      }
    }
    return min2;
  }
  function compareParams(param1, param2) {
    if (param1.hasAny) {
      if (!param2.hasAny) {
        return 1;
      }
    } else if (param2.hasAny) {
      return -1;
    }
    if (param1.restParam) {
      if (!param2.restParam) {
        return 1;
      }
    } else if (param2.restParam) {
      return -1;
    }
    if (param1.hasConversion) {
      if (!param2.hasConversion) {
        return 1;
      }
    } else if (param2.hasConversion) {
      return -1;
    }
    const typeDiff = getLowestTypeIndex(param1) - getLowestTypeIndex(param2);
    if (typeDiff < 0) {
      return -1;
    }
    if (typeDiff > 0) {
      return 1;
    }
    const convDiff = getLowestConversionIndex(param1) - getLowestConversionIndex(param2);
    if (convDiff < 0) {
      return -1;
    }
    if (convDiff > 0) {
      return 1;
    }
    return 0;
  }
  function compareSignatures(signature1, signature2) {
    const pars1 = signature1.params;
    const pars2 = signature2.params;
    const last1 = last(pars1);
    const last2 = last(pars2);
    const hasRest1 = hasRestParam(pars1);
    const hasRest2 = hasRestParam(pars2);
    if (hasRest1 && last1.hasAny) {
      if (!hasRest2 || !last2.hasAny) {
        return 1;
      }
    } else if (hasRest2 && last2.hasAny) {
      return -1;
    }
    let any1 = 0;
    let conv1 = 0;
    let par;
    for (par of pars1) {
      if (par.hasAny)
        ++any1;
      if (par.hasConversion)
        ++conv1;
    }
    let any2 = 0;
    let conv2 = 0;
    for (par of pars2) {
      if (par.hasAny)
        ++any2;
      if (par.hasConversion)
        ++conv2;
    }
    if (any1 !== any2) {
      return any1 - any2;
    }
    if (hasRest1 && last1.hasConversion) {
      if (!hasRest2 || !last2.hasConversion) {
        return 1;
      }
    } else if (hasRest2 && last2.hasConversion) {
      return -1;
    }
    if (conv1 !== conv2) {
      return conv1 - conv2;
    }
    if (hasRest1) {
      if (!hasRest2) {
        return 1;
      }
    } else if (hasRest2) {
      return -1;
    }
    const lengthCriterion = (pars1.length - pars2.length) * (hasRest1 ? -1 : 1);
    if (lengthCriterion !== 0) {
      return lengthCriterion;
    }
    const comparisons = [];
    let tc = 0;
    for (let i2 = 0; i2 < pars1.length; ++i2) {
      const thisComparison = compareParams(pars1[i2], pars2[i2]);
      comparisons.push(thisComparison);
      tc += thisComparison;
    }
    if (tc !== 0) {
      return tc;
    }
    let c;
    for (c of comparisons) {
      if (c !== 0) {
        return c;
      }
    }
    return 0;
  }
  function availableConversions(typeNames) {
    if (typeNames.length === 0) {
      return [];
    }
    const types = typeNames.map(findType);
    if (typeNames.length > 1) {
      types.sort((t1, t2) => t1.index - t2.index);
    }
    let matches = types[0].conversionsTo;
    if (typeNames.length === 1) {
      return matches;
    }
    matches = matches.concat([]);
    const knownTypes = new Set(typeNames);
    for (let i2 = 1; i2 < types.length; ++i2) {
      let newMatch;
      for (newMatch of types[i2].conversionsTo) {
        if (!knownTypes.has(newMatch.from)) {
          matches.push(newMatch);
          knownTypes.add(newMatch.from);
        }
      }
    }
    return matches;
  }
  function compileArgsPreprocessing(params, fn) {
    let fnConvert = fn;
    if (params.some((p) => p.hasConversion)) {
      const restParam = hasRestParam(params);
      const compiledConversions = params.map(compileArgConversion);
      fnConvert = function convertArgs() {
        const args = [];
        const last2 = restParam ? arguments.length - 1 : arguments.length;
        for (let i2 = 0; i2 < last2; i2++) {
          args[i2] = compiledConversions[i2](arguments[i2]);
        }
        if (restParam) {
          args[last2] = arguments[last2].map(compiledConversions[last2]);
        }
        return fn.apply(this, args);
      };
    }
    let fnPreprocess = fnConvert;
    if (hasRestParam(params)) {
      const offset = params.length - 1;
      fnPreprocess = function preprocessRestParams() {
        return fnConvert.apply(this, slice(arguments, 0, offset).concat([slice(arguments, offset)]));
      };
    }
    return fnPreprocess;
  }
  function compileArgConversion(param) {
    let test0, test1, conversion0, conversion1;
    const tests = [];
    const conversions = [];
    param.types.forEach(function(type) {
      if (type.conversion) {
        tests.push(findType(type.conversion.from).test);
        conversions.push(type.conversion.convert);
      }
    });
    switch (conversions.length) {
      case 0:
        return function convertArg(arg2) {
          return arg2;
        };
      case 1:
        test0 = tests[0];
        conversion0 = conversions[0];
        return function convertArg(arg2) {
          if (test0(arg2)) {
            return conversion0(arg2);
          }
          return arg2;
        };
      case 2:
        test0 = tests[0];
        test1 = tests[1];
        conversion0 = conversions[0];
        conversion1 = conversions[1];
        return function convertArg(arg2) {
          if (test0(arg2)) {
            return conversion0(arg2);
          }
          if (test1(arg2)) {
            return conversion1(arg2);
          }
          return arg2;
        };
      default:
        return function convertArg(arg2) {
          for (let i2 = 0; i2 < conversions.length; i2++) {
            if (tests[i2](arg2)) {
              return conversions[i2](arg2);
            }
          }
          return arg2;
        };
    }
  }
  function splitParams(params) {
    function _splitParams(params2, index2, paramsSoFar) {
      if (index2 < params2.length) {
        const param = params2[index2];
        let resultingParams = [];
        if (param.restParam) {
          const exactTypes = param.types.filter(isExactType);
          if (exactTypes.length < param.types.length) {
            resultingParams.push({
              types: exactTypes,
              name: "..." + exactTypes.map((t) => t.name).join("|"),
              hasAny: exactTypes.some((t) => t.isAny),
              hasConversion: false,
              restParam: true
            });
          }
          resultingParams.push(param);
        } else {
          resultingParams = param.types.map(function(type) {
            return {
              types: [type],
              name: type.name,
              hasAny: type.isAny,
              hasConversion: type.conversion,
              restParam: false
            };
          });
        }
        return flatMap(resultingParams, function(nextParam) {
          return _splitParams(params2, index2 + 1, paramsSoFar.concat([nextParam]));
        });
      } else {
        return [paramsSoFar];
      }
    }
    return _splitParams(params, 0, []);
  }
  function conflicting(params1, params2) {
    const ii = Math.max(params1.length, params2.length);
    for (let i2 = 0; i2 < ii; i2++) {
      const typeSet1 = getTypeSetAtIndex(params1, i2);
      const typeSet2 = getTypeSetAtIndex(params2, i2);
      let overlap = false;
      let name2;
      for (name2 of typeSet2) {
        if (typeSet1.has(name2)) {
          overlap = true;
          break;
        }
      }
      if (!overlap) {
        return false;
      }
    }
    const len1 = params1.length;
    const len2 = params2.length;
    const restParam1 = hasRestParam(params1);
    const restParam2 = hasRestParam(params2);
    return restParam1 ? restParam2 ? len1 === len2 : len2 >= len1 : restParam2 ? len1 >= len2 : len1 === len2;
  }
  function clearResolutions(functionList) {
    return functionList.map((fn) => {
      if (isReferToSelf(fn)) {
        return referToSelf(fn.referToSelf.callback);
      }
      if (isReferTo(fn)) {
        return makeReferTo(fn.referTo.references, fn.referTo.callback);
      }
      return fn;
    });
  }
  function collectResolutions(references, functionList, signatureMap) {
    const resolvedReferences = [];
    let reference;
    for (reference of references) {
      let resolution = signatureMap[reference];
      if (typeof resolution !== "number") {
        throw new TypeError('No definition for referenced signature "' + reference + '"');
      }
      resolution = functionList[resolution];
      if (typeof resolution !== "function") {
        return false;
      }
      resolvedReferences.push(resolution);
    }
    return resolvedReferences;
  }
  function resolveReferences(functionList, signatureMap, self2) {
    const resolvedFunctions = clearResolutions(functionList);
    const isResolved = new Array(resolvedFunctions.length).fill(false);
    let leftUnresolved = true;
    while (leftUnresolved) {
      leftUnresolved = false;
      let nothingResolved = true;
      for (let i2 = 0; i2 < resolvedFunctions.length; ++i2) {
        if (isResolved[i2])
          continue;
        const fn = resolvedFunctions[i2];
        if (isReferToSelf(fn)) {
          resolvedFunctions[i2] = fn.referToSelf.callback(self2);
          resolvedFunctions[i2].referToSelf = fn.referToSelf;
          isResolved[i2] = true;
          nothingResolved = false;
        } else if (isReferTo(fn)) {
          const resolvedReferences = collectResolutions(fn.referTo.references, resolvedFunctions, signatureMap);
          if (resolvedReferences) {
            resolvedFunctions[i2] = fn.referTo.callback.apply(this, resolvedReferences);
            resolvedFunctions[i2].referTo = fn.referTo;
            isResolved[i2] = true;
            nothingResolved = false;
          } else {
            leftUnresolved = true;
          }
        }
      }
      if (nothingResolved && leftUnresolved) {
        throw new SyntaxError("Circular reference detected in resolving typed.referTo");
      }
    }
    return resolvedFunctions;
  }
  function validateDeprecatedThis(signaturesMap) {
    const deprecatedThisRegex = /\bthis(\(|\.signatures\b)/;
    Object.keys(signaturesMap).forEach((signature) => {
      const fn = signaturesMap[signature];
      if (deprecatedThisRegex.test(fn.toString())) {
        throw new SyntaxError("Using `this` to self-reference a function is deprecated since typed-function@3. Use typed.referTo and typed.referToSelf instead.");
      }
    });
  }
  function createTypedFunction(name2, rawSignaturesMap) {
    typed2.createCount++;
    if (Object.keys(rawSignaturesMap).length === 0) {
      throw new SyntaxError("No signatures provided");
    }
    if (typed2.warnAgainstDeprecatedThis) {
      validateDeprecatedThis(rawSignaturesMap);
    }
    const parsedParams = [];
    const originalFunctions = [];
    const signaturesMap = {};
    const preliminarySignatures = [];
    let signature;
    for (signature in rawSignaturesMap) {
      if (!Object.prototype.hasOwnProperty.call(rawSignaturesMap, signature)) {
        continue;
      }
      const params = parseSignature(signature);
      if (!params)
        continue;
      parsedParams.forEach(function(pp) {
        if (conflicting(pp, params)) {
          throw new TypeError('Conflicting signatures "' + stringifyParams(pp) + '" and "' + stringifyParams(params) + '".');
        }
      });
      parsedParams.push(params);
      const functionIndex = originalFunctions.length;
      originalFunctions.push(rawSignaturesMap[signature]);
      const conversionParams = params.map(expandParam);
      let sp;
      for (sp of splitParams(conversionParams)) {
        const spName = stringifyParams(sp);
        preliminarySignatures.push({
          params: sp,
          name: spName,
          fn: functionIndex
        });
        if (sp.every((p) => !p.hasConversion)) {
          signaturesMap[spName] = functionIndex;
        }
      }
    }
    preliminarySignatures.sort(compareSignatures);
    const resolvedFunctions = resolveReferences(originalFunctions, signaturesMap, theTypedFn);
    let s;
    for (s in signaturesMap) {
      if (Object.prototype.hasOwnProperty.call(signaturesMap, s)) {
        signaturesMap[s] = resolvedFunctions[signaturesMap[s]];
      }
    }
    const signatures = [];
    const internalSignatureMap = /* @__PURE__ */ new Map();
    for (s of preliminarySignatures) {
      if (!internalSignatureMap.has(s.name)) {
        s.fn = resolvedFunctions[s.fn];
        signatures.push(s);
        internalSignatureMap.set(s.name, s);
      }
    }
    const ok0 = signatures[0] && signatures[0].params.length <= 2 && !hasRestParam(signatures[0].params);
    const ok1 = signatures[1] && signatures[1].params.length <= 2 && !hasRestParam(signatures[1].params);
    const ok2 = signatures[2] && signatures[2].params.length <= 2 && !hasRestParam(signatures[2].params);
    const ok3 = signatures[3] && signatures[3].params.length <= 2 && !hasRestParam(signatures[3].params);
    const ok4 = signatures[4] && signatures[4].params.length <= 2 && !hasRestParam(signatures[4].params);
    const ok5 = signatures[5] && signatures[5].params.length <= 2 && !hasRestParam(signatures[5].params);
    const allOk = ok0 && ok1 && ok2 && ok3 && ok4 && ok5;
    for (let i2 = 0; i2 < signatures.length; ++i2) {
      signatures[i2].test = compileTests(signatures[i2].params);
    }
    const test00 = ok0 ? compileTest(signatures[0].params[0]) : notOk;
    const test10 = ok1 ? compileTest(signatures[1].params[0]) : notOk;
    const test20 = ok2 ? compileTest(signatures[2].params[0]) : notOk;
    const test30 = ok3 ? compileTest(signatures[3].params[0]) : notOk;
    const test40 = ok4 ? compileTest(signatures[4].params[0]) : notOk;
    const test50 = ok5 ? compileTest(signatures[5].params[0]) : notOk;
    const test01 = ok0 ? compileTest(signatures[0].params[1]) : notOk;
    const test11 = ok1 ? compileTest(signatures[1].params[1]) : notOk;
    const test21 = ok2 ? compileTest(signatures[2].params[1]) : notOk;
    const test31 = ok3 ? compileTest(signatures[3].params[1]) : notOk;
    const test41 = ok4 ? compileTest(signatures[4].params[1]) : notOk;
    const test51 = ok5 ? compileTest(signatures[5].params[1]) : notOk;
    for (let i2 = 0; i2 < signatures.length; ++i2) {
      signatures[i2].implementation = compileArgsPreprocessing(signatures[i2].params, signatures[i2].fn);
    }
    const fn0 = ok0 ? signatures[0].implementation : undef;
    const fn1 = ok1 ? signatures[1].implementation : undef;
    const fn2 = ok2 ? signatures[2].implementation : undef;
    const fn3 = ok3 ? signatures[3].implementation : undef;
    const fn4 = ok4 ? signatures[4].implementation : undef;
    const fn5 = ok5 ? signatures[5].implementation : undef;
    const len0 = ok0 ? signatures[0].params.length : -1;
    const len1 = ok1 ? signatures[1].params.length : -1;
    const len2 = ok2 ? signatures[2].params.length : -1;
    const len3 = ok3 ? signatures[3].params.length : -1;
    const len4 = ok4 ? signatures[4].params.length : -1;
    const len5 = ok5 ? signatures[5].params.length : -1;
    const iStart = allOk ? 6 : 0;
    const iEnd = signatures.length;
    const tests = signatures.map((s2) => s2.test);
    const fns = signatures.map((s2) => s2.implementation);
    const generic = function generic2() {
      for (let i2 = iStart; i2 < iEnd; i2++) {
        if (tests[i2](arguments)) {
          return fns[i2].apply(this, arguments);
        }
      }
      return typed2.onMismatch(name2, arguments, signatures);
    };
    function theTypedFn(arg0, arg1) {
      if (arguments.length === len0 && test00(arg0) && test01(arg1)) {
        return fn0.apply(this, arguments);
      }
      if (arguments.length === len1 && test10(arg0) && test11(arg1)) {
        return fn1.apply(this, arguments);
      }
      if (arguments.length === len2 && test20(arg0) && test21(arg1)) {
        return fn2.apply(this, arguments);
      }
      if (arguments.length === len3 && test30(arg0) && test31(arg1)) {
        return fn3.apply(this, arguments);
      }
      if (arguments.length === len4 && test40(arg0) && test41(arg1)) {
        return fn4.apply(this, arguments);
      }
      if (arguments.length === len5 && test50(arg0) && test51(arg1)) {
        return fn5.apply(this, arguments);
      }
      return generic.apply(this, arguments);
    }
    try {
      Object.defineProperty(theTypedFn, "name", {
        value: name2
      });
    } catch (err) {
    }
    theTypedFn.signatures = signaturesMap;
    theTypedFn._typedFunctionData = {
      signatures,
      signatureMap: internalSignatureMap
    };
    return theTypedFn;
  }
  function _onMismatch(name2, args, signatures) {
    throw createError(name2, args, signatures);
  }
  function initial(arr) {
    return slice(arr, 0, arr.length - 1);
  }
  function last(arr) {
    return arr[arr.length - 1];
  }
  function slice(arr, start, end) {
    return Array.prototype.slice.call(arr, start, end);
  }
  function findInArray(arr, test) {
    for (let i2 = 0; i2 < arr.length; i2++) {
      if (test(arr[i2])) {
        return arr[i2];
      }
    }
    return void 0;
  }
  function flatMap(arr, callback) {
    return Array.prototype.concat.apply([], arr.map(callback));
  }
  function referTo() {
    const references = initial(arguments).map((s) => stringifyParams(parseSignature(s)));
    const callback = last(arguments);
    if (typeof callback !== "function") {
      throw new TypeError("Callback function expected as last argument");
    }
    return makeReferTo(references, callback);
  }
  function makeReferTo(references, callback) {
    return {
      referTo: {
        references,
        callback
      }
    };
  }
  function referToSelf(callback) {
    if (typeof callback !== "function") {
      throw new TypeError("Callback function expected as first argument");
    }
    return {
      referToSelf: {
        callback
      }
    };
  }
  function isReferTo(objectOrFn) {
    return objectOrFn && typeof objectOrFn.referTo === "object" && Array.isArray(objectOrFn.referTo.references) && typeof objectOrFn.referTo.callback === "function";
  }
  function isReferToSelf(objectOrFn) {
    return objectOrFn && typeof objectOrFn.referToSelf === "object" && typeof objectOrFn.referToSelf.callback === "function";
  }
  function checkName(nameSoFar, newName) {
    if (!nameSoFar) {
      return newName;
    }
    if (newName && newName !== nameSoFar) {
      const err = new Error("Function names do not match (expected: " + nameSoFar + ", actual: " + newName + ")");
      err.data = {
        actual: newName,
        expected: nameSoFar
      };
      throw err;
    }
    return nameSoFar;
  }
  function getObjectName(obj) {
    let name2;
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && (isTypedFunction(obj[key]) || typeof obj[key].signature === "string")) {
        name2 = checkName(name2, obj[key].name);
      }
    }
    return name2;
  }
  function mergeSignatures(dest, source) {
    let key;
    for (key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        if (key in dest) {
          if (source[key] !== dest[key]) {
            const err = new Error('Signature "' + key + '" is defined twice');
            err.data = {
              signature: key,
              sourceFunction: source[key],
              destFunction: dest[key]
            };
            throw err;
          }
        }
        dest[key] = source[key];
      }
    }
  }
  const saveTyped = typed2;
  typed2 = function(maybeName) {
    const named = typeof maybeName === "string";
    const start = named ? 1 : 0;
    let name2 = named ? maybeName : "";
    const allSignatures = {};
    for (let i2 = start; i2 < arguments.length; ++i2) {
      const item = arguments[i2];
      let theseSignatures = {};
      let thisName;
      if (typeof item === "function") {
        thisName = item.name;
        if (typeof item.signature === "string") {
          theseSignatures[item.signature] = item;
        } else if (isTypedFunction(item)) {
          theseSignatures = item.signatures;
        }
      } else if (isPlainObject2(item)) {
        theseSignatures = item;
        if (!named) {
          thisName = getObjectName(item);
        }
      }
      if (Object.keys(theseSignatures).length === 0) {
        const err = new TypeError("Argument to 'typed' at index " + i2 + " is not a (typed) function, nor an object with signatures as keys and functions as values.");
        err.data = {
          index: i2,
          argument: item
        };
        throw err;
      }
      if (!named) {
        name2 = checkName(name2, thisName);
      }
      mergeSignatures(allSignatures, theseSignatures);
    }
    return createTypedFunction(name2 || "", allSignatures);
  };
  typed2.create = create;
  typed2.createCount = saveTyped.createCount;
  typed2.onMismatch = _onMismatch;
  typed2.throwMismatchError = _onMismatch;
  typed2.createError = createError;
  typed2.clear = clear;
  typed2.clearConversions = clearConversions;
  typed2.addTypes = addTypes;
  typed2._findType = findType;
  typed2.referTo = referTo;
  typed2.referToSelf = referToSelf;
  typed2.convert = convert;
  typed2.findSignature = findSignature;
  typed2.find = find;
  typed2.isTypedFunction = isTypedFunction;
  typed2.warnAgainstDeprecatedThis = true;
  typed2.addType = function(type, beforeObjectTest) {
    let before = "any";
    if (beforeObjectTest !== false && typeMap.has("Object")) {
      before = "Object";
    }
    typed2.addTypes([type], before);
  };
  function _validateConversion(conversion) {
    if (!conversion || typeof conversion.from !== "string" || typeof conversion.to !== "string" || typeof conversion.convert !== "function") {
      throw new TypeError("Object with properties {from: string, to: string, convert: function} expected");
    }
    if (conversion.to === conversion.from) {
      throw new SyntaxError('Illegal to define conversion from "' + conversion.from + '" to itself.');
    }
  }
  typed2.addConversion = function(conversion) {
    _validateConversion(conversion);
    const to2 = findType(conversion.to);
    if (to2.conversionsTo.every(function(other) {
      return other.from !== conversion.from;
    })) {
      to2.conversionsTo.push({
        from: conversion.from,
        convert: conversion.convert,
        index: nConversions++
      });
    } else {
      throw new Error('There is already a conversion from "' + conversion.from + '" to "' + to2.name + '"');
    }
  };
  typed2.addConversions = function(conversions) {
    conversions.forEach(typed2.addConversion);
  };
  typed2.removeConversion = function(conversion) {
    _validateConversion(conversion);
    const to2 = findType(conversion.to);
    const existingConversion = findInArray(to2.conversionsTo, (c) => c.from === conversion.from);
    if (!existingConversion) {
      throw new Error("Attempt to remove nonexistent conversion from " + conversion.from + " to " + conversion.to);
    }
    if (existingConversion.convert !== conversion.convert) {
      throw new Error("Conversion to remove does not match existing conversion");
    }
    const index2 = to2.conversionsTo.indexOf(existingConversion);
    to2.conversionsTo.splice(index2, 1);
  };
  typed2.resolve = function(tf, argList) {
    if (!isTypedFunction(tf)) {
      throw new TypeError(NOT_TYPED_FUNCTION);
    }
    const sigs = tf._typedFunctionData.signatures;
    for (let i2 = 0; i2 < sigs.length; ++i2) {
      if (sigs[i2].test(argList)) {
        return sigs[i2];
      }
    }
    return null;
  };
  return typed2;
}
const typedFunction = create();
function isInteger$1(value) {
  if (typeof value === "boolean") {
    return true;
  }
  return isFinite(value) ? value === Math.round(value) : false;
}
var sign$2 = Math.sign || function(x) {
  if (x > 0) {
    return 1;
  } else if (x < 0) {
    return -1;
  } else {
    return 0;
  }
};
var log2$2 = Math.log2 || function log2(x) {
  return Math.log(x) / Math.LN2;
};
var log10$2 = Math.log10 || function log10(x) {
  return Math.log(x) / Math.LN10;
};
var log1p$1 = Math.log1p || function(x) {
  return Math.log(x + 1);
};
var cbrt$2 = Math.cbrt || function cbrt(x) {
  if (x === 0) {
    return x;
  }
  var negate = x < 0;
  var result;
  if (negate) {
    x = -x;
  }
  if (isFinite(x)) {
    result = Math.exp(Math.log(x) / 3);
    result = (x / (result * result) + 2 * result) / 3;
  } else {
    result = x;
  }
  return negate ? -result : result;
};
var expm1$1 = Math.expm1 || function expm1(x) {
  return x >= 2e-4 || x <= -2e-4 ? Math.exp(x) - 1 : x + x * x / 2 + x * x * x / 6;
};
function formatNumberToBase(n, base, size2) {
  var prefixes = {
    2: "0b",
    8: "0o",
    16: "0x"
  };
  var prefix = prefixes[base];
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger$1(size2)) {
      throw new Error("size must be an integer");
    }
    if (n > 2 ** (size2 - 1) - 1 || n < -(2 ** (size2 - 1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!isInteger$1(n)) {
      throw new Error("Value must be an integer");
    }
    if (n < 0) {
      n = n + 2 ** size2;
    }
    suffix = "i".concat(size2);
  }
  var sign2 = "";
  if (n < 0) {
    n = -n;
    sign2 = "-";
  }
  return "".concat(sign2).concat(prefix).concat(n.toString(base)).concat(suffix);
}
function format$3(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (value === Infinity) {
    return "Infinity";
  } else if (value === -Infinity) {
    return "-Infinity";
  } else if (isNaN(value)) {
    return "NaN";
  }
  var {
    notation,
    precision,
    wordSize
  } = normalizeFormatOptions(options);
  switch (notation) {
    case "fixed":
      return toFixed$1(value, precision);
    case "exponential":
      return toExponential$1(value, precision);
    case "engineering":
      return toEngineering$1(value, precision);
    case "bin":
      return formatNumberToBase(value, 2, wordSize);
    case "oct":
      return formatNumberToBase(value, 8, wordSize);
    case "hex":
      return formatNumberToBase(value, 16, wordSize);
    case "auto":
      return toPrecision(value, precision, options).replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e2 = arguments[4];
        return digits2 !== "." ? digits2 + e2 : e2;
      });
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function normalizeFormatOptions(options) {
  var notation = "auto";
  var precision;
  var wordSize;
  if (options !== void 0) {
    if (isNumber(options)) {
      precision = options;
    } else if (isBigNumber(options)) {
      precision = options.toNumber();
    } else if (isObject(options)) {
      if (options.precision !== void 0) {
        precision = _toNumberOrThrow(options.precision, () => {
          throw new Error('Option "precision" must be a number or BigNumber');
        });
      }
      if (options.wordSize !== void 0) {
        wordSize = _toNumberOrThrow(options.wordSize, () => {
          throw new Error('Option "wordSize" must be a number or BigNumber');
        });
      }
      if (options.notation) {
        notation = options.notation;
      }
    } else {
      throw new Error("Unsupported type of options, number, BigNumber, or object expected");
    }
  }
  return {
    notation,
    precision,
    wordSize
  };
}
function splitNumber(value) {
  var match = String(value).toLowerCase().match(/^(-?)(\d+\.?\d*)(e([+-]?\d+))?$/);
  if (!match) {
    throw new SyntaxError("Invalid number " + value);
  }
  var sign2 = match[1];
  var digits2 = match[2];
  var exponent = parseFloat(match[4] || "0");
  var dot2 = digits2.indexOf(".");
  exponent += dot2 !== -1 ? dot2 - 1 : digits2.length - 1;
  var coefficients = digits2.replace(".", "").replace(/^0*/, function(zeros2) {
    exponent -= zeros2.length;
    return "";
  }).replace(/0*$/, "").split("").map(function(d) {
    return parseInt(d);
  });
  if (coefficients.length === 0) {
    coefficients.push(0);
    exponent++;
  }
  return {
    sign: sign2,
    coefficients,
    exponent
  };
}
function toEngineering$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = roundDigits(split, precision);
  var e2 = rounded.exponent;
  var c = rounded.coefficients;
  var newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
  if (isNumber(precision)) {
    while (precision > c.length || e2 - newExp + 1 > c.length) {
      c.push(0);
    }
  } else {
    var missingZeros = Math.abs(e2 - newExp) - (c.length - 1);
    for (var i2 = 0; i2 < missingZeros; i2++) {
      c.push(0);
    }
  }
  var expDiff = Math.abs(e2 - newExp);
  var decimalIdx = 1;
  while (expDiff > 0) {
    decimalIdx++;
    expDiff--;
  }
  var decimals = c.slice(decimalIdx).join("");
  var decimalVal = isNumber(precision) && decimals.length || decimals.match(/[1-9]/) ? "." + decimals : "";
  var str = c.slice(0, decimalIdx).join("") + decimalVal + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
  return rounded.sign + str;
}
function toFixed$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var splitValue = splitNumber(value);
  var rounded = typeof precision === "number" ? roundDigits(splitValue, splitValue.exponent + 1 + precision) : splitValue;
  var c = rounded.coefficients;
  var p = rounded.exponent + 1;
  var pp = p + (precision || 0);
  if (c.length < pp) {
    c = c.concat(zeros$1(pp - c.length));
  }
  if (p < 0) {
    c = zeros$1(-p + 1).concat(c);
    p = 1;
  }
  if (p < c.length) {
    c.splice(p, 0, p === 0 ? "0." : ".");
  }
  return rounded.sign + c.join("");
}
function toExponential$1(value, precision) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  var c = rounded.coefficients;
  var e2 = rounded.exponent;
  if (c.length < precision) {
    c = c.concat(zeros$1(precision - c.length));
  }
  var first = c.shift();
  return rounded.sign + first + (c.length > 0 ? "." + c.join("") : "") + "e" + (e2 >= 0 ? "+" : "") + e2;
}
function toPrecision(value, precision, options) {
  if (isNaN(value) || !isFinite(value)) {
    return String(value);
  }
  var lowerExp = _toNumberOrDefault$1(options === null || options === void 0 ? void 0 : options.lowerExp, -3);
  var upperExp = _toNumberOrDefault$1(options === null || options === void 0 ? void 0 : options.upperExp, 5);
  var split = splitNumber(value);
  var rounded = precision ? roundDigits(split, precision) : split;
  if (rounded.exponent < lowerExp || rounded.exponent >= upperExp) {
    return toExponential$1(value, precision);
  } else {
    var c = rounded.coefficients;
    var e2 = rounded.exponent;
    if (c.length < precision) {
      c = c.concat(zeros$1(precision - c.length));
    }
    c = c.concat(zeros$1(e2 - c.length + 1 + (c.length < precision ? precision - c.length : 0)));
    c = zeros$1(-e2).concat(c);
    var dot2 = e2 > 0 ? e2 : 0;
    if (dot2 < c.length - 1) {
      c.splice(dot2 + 1, 0, ".");
    }
    return rounded.sign + c.join("");
  }
}
function roundDigits(split, precision) {
  var rounded = {
    sign: split.sign,
    coefficients: split.coefficients,
    exponent: split.exponent
  };
  var c = rounded.coefficients;
  while (precision <= 0) {
    c.unshift(0);
    rounded.exponent++;
    precision++;
  }
  if (c.length > precision) {
    var removed = c.splice(precision, c.length - precision);
    if (removed[0] >= 5) {
      var i2 = precision - 1;
      c[i2]++;
      while (c[i2] === 10) {
        c.pop();
        if (i2 === 0) {
          c.unshift(0);
          rounded.exponent++;
          i2++;
        }
        i2--;
        c[i2]++;
      }
    }
  }
  return rounded;
}
function zeros$1(length) {
  var arr = [];
  for (var i2 = 0; i2 < length; i2++) {
    arr.push(0);
  }
  return arr;
}
function digits(value) {
  return value.toExponential().replace(/e.*$/, "").replace(/^0\.?0*|\./, "").length;
}
var DBL_EPSILON = Number.EPSILON || 2220446049250313e-31;
function nearlyEqual$1(x, y, epsilon) {
  if (epsilon === null || epsilon === void 0) {
    return x === y;
  }
  if (x === y) {
    return true;
  }
  if (isNaN(x) || isNaN(y)) {
    return false;
  }
  if (isFinite(x) && isFinite(y)) {
    var diff2 = Math.abs(x - y);
    if (diff2 <= DBL_EPSILON) {
      return true;
    } else {
      return diff2 <= Math.max(Math.abs(x), Math.abs(y)) * epsilon;
    }
  }
  return false;
}
var acosh$2 = Math.acosh || function(x) {
  return Math.log(Math.sqrt(x * x - 1) + x);
};
var asinh$2 = Math.asinh || function(x) {
  return Math.log(Math.sqrt(x * x + 1) + x);
};
var atanh$2 = Math.atanh || function(x) {
  return Math.log((1 + x) / (1 - x)) / 2;
};
var cosh$2 = Math.cosh || function(x) {
  return (Math.exp(x) + Math.exp(-x)) / 2;
};
var sinh$2 = Math.sinh || function(x) {
  return (Math.exp(x) - Math.exp(-x)) / 2;
};
var tanh$2 = Math.tanh || function(x) {
  var e2 = Math.exp(2 * x);
  return (e2 - 1) / (e2 + 1);
};
function copysign(x, y) {
  var signx = x > 0 ? true : x < 0 ? false : 1 / x === Infinity;
  var signy = y > 0 ? true : y < 0 ? false : 1 / y === Infinity;
  return signx ^ signy ? -x : x;
}
function _toNumberOrThrow(value, onError) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    onError();
  }
}
function _toNumberOrDefault$1(value, defaultValue) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    return defaultValue;
  }
}
function formatBigNumberToBase(n, base, size2) {
  var BigNumberCtor = n.constructor;
  var big2 = new BigNumberCtor(2);
  var suffix = "";
  if (size2) {
    if (size2 < 1) {
      throw new Error("size must be in greater than 0");
    }
    if (!isInteger$1(size2)) {
      throw new Error("size must be an integer");
    }
    if (n.greaterThan(big2.pow(size2 - 1).sub(1)) || n.lessThan(big2.pow(size2 - 1).mul(-1))) {
      throw new Error("Value must be in range [-2^".concat(size2 - 1, ", 2^").concat(size2 - 1, "-1]"));
    }
    if (!n.isInteger()) {
      throw new Error("Value must be an integer");
    }
    if (n.lessThan(0)) {
      n = n.add(big2.pow(size2));
    }
    suffix = "i".concat(size2);
  }
  switch (base) {
    case 2:
      return "".concat(n.toBinary()).concat(suffix);
    case 8:
      return "".concat(n.toOctal()).concat(suffix);
    case 16:
      return "".concat(n.toHexadecimal()).concat(suffix);
    default:
      throw new Error("Base ".concat(base, " not supported "));
  }
}
function format$2(value, options) {
  if (typeof options === "function") {
    return options(value);
  }
  if (!value.isFinite()) {
    return value.isNaN() ? "NaN" : value.gt(0) ? "Infinity" : "-Infinity";
  }
  var {
    notation,
    precision,
    wordSize
  } = normalizeFormatOptions(options);
  switch (notation) {
    case "fixed":
      return toFixed(value, precision);
    case "exponential":
      return toExponential(value, precision);
    case "engineering":
      return toEngineering(value, precision);
    case "bin":
      return formatBigNumberToBase(value, 2, wordSize);
    case "oct":
      return formatBigNumberToBase(value, 8, wordSize);
    case "hex":
      return formatBigNumberToBase(value, 16, wordSize);
    case "auto": {
      var lowerExp = _toNumberOrDefault(options === null || options === void 0 ? void 0 : options.lowerExp, -3);
      var upperExp = _toNumberOrDefault(options === null || options === void 0 ? void 0 : options.upperExp, 5);
      if (value.isZero())
        return "0";
      var str;
      var rounded = value.toSignificantDigits(precision);
      var exp2 = rounded.e;
      if (exp2 >= lowerExp && exp2 < upperExp) {
        str = rounded.toFixed();
      } else {
        str = toExponential(value, precision);
      }
      return str.replace(/((\.\d*?)(0+))($|e)/, function() {
        var digits2 = arguments[2];
        var e2 = arguments[4];
        return digits2 !== "." ? digits2 + e2 : e2;
      });
    }
    default:
      throw new Error('Unknown notation "' + notation + '". Choose "auto", "exponential", "fixed", "bin", "oct", or "hex.');
  }
}
function toEngineering(value, precision) {
  var e2 = value.e;
  var newExp = e2 % 3 === 0 ? e2 : e2 < 0 ? e2 - 3 - e2 % 3 : e2 - e2 % 3;
  var valueWithoutExp = value.mul(Math.pow(10, -newExp));
  var valueStr = valueWithoutExp.toPrecision(precision);
  if (valueStr.indexOf("e") !== -1) {
    var BigNumber2 = value.constructor;
    valueStr = new BigNumber2(valueStr).toFixed();
  }
  return valueStr + "e" + (e2 >= 0 ? "+" : "") + newExp.toString();
}
function toExponential(value, precision) {
  if (precision !== void 0) {
    return value.toExponential(precision - 1);
  } else {
    return value.toExponential();
  }
}
function toFixed(value, precision) {
  return value.toFixed(precision);
}
function _toNumberOrDefault(value, defaultValue) {
  if (isNumber(value)) {
    return value;
  } else if (isBigNumber(value)) {
    return value.toNumber();
  } else {
    return defaultValue;
  }
}
function endsWith(text2, search) {
  var start = text2.length - search.length;
  var end = text2.length;
  return text2.substring(start, end) === search;
}
function format$1(value, options) {
  var result = _format(value, options);
  if (options && typeof options === "object" && "truncate" in options && result.length > options.truncate) {
    return result.substring(0, options.truncate - 3) + "...";
  }
  return result;
}
function _format(value, options) {
  if (typeof value === "number") {
    return format$3(value, options);
  }
  if (isBigNumber(value)) {
    return format$2(value, options);
  }
  if (looksLikeFraction(value)) {
    if (!options || options.fraction !== "decimal") {
      return value.s * value.n + "/" + value.d;
    } else {
      return value.toString();
    }
  }
  if (Array.isArray(value)) {
    return formatArray(value, options);
  }
  if (isString(value)) {
    return stringify(value);
  }
  if (typeof value === "function") {
    return value.syntax ? String(value.syntax) : "function";
  }
  if (value && typeof value === "object") {
    if (typeof value.format === "function") {
      return value.format(options);
    } else if (value && value.toString(options) !== {}.toString()) {
      return value.toString(options);
    } else {
      var entries = Object.keys(value).map((key) => {
        return stringify(key) + ": " + format$1(value[key], options);
      });
      return "{" + entries.join(", ") + "}";
    }
  }
  return String(value);
}
function stringify(value) {
  var text2 = String(value);
  var escaped = "";
  var i2 = 0;
  while (i2 < text2.length) {
    var c = text2.charAt(i2);
    escaped += c in controlCharacters ? controlCharacters[c] : c;
    i2++;
  }
  return '"' + escaped + '"';
}
var controlCharacters = {
  '"': '\\"',
  "\\": "\\\\",
  "\b": "\\b",
  "\f": "\\f",
  "\n": "\\n",
  "\r": "\\r",
  "	": "\\t"
};
function escape(value) {
  var text2 = String(value);
  text2 = text2.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
  return text2;
}
function formatArray(array, options) {
  if (Array.isArray(array)) {
    var str = "[";
    var len = array.length;
    for (var i2 = 0; i2 < len; i2++) {
      if (i2 !== 0) {
        str += ", ";
      }
      str += formatArray(array[i2], options);
    }
    str += "]";
    return str;
  } else {
    return format$1(array, options);
  }
}
function looksLikeFraction(value) {
  return value && typeof value === "object" && typeof value.s === "number" && typeof value.n === "number" && typeof value.d === "number" || false;
}
function compareText$1(x, y) {
  if (!isString(x)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf$1(x) + ", index: 0)");
  }
  if (!isString(y)) {
    throw new TypeError("Unexpected type of argument in function compareText (expected: string or Array or Matrix, actual: " + typeOf$1(y) + ", index: 1)");
  }
  return x === y ? 0 : x > y ? 1 : -1;
}
function DimensionError(actual, expected, relation) {
  if (!(this instanceof DimensionError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.actual = actual;
  this.expected = expected;
  this.relation = relation;
  this.message = "Dimension mismatch (" + (Array.isArray(actual) ? "[" + actual.join(", ") + "]" : actual) + " " + (this.relation || "!=") + " " + (Array.isArray(expected) ? "[" + expected.join(", ") + "]" : expected) + ")";
  this.stack = new Error().stack;
}
DimensionError.prototype = new RangeError();
DimensionError.prototype.constructor = RangeError;
DimensionError.prototype.name = "DimensionError";
DimensionError.prototype.isDimensionError = true;
function IndexError(index2, min2, max2) {
  if (!(this instanceof IndexError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.index = index2;
  if (arguments.length < 3) {
    this.min = 0;
    this.max = min2;
  } else {
    this.min = min2;
    this.max = max2;
  }
  if (this.min !== void 0 && this.index < this.min) {
    this.message = "Index out of range (" + this.index + " < " + this.min + ")";
  } else if (this.max !== void 0 && this.index >= this.max) {
    this.message = "Index out of range (" + this.index + " > " + (this.max - 1) + ")";
  } else {
    this.message = "Index out of range (" + this.index + ")";
  }
  this.stack = new Error().stack;
}
IndexError.prototype = new RangeError();
IndexError.prototype.constructor = RangeError;
IndexError.prototype.name = "IndexError";
IndexError.prototype.isIndexError = true;
function arraySize(x) {
  var s = [];
  while (Array.isArray(x)) {
    s.push(x.length);
    x = x[0];
  }
  return s;
}
function _validate(array, size2, dim) {
  var i2;
  var len = array.length;
  if (len !== size2[dim]) {
    throw new DimensionError(len, size2[dim]);
  }
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i2 = 0; i2 < len; i2++) {
      var child = array[i2];
      if (!Array.isArray(child)) {
        throw new DimensionError(size2.length - 1, size2.length, "<");
      }
      _validate(array[i2], size2, dimNext);
    }
  } else {
    for (i2 = 0; i2 < len; i2++) {
      if (Array.isArray(array[i2])) {
        throw new DimensionError(size2.length + 1, size2.length, ">");
      }
    }
  }
}
function validate(array, size2) {
  var isScalar = size2.length === 0;
  if (isScalar) {
    if (Array.isArray(array)) {
      throw new DimensionError(array.length, 0);
    }
  } else {
    _validate(array, size2, 0);
  }
}
function validateIndexSourceSize(value, index2) {
  var valueSize = value.isMatrix ? value._size : arraySize(value);
  var sourceSize = index2._sourceSize;
  sourceSize.forEach((sourceDim, i2) => {
    if (sourceDim !== null && sourceDim !== valueSize[i2]) {
      throw new DimensionError(sourceDim, valueSize[i2]);
    }
  });
}
function validateIndex(index2, length) {
  if (index2 !== void 0) {
    if (!isNumber(index2) || !isInteger$1(index2)) {
      throw new TypeError("Index must be an integer (value: " + index2 + ")");
    }
    if (index2 < 0 || typeof length === "number" && index2 >= length) {
      throw new IndexError(index2, length);
    }
  }
}
function isEmptyIndex(index2) {
  for (var i2 = 0; i2 < index2._dimensions.length; ++i2) {
    var dimension = index2._dimensions[i2];
    if (dimension._data && isArray(dimension._data)) {
      if (dimension._size[0] === 0) {
        return true;
      }
    } else if (dimension.isRange) {
      if (dimension.start === dimension.end) {
        return true;
      }
    } else if (isString(dimension)) {
      if (dimension.length === 0) {
        return true;
      }
    }
  }
  return false;
}
function resize$1(array, size2, defaultValue) {
  if (!Array.isArray(size2)) {
    throw new TypeError("Array expected");
  }
  if (size2.length === 0) {
    throw new Error("Resizing to scalar is not supported");
  }
  size2.forEach(function(value) {
    if (!isNumber(value) || !isInteger$1(value) || value < 0) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format$1(size2) + ")");
    }
  });
  if (isNumber(array) || isBigNumber(array)) {
    array = [array];
  }
  var _defaultValue = defaultValue !== void 0 ? defaultValue : 0;
  _resize(array, size2, 0, _defaultValue);
  return array;
}
function _resize(array, size2, dim, defaultValue) {
  var i2;
  var elem;
  var oldLen = array.length;
  var newLen = size2[dim];
  var minLen = Math.min(oldLen, newLen);
  array.length = newLen;
  if (dim < size2.length - 1) {
    var dimNext = dim + 1;
    for (i2 = 0; i2 < minLen; i2++) {
      elem = array[i2];
      if (!Array.isArray(elem)) {
        elem = [elem];
        array[i2] = elem;
      }
      _resize(elem, size2, dimNext, defaultValue);
    }
    for (i2 = minLen; i2 < newLen; i2++) {
      elem = [];
      array[i2] = elem;
      _resize(elem, size2, dimNext, defaultValue);
    }
  } else {
    for (i2 = 0; i2 < minLen; i2++) {
      while (Array.isArray(array[i2])) {
        array[i2] = array[i2][0];
      }
    }
    for (i2 = minLen; i2 < newLen; i2++) {
      array[i2] = defaultValue;
    }
  }
}
function reshape$1(array, sizes) {
  var flatArray = flatten$1(array);
  var currentLength = flatArray.length;
  if (!Array.isArray(array) || !Array.isArray(sizes)) {
    throw new TypeError("Array expected");
  }
  if (sizes.length === 0) {
    throw new DimensionError(0, currentLength, "!=");
  }
  sizes = processSizesWildcard(sizes, currentLength);
  var newLength = product$1(sizes);
  if (currentLength !== newLength) {
    throw new DimensionError(newLength, currentLength, "!=");
  }
  try {
    return _reshape(flatArray, sizes);
  } catch (e2) {
    if (e2 instanceof DimensionError) {
      throw new DimensionError(newLength, currentLength, "!=");
    }
    throw e2;
  }
}
function processSizesWildcard(sizes, currentLength) {
  var newLength = product$1(sizes);
  var processedSizes = sizes.slice();
  var WILDCARD = -1;
  var wildCardIndex = sizes.indexOf(WILDCARD);
  var isMoreThanOneWildcard = sizes.indexOf(WILDCARD, wildCardIndex + 1) >= 0;
  if (isMoreThanOneWildcard) {
    throw new Error("More than one wildcard in sizes");
  }
  var hasWildcard = wildCardIndex >= 0;
  var canReplaceWildcard = currentLength % newLength === 0;
  if (hasWildcard) {
    if (canReplaceWildcard) {
      processedSizes[wildCardIndex] = -currentLength / newLength;
    } else {
      throw new Error("Could not replace wildcard, since " + currentLength + " is no multiple of " + -newLength);
    }
  }
  return processedSizes;
}
function product$1(array) {
  return array.reduce((prev, curr) => prev * curr, 1);
}
function _reshape(array, sizes) {
  var tmpArray = array;
  var tmpArray2;
  for (var sizeIndex = sizes.length - 1; sizeIndex > 0; sizeIndex--) {
    var size2 = sizes[sizeIndex];
    tmpArray2 = [];
    var length = tmpArray.length / size2;
    for (var i2 = 0; i2 < length; i2++) {
      tmpArray2.push(tmpArray.slice(i2 * size2, (i2 + 1) * size2));
    }
    tmpArray = tmpArray2;
  }
  return tmpArray;
}
function squeeze$1(array, size2) {
  var s = size2 || arraySize(array);
  while (Array.isArray(array) && array.length === 1) {
    array = array[0];
    s.shift();
  }
  var dims = s.length;
  while (s[dims - 1] === 1) {
    dims--;
  }
  if (dims < s.length) {
    array = _squeeze(array, dims, 0);
    s.length = dims;
  }
  return array;
}
function _squeeze(array, dims, dim) {
  var i2, ii;
  if (dim < dims) {
    var next = dim + 1;
    for (i2 = 0, ii = array.length; i2 < ii; i2++) {
      array[i2] = _squeeze(array[i2], dims, next);
    }
  } else {
    while (Array.isArray(array)) {
      array = array[0];
    }
  }
  return array;
}
function unsqueeze(array, dims, outer, size2) {
  var s = size2 || arraySize(array);
  if (outer) {
    for (var i2 = 0; i2 < outer; i2++) {
      array = [array];
      s.unshift(1);
    }
  }
  array = _unsqueeze(array, dims, 0);
  while (s.length < dims) {
    s.push(1);
  }
  return array;
}
function _unsqueeze(array, dims, dim) {
  var i2, ii;
  if (Array.isArray(array)) {
    var next = dim + 1;
    for (i2 = 0, ii = array.length; i2 < ii; i2++) {
      array[i2] = _unsqueeze(array[i2], dims, next);
    }
  } else {
    for (var d = dim; d < dims; d++) {
      array = [array];
    }
  }
  return array;
}
function flatten$1(array) {
  if (!Array.isArray(array)) {
    return array;
  }
  var flat = [];
  array.forEach(function callback(value) {
    if (Array.isArray(value)) {
      value.forEach(callback);
    } else {
      flat.push(value);
    }
  });
  return flat;
}
function map$1(array, callback) {
  return Array.prototype.map.call(array, callback);
}
function forEach$1(array, callback) {
  Array.prototype.forEach.call(array, callback);
}
function filter$1(array, callback) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, callback);
}
function filterRegExp(array, regexp) {
  if (arraySize(array).length !== 1) {
    throw new Error("Only one dimensional matrices supported");
  }
  return Array.prototype.filter.call(array, (entry) => regexp.test(entry));
}
function join(array, separator) {
  return Array.prototype.join.call(array, separator);
}
function identify(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  var count2 = 0;
  b[0] = {
    value: a[0],
    identifier: 0
  };
  for (var i2 = 1; i2 < a.length; i2++) {
    if (a[i2] === a[i2 - 1]) {
      count2++;
    } else {
      count2 = 0;
    }
    b.push({
      value: a[i2],
      identifier: count2
    });
  }
  return b;
}
function generalize(a) {
  if (!Array.isArray(a)) {
    throw new TypeError("Array input expected");
  }
  if (a.length === 0) {
    return a;
  }
  var b = [];
  for (var i2 = 0; i2 < a.length; i2++) {
    b.push(a[i2].value);
  }
  return b;
}
function getArrayDataType(array, typeOf2) {
  var type;
  var length = 0;
  for (var i2 = 0; i2 < array.length; i2++) {
    var item = array[i2];
    var _isArray = Array.isArray(item);
    if (i2 === 0 && _isArray) {
      length = item.length;
    }
    if (_isArray && item.length !== length) {
      return void 0;
    }
    var itemType = _isArray ? getArrayDataType(item, typeOf2) : typeOf2(item);
    if (type === void 0) {
      type = itemType;
    } else if (type !== itemType) {
      return "mixed";
    } else
      ;
  }
  return type;
}
function concatRecursive(a, b, concatDim, dim) {
  if (dim < concatDim) {
    if (a.length !== b.length) {
      throw new DimensionError(a.length, b.length);
    }
    var c = [];
    for (var i2 = 0; i2 < a.length; i2++) {
      c[i2] = concatRecursive(a[i2], b[i2], concatDim, dim + 1);
    }
    return c;
  } else {
    return a.concat(b);
  }
}
function concat$1() {
  var arrays = Array.prototype.slice.call(arguments, 0, -1);
  var concatDim = Array.prototype.slice.call(arguments, -1);
  if (arrays.length === 1) {
    return arrays[0];
  }
  if (arrays.length > 1) {
    return arrays.slice(1).reduce(function(A, B) {
      return concatRecursive(A, B, concatDim, 0);
    }, arrays[0]);
  } else {
    throw new Error("Wrong number of arguments in function concat");
  }
}
function broadcastSizes() {
  for (var _len = arguments.length, sizes = new Array(_len), _key = 0; _key < _len; _key++) {
    sizes[_key] = arguments[_key];
  }
  var dimensions = sizes.map((s) => s.length);
  var N = Math.max(...dimensions);
  var sizeMax = new Array(N).fill(null);
  for (var i2 = 0; i2 < sizes.length; i2++) {
    var size2 = sizes[i2];
    var dim = dimensions[i2];
    for (var j = 0; j < dim; j++) {
      var n = N - dim + j;
      if (size2[j] > sizeMax[n]) {
        sizeMax[n] = size2[j];
      }
    }
  }
  for (var _i = 0; _i < sizes.length; _i++) {
    checkBroadcastingRules(sizes[_i], sizeMax);
  }
  return sizeMax;
}
function checkBroadcastingRules(size2, toSize) {
  var N = toSize.length;
  var dim = size2.length;
  for (var j = 0; j < dim; j++) {
    var n = N - dim + j;
    if (size2[j] < toSize[n] && size2[j] > 1 || size2[j] > toSize[n]) {
      throw new Error("shape missmatch: missmatch is found in arg with shape (".concat(size2, ") not possible to broadcast dimension ").concat(dim, " with size ").concat(size2[j], " to size ").concat(toSize[n]));
    }
  }
}
function broadcastTo(array, toSize) {
  var Asize = arraySize(array);
  if (deepStrictEqual(Asize, toSize)) {
    return array;
  }
  checkBroadcastingRules(Asize, toSize);
  var broadcastedSize = broadcastSizes(Asize, toSize);
  var N = broadcastedSize.length;
  var paddedSize = [...Array(N - Asize.length).fill(1), ...Asize];
  var A = clone$2(array);
  if (Asize.length < N) {
    A = reshape$1(A, paddedSize);
    Asize = arraySize(A);
  }
  for (var dim = 0; dim < N; dim++) {
    if (Asize[dim] < broadcastedSize[dim]) {
      A = stretch(A, broadcastedSize[dim], dim);
      Asize = arraySize(A);
    }
  }
  return A;
}
function stretch(arrayToStretch, sizeToStretch, dimToStretch) {
  return concat$1(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
}
function clone$2(array) {
  return _extends$1([], array);
}
function factory(name2, dependencies2, create2, meta) {
  function assertAndCreate(scope) {
    var deps = pickShallow(scope, dependencies2.map(stripOptionalNotation));
    assertDependencies(name2, dependencies2, scope);
    return create2(deps);
  }
  assertAndCreate.isFactory = true;
  assertAndCreate.fn = name2;
  assertAndCreate.dependencies = dependencies2.slice().sort();
  if (meta) {
    assertAndCreate.meta = meta;
  }
  return assertAndCreate;
}
function assertDependencies(name2, dependencies2, scope) {
  var allDefined = dependencies2.filter((dependency) => !isOptionalDependency(dependency)).every((dependency) => scope[dependency] !== void 0);
  if (!allDefined) {
    var missingDependencies = dependencies2.filter((dependency) => scope[dependency] === void 0);
    throw new Error('Cannot create function "'.concat(name2, '", ') + "some dependencies are missing: ".concat(missingDependencies.map((d) => '"'.concat(d, '"')).join(", "), "."));
  }
}
function isOptionalDependency(dependency) {
  return dependency && dependency[0] === "?";
}
function stripOptionalNotation(dependency) {
  return dependency && dependency[0] === "?" ? dependency.slice(1) : dependency;
}
function getSafeProperty(object, prop) {
  if (isPlainObject(object) && isSafeProperty(object, prop)) {
    return object[prop];
  }
  if (typeof object[prop] === "function" && isSafeMethod(object, prop)) {
    throw new Error('Cannot access method "' + prop + '" as a property');
  }
  throw new Error('No access to property "' + prop + '"');
}
function setSafeProperty(object, prop, value) {
  if (isPlainObject(object) && isSafeProperty(object, prop)) {
    object[prop] = value;
    return value;
  }
  throw new Error('No access to property "' + prop + '"');
}
function hasSafeProperty(object, prop) {
  return prop in object;
}
function isSafeProperty(object, prop) {
  if (!object || typeof object !== "object") {
    return false;
  }
  if (hasOwnProperty(safeNativeProperties, prop)) {
    return true;
  }
  if (prop in Object.prototype) {
    return false;
  }
  if (prop in Function.prototype) {
    return false;
  }
  return true;
}
function getSafeMethod(object, method) {
  if (!isSafeMethod(object, method)) {
    throw new Error('No access to method "' + method + '"');
  }
  return object[method];
}
function isSafeMethod(object, method) {
  if (object === null || object === void 0 || typeof object[method] !== "function") {
    return false;
  }
  if (hasOwnProperty(object, method) && Object.getPrototypeOf && method in Object.getPrototypeOf(object)) {
    return false;
  }
  if (hasOwnProperty(safeNativeMethods, method)) {
    return true;
  }
  if (method in Object.prototype) {
    return false;
  }
  if (method in Function.prototype) {
    return false;
  }
  return true;
}
function isPlainObject(object) {
  return typeof object === "object" && object && object.constructor === Object;
}
var safeNativeProperties = {
  length: true,
  name: true
};
var safeNativeMethods = {
  toString: true,
  valueOf: true,
  toLocaleString: true
};
class ObjectWrappingMap {
  constructor(object) {
    this.wrappedObject = object;
    this[Symbol.iterator] = this.entries;
  }
  keys() {
    return Object.keys(this.wrappedObject).values();
  }
  get(key) {
    return getSafeProperty(this.wrappedObject, key);
  }
  set(key, value) {
    setSafeProperty(this.wrappedObject, key, value);
    return this;
  }
  has(key) {
    return hasSafeProperty(this.wrappedObject, key);
  }
  entries() {
    return mapIterator(this.keys(), (key) => [key, this.get(key)]);
  }
  forEach(callback) {
    for (var key of this.keys()) {
      callback(this.get(key), key, this);
    }
  }
  delete(key) {
    delete this.wrappedObject[key];
  }
  clear() {
    for (var key of this.keys()) {
      this.delete(key);
    }
  }
  get size() {
    return Object.keys(this.wrappedObject).length;
  }
}
class PartitionedMap {
  /**
   * @param {Map} a
   * @param {Map} b
   * @param {Set} bKeys
   */
  constructor(a, b, bKeys) {
    this.a = a;
    this.b = b;
    this.bKeys = bKeys;
    this[Symbol.iterator] = this.entries;
  }
  get(key) {
    return this.bKeys.has(key) ? this.b.get(key) : this.a.get(key);
  }
  set(key, value) {
    if (this.bKeys.has(key)) {
      this.b.set(key, value);
    } else {
      this.a.set(key, value);
    }
    return this;
  }
  has(key) {
    return this.b.has(key) || this.a.has(key);
  }
  keys() {
    return (/* @__PURE__ */ new Set([...this.a.keys(), ...this.b.keys()]))[Symbol.iterator]();
  }
  entries() {
    return mapIterator(this.keys(), (key) => [key, this.get(key)]);
  }
  forEach(callback) {
    for (var key of this.keys()) {
      callback(this.get(key), key, this);
    }
  }
  delete(key) {
    return this.bKeys.has(key) ? this.b.delete(key) : this.a.delete(key);
  }
  clear() {
    this.a.clear();
    this.b.clear();
  }
  get size() {
    return [...this.keys()].length;
  }
}
function mapIterator(it, callback) {
  return {
    next: () => {
      var n = it.next();
      return n.done ? n : {
        value: callback(n.value),
        done: false
      };
    }
  };
}
function createEmptyMap() {
  return /* @__PURE__ */ new Map();
}
function createMap$1(mapOrObject) {
  if (!mapOrObject) {
    return createEmptyMap();
  }
  if (isMap(mapOrObject)) {
    return mapOrObject;
  }
  if (isObject(mapOrObject)) {
    return new ObjectWrappingMap(mapOrObject);
  }
  throw new Error("createMap can create maps from objects or Maps");
}
function toObject(map2) {
  if (map2 instanceof ObjectWrappingMap) {
    return map2.wrappedObject;
  }
  var object = {};
  for (var key of map2.keys()) {
    var value = map2.get(key);
    setSafeProperty(object, key, value);
  }
  return object;
}
function isMap(object) {
  if (!object) {
    return false;
  }
  return object instanceof Map || object instanceof ObjectWrappingMap || typeof object.set === "function" && typeof object.get === "function" && typeof object.keys === "function" && typeof object.has === "function";
}
var _createTyped2 = function _createTyped() {
  _createTyped2 = typedFunction.create;
  return typedFunction;
};
var dependencies$4U = ["?BigNumber", "?Complex", "?DenseMatrix", "?Fraction"];
var createTyped = /* @__PURE__ */ factory("typed", dependencies$4U, function createTyped2(_ref) {
  var {
    BigNumber: BigNumber2,
    Complex: Complex2,
    DenseMatrix: DenseMatrix2,
    Fraction: Fraction2
  } = _ref;
  var typed2 = _createTyped2();
  typed2.clear();
  typed2.addTypes([
    {
      name: "number",
      test: isNumber
    },
    {
      name: "Complex",
      test: isComplex
    },
    {
      name: "BigNumber",
      test: isBigNumber
    },
    {
      name: "Fraction",
      test: isFraction
    },
    {
      name: "Unit",
      test: isUnit
    },
    // The following type matches a valid variable name, i.e., an alphanumeric
    // string starting with an alphabetic character. It is used (at least)
    // in the definition of the derivative() function, as the argument telling
    // what to differentiate over must (currently) be a variable.
    {
      name: "identifier",
      test: (s) => isString && /^(?:[A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])(?:[0-9A-Za-z\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16F1-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2183\u2184\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005\u3006\u3031-\u3035\u303B\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6E5\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF2D-\uDF40\uDF42-\uDF49\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDD70-\uDD7A\uDD7C-\uDD8A\uDD8C-\uDD92\uDD94\uDD95\uDD97-\uDDA1\uDDA3-\uDDB1\uDDB3-\uDDB9\uDDBB\uDDBC\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67\uDF80-\uDF85\uDF87-\uDFB0\uDFB2-\uDFBA]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE35\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2\uDD00-\uDD23\uDE80-\uDEA9\uDEB0\uDEB1\uDF00-\uDF1C\uDF27\uDF30-\uDF45\uDF70-\uDF81\uDFB0-\uDFC4\uDFE0-\uDFF6]|\uD804[\uDC03-\uDC37\uDC71\uDC72\uDC75\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD44\uDD47\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE3F\uDE40\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC5F-\uDC61\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDEB8\uDF00-\uDF1A\uDF40-\uDF46]|\uD806[\uDC00-\uDC2B\uDCA0-\uDCDF\uDCFF-\uDD06\uDD09\uDD0C-\uDD13\uDD15\uDD16\uDD18-\uDD2F\uDD3F\uDD41\uDDA0-\uDDA7\uDDAA-\uDDD0\uDDE1\uDDE3\uDE00\uDE0B-\uDE32\uDE3A\uDE50\uDE5C-\uDE89\uDE9D\uDEB0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F\uDD00-\uDD06\uDD08\uDD09\uDD0B-\uDD30\uDD46\uDD60-\uDD65\uDD67\uDD68\uDD6A-\uDD89\uDD98\uDEE0-\uDEF2\uDF02\uDF04-\uDF10\uDF12-\uDF33\uDFB0]|\uD808[\uDC00-\uDF99]|\uD809[\uDC80-\uDD43]|\uD80B[\uDF90-\uDFF0]|[\uD80C\uD81C-\uD820\uD822\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872\uD874-\uD879\uD880-\uD883\uD885-\uD887][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2F\uDC41-\uDC46]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE70-\uDEBE\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDE40-\uDE7F\uDF00-\uDF4A\uDF50\uDF93-\uDF9F\uDFE0\uDFE1\uDFE3]|\uD821[\uDC00-\uDFF7]|\uD823[\uDC00-\uDCD5\uDD00-\uDD08]|\uD82B[\uDFF0-\uDFF3\uDFF5-\uDFFB\uDFFD\uDFFE]|\uD82C[\uDC00-\uDD22\uDD32\uDD50-\uDD52\uDD55\uDD64-\uDD67\uDD70-\uDEFB]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD837[\uDF00-\uDF1E\uDF25-\uDF2A]|\uD838[\uDC30-\uDC6D\uDD00-\uDD2C\uDD37-\uDD3D\uDD4E\uDE90-\uDEAD\uDEC0-\uDEEB]|\uD839[\uDCD0-\uDCEB\uDFE0-\uDFE6\uDFE8-\uDFEB\uDFED\uDFEE\uDFF0-\uDFFE]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43\uDD4B]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDEDF\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF39\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1\uDEB0-\uDFFF]|\uD87A[\uDC00-\uDFE0]|\uD87E[\uDC00-\uDE1D]|\uD884[\uDC00-\uDF4A\uDF50-\uDFFF]|\uD888[\uDC00-\uDFAF])*$/.test(s)
    },
    {
      name: "string",
      test: isString
    },
    {
      name: "Chain",
      test: isChain
    },
    {
      name: "Array",
      test: isArray
    },
    {
      name: "Matrix",
      test: isMatrix
    },
    {
      name: "DenseMatrix",
      test: isDenseMatrix
    },
    {
      name: "SparseMatrix",
      test: isSparseMatrix
    },
    {
      name: "Range",
      test: isRange
    },
    {
      name: "Index",
      test: isIndex
    },
    {
      name: "boolean",
      test: isBoolean
    },
    {
      name: "ResultSet",
      test: isResultSet
    },
    {
      name: "Help",
      test: isHelp
    },
    {
      name: "function",
      test: isFunction
    },
    {
      name: "Date",
      test: isDate
    },
    {
      name: "RegExp",
      test: isRegExp
    },
    {
      name: "null",
      test: isNull
    },
    {
      name: "undefined",
      test: isUndefined
    },
    {
      name: "AccessorNode",
      test: isAccessorNode
    },
    {
      name: "ArrayNode",
      test: isArrayNode
    },
    {
      name: "AssignmentNode",
      test: isAssignmentNode
    },
    {
      name: "BlockNode",
      test: isBlockNode
    },
    {
      name: "ConditionalNode",
      test: isConditionalNode
    },
    {
      name: "ConstantNode",
      test: isConstantNode
    },
    {
      name: "FunctionNode",
      test: isFunctionNode
    },
    {
      name: "FunctionAssignmentNode",
      test: isFunctionAssignmentNode
    },
    {
      name: "IndexNode",
      test: isIndexNode
    },
    {
      name: "Node",
      test: isNode
    },
    {
      name: "ObjectNode",
      test: isObjectNode
    },
    {
      name: "OperatorNode",
      test: isOperatorNode
    },
    {
      name: "ParenthesisNode",
      test: isParenthesisNode
    },
    {
      name: "RangeNode",
      test: isRangeNode
    },
    {
      name: "RelationalNode",
      test: isRelationalNode
    },
    {
      name: "SymbolNode",
      test: isSymbolNode
    },
    {
      name: "Map",
      test: isMap
    },
    {
      name: "Object",
      test: isObject
    }
    // order 'Object' last, it matches on other classes too
  ]);
  typed2.addConversions([{
    from: "number",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      if (digits(x) > 15) {
        throw new TypeError("Cannot implicitly convert a number with >15 significant digits to BigNumber (value: " + x + "). Use function bignumber(x) to convert to BigNumber.");
      }
      return new BigNumber2(x);
    }
  }, {
    from: "number",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x, 0);
    }
  }, {
    from: "BigNumber",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x.toNumber(), 0);
    }
  }, {
    from: "Fraction",
    to: "BigNumber",
    convert: function convert(x) {
      throw new TypeError("Cannot implicitly convert a Fraction to BigNumber or vice versa. Use function bignumber(x) to convert to BigNumber or fraction(x) to convert to Fraction.");
    }
  }, {
    from: "Fraction",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      return new Complex2(x.valueOf(), 0);
    }
  }, {
    from: "number",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      var f = new Fraction2(x);
      if (f.valueOf() !== x) {
        throw new TypeError("Cannot implicitly convert a number to a Fraction when there will be a loss of precision (value: " + x + "). Use function fraction(x) to convert to Fraction.");
      }
      return f;
    }
  }, {
    // FIXME: add conversion from Fraction to number, for example for `sqrt(fraction(1,3))`
    //  from: 'Fraction',
    //  to: 'number',
    //  convert: function (x) {
    //    return x.valueOf()
    //  }
    // }, {
    from: "string",
    to: "number",
    convert: function convert(x) {
      var n = Number(x);
      if (isNaN(n)) {
        throw new Error('Cannot convert "' + x + '" to a number');
      }
      return n;
    }
  }, {
    from: "string",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      try {
        return new BigNumber2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to BigNumber');
      }
    }
  }, {
    from: "string",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      try {
        return new Fraction2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Fraction');
      }
    }
  }, {
    from: "string",
    to: "Complex",
    convert: function convert(x) {
      if (!Complex2) {
        throwNoComplex(x);
      }
      try {
        return new Complex2(x);
      } catch (err) {
        throw new Error('Cannot convert "' + x + '" to Complex');
      }
    }
  }, {
    from: "boolean",
    to: "number",
    convert: function convert(x) {
      return +x;
    }
  }, {
    from: "boolean",
    to: "BigNumber",
    convert: function convert(x) {
      if (!BigNumber2) {
        throwNoBignumber(x);
      }
      return new BigNumber2(+x);
    }
  }, {
    from: "boolean",
    to: "Fraction",
    convert: function convert(x) {
      if (!Fraction2) {
        throwNoFraction(x);
      }
      return new Fraction2(+x);
    }
  }, {
    from: "boolean",
    to: "string",
    convert: function convert(x) {
      return String(x);
    }
  }, {
    from: "Array",
    to: "Matrix",
    convert: function convert(array) {
      if (!DenseMatrix2) {
        throwNoMatrix();
      }
      return new DenseMatrix2(array);
    }
  }, {
    from: "Matrix",
    to: "Array",
    convert: function convert(matrix2) {
      return matrix2.valueOf();
    }
  }]);
  typed2.onMismatch = (name2, args, signatures) => {
    var usualError = typed2.createError(name2, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
    signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name2, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name2, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  typed2.onMismatch = (name2, args, signatures) => {
    var usualError = typed2.createError(name2, args, signatures);
    if (["wrongType", "mismatch"].includes(usualError.data.category) && args.length === 1 && isCollection(args[0]) && // check if the function can be unary:
    signatures.some((sig) => !sig.params.includes(","))) {
      var err = new TypeError("Function '".concat(name2, "' doesn't apply to matrices. To call it ") + "elementwise on a matrix 'M', try 'map(M, ".concat(name2, ")'."));
      err.data = usualError.data;
      throw err;
    }
    throw usualError;
  };
  return typed2;
});
function throwNoBignumber(x) {
  throw new Error("Cannot convert value ".concat(x, " into a BigNumber: no class 'BigNumber' provided"));
}
function throwNoComplex(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Complex number: no class 'Complex' provided"));
}
function throwNoMatrix() {
  throw new Error("Cannot convert array into a Matrix: no class 'DenseMatrix' provided");
}
function throwNoFraction(x) {
  throw new Error("Cannot convert value ".concat(x, " into a Fraction, no class 'Fraction' provided."));
}
var name$4U = "ResultSet";
var dependencies$4T = [];
var createResultSet = /* @__PURE__ */ factory(name$4U, dependencies$4T, () => {
  function ResultSet2(entries) {
    if (!(this instanceof ResultSet2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this.entries = entries || [];
  }
  ResultSet2.prototype.type = "ResultSet";
  ResultSet2.prototype.isResultSet = true;
  ResultSet2.prototype.valueOf = function() {
    return this.entries;
  };
  ResultSet2.prototype.toString = function() {
    return "[" + this.entries.join(", ") + "]";
  };
  ResultSet2.prototype.toJSON = function() {
    return {
      mathjs: "ResultSet",
      entries: this.entries
    };
  };
  ResultSet2.fromJSON = function(json) {
    return new ResultSet2(json.entries);
  };
  return ResultSet2;
}, {
  isClass: true
});
/*!
 *  decimal.js v10.4.3
 *  An arbitrary-precision Decimal type for JavaScript.
 *  https://github.com/MikeMcl/decimal.js
 *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
 *  MIT Licence
 */
var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10$1 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
  // These values must be integers within the stated ranges (inclusive).
  // Most of these values can be changed at run-time using the `Decimal.config` method.
  // The maximum number of significant digits of the result of a calculation or base conversion.
  // E.g. `Decimal.config({ precision: 20 });`
  precision: 20,
  // 1 to MAX_DIGITS
  // The rounding mode used when rounding to `precision`.
  //
  // ROUND_UP         0 Away from zero.
  // ROUND_DOWN       1 Towards zero.
  // ROUND_CEIL       2 Towards +Infinity.
  // ROUND_FLOOR      3 Towards -Infinity.
  // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
  // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
  // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
  // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
  // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
  //
  // E.g.
  // `Decimal.rounding = 4;`
  // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
  rounding: 4,
  // 0 to 8
  // The modulo mode used when calculating the modulus: a mod n.
  // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
  // The remainder (r) is calculated as: r = a - n * q.
  //
  // UP         0 The remainder is positive if the dividend is negative, else is negative.
  // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
  // FLOOR      3 The remainder has the same sign as the divisor (Python %).
  // HALF_EVEN  6 The IEEE 754 remainder function.
  // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
  //
  // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
  // division (9) are commonly used for the modulus operation. The other rounding modes can also
  // be used, but they may not give useful results.
  modulo: 1,
  // 0 to 9
  // The exponent value at and beneath which `toString` returns exponential notation.
  // JavaScript numbers: -7
  toExpNeg: -7,
  // 0 to -EXP_LIMIT
  // The exponent value at and above which `toString` returns exponential notation.
  // JavaScript numbers: 21
  toExpPos: 21,
  // 0 to EXP_LIMIT
  // The minimum exponent value, beneath which underflow to zero occurs.
  // JavaScript numbers: -324  (5e-324)
  minE: -EXP_LIMIT,
  // -1 to -EXP_LIMIT
  // The maximum exponent value, above which overflow to Infinity occurs.
  // JavaScript numbers: 308  (1.7976931348623157e+308)
  maxE: EXP_LIMIT,
  // 1 to EXP_LIMIT
  // Whether to use cryptographically-secure random number generation, if available.
  crypto: false
  // true/false
}, inexact, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10$1.length - 1, PI_PRECISION = PI.length - 1, P$1 = { toStringTag: tag };
P$1.absoluteValue = P$1.abs = function() {
  var x = new this.constructor(this);
  if (x.s < 0)
    x.s = 1;
  return finalise(x);
};
P$1.ceil = function() {
  return finalise(new this.constructor(this), this.e + 1, 2);
};
P$1.clampedTo = P$1.clamp = function(min2, max2) {
  var k, x = this, Ctor = x.constructor;
  min2 = new Ctor(min2);
  max2 = new Ctor(max2);
  if (!min2.s || !max2.s)
    return new Ctor(NaN);
  if (min2.gt(max2))
    throw Error(invalidArgument + max2);
  k = x.cmp(min2);
  return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
};
P$1.comparedTo = P$1.cmp = function(y) {
  var i2, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
  if (!xd || !yd) {
    return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
  }
  if (!xd[0] || !yd[0])
    return xd[0] ? xs : yd[0] ? -ys : 0;
  if (xs !== ys)
    return xs;
  if (x.e !== y.e)
    return x.e > y.e ^ xs < 0 ? 1 : -1;
  xdL = xd.length;
  ydL = yd.length;
  for (i2 = 0, j = xdL < ydL ? xdL : ydL; i2 < j; ++i2) {
    if (xd[i2] !== yd[i2])
      return xd[i2] > yd[i2] ^ xs < 0 ? 1 : -1;
  }
  return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
};
P$1.cosine = P$1.cos = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.d)
    return new Ctor(NaN);
  if (!x.d[0])
    return new Ctor(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
};
P$1.cubeRoot = P$1.cbrt = function() {
  var e2, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  external = false;
  s = x.s * mathpow(x.s * x, 1 / 3);
  if (!s || Math.abs(s) == 1 / 0) {
    n = digitsToString(x.d);
    e2 = x.e;
    if (s = (e2 - n.length + 1) % 3)
      n += s == 1 || s == -2 ? "0" : "00";
    s = mathpow(n, 1 / 3);
    e2 = mathfloor((e2 + 1) / 3) - (e2 % 3 == (e2 < 0 ? -1 : 2));
    if (s == 1 / 0) {
      n = "5e" + e2;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e2;
    }
    r = new Ctor(n);
    r.s = x.s;
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e2 = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    t3 = t.times(t).times(t);
    t3plusx = t3.plus(x);
    r = divide$1(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e2 + 1, 0);
          if (t.times(t).times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e2 + 1, 1);
          m = !r.times(r).times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e2, Ctor.rounding, m);
};
P$1.decimalPlaces = P$1.dp = function() {
  var w, d = this.d, n = NaN;
  if (d) {
    w = d.length - 1;
    n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
    w = d[w];
    if (w)
      for (; w % 10 == 0; w /= 10)
        n--;
    if (n < 0)
      n = 0;
  }
  return n;
};
P$1.dividedBy = P$1.div = function(y) {
  return divide$1(this, new this.constructor(y));
};
P$1.dividedToIntegerBy = P$1.divToInt = function(y) {
  var x = this, Ctor = x.constructor;
  return finalise(divide$1(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
};
P$1.equals = P$1.eq = function(y) {
  return this.cmp(y) === 0;
};
P$1.floor = function() {
  return finalise(new this.constructor(this), this.e + 1, 3);
};
P$1.greaterThan = P$1.gt = function(y) {
  return this.cmp(y) > 0;
};
P$1.greaterThanOrEqualTo = P$1.gte = function(y) {
  var k = this.cmp(y);
  return k == 1 || k === 0;
};
P$1.hyperbolicCosine = P$1.cosh = function() {
  var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
  if (!x.isFinite())
    return new Ctor(x.s ? 1 / 0 : NaN);
  if (x.isZero())
    return one;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    n = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    n = "2.3283064365386962890625e-10";
  }
  x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
  var cosh2_x, i2 = k, d8 = new Ctor(8);
  for (; i2--; ) {
    cosh2_x = x.times(x);
    x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
  }
  return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P$1.hyperbolicSine = P$1.sinh = function() {
  var k, pr, rm, len, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
  Ctor.rounding = 1;
  len = x.d.length;
  if (len < 3) {
    x = taylorSeries(Ctor, 2, x, x, true);
  } else {
    k = 1.4 * Math.sqrt(len);
    k = k > 16 ? 16 : k | 0;
    x = x.times(1 / tinyPow(5, k));
    x = taylorSeries(Ctor, 2, x, x, true);
    var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
    for (; k--; ) {
      sinh2_x = x.times(x);
      x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
    }
  }
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(x, pr, rm, true);
};
P$1.hyperbolicTangent = P$1.tanh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(x.s);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 7;
  Ctor.rounding = 1;
  return divide$1(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
};
P$1.inverseCosine = P$1.acos = function() {
  var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
  if (k !== -1) {
    return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
  }
  if (x.isZero())
    return getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.asin();
  halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return halfPi.minus(x);
};
P$1.inverseHyperbolicCosine = P$1.acosh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (x.lte(1))
    return new Ctor(x.eq(1) ? 0 : NaN);
  if (!x.isFinite())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).minus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P$1.inverseHyperbolicSine = P$1.asinh = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite() || x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
  Ctor.rounding = 1;
  external = false;
  x = x.times(x).plus(1).sqrt().plus(x);
  external = true;
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.ln();
};
P$1.inverseHyperbolicTangent = P$1.atanh = function() {
  var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.e >= 0)
    return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  xsd = x.sd();
  if (Math.max(xsd, pr) < 2 * -x.e - 1)
    return finalise(new Ctor(x), pr, rm, true);
  Ctor.precision = wpr = xsd - x.e;
  x = divide$1(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
  Ctor.precision = pr + 4;
  Ctor.rounding = 1;
  x = x.ln();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(0.5);
};
P$1.inverseSine = P$1.asin = function() {
  var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
  if (x.isZero())
    return new Ctor(x);
  k = x.abs().cmp(1);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (k !== -1) {
    if (k === 0) {
      halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
      halfPi.s = x.s;
      return halfPi;
    }
    return new Ctor(NaN);
  }
  Ctor.precision = pr + 6;
  Ctor.rounding = 1;
  x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return x.times(2);
};
P$1.inverseTangent = P$1.atan = function() {
  var i2, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
  if (!x.isFinite()) {
    if (!x.s)
      return new Ctor(NaN);
    if (pr + 4 <= PI_PRECISION) {
      r = getPi(Ctor, pr + 4, rm).times(0.5);
      r.s = x.s;
      return r;
    }
  } else if (x.isZero()) {
    return new Ctor(x);
  } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
    r = getPi(Ctor, pr + 4, rm).times(0.25);
    r.s = x.s;
    return r;
  }
  Ctor.precision = wpr = pr + 10;
  Ctor.rounding = 1;
  k = Math.min(28, wpr / LOG_BASE + 2 | 0);
  for (i2 = k; i2; --i2)
    x = x.div(x.times(x).plus(1).sqrt().plus(1));
  external = false;
  j = Math.ceil(wpr / LOG_BASE);
  n = 1;
  x2 = x.times(x);
  r = new Ctor(x);
  px = x;
  for (; i2 !== -1; ) {
    px = px.times(x2);
    t = r.minus(px.div(n += 2));
    px = px.times(x2);
    r = t.plus(px.div(n += 2));
    if (r.d[j] !== void 0)
      for (i2 = j; r.d[i2] === t.d[i2] && i2--; )
        ;
  }
  if (k)
    r = r.times(2 << k - 1);
  external = true;
  return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
};
P$1.isFinite = function() {
  return !!this.d;
};
P$1.isInteger = P$1.isInt = function() {
  return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
};
P$1.isNaN = function() {
  return !this.s;
};
P$1.isNegative = P$1.isNeg = function() {
  return this.s < 0;
};
P$1.isPositive = P$1.isPos = function() {
  return this.s > 0;
};
P$1.isZero = function() {
  return !!this.d && this.d[0] === 0;
};
P$1.lessThan = P$1.lt = function(y) {
  return this.cmp(y) < 0;
};
P$1.lessThanOrEqualTo = P$1.lte = function(y) {
  return this.cmp(y) < 1;
};
P$1.logarithm = P$1.log = function(base) {
  var isBase10, d, denominator, k, inf, num, sd, r, arg2 = this, Ctor = arg2.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
  if (base == null) {
    base = new Ctor(10);
    isBase10 = true;
  } else {
    base = new Ctor(base);
    d = base.d;
    if (base.s < 0 || !d || !d[0] || base.eq(1))
      return new Ctor(NaN);
    isBase10 = base.eq(10);
  }
  d = arg2.d;
  if (arg2.s < 0 || !d || !d[0] || arg2.eq(1)) {
    return new Ctor(d && !d[0] ? -1 / 0 : arg2.s != 1 ? NaN : d ? 0 : 1 / 0);
  }
  if (isBase10) {
    if (d.length > 1) {
      inf = true;
    } else {
      for (k = d[0]; k % 10 === 0; )
        k /= 10;
      inf = k !== 1;
    }
  }
  external = false;
  sd = pr + guard;
  num = naturalLogarithm(arg2, sd);
  denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
  r = divide$1(num, denominator, sd, 1);
  if (checkRoundingDigits(r.d, k = pr, rm)) {
    do {
      sd += 10;
      num = naturalLogarithm(arg2, sd);
      denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
      r = divide$1(num, denominator, sd, 1);
      if (!inf) {
        if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
          r = finalise(r, pr + 1, 0);
        }
        break;
      }
    } while (checkRoundingDigits(r.d, k += 10, rm));
  }
  external = true;
  return finalise(r, pr, rm);
};
P$1.minus = P$1.sub = function(y) {
  var d, e2, i2, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (x.d)
      y.s = -y.s;
    else
      y = new Ctor(y.d || x.s !== y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.plus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (yd[0])
      y.s = -y.s;
    else if (xd[0])
      y = new Ctor(x);
    else
      return new Ctor(rm === 3 ? -0 : 0);
    return external ? finalise(y, pr, rm) : y;
  }
  e2 = mathfloor(y.e / LOG_BASE);
  xe = mathfloor(x.e / LOG_BASE);
  xd = xd.slice();
  k = xe - e2;
  if (k) {
    xLTy = k < 0;
    if (xLTy) {
      d = xd;
      k = -k;
      len = yd.length;
    } else {
      d = yd;
      e2 = xe;
      len = xd.length;
    }
    i2 = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
    if (k > i2) {
      k = i2;
      d.length = 1;
    }
    d.reverse();
    for (i2 = k; i2--; )
      d.push(0);
    d.reverse();
  } else {
    i2 = xd.length;
    len = yd.length;
    xLTy = i2 < len;
    if (xLTy)
      len = i2;
    for (i2 = 0; i2 < len; i2++) {
      if (xd[i2] != yd[i2]) {
        xLTy = xd[i2] < yd[i2];
        break;
      }
    }
    k = 0;
  }
  if (xLTy) {
    d = xd;
    xd = yd;
    yd = d;
    y.s = -y.s;
  }
  len = xd.length;
  for (i2 = yd.length - len; i2 > 0; --i2)
    xd[len++] = 0;
  for (i2 = yd.length; i2 > k; ) {
    if (xd[--i2] < yd[i2]) {
      for (j = i2; j && xd[--j] === 0; )
        xd[j] = BASE - 1;
      --xd[j];
      xd[i2] += BASE;
    }
    xd[i2] -= yd[i2];
  }
  for (; xd[--len] === 0; )
    xd.pop();
  for (; xd[0] === 0; xd.shift())
    --e2;
  if (!xd[0])
    return new Ctor(rm === 3 ? -0 : 0);
  y.d = xd;
  y.e = getBase10Exponent(xd, e2);
  return external ? finalise(y, pr, rm) : y;
};
P$1.modulo = P$1.mod = function(y) {
  var q, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.s || y.d && !y.d[0])
    return new Ctor(NaN);
  if (!y.d || x.d && !x.d[0]) {
    return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
  }
  external = false;
  if (Ctor.modulo == 9) {
    q = divide$1(x, y.abs(), 0, 3, 1);
    q.s *= y.s;
  } else {
    q = divide$1(x, y, 0, Ctor.modulo, 1);
  }
  q = q.times(y);
  external = true;
  return x.minus(q);
};
P$1.naturalExponential = P$1.exp = function() {
  return naturalExponential(this);
};
P$1.naturalLogarithm = P$1.ln = function() {
  return naturalLogarithm(this);
};
P$1.negated = P$1.neg = function() {
  var x = new this.constructor(this);
  x.s = -x.s;
  return finalise(x);
};
P$1.plus = P$1.add = function(y) {
  var carry, d, e2, i2, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
  y = new Ctor(y);
  if (!x.d || !y.d) {
    if (!x.s || !y.s)
      y = new Ctor(NaN);
    else if (!x.d)
      y = new Ctor(y.d || x.s === y.s ? x : NaN);
    return y;
  }
  if (x.s != y.s) {
    y.s = -y.s;
    return x.minus(y);
  }
  xd = x.d;
  yd = y.d;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (!xd[0] || !yd[0]) {
    if (!yd[0])
      y = new Ctor(x);
    return external ? finalise(y, pr, rm) : y;
  }
  k = mathfloor(x.e / LOG_BASE);
  e2 = mathfloor(y.e / LOG_BASE);
  xd = xd.slice();
  i2 = k - e2;
  if (i2) {
    if (i2 < 0) {
      d = xd;
      i2 = -i2;
      len = yd.length;
    } else {
      d = yd;
      e2 = k;
      len = xd.length;
    }
    k = Math.ceil(pr / LOG_BASE);
    len = k > len ? k + 1 : len + 1;
    if (i2 > len) {
      i2 = len;
      d.length = 1;
    }
    d.reverse();
    for (; i2--; )
      d.push(0);
    d.reverse();
  }
  len = xd.length;
  i2 = yd.length;
  if (len - i2 < 0) {
    i2 = len;
    d = yd;
    yd = xd;
    xd = d;
  }
  for (carry = 0; i2; ) {
    carry = (xd[--i2] = xd[i2] + yd[i2] + carry) / BASE | 0;
    xd[i2] %= BASE;
  }
  if (carry) {
    xd.unshift(carry);
    ++e2;
  }
  for (len = xd.length; xd[--len] == 0; )
    xd.pop();
  y.d = xd;
  y.e = getBase10Exponent(xd, e2);
  return external ? finalise(y, pr, rm) : y;
};
P$1.precision = P$1.sd = function(z) {
  var k, x = this;
  if (z !== void 0 && z !== !!z && z !== 1 && z !== 0)
    throw Error(invalidArgument + z);
  if (x.d) {
    k = getPrecision(x.d);
    if (z && x.e + 1 > k)
      k = x.e + 1;
  } else {
    k = NaN;
  }
  return k;
};
P$1.round = function() {
  var x = this, Ctor = x.constructor;
  return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
};
P$1.sine = P$1.sin = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
  Ctor.rounding = 1;
  x = sine(Ctor, toLessThanHalfPi(Ctor, x));
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
};
P$1.squareRoot = P$1.sqrt = function() {
  var m, n, sd, r, rep, t, x = this, d = x.d, e2 = x.e, s = x.s, Ctor = x.constructor;
  if (s !== 1 || !d || !d[0]) {
    return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
  }
  external = false;
  s = Math.sqrt(+x);
  if (s == 0 || s == 1 / 0) {
    n = digitsToString(d);
    if ((n.length + e2) % 2 == 0)
      n += "0";
    s = Math.sqrt(n);
    e2 = mathfloor((e2 + 1) / 2) - (e2 < 0 || e2 % 2);
    if (s == 1 / 0) {
      n = "5e" + e2;
    } else {
      n = s.toExponential();
      n = n.slice(0, n.indexOf("e") + 1) + e2;
    }
    r = new Ctor(n);
  } else {
    r = new Ctor(s.toString());
  }
  sd = (e2 = Ctor.precision) + 3;
  for (; ; ) {
    t = r;
    r = t.plus(divide$1(x, t, sd + 2, 1)).times(0.5);
    if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
      n = n.slice(sd - 3, sd + 1);
      if (n == "9999" || !rep && n == "4999") {
        if (!rep) {
          finalise(t, e2 + 1, 0);
          if (t.times(t).eq(x)) {
            r = t;
            break;
          }
        }
        sd += 4;
        rep = 1;
      } else {
        if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
          finalise(r, e2 + 1, 1);
          m = !r.times(r).eq(x);
        }
        break;
      }
    }
  }
  external = true;
  return finalise(r, e2, Ctor.rounding, m);
};
P$1.tangent = P$1.tan = function() {
  var pr, rm, x = this, Ctor = x.constructor;
  if (!x.isFinite())
    return new Ctor(NaN);
  if (x.isZero())
    return new Ctor(x);
  pr = Ctor.precision;
  rm = Ctor.rounding;
  Ctor.precision = pr + 10;
  Ctor.rounding = 1;
  x = x.sin();
  x.s = 1;
  x = divide$1(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
  Ctor.precision = pr;
  Ctor.rounding = rm;
  return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
};
P$1.times = P$1.mul = function(y) {
  var carry, e2, i2, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
  y.s *= x.s;
  if (!xd || !xd[0] || !yd || !yd[0]) {
    return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
  }
  e2 = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
  xdL = xd.length;
  ydL = yd.length;
  if (xdL < ydL) {
    r = xd;
    xd = yd;
    yd = r;
    rL = xdL;
    xdL = ydL;
    ydL = rL;
  }
  r = [];
  rL = xdL + ydL;
  for (i2 = rL; i2--; )
    r.push(0);
  for (i2 = ydL; --i2 >= 0; ) {
    carry = 0;
    for (k = xdL + i2; k > i2; ) {
      t = r[k] + yd[i2] * xd[k - i2 - 1] + carry;
      r[k--] = t % BASE | 0;
      carry = t / BASE | 0;
    }
    r[k] = (r[k] + carry) % BASE | 0;
  }
  for (; !r[--rL]; )
    r.pop();
  if (carry)
    ++e2;
  else
    r.shift();
  y.d = r;
  y.e = getBase10Exponent(r, e2);
  return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
};
P$1.toBinary = function(sd, rm) {
  return toStringBinary(this, 2, sd, rm);
};
P$1.toDecimalPlaces = P$1.toDP = function(dp, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (dp === void 0)
    return x;
  checkInt32(dp, 0, MAX_DIGITS);
  if (rm === void 0)
    rm = Ctor.rounding;
  else
    checkInt32(rm, 0, 8);
  return finalise(x, dp + x.e + 1, rm);
};
P$1.toExponential = function(dp, rm) {
  var str, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x, true);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), dp + 1, rm);
    str = finiteToString(x, true, dp + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$1.toFixed = function(dp, rm) {
  var str, y, x = this, Ctor = x.constructor;
  if (dp === void 0) {
    str = finiteToString(x);
  } else {
    checkInt32(dp, 0, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    y = finalise(new Ctor(x), dp + x.e + 1, rm);
    str = finiteToString(y, false, dp + y.e + 1);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$1.toFraction = function(maxD) {
  var d, d0, d1, d2, e2, k, n, n0, n12, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
  if (!xd)
    return new Ctor(x);
  n12 = d0 = new Ctor(1);
  d1 = n0 = new Ctor(0);
  d = new Ctor(d1);
  e2 = d.e = getPrecision(xd) - x.e - 1;
  k = e2 % LOG_BASE;
  d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
  if (maxD == null) {
    maxD = e2 > 0 ? d : n12;
  } else {
    n = new Ctor(maxD);
    if (!n.isInt() || n.lt(n12))
      throw Error(invalidArgument + n);
    maxD = n.gt(d) ? e2 > 0 ? d : n12 : n;
  }
  external = false;
  n = new Ctor(digitsToString(xd));
  pr = Ctor.precision;
  Ctor.precision = e2 = xd.length * LOG_BASE * 2;
  for (; ; ) {
    q = divide$1(n, d, 0, 1, 1);
    d2 = d0.plus(q.times(d1));
    if (d2.cmp(maxD) == 1)
      break;
    d0 = d1;
    d1 = d2;
    d2 = n12;
    n12 = n0.plus(q.times(d2));
    n0 = d2;
    d2 = d;
    d = n.minus(q.times(d2));
    n = d2;
  }
  d2 = divide$1(maxD.minus(d0), d1, 0, 1, 1);
  n0 = n0.plus(d2.times(n12));
  d0 = d0.plus(d2.times(d1));
  n0.s = n12.s = x.s;
  r = divide$1(n12, d1, e2, 1).minus(x).abs().cmp(divide$1(n0, d0, e2, 1).minus(x).abs()) < 1 ? [n12, d1] : [n0, d0];
  Ctor.precision = pr;
  external = true;
  return r;
};
P$1.toHexadecimal = P$1.toHex = function(sd, rm) {
  return toStringBinary(this, 16, sd, rm);
};
P$1.toNearest = function(y, rm) {
  var x = this, Ctor = x.constructor;
  x = new Ctor(x);
  if (y == null) {
    if (!x.d)
      return x;
    y = new Ctor(1);
    rm = Ctor.rounding;
  } else {
    y = new Ctor(y);
    if (rm === void 0) {
      rm = Ctor.rounding;
    } else {
      checkInt32(rm, 0, 8);
    }
    if (!x.d)
      return y.s ? x : y;
    if (!y.d) {
      if (y.s)
        y.s = x.s;
      return y;
    }
  }
  if (y.d[0]) {
    external = false;
    x = divide$1(x, y, 0, rm, 1).times(y);
    external = true;
    finalise(x);
  } else {
    y.s = x.s;
    x = y;
  }
  return x;
};
P$1.toNumber = function() {
  return +this;
};
P$1.toOctal = function(sd, rm) {
  return toStringBinary(this, 8, sd, rm);
};
P$1.toPower = P$1.pow = function(y) {
  var e2, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
  if (!x.d || !y.d || !x.d[0] || !y.d[0])
    return new Ctor(mathpow(+x, yn));
  x = new Ctor(x);
  if (x.eq(1))
    return x;
  pr = Ctor.precision;
  rm = Ctor.rounding;
  if (y.eq(1))
    return finalise(x, pr, rm);
  e2 = mathfloor(y.e / LOG_BASE);
  if (e2 >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
    r = intPow(Ctor, x, k, pr);
    return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
  }
  s = x.s;
  if (s < 0) {
    if (e2 < y.d.length - 1)
      return new Ctor(NaN);
    if ((y.d[e2] & 1) == 0)
      s = 1;
    if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
      x.s = s;
      return x;
    }
  }
  k = mathpow(+x, yn);
  e2 = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
  if (e2 > Ctor.maxE + 1 || e2 < Ctor.minE - 1)
    return new Ctor(e2 > 0 ? s / 0 : 0);
  external = false;
  Ctor.rounding = x.s = 1;
  k = Math.min(12, (e2 + "").length);
  r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
  if (r.d) {
    r = finalise(r, pr + 5, 1);
    if (checkRoundingDigits(r.d, pr, rm)) {
      e2 = pr + 10;
      r = finalise(naturalExponential(y.times(naturalLogarithm(x, e2 + k)), e2), e2 + 5, 1);
      if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
        r = finalise(r, pr + 1, 0);
      }
    }
  }
  r.s = s;
  external = true;
  Ctor.rounding = rm;
  return finalise(r, pr, rm);
};
P$1.toPrecision = function(sd, rm) {
  var str, x = this, Ctor = x.constructor;
  if (sd === void 0) {
    str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
    x = finalise(new Ctor(x), sd, rm);
    str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
  }
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$1.toSignificantDigits = P$1.toSD = function(sd, rm) {
  var x = this, Ctor = x.constructor;
  if (sd === void 0) {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  } else {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  }
  return finalise(new Ctor(x), sd, rm);
};
P$1.toString = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() && !x.isZero() ? "-" + str : str;
};
P$1.truncated = P$1.trunc = function() {
  return finalise(new this.constructor(this), this.e + 1, 1);
};
P$1.valueOf = P$1.toJSON = function() {
  var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
  return x.isNeg() ? "-" + str : str;
};
function digitsToString(d) {
  var i2, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
  if (indexOfLastWord > 0) {
    str += w;
    for (i2 = 1; i2 < indexOfLastWord; i2++) {
      ws = d[i2] + "";
      k = LOG_BASE - ws.length;
      if (k)
        str += getZeroString(k);
      str += ws;
    }
    w = d[i2];
    ws = w + "";
    k = LOG_BASE - ws.length;
    if (k)
      str += getZeroString(k);
  } else if (w === 0) {
    return "0";
  }
  for (; w % 10 === 0; )
    w /= 10;
  return str + w;
}
function checkInt32(i2, min2, max2) {
  if (i2 !== ~~i2 || i2 < min2 || i2 > max2) {
    throw Error(invalidArgument + i2);
  }
}
function checkRoundingDigits(d, i2, rm, repeating) {
  var di, k, r, rd;
  for (k = d[0]; k >= 10; k /= 10)
    --i2;
  if (--i2 < 0) {
    i2 += LOG_BASE;
    di = 0;
  } else {
    di = Math.ceil((i2 + 1) / LOG_BASE);
    i2 %= LOG_BASE;
  }
  k = mathpow(10, LOG_BASE - i2);
  rd = d[di] % k | 0;
  if (repeating == null) {
    if (i2 < 3) {
      if (i2 == 0)
        rd = rd / 100 | 0;
      else if (i2 == 1)
        rd = rd / 10 | 0;
      r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
    } else {
      r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i2 - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
    }
  } else {
    if (i2 < 4) {
      if (i2 == 0)
        rd = rd / 1e3 | 0;
      else if (i2 == 1)
        rd = rd / 100 | 0;
      else if (i2 == 2)
        rd = rd / 10 | 0;
      r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
    } else {
      r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i2 - 3) - 1;
    }
  }
  return r;
}
function convertBase(str, baseIn, baseOut) {
  var j, arr = [0], arrL, i2 = 0, strL = str.length;
  for (; i2 < strL; ) {
    for (arrL = arr.length; arrL--; )
      arr[arrL] *= baseIn;
    arr[0] += NUMERALS.indexOf(str.charAt(i2++));
    for (j = 0; j < arr.length; j++) {
      if (arr[j] > baseOut - 1) {
        if (arr[j + 1] === void 0)
          arr[j + 1] = 0;
        arr[j + 1] += arr[j] / baseOut | 0;
        arr[j] %= baseOut;
      }
    }
  }
  return arr.reverse();
}
function cosine(Ctor, x) {
  var k, len, y;
  if (x.isZero())
    return x;
  len = x.d.length;
  if (len < 32) {
    k = Math.ceil(len / 3);
    y = (1 / tinyPow(4, k)).toString();
  } else {
    k = 16;
    y = "2.3283064365386962890625e-10";
  }
  Ctor.precision += k;
  x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
  for (var i2 = k; i2--; ) {
    var cos2x = x.times(x);
    x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
  }
  Ctor.precision -= k;
  return x;
}
var divide$1 = function() {
  function multiplyInteger(x, k, base) {
    var temp, carry = 0, i2 = x.length;
    for (x = x.slice(); i2--; ) {
      temp = x[i2] * k + carry;
      x[i2] = temp % base | 0;
      carry = temp / base | 0;
    }
    if (carry)
      x.unshift(carry);
    return x;
  }
  function compare2(a, b, aL, bL) {
    var i2, r;
    if (aL != bL) {
      r = aL > bL ? 1 : -1;
    } else {
      for (i2 = r = 0; i2 < aL; i2++) {
        if (a[i2] != b[i2]) {
          r = a[i2] > b[i2] ? 1 : -1;
          break;
        }
      }
    }
    return r;
  }
  function subtract2(a, b, aL, base) {
    var i2 = 0;
    for (; aL--; ) {
      a[aL] -= i2;
      i2 = a[aL] < b[aL] ? 1 : 0;
      a[aL] = i2 * base + a[aL] - b[aL];
    }
    for (; !a[0] && a.length > 1; )
      a.shift();
  }
  return function(x, y, pr, rm, dp, base) {
    var cmp, e2, i2, k, logBase, more, prod2, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
    if (!xd || !xd[0] || !yd || !yd[0]) {
      return new Ctor(
        // Return NaN if either NaN, or both Infinity or 0.
        !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
          // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
          xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
        )
      );
    }
    if (base) {
      logBase = 1;
      e2 = x.e - y.e;
    } else {
      base = BASE;
      logBase = LOG_BASE;
      e2 = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
    }
    yL = yd.length;
    xL = xd.length;
    q = new Ctor(sign2);
    qd = q.d = [];
    for (i2 = 0; yd[i2] == (xd[i2] || 0); i2++)
      ;
    if (yd[i2] > (xd[i2] || 0))
      e2--;
    if (pr == null) {
      sd = pr = Ctor.precision;
      rm = Ctor.rounding;
    } else if (dp) {
      sd = pr + (x.e - y.e) + 1;
    } else {
      sd = pr;
    }
    if (sd < 0) {
      qd.push(1);
      more = true;
    } else {
      sd = sd / logBase + 2 | 0;
      i2 = 0;
      if (yL == 1) {
        k = 0;
        yd = yd[0];
        sd++;
        for (; (i2 < xL || k) && sd--; i2++) {
          t = k * base + (xd[i2] || 0);
          qd[i2] = t / yd | 0;
          k = t % yd | 0;
        }
        more = k || i2 < xL;
      } else {
        k = base / (yd[0] + 1) | 0;
        if (k > 1) {
          yd = multiplyInteger(yd, k, base);
          xd = multiplyInteger(xd, k, base);
          yL = yd.length;
          xL = xd.length;
        }
        xi = yL;
        rem = xd.slice(0, yL);
        remL = rem.length;
        for (; remL < yL; )
          rem[remL++] = 0;
        yz = yd.slice();
        yz.unshift(0);
        yd0 = yd[0];
        if (yd[1] >= base / 2)
          ++yd0;
        do {
          k = 0;
          cmp = compare2(yd, rem, yL, remL);
          if (cmp < 0) {
            rem0 = rem[0];
            if (yL != remL)
              rem0 = rem0 * base + (rem[1] || 0);
            k = rem0 / yd0 | 0;
            if (k > 1) {
              if (k >= base)
                k = base - 1;
              prod2 = multiplyInteger(yd, k, base);
              prodL = prod2.length;
              remL = rem.length;
              cmp = compare2(prod2, rem, prodL, remL);
              if (cmp == 1) {
                k--;
                subtract2(prod2, yL < prodL ? yz : yd, prodL, base);
              }
            } else {
              if (k == 0)
                cmp = k = 1;
              prod2 = yd.slice();
            }
            prodL = prod2.length;
            if (prodL < remL)
              prod2.unshift(0);
            subtract2(rem, prod2, remL, base);
            if (cmp == -1) {
              remL = rem.length;
              cmp = compare2(yd, rem, yL, remL);
              if (cmp < 1) {
                k++;
                subtract2(rem, yL < remL ? yz : yd, remL, base);
              }
            }
            remL = rem.length;
          } else if (cmp === 0) {
            k++;
            rem = [0];
          }
          qd[i2++] = k;
          if (cmp && rem[0]) {
            rem[remL++] = xd[xi] || 0;
          } else {
            rem = [xd[xi]];
            remL = 1;
          }
        } while ((xi++ < xL || rem[0] !== void 0) && sd--);
        more = rem[0] !== void 0;
      }
      if (!qd[0])
        qd.shift();
    }
    if (logBase == 1) {
      q.e = e2;
      inexact = more;
    } else {
      for (i2 = 1, k = qd[0]; k >= 10; k /= 10)
        i2++;
      q.e = i2 + e2 * logBase - 1;
      finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
    }
    return q;
  };
}();
function finalise(x, sd, rm, isTruncated) {
  var digits2, i2, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
  out:
    if (sd != null) {
      xd = x.d;
      if (!xd)
        return x;
      for (digits2 = 1, k = xd[0]; k >= 10; k /= 10)
        digits2++;
      i2 = sd - digits2;
      if (i2 < 0) {
        i2 += LOG_BASE;
        j = sd;
        w = xd[xdi = 0];
        rd = w / mathpow(10, digits2 - j - 1) % 10 | 0;
      } else {
        xdi = Math.ceil((i2 + 1) / LOG_BASE);
        k = xd.length;
        if (xdi >= k) {
          if (isTruncated) {
            for (; k++ <= xdi; )
              xd.push(0);
            w = rd = 0;
            digits2 = 1;
            i2 %= LOG_BASE;
            j = i2 - LOG_BASE + 1;
          } else {
            break out;
          }
        } else {
          w = k = xd[xdi];
          for (digits2 = 1; k >= 10; k /= 10)
            digits2++;
          i2 %= LOG_BASE;
          j = i2 - LOG_BASE + digits2;
          rd = j < 0 ? 0 : w / mathpow(10, digits2 - j - 1) % 10 | 0;
        }
      }
      isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits2 - j - 1));
      roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
      (i2 > 0 ? j > 0 ? w / mathpow(10, digits2 - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
      if (sd < 1 || !xd[0]) {
        xd.length = 0;
        if (roundUp) {
          sd -= x.e + 1;
          xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
          x.e = -sd || 0;
        } else {
          xd[0] = x.e = 0;
        }
        return x;
      }
      if (i2 == 0) {
        xd.length = xdi;
        k = 1;
        xdi--;
      } else {
        xd.length = xdi + 1;
        k = mathpow(10, LOG_BASE - i2);
        xd[xdi] = j > 0 ? (w / mathpow(10, digits2 - j) % mathpow(10, j) | 0) * k : 0;
      }
      if (roundUp) {
        for (; ; ) {
          if (xdi == 0) {
            for (i2 = 1, j = xd[0]; j >= 10; j /= 10)
              i2++;
            j = xd[0] += k;
            for (k = 1; j >= 10; j /= 10)
              k++;
            if (i2 != k) {
              x.e++;
              if (xd[0] == BASE)
                xd[0] = 1;
            }
            break;
          } else {
            xd[xdi] += k;
            if (xd[xdi] != BASE)
              break;
            xd[xdi--] = 0;
            k = 1;
          }
        }
      }
      for (i2 = xd.length; xd[--i2] === 0; )
        xd.pop();
    }
  if (external) {
    if (x.e > Ctor.maxE) {
      x.d = null;
      x.e = NaN;
    } else if (x.e < Ctor.minE) {
      x.e = 0;
      x.d = [0];
    }
  }
  return x;
}
function finiteToString(x, isExp, sd) {
  if (!x.isFinite())
    return nonFiniteToString(x);
  var k, e2 = x.e, str = digitsToString(x.d), len = str.length;
  if (isExp) {
    if (sd && (k = sd - len) > 0) {
      str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
    } else if (len > 1) {
      str = str.charAt(0) + "." + str.slice(1);
    }
    str = str + (x.e < 0 ? "e" : "e+") + x.e;
  } else if (e2 < 0) {
    str = "0." + getZeroString(-e2 - 1) + str;
    if (sd && (k = sd - len) > 0)
      str += getZeroString(k);
  } else if (e2 >= len) {
    str += getZeroString(e2 + 1 - len);
    if (sd && (k = sd - e2 - 1) > 0)
      str = str + "." + getZeroString(k);
  } else {
    if ((k = e2 + 1) < len)
      str = str.slice(0, k) + "." + str.slice(k);
    if (sd && (k = sd - len) > 0) {
      if (e2 + 1 === len)
        str += ".";
      str += getZeroString(k);
    }
  }
  return str;
}
function getBase10Exponent(digits2, e2) {
  var w = digits2[0];
  for (e2 *= LOG_BASE; w >= 10; w /= 10)
    e2++;
  return e2;
}
function getLn10(Ctor, sd, pr) {
  if (sd > LN10_PRECISION) {
    external = true;
    if (pr)
      Ctor.precision = pr;
    throw Error(precisionLimitExceeded);
  }
  return finalise(new Ctor(LN10$1), sd, 1, true);
}
function getPi(Ctor, sd, rm) {
  if (sd > PI_PRECISION)
    throw Error(precisionLimitExceeded);
  return finalise(new Ctor(PI), sd, rm, true);
}
function getPrecision(digits2) {
  var w = digits2.length - 1, len = w * LOG_BASE + 1;
  w = digits2[w];
  if (w) {
    for (; w % 10 == 0; w /= 10)
      len--;
    for (w = digits2[0]; w >= 10; w /= 10)
      len++;
  }
  return len;
}
function getZeroString(k) {
  var zs = "";
  for (; k--; )
    zs += "0";
  return zs;
}
function intPow(Ctor, x, n, pr) {
  var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
  external = false;
  for (; ; ) {
    if (n % 2) {
      r = r.times(x);
      if (truncate(r.d, k))
        isTruncated = true;
    }
    n = mathfloor(n / 2);
    if (n === 0) {
      n = r.d.length - 1;
      if (isTruncated && r.d[n] === 0)
        ++r.d[n];
      break;
    }
    x = x.times(x);
    truncate(x.d, k);
  }
  external = true;
  return r;
}
function isOdd(n) {
  return n.d[n.d.length - 1] & 1;
}
function maxOrMin(Ctor, args, ltgt) {
  var y, x = new Ctor(args[0]), i2 = 0;
  for (; ++i2 < args.length; ) {
    y = new Ctor(args[i2]);
    if (!y.s) {
      x = y;
      break;
    } else if (x[ltgt](y)) {
      x = y;
    }
  }
  return x;
}
function naturalExponential(x, sd) {
  var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i2 = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (!x.d || !x.d[0] || x.e > 17) {
    return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  t = new Ctor(0.03125);
  while (x.e > -2) {
    x = x.times(t);
    k += 5;
  }
  guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
  wpr += guard;
  denominator = pow2 = sum2 = new Ctor(1);
  Ctor.precision = wpr;
  for (; ; ) {
    pow2 = finalise(pow2.times(x), wpr, 1);
    denominator = denominator.times(++i2);
    t = sum2.plus(divide$1(pow2, denominator, wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      j = k;
      while (j--)
        sum2 = finalise(sum2.times(sum2), wpr, 1);
      if (sd == null) {
        if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += 10;
          denominator = pow2 = t = new Ctor(1);
          i2 = 0;
          rep++;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
  }
}
function naturalLogarithm(y, sd) {
  var c, c0, denominator, e2, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
  if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
    return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
  }
  if (sd == null) {
    external = false;
    wpr = pr;
  } else {
    wpr = sd;
  }
  Ctor.precision = wpr += guard;
  c = digitsToString(xd);
  c0 = c.charAt(0);
  if (Math.abs(e2 = x.e) < 15e14) {
    while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
      x = x.times(y);
      c = digitsToString(x.d);
      c0 = c.charAt(0);
      n++;
    }
    e2 = x.e;
    if (c0 > 1) {
      x = new Ctor("0." + c);
      e2++;
    } else {
      x = new Ctor(c0 + "." + c.slice(1));
    }
  } else {
    t = getLn10(Ctor, wpr + 2, pr).times(e2 + "");
    x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
    Ctor.precision = pr;
    return sd == null ? finalise(x, pr, rm, external = true) : x;
  }
  x1 = x;
  sum2 = numerator = x = divide$1(x.minus(1), x.plus(1), wpr, 1);
  x2 = finalise(x.times(x), wpr, 1);
  denominator = 3;
  for (; ; ) {
    numerator = finalise(numerator.times(x2), wpr, 1);
    t = sum2.plus(divide$1(numerator, new Ctor(denominator), wpr, 1));
    if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
      sum2 = sum2.times(2);
      if (e2 !== 0)
        sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e2 + ""));
      sum2 = divide$1(sum2, new Ctor(n), wpr, 1);
      if (sd == null) {
        if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
          Ctor.precision = wpr += guard;
          t = numerator = x = divide$1(x1.minus(1), x1.plus(1), wpr, 1);
          x2 = finalise(x.times(x), wpr, 1);
          denominator = rep = 1;
        } else {
          return finalise(sum2, Ctor.precision = pr, rm, external = true);
        }
      } else {
        Ctor.precision = pr;
        return sum2;
      }
    }
    sum2 = t;
    denominator += 2;
  }
}
function nonFiniteToString(x) {
  return String(x.s * x.s / 0);
}
function parseDecimal(x, str) {
  var e2, i2, len;
  if ((e2 = str.indexOf(".")) > -1)
    str = str.replace(".", "");
  if ((i2 = str.search(/e/i)) > 0) {
    if (e2 < 0)
      e2 = i2;
    e2 += +str.slice(i2 + 1);
    str = str.substring(0, i2);
  } else if (e2 < 0) {
    e2 = str.length;
  }
  for (i2 = 0; str.charCodeAt(i2) === 48; i2++)
    ;
  for (len = str.length; str.charCodeAt(len - 1) === 48; --len)
    ;
  str = str.slice(i2, len);
  if (str) {
    len -= i2;
    x.e = e2 = e2 - i2 - 1;
    x.d = [];
    i2 = (e2 + 1) % LOG_BASE;
    if (e2 < 0)
      i2 += LOG_BASE;
    if (i2 < len) {
      if (i2)
        x.d.push(+str.slice(0, i2));
      for (len -= LOG_BASE; i2 < len; )
        x.d.push(+str.slice(i2, i2 += LOG_BASE));
      str = str.slice(i2);
      i2 = LOG_BASE - str.length;
    } else {
      i2 -= len;
    }
    for (; i2--; )
      str += "0";
    x.d.push(+str);
    if (external) {
      if (x.e > x.constructor.maxE) {
        x.d = null;
        x.e = NaN;
      } else if (x.e < x.constructor.minE) {
        x.e = 0;
        x.d = [0];
      }
    }
  } else {
    x.e = 0;
    x.d = [0];
  }
  return x;
}
function parseOther(x, str) {
  var base, Ctor, divisor, i2, isFloat, len, p, xd, xe;
  if (str.indexOf("_") > -1) {
    str = str.replace(/(\d)_(?=\d)/g, "$1");
    if (isDecimal.test(str))
      return parseDecimal(x, str);
  } else if (str === "Infinity" || str === "NaN") {
    if (!+str)
      x.s = NaN;
    x.e = NaN;
    x.d = null;
    return x;
  }
  if (isHex.test(str)) {
    base = 16;
    str = str.toLowerCase();
  } else if (isBinary.test(str)) {
    base = 2;
  } else if (isOctal.test(str)) {
    base = 8;
  } else {
    throw Error(invalidArgument + str);
  }
  i2 = str.search(/p/i);
  if (i2 > 0) {
    p = +str.slice(i2 + 1);
    str = str.substring(2, i2);
  } else {
    str = str.slice(2);
  }
  i2 = str.indexOf(".");
  isFloat = i2 >= 0;
  Ctor = x.constructor;
  if (isFloat) {
    str = str.replace(".", "");
    len = str.length;
    i2 = len - i2;
    divisor = intPow(Ctor, new Ctor(base), i2, i2 * 2);
  }
  xd = convertBase(str, base, BASE);
  xe = xd.length - 1;
  for (i2 = xe; xd[i2] === 0; --i2)
    xd.pop();
  if (i2 < 0)
    return new Ctor(x.s * 0);
  x.e = getBase10Exponent(xd, xe);
  x.d = xd;
  external = false;
  if (isFloat)
    x = divide$1(x, divisor, len * 4);
  if (p)
    x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
  external = true;
  return x;
}
function sine(Ctor, x) {
  var k, len = x.d.length;
  if (len < 3) {
    return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
  }
  k = 1.4 * Math.sqrt(len);
  k = k > 16 ? 16 : k | 0;
  x = x.times(1 / tinyPow(5, k));
  x = taylorSeries(Ctor, 2, x, x);
  var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
  for (; k--; ) {
    sin2_x = x.times(x);
    x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
  }
  return x;
}
function taylorSeries(Ctor, n, x, y, isHyperbolic) {
  var j, t, u, x2, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
  external = false;
  x2 = x.times(x);
  u = new Ctor(y);
  for (; ; ) {
    t = divide$1(u.times(x2), new Ctor(n++ * n++), pr, 1);
    u = isHyperbolic ? y.plus(t) : y.minus(t);
    y = divide$1(t.times(x2), new Ctor(n++ * n++), pr, 1);
    t = u.plus(y);
    if (t.d[k] !== void 0) {
      for (j = k; t.d[j] === u.d[j] && j--; )
        ;
      if (j == -1)
        break;
    }
    j = u;
    u = y;
    y = t;
    t = j;
  }
  external = true;
  t.d.length = k + 1;
  return t;
}
function tinyPow(b, e2) {
  var n = b;
  while (--e2)
    n *= b;
  return n;
}
function toLessThanHalfPi(Ctor, x) {
  var t, isNeg = x.s < 0, pi2 = getPi(Ctor, Ctor.precision, 1), halfPi = pi2.times(0.5);
  x = x.abs();
  if (x.lte(halfPi)) {
    quadrant = isNeg ? 4 : 1;
    return x;
  }
  t = x.divToInt(pi2);
  if (t.isZero()) {
    quadrant = isNeg ? 3 : 2;
  } else {
    x = x.minus(t.times(pi2));
    if (x.lte(halfPi)) {
      quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
      return x;
    }
    quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
  }
  return x.minus(pi2).abs();
}
function toStringBinary(x, baseOut, sd, rm) {
  var base, e2, i2, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
  if (isExp) {
    checkInt32(sd, 1, MAX_DIGITS);
    if (rm === void 0)
      rm = Ctor.rounding;
    else
      checkInt32(rm, 0, 8);
  } else {
    sd = Ctor.precision;
    rm = Ctor.rounding;
  }
  if (!x.isFinite()) {
    str = nonFiniteToString(x);
  } else {
    str = finiteToString(x);
    i2 = str.indexOf(".");
    if (isExp) {
      base = 2;
      if (baseOut == 16) {
        sd = sd * 4 - 3;
      } else if (baseOut == 8) {
        sd = sd * 3 - 2;
      }
    } else {
      base = baseOut;
    }
    if (i2 >= 0) {
      str = str.replace(".", "");
      y = new Ctor(1);
      y.e = str.length - i2;
      y.d = convertBase(finiteToString(y), 10, base);
      y.e = y.d.length;
    }
    xd = convertBase(str, 10, base);
    e2 = len = xd.length;
    for (; xd[--len] == 0; )
      xd.pop();
    if (!xd[0]) {
      str = isExp ? "0p+0" : "0";
    } else {
      if (i2 < 0) {
        e2--;
      } else {
        x = new Ctor(x);
        x.d = xd;
        x.e = e2;
        x = divide$1(x, y, sd, rm, 0, base);
        xd = x.d;
        e2 = x.e;
        roundUp = inexact;
      }
      i2 = xd[sd];
      k = base / 2;
      roundUp = roundUp || xd[sd + 1] !== void 0;
      roundUp = rm < 4 ? (i2 !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i2 > k || i2 === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
      xd.length = sd;
      if (roundUp) {
        for (; ++xd[--sd] > base - 1; ) {
          xd[sd] = 0;
          if (!sd) {
            ++e2;
            xd.unshift(1);
          }
        }
      }
      for (len = xd.length; !xd[len - 1]; --len)
        ;
      for (i2 = 0, str = ""; i2 < len; i2++)
        str += NUMERALS.charAt(xd[i2]);
      if (isExp) {
        if (len > 1) {
          if (baseOut == 16 || baseOut == 8) {
            i2 = baseOut == 16 ? 4 : 3;
            for (--len; len % i2; len++)
              str += "0";
            xd = convertBase(str, base, baseOut);
            for (len = xd.length; !xd[len - 1]; --len)
              ;
            for (i2 = 1, str = "1."; i2 < len; i2++)
              str += NUMERALS.charAt(xd[i2]);
          } else {
            str = str.charAt(0) + "." + str.slice(1);
          }
        }
        str = str + (e2 < 0 ? "p" : "p+") + e2;
      } else if (e2 < 0) {
        for (; ++e2; )
          str = "0" + str;
        str = "0." + str;
      } else {
        if (++e2 > len)
          for (e2 -= len; e2--; )
            str += "0";
        else if (e2 < len)
          str = str.slice(0, e2) + "." + str.slice(e2);
      }
    }
    str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
  }
  return x.s < 0 ? "-" + str : str;
}
function truncate(arr, len) {
  if (arr.length > len) {
    arr.length = len;
    return true;
  }
}
function abs$1(x) {
  return new this(x).abs();
}
function acos$1(x) {
  return new this(x).acos();
}
function acosh$1(x) {
  return new this(x).acosh();
}
function add$1(x, y) {
  return new this(x).plus(y);
}
function asin$1(x) {
  return new this(x).asin();
}
function asinh$1(x) {
  return new this(x).asinh();
}
function atan$1(x) {
  return new this(x).atan();
}
function atanh$1(x) {
  return new this(x).atanh();
}
function atan2$1(y, x) {
  y = new this(y);
  x = new this(x);
  var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
  if (!y.s || !x.s) {
    r = new this(NaN);
  } else if (!y.d && !x.d) {
    r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
    r.s = y.s;
  } else if (!x.d || y.isZero()) {
    r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
    r.s = y.s;
  } else if (!y.d || x.isZero()) {
    r = getPi(this, wpr, 1).times(0.5);
    r.s = y.s;
  } else if (x.s < 0) {
    this.precision = wpr;
    this.rounding = 1;
    r = this.atan(divide$1(y, x, wpr, 1));
    x = getPi(this, wpr, 1);
    this.precision = pr;
    this.rounding = rm;
    r = y.s < 0 ? r.minus(x) : r.plus(x);
  } else {
    r = this.atan(divide$1(y, x, wpr, 1));
  }
  return r;
}
function cbrt$1(x) {
  return new this(x).cbrt();
}
function ceil$1(x) {
  return finalise(x = new this(x), x.e + 1, 2);
}
function clamp(x, min2, max2) {
  return new this(x).clamp(min2, max2);
}
function config2(obj) {
  if (!obj || typeof obj !== "object")
    throw Error(decimalError + "Object expected");
  var i2, p, v, useDefaults = obj.defaults === true, ps = [
    "precision",
    1,
    MAX_DIGITS,
    "rounding",
    0,
    8,
    "toExpNeg",
    -EXP_LIMIT,
    0,
    "toExpPos",
    0,
    EXP_LIMIT,
    "maxE",
    0,
    EXP_LIMIT,
    "minE",
    -EXP_LIMIT,
    0,
    "modulo",
    0,
    9
  ];
  for (i2 = 0; i2 < ps.length; i2 += 3) {
    if (p = ps[i2], useDefaults)
      this[p] = DEFAULTS[p];
    if ((v = obj[p]) !== void 0) {
      if (mathfloor(v) === v && v >= ps[i2 + 1] && v <= ps[i2 + 2])
        this[p] = v;
      else
        throw Error(invalidArgument + p + ": " + v);
    }
  }
  if (p = "crypto", useDefaults)
    this[p] = DEFAULTS[p];
  if ((v = obj[p]) !== void 0) {
    if (v === true || v === false || v === 0 || v === 1) {
      if (v) {
        if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
          this[p] = true;
        } else {
          throw Error(cryptoUnavailable);
        }
      } else {
        this[p] = false;
      }
    } else {
      throw Error(invalidArgument + p + ": " + v);
    }
  }
  return this;
}
function cos$1(x) {
  return new this(x).cos();
}
function cosh$1(x) {
  return new this(x).cosh();
}
function clone$1(obj) {
  var i2, p, ps;
  function Decimal2(v) {
    var e2, i3, t, x = this;
    if (!(x instanceof Decimal2))
      return new Decimal2(v);
    x.constructor = Decimal2;
    if (isDecimalInstance(v)) {
      x.s = v.s;
      if (external) {
        if (!v.d || v.e > Decimal2.maxE) {
          x.e = NaN;
          x.d = null;
        } else if (v.e < Decimal2.minE) {
          x.e = 0;
          x.d = [0];
        } else {
          x.e = v.e;
          x.d = v.d.slice();
        }
      } else {
        x.e = v.e;
        x.d = v.d ? v.d.slice() : v.d;
      }
      return;
    }
    t = typeof v;
    if (t === "number") {
      if (v === 0) {
        x.s = 1 / v < 0 ? -1 : 1;
        x.e = 0;
        x.d = [0];
        return;
      }
      if (v < 0) {
        v = -v;
        x.s = -1;
      } else {
        x.s = 1;
      }
      if (v === ~~v && v < 1e7) {
        for (e2 = 0, i3 = v; i3 >= 10; i3 /= 10)
          e2++;
        if (external) {
          if (e2 > Decimal2.maxE) {
            x.e = NaN;
            x.d = null;
          } else if (e2 < Decimal2.minE) {
            x.e = 0;
            x.d = [0];
          } else {
            x.e = e2;
            x.d = [v];
          }
        } else {
          x.e = e2;
          x.d = [v];
        }
        return;
      } else if (v * 0 !== 0) {
        if (!v)
          x.s = NaN;
        x.e = NaN;
        x.d = null;
        return;
      }
      return parseDecimal(x, v.toString());
    } else if (t !== "string") {
      throw Error(invalidArgument + v);
    }
    if ((i3 = v.charCodeAt(0)) === 45) {
      v = v.slice(1);
      x.s = -1;
    } else {
      if (i3 === 43)
        v = v.slice(1);
      x.s = 1;
    }
    return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
  }
  Decimal2.prototype = P$1;
  Decimal2.ROUND_UP = 0;
  Decimal2.ROUND_DOWN = 1;
  Decimal2.ROUND_CEIL = 2;
  Decimal2.ROUND_FLOOR = 3;
  Decimal2.ROUND_HALF_UP = 4;
  Decimal2.ROUND_HALF_DOWN = 5;
  Decimal2.ROUND_HALF_EVEN = 6;
  Decimal2.ROUND_HALF_CEIL = 7;
  Decimal2.ROUND_HALF_FLOOR = 8;
  Decimal2.EUCLID = 9;
  Decimal2.config = Decimal2.set = config2;
  Decimal2.clone = clone$1;
  Decimal2.isDecimal = isDecimalInstance;
  Decimal2.abs = abs$1;
  Decimal2.acos = acos$1;
  Decimal2.acosh = acosh$1;
  Decimal2.add = add$1;
  Decimal2.asin = asin$1;
  Decimal2.asinh = asinh$1;
  Decimal2.atan = atan$1;
  Decimal2.atanh = atanh$1;
  Decimal2.atan2 = atan2$1;
  Decimal2.cbrt = cbrt$1;
  Decimal2.ceil = ceil$1;
  Decimal2.clamp = clamp;
  Decimal2.cos = cos$1;
  Decimal2.cosh = cosh$1;
  Decimal2.div = div;
  Decimal2.exp = exp$1;
  Decimal2.floor = floor$1;
  Decimal2.hypot = hypot$1;
  Decimal2.ln = ln;
  Decimal2.log = log$1;
  Decimal2.log10 = log10$1;
  Decimal2.log2 = log2$1;
  Decimal2.max = max$1;
  Decimal2.min = min$1;
  Decimal2.mod = mod$1;
  Decimal2.mul = mul;
  Decimal2.pow = pow$1;
  Decimal2.random = random$1;
  Decimal2.round = round$1;
  Decimal2.sign = sign$1;
  Decimal2.sin = sin$1;
  Decimal2.sinh = sinh$1;
  Decimal2.sqrt = sqrt$1;
  Decimal2.sub = sub;
  Decimal2.sum = sum$1;
  Decimal2.tan = tan$1;
  Decimal2.tanh = tanh$1;
  Decimal2.trunc = trunc;
  if (obj === void 0)
    obj = {};
  if (obj) {
    if (obj.defaults !== true) {
      ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
      for (i2 = 0; i2 < ps.length; )
        if (!obj.hasOwnProperty(p = ps[i2++]))
          obj[p] = this[p];
    }
  }
  Decimal2.config(obj);
  return Decimal2;
}
function div(x, y) {
  return new this(x).div(y);
}
function exp$1(x) {
  return new this(x).exp();
}
function floor$1(x) {
  return finalise(x = new this(x), x.e + 1, 3);
}
function hypot$1() {
  var i2, n, t = new this(0);
  external = false;
  for (i2 = 0; i2 < arguments.length; ) {
    n = new this(arguments[i2++]);
    if (!n.d) {
      if (n.s) {
        external = true;
        return new this(1 / 0);
      }
      t = n;
    } else if (t.d) {
      t = t.plus(n.times(n));
    }
  }
  external = true;
  return t.sqrt();
}
function isDecimalInstance(obj) {
  return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
}
function ln(x) {
  return new this(x).ln();
}
function log$1(x, y) {
  return new this(x).log(y);
}
function log2$1(x) {
  return new this(x).log(2);
}
function log10$1(x) {
  return new this(x).log(10);
}
function max$1() {
  return maxOrMin(this, arguments, "lt");
}
function min$1() {
  return maxOrMin(this, arguments, "gt");
}
function mod$1(x, y) {
  return new this(x).mod(y);
}
function mul(x, y) {
  return new this(x).mul(y);
}
function pow$1(x, y) {
  return new this(x).pow(y);
}
function random$1(sd) {
  var d, e2, k, n, i2 = 0, r = new this(1), rd = [];
  if (sd === void 0)
    sd = this.precision;
  else
    checkInt32(sd, 1, MAX_DIGITS);
  k = Math.ceil(sd / LOG_BASE);
  if (!this.crypto) {
    for (; i2 < k; )
      rd[i2++] = Math.random() * 1e7 | 0;
  } else if (crypto.getRandomValues) {
    d = crypto.getRandomValues(new Uint32Array(k));
    for (; i2 < k; ) {
      n = d[i2];
      if (n >= 429e7) {
        d[i2] = crypto.getRandomValues(new Uint32Array(1))[0];
      } else {
        rd[i2++] = n % 1e7;
      }
    }
  } else if (crypto.randomBytes) {
    d = crypto.randomBytes(k *= 4);
    for (; i2 < k; ) {
      n = d[i2] + (d[i2 + 1] << 8) + (d[i2 + 2] << 16) + ((d[i2 + 3] & 127) << 24);
      if (n >= 214e7) {
        crypto.randomBytes(4).copy(d, i2);
      } else {
        rd.push(n % 1e7);
        i2 += 4;
      }
    }
    i2 = k / 4;
  } else {
    throw Error(cryptoUnavailable);
  }
  k = rd[--i2];
  sd %= LOG_BASE;
  if (k && sd) {
    n = mathpow(10, LOG_BASE - sd);
    rd[i2] = (k / n | 0) * n;
  }
  for (; rd[i2] === 0; i2--)
    rd.pop();
  if (i2 < 0) {
    e2 = 0;
    rd = [0];
  } else {
    e2 = -1;
    for (; rd[0] === 0; e2 -= LOG_BASE)
      rd.shift();
    for (k = 1, n = rd[0]; n >= 10; n /= 10)
      k++;
    if (k < LOG_BASE)
      e2 -= LOG_BASE - k;
  }
  r.e = e2;
  r.d = rd;
  return r;
}
function round$1(x) {
  return finalise(x = new this(x), x.e + 1, this.rounding);
}
function sign$1(x) {
  x = new this(x);
  return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
}
function sin$1(x) {
  return new this(x).sin();
}
function sinh$1(x) {
  return new this(x).sinh();
}
function sqrt$1(x) {
  return new this(x).sqrt();
}
function sub(x, y) {
  return new this(x).sub(y);
}
function sum$1() {
  var i2 = 0, args = arguments, x = new this(args[i2]);
  external = false;
  for (; x.s && ++i2 < args.length; )
    x = x.plus(args[i2]);
  external = true;
  return finalise(x, this.precision, this.rounding);
}
function tan$1(x) {
  return new this(x).tan();
}
function tanh$1(x) {
  return new this(x).tanh();
}
function trunc(x) {
  return finalise(x = new this(x), x.e + 1, 1);
}
P$1[Symbol.for("nodejs.util.inspect.custom")] = P$1.toString;
P$1[Symbol.toStringTag] = "Decimal";
var Decimal = P$1.constructor = clone$1(DEFAULTS);
LN10$1 = new Decimal(LN10$1);
PI = new Decimal(PI);
var name$4T = "BigNumber";
var dependencies$4S = ["?on", "config"];
var createBigNumberClass = /* @__PURE__ */ factory(name$4T, dependencies$4S, (_ref) => {
  var {
    on,
    config: config3
  } = _ref;
  var BigNumber2 = Decimal.clone({
    precision: config3.precision,
    modulo: Decimal.EUCLID
  });
  BigNumber2.prototype = Object.create(BigNumber2.prototype);
  BigNumber2.prototype.type = "BigNumber";
  BigNumber2.prototype.isBigNumber = true;
  BigNumber2.prototype.toJSON = function() {
    return {
      mathjs: "BigNumber",
      value: this.toString()
    };
  };
  BigNumber2.fromJSON = function(json) {
    return new BigNumber2(json.value);
  };
  if (on) {
    on("config", function(curr, prev) {
      if (curr.precision !== prev.precision) {
        BigNumber2.config({
          precision: curr.precision
        });
      }
    });
  }
  return BigNumber2;
}, {
  isClass: true
});
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
function getAugmentedNamespace(n) {
  if (n.__esModule)
    return n;
  var f = n.default;
  if (typeof f == "function") {
    var a = function a2() {
      if (this instanceof a2) {
        return Reflect.construct(f, arguments, this.constructor);
      }
      return f.apply(this, arguments);
    };
    a.prototype = f.prototype;
  } else
    a = {};
  Object.defineProperty(a, "__esModule", { value: true });
  Object.keys(n).forEach(function(k) {
    var d = Object.getOwnPropertyDescriptor(n, k);
    Object.defineProperty(a, k, d.get ? d : {
      enumerable: true,
      get: function() {
        return n[k];
      }
    });
  });
  return a;
}
var complex$1 = { exports: {} };
/**
 * @license Complex.js v2.1.1 12/05/2020
 *
 * Copyright (c) 2020, Robert Eisele (robert@xarg.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(module, exports) {
  (function(root) {
    var cosh2 = Math.cosh || function(x) {
      return Math.abs(x) < 1e-9 ? 1 - x : (Math.exp(x) + Math.exp(-x)) * 0.5;
    };
    var sinh2 = Math.sinh || function(x) {
      return Math.abs(x) < 1e-9 ? x : (Math.exp(x) - Math.exp(-x)) * 0.5;
    };
    var cosm1 = function(x) {
      var b = Math.PI / 4;
      if (-b > x || x > b) {
        return Math.cos(x) - 1;
      }
      var xx = x * x;
      return xx * (xx * (xx * (xx * (xx * (xx * (xx * (xx / 20922789888e3 - 1 / 87178291200) + 1 / 479001600) - 1 / 3628800) + 1 / 40320) - 1 / 720) + 1 / 24) - 1 / 2);
    };
    var hypot2 = function(x, y) {
      var a = Math.abs(x);
      var b = Math.abs(y);
      if (a < 3e3 && b < 3e3) {
        return Math.sqrt(a * a + b * b);
      }
      if (a < b) {
        a = b;
        b = x / y;
      } else {
        b = y / x;
      }
      return a * Math.sqrt(1 + b * b);
    };
    var parser_exit = function() {
      throw SyntaxError("Invalid Param");
    };
    function logHypot(a, b) {
      var _a = Math.abs(a);
      var _b = Math.abs(b);
      if (a === 0) {
        return Math.log(_b);
      }
      if (b === 0) {
        return Math.log(_a);
      }
      if (_a < 3e3 && _b < 3e3) {
        return Math.log(a * a + b * b) * 0.5;
      }
      a = a / 2;
      b = b / 2;
      return 0.5 * Math.log(a * a + b * b) + Math.LN2;
    }
    var parse2 = function(a, b) {
      var z = { "re": 0, "im": 0 };
      if (a === void 0 || a === null) {
        z["re"] = z["im"] = 0;
      } else if (b !== void 0) {
        z["re"] = a;
        z["im"] = b;
      } else
        switch (typeof a) {
          case "object":
            if ("im" in a && "re" in a) {
              z["re"] = a["re"];
              z["im"] = a["im"];
            } else if ("abs" in a && "arg" in a) {
              if (!Number.isFinite(a["abs"]) && Number.isFinite(a["arg"])) {
                return Complex2["INFINITY"];
              }
              z["re"] = a["abs"] * Math.cos(a["arg"]);
              z["im"] = a["abs"] * Math.sin(a["arg"]);
            } else if ("r" in a && "phi" in a) {
              if (!Number.isFinite(a["r"]) && Number.isFinite(a["phi"])) {
                return Complex2["INFINITY"];
              }
              z["re"] = a["r"] * Math.cos(a["phi"]);
              z["im"] = a["r"] * Math.sin(a["phi"]);
            } else if (a.length === 2) {
              z["re"] = a[0];
              z["im"] = a[1];
            } else {
              parser_exit();
            }
            break;
          case "string":
            z["im"] = /* void */
            z["re"] = 0;
            var tokens = a.match(/\d+\.?\d*e[+-]?\d+|\d+\.?\d*|\.\d+|./g);
            var plus = 1;
            var minus = 0;
            if (tokens === null) {
              parser_exit();
            }
            for (var i2 = 0; i2 < tokens.length; i2++) {
              var c = tokens[i2];
              if (c === " " || c === "	" || c === "\n")
                ;
              else if (c === "+") {
                plus++;
              } else if (c === "-") {
                minus++;
              } else if (c === "i" || c === "I") {
                if (plus + minus === 0) {
                  parser_exit();
                }
                if (tokens[i2 + 1] !== " " && !isNaN(tokens[i2 + 1])) {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + tokens[i2 + 1]);
                  i2++;
                } else {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + "1");
                }
                plus = minus = 0;
              } else {
                if (plus + minus === 0 || isNaN(c)) {
                  parser_exit();
                }
                if (tokens[i2 + 1] === "i" || tokens[i2 + 1] === "I") {
                  z["im"] += parseFloat((minus % 2 ? "-" : "") + c);
                  i2++;
                } else {
                  z["re"] += parseFloat((minus % 2 ? "-" : "") + c);
                }
                plus = minus = 0;
              }
            }
            if (plus + minus > 0) {
              parser_exit();
            }
            break;
          case "number":
            z["im"] = 0;
            z["re"] = a;
            break;
          default:
            parser_exit();
        }
      if (isNaN(z["re"]) || isNaN(z["im"]))
        ;
      return z;
    };
    function Complex2(a, b) {
      if (!(this instanceof Complex2)) {
        return new Complex2(a, b);
      }
      var z = parse2(a, b);
      this["re"] = z["re"];
      this["im"] = z["im"];
    }
    Complex2.prototype = {
      "re": 0,
      "im": 0,
      /**
       * Calculates the sign of a complex number, which is a normalized complex
       *
       * @returns {Complex}
       */
      "sign": function() {
        var abs2 = this["abs"]();
        return new Complex2(
          this["re"] / abs2,
          this["im"] / abs2
        );
      },
      /**
       * Adds two complex numbers
       *
       * @returns {Complex}
       */
      "add": function(a, b) {
        var z = new Complex2(a, b);
        if (this["isInfinite"]() && z["isInfinite"]()) {
          return Complex2["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return Complex2["INFINITY"];
        }
        return new Complex2(
          this["re"] + z["re"],
          this["im"] + z["im"]
        );
      },
      /**
       * Subtracts two complex numbers
       *
       * @returns {Complex}
       */
      "sub": function(a, b) {
        var z = new Complex2(a, b);
        if (this["isInfinite"]() && z["isInfinite"]()) {
          return Complex2["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return Complex2["INFINITY"];
        }
        return new Complex2(
          this["re"] - z["re"],
          this["im"] - z["im"]
        );
      },
      /**
       * Multiplies two complex numbers
       *
       * @returns {Complex}
       */
      "mul": function(a, b) {
        var z = new Complex2(a, b);
        if (this["isInfinite"]() && z["isZero"]() || this["isZero"]() && z["isInfinite"]()) {
          return Complex2["NAN"];
        }
        if (this["isInfinite"]() || z["isInfinite"]()) {
          return Complex2["INFINITY"];
        }
        if (z["im"] === 0 && this["im"] === 0) {
          return new Complex2(this["re"] * z["re"], 0);
        }
        return new Complex2(
          this["re"] * z["re"] - this["im"] * z["im"],
          this["re"] * z["im"] + this["im"] * z["re"]
        );
      },
      /**
       * Divides two complex numbers
       *
       * @returns {Complex}
       */
      "div": function(a, b) {
        var z = new Complex2(a, b);
        if (this["isZero"]() && z["isZero"]() || this["isInfinite"]() && z["isInfinite"]()) {
          return Complex2["NAN"];
        }
        if (this["isInfinite"]() || z["isZero"]()) {
          return Complex2["INFINITY"];
        }
        if (this["isZero"]() || z["isInfinite"]()) {
          return Complex2["ZERO"];
        }
        a = this["re"];
        b = this["im"];
        var c = z["re"];
        var d = z["im"];
        var t, x;
        if (0 === d) {
          return new Complex2(a / c, b / c);
        }
        if (Math.abs(c) < Math.abs(d)) {
          x = c / d;
          t = c * x + d;
          return new Complex2(
            (a * x + b) / t,
            (b * x - a) / t
          );
        } else {
          x = d / c;
          t = d * x + c;
          return new Complex2(
            (a + b * x) / t,
            (b - a * x) / t
          );
        }
      },
      /**
       * Calculate the power of two complex numbers
       *
       * @returns {Complex}
       */
      "pow": function(a, b) {
        var z = new Complex2(a, b);
        a = this["re"];
        b = this["im"];
        if (z["isZero"]()) {
          return Complex2["ONE"];
        }
        if (z["im"] === 0) {
          if (b === 0 && a > 0) {
            return new Complex2(Math.pow(a, z["re"]), 0);
          } else if (a === 0) {
            switch ((z["re"] % 4 + 4) % 4) {
              case 0:
                return new Complex2(Math.pow(b, z["re"]), 0);
              case 1:
                return new Complex2(0, Math.pow(b, z["re"]));
              case 2:
                return new Complex2(-Math.pow(b, z["re"]), 0);
              case 3:
                return new Complex2(0, -Math.pow(b, z["re"]));
            }
          }
        }
        if (a === 0 && b === 0 && z["re"] > 0 && z["im"] >= 0) {
          return Complex2["ZERO"];
        }
        var arg2 = Math.atan2(b, a);
        var loh = logHypot(a, b);
        a = Math.exp(z["re"] * loh - z["im"] * arg2);
        b = z["im"] * loh + z["re"] * arg2;
        return new Complex2(
          a * Math.cos(b),
          a * Math.sin(b)
        );
      },
      /**
       * Calculate the complex square root
       *
       * @returns {Complex}
       */
      "sqrt": function() {
        var a = this["re"];
        var b = this["im"];
        var r = this["abs"]();
        var re2, im2;
        if (a >= 0) {
          if (b === 0) {
            return new Complex2(Math.sqrt(a), 0);
          }
          re2 = 0.5 * Math.sqrt(2 * (r + a));
        } else {
          re2 = Math.abs(b) / Math.sqrt(2 * (r - a));
        }
        if (a <= 0) {
          im2 = 0.5 * Math.sqrt(2 * (r - a));
        } else {
          im2 = Math.abs(b) / Math.sqrt(2 * (r + a));
        }
        return new Complex2(re2, b < 0 ? -im2 : im2);
      },
      /**
       * Calculate the complex exponent
       *
       * @returns {Complex}
       */
      "exp": function() {
        var tmp = Math.exp(this["re"]);
        if (this["im"] === 0)
          ;
        return new Complex2(
          tmp * Math.cos(this["im"]),
          tmp * Math.sin(this["im"])
        );
      },
      /**
       * Calculate the complex exponent and subtracts one.
       *
       * This may be more accurate than `Complex(x).exp().sub(1)` if
       * `x` is small.
       *
       * @returns {Complex}
       */
      "expm1": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          Math.expm1(a) * Math.cos(b) + cosm1(b),
          Math.exp(a) * Math.sin(b)
        );
      },
      /**
       * Calculate the natural log
       *
       * @returns {Complex}
       */
      "log": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          logHypot(a, b),
          Math.atan2(b, a)
        );
      },
      /**
       * Calculate the magnitude of the complex number
       *
       * @returns {number}
       */
      "abs": function() {
        return hypot2(this["re"], this["im"]);
      },
      /**
       * Calculate the angle of the complex number
       *
       * @returns {number}
       */
      "arg": function() {
        return Math.atan2(this["im"], this["re"]);
      },
      /**
       * Calculate the sine of the complex number
       *
       * @returns {Complex}
       */
      "sin": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          Math.sin(a) * cosh2(b),
          Math.cos(a) * sinh2(b)
        );
      },
      /**
       * Calculate the cosine
       *
       * @returns {Complex}
       */
      "cos": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          Math.cos(a) * cosh2(b),
          -Math.sin(a) * sinh2(b)
        );
      },
      /**
       * Calculate the tangent
       *
       * @returns {Complex}
       */
      "tan": function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = Math.cos(a) + cosh2(b);
        return new Complex2(
          Math.sin(a) / d,
          sinh2(b) / d
        );
      },
      /**
       * Calculate the cotangent
       *
       * @returns {Complex}
       */
      "cot": function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = Math.cos(a) - cosh2(b);
        return new Complex2(
          -Math.sin(a) / d,
          sinh2(b) / d
        );
      },
      /**
       * Calculate the secant
       *
       * @returns {Complex}
       */
      "sec": function() {
        var a = this["re"];
        var b = this["im"];
        var d = 0.5 * cosh2(2 * b) + 0.5 * Math.cos(2 * a);
        return new Complex2(
          Math.cos(a) * cosh2(b) / d,
          Math.sin(a) * sinh2(b) / d
        );
      },
      /**
       * Calculate the cosecans
       *
       * @returns {Complex}
       */
      "csc": function() {
        var a = this["re"];
        var b = this["im"];
        var d = 0.5 * cosh2(2 * b) - 0.5 * Math.cos(2 * a);
        return new Complex2(
          Math.sin(a) * cosh2(b) / d,
          -Math.cos(a) * sinh2(b) / d
        );
      },
      /**
       * Calculate the complex arcus sinus
       *
       * @returns {Complex}
       */
      "asin": function() {
        var a = this["re"];
        var b = this["im"];
        var t1 = new Complex2(
          b * b - a * a + 1,
          -2 * a * b
        )["sqrt"]();
        var t2 = new Complex2(
          t1["re"] - b,
          t1["im"] + a
        )["log"]();
        return new Complex2(t2["im"], -t2["re"]);
      },
      /**
       * Calculate the complex arcus cosinus
       *
       * @returns {Complex}
       */
      "acos": function() {
        var a = this["re"];
        var b = this["im"];
        var t1 = new Complex2(
          b * b - a * a + 1,
          -2 * a * b
        )["sqrt"]();
        var t2 = new Complex2(
          t1["re"] - b,
          t1["im"] + a
        )["log"]();
        return new Complex2(Math.PI / 2 - t2["im"], t2["re"]);
      },
      /**
       * Calculate the complex arcus tangent
       *
       * @returns {Complex}
       */
      "atan": function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0) {
          if (b === 1) {
            return new Complex2(0, Infinity);
          }
          if (b === -1) {
            return new Complex2(0, -Infinity);
          }
        }
        var d = a * a + (1 - b) * (1 - b);
        var t1 = new Complex2(
          (1 - b * b - a * a) / d,
          -2 * a / d
        ).log();
        return new Complex2(-0.5 * t1["im"], 0.5 * t1["re"]);
      },
      /**
       * Calculate the complex arcus cotangent
       *
       * @returns {Complex}
       */
      "acot": function() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0) {
          return new Complex2(Math.atan2(1, a), 0);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).atan() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).atan();
      },
      /**
       * Calculate the complex arcus secant
       *
       * @returns {Complex}
       */
      "asec": function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex2(0, Infinity);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).acos() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).acos();
      },
      /**
       * Calculate the complex arcus cosecans
       *
       * @returns {Complex}
       */
      "acsc": function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex2(Math.PI / 2, Infinity);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).asin() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).asin();
      },
      /**
       * Calculate the complex sinh
       *
       * @returns {Complex}
       */
      "sinh": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          sinh2(a) * Math.cos(b),
          cosh2(a) * Math.sin(b)
        );
      },
      /**
       * Calculate the complex cosh
       *
       * @returns {Complex}
       */
      "cosh": function() {
        var a = this["re"];
        var b = this["im"];
        return new Complex2(
          cosh2(a) * Math.cos(b),
          sinh2(a) * Math.sin(b)
        );
      },
      /**
       * Calculate the complex tanh
       *
       * @returns {Complex}
       */
      "tanh": function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = cosh2(a) + Math.cos(b);
        return new Complex2(
          sinh2(a) / d,
          Math.sin(b) / d
        );
      },
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      "coth": function() {
        var a = 2 * this["re"];
        var b = 2 * this["im"];
        var d = cosh2(a) - Math.cos(b);
        return new Complex2(
          sinh2(a) / d,
          -Math.sin(b) / d
        );
      },
      /**
       * Calculate the complex coth
       *
       * @returns {Complex}
       */
      "csch": function() {
        var a = this["re"];
        var b = this["im"];
        var d = Math.cos(2 * b) - cosh2(2 * a);
        return new Complex2(
          -2 * sinh2(a) * Math.cos(b) / d,
          2 * cosh2(a) * Math.sin(b) / d
        );
      },
      /**
       * Calculate the complex sech
       *
       * @returns {Complex}
       */
      "sech": function() {
        var a = this["re"];
        var b = this["im"];
        var d = Math.cos(2 * b) + cosh2(2 * a);
        return new Complex2(
          2 * cosh2(a) * Math.cos(b) / d,
          -2 * sinh2(a) * Math.sin(b) / d
        );
      },
      /**
       * Calculate the complex asinh
       *
       * @returns {Complex}
       */
      "asinh": function() {
        var tmp = this["im"];
        this["im"] = -this["re"];
        this["re"] = tmp;
        var res = this["asin"]();
        this["re"] = -this["im"];
        this["im"] = tmp;
        tmp = res["re"];
        res["re"] = -res["im"];
        res["im"] = tmp;
        return res;
      },
      /**
       * Calculate the complex acosh
       *
       * @returns {Complex}
       */
      "acosh": function() {
        var res = this["acos"]();
        if (res["im"] <= 0) {
          var tmp = res["re"];
          res["re"] = -res["im"];
          res["im"] = tmp;
        } else {
          var tmp = res["im"];
          res["im"] = -res["re"];
          res["re"] = tmp;
        }
        return res;
      },
      /**
       * Calculate the complex atanh
       *
       * @returns {Complex}
       */
      "atanh": function() {
        var a = this["re"];
        var b = this["im"];
        var noIM = a > 1 && b === 0;
        var oneMinus = 1 - a;
        var onePlus = 1 + a;
        var d = oneMinus * oneMinus + b * b;
        var x = d !== 0 ? new Complex2(
          (onePlus * oneMinus - b * b) / d,
          (b * oneMinus + onePlus * b) / d
        ) : new Complex2(
          a !== -1 ? a / 0 : 0,
          b !== 0 ? b / 0 : 0
        );
        var temp = x["re"];
        x["re"] = logHypot(x["re"], x["im"]) / 2;
        x["im"] = Math.atan2(x["im"], temp) / 2;
        if (noIM) {
          x["im"] = -x["im"];
        }
        return x;
      },
      /**
       * Calculate the complex acoth
       *
       * @returns {Complex}
       */
      "acoth": function() {
        var a = this["re"];
        var b = this["im"];
        if (a === 0 && b === 0) {
          return new Complex2(0, Math.PI / 2);
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).atanh() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).atanh();
      },
      /**
       * Calculate the complex acsch
       *
       * @returns {Complex}
       */
      "acsch": function() {
        var a = this["re"];
        var b = this["im"];
        if (b === 0) {
          return new Complex2(
            a !== 0 ? Math.log(a + Math.sqrt(a * a + 1)) : Infinity,
            0
          );
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).asinh() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).asinh();
      },
      /**
       * Calculate the complex asech
       *
       * @returns {Complex}
       */
      "asech": function() {
        var a = this["re"];
        var b = this["im"];
        if (this["isZero"]()) {
          return Complex2["INFINITY"];
        }
        var d = a * a + b * b;
        return d !== 0 ? new Complex2(
          a / d,
          -b / d
        ).acosh() : new Complex2(
          a !== 0 ? a / 0 : 0,
          b !== 0 ? -b / 0 : 0
        ).acosh();
      },
      /**
       * Calculate the complex inverse 1/z
       *
       * @returns {Complex}
       */
      "inverse": function() {
        if (this["isZero"]()) {
          return Complex2["INFINITY"];
        }
        if (this["isInfinite"]()) {
          return Complex2["ZERO"];
        }
        var a = this["re"];
        var b = this["im"];
        var d = a * a + b * b;
        return new Complex2(a / d, -b / d);
      },
      /**
       * Returns the complex conjugate
       *
       * @returns {Complex}
       */
      "conjugate": function() {
        return new Complex2(this["re"], -this["im"]);
      },
      /**
       * Gets the negated complex number
       *
       * @returns {Complex}
       */
      "neg": function() {
        return new Complex2(-this["re"], -this["im"]);
      },
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      "ceil": function(places) {
        places = Math.pow(10, places || 0);
        return new Complex2(
          Math.ceil(this["re"] * places) / places,
          Math.ceil(this["im"] * places) / places
        );
      },
      /**
       * Floors the actual complex number
       *
       * @returns {Complex}
       */
      "floor": function(places) {
        places = Math.pow(10, places || 0);
        return new Complex2(
          Math.floor(this["re"] * places) / places,
          Math.floor(this["im"] * places) / places
        );
      },
      /**
       * Ceils the actual complex number
       *
       * @returns {Complex}
       */
      "round": function(places) {
        places = Math.pow(10, places || 0);
        return new Complex2(
          Math.round(this["re"] * places) / places,
          Math.round(this["im"] * places) / places
        );
      },
      /**
       * Compares two complex numbers
       *
       * **Note:** new Complex(Infinity).equals(Infinity) === false
       *
       * @returns {boolean}
       */
      "equals": function(a, b) {
        var z = new Complex2(a, b);
        return Math.abs(z["re"] - this["re"]) <= Complex2["EPSILON"] && Math.abs(z["im"] - this["im"]) <= Complex2["EPSILON"];
      },
      /**
       * Clones the actual object
       *
       * @returns {Complex}
       */
      "clone": function() {
        return new Complex2(this["re"], this["im"]);
      },
      /**
       * Gets a string of the actual complex number
       *
       * @returns {string}
       */
      "toString": function() {
        var a = this["re"];
        var b = this["im"];
        var ret = "";
        if (this["isNaN"]()) {
          return "NaN";
        }
        if (this["isInfinite"]()) {
          return "Infinity";
        }
        if (Math.abs(a) < Complex2["EPSILON"]) {
          a = 0;
        }
        if (Math.abs(b) < Complex2["EPSILON"]) {
          b = 0;
        }
        if (b === 0) {
          return ret + a;
        }
        if (a !== 0) {
          ret += a;
          ret += " ";
          if (b < 0) {
            b = -b;
            ret += "-";
          } else {
            ret += "+";
          }
          ret += " ";
        } else if (b < 0) {
          b = -b;
          ret += "-";
        }
        if (1 !== b) {
          ret += b;
        }
        return ret + "i";
      },
      /**
       * Returns the actual number as a vector
       *
       * @returns {Array}
       */
      "toVector": function() {
        return [this["re"], this["im"]];
      },
      /**
       * Returns the actual real value of the current object
       *
       * @returns {number|null}
       */
      "valueOf": function() {
        if (this["im"] === 0) {
          return this["re"];
        }
        return null;
      },
      /**
       * Determines whether a complex number is not on the Riemann sphere.
       *
       * @returns {boolean}
       */
      "isNaN": function() {
        return isNaN(this["re"]) || isNaN(this["im"]);
      },
      /**
       * Determines whether or not a complex number is at the zero pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      "isZero": function() {
        return this["im"] === 0 && this["re"] === 0;
      },
      /**
       * Determines whether a complex number is not at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      "isFinite": function() {
        return isFinite(this["re"]) && isFinite(this["im"]);
      },
      /**
       * Determines whether or not a complex number is at the infinity pole of the
       * Riemann sphere.
       *
       * @returns {boolean}
       */
      "isInfinite": function() {
        return !(this["isNaN"]() || this["isFinite"]());
      }
    };
    Complex2["ZERO"] = new Complex2(0, 0);
    Complex2["ONE"] = new Complex2(1, 0);
    Complex2["I"] = new Complex2(0, 1);
    Complex2["PI"] = new Complex2(Math.PI, 0);
    Complex2["E"] = new Complex2(Math.E, 0);
    Complex2["INFINITY"] = new Complex2(Infinity, Infinity);
    Complex2["NAN"] = new Complex2(NaN, NaN);
    Complex2["EPSILON"] = 1e-15;
    {
      Object.defineProperty(Complex2, "__esModule", { "value": true });
      Complex2["default"] = Complex2;
      Complex2["Complex"] = Complex2;
      module["exports"] = Complex2;
    }
  })();
})(complex$1);
var complexExports = complex$1.exports;
const Complex$1 = /* @__PURE__ */ getDefaultExportFromCjs(complexExports);
var name$4S = "Complex";
var dependencies$4R = [];
var createComplexClass = /* @__PURE__ */ factory(name$4S, dependencies$4R, () => {
  Object.defineProperty(Complex$1, "name", {
    value: "Complex"
  });
  Complex$1.prototype.constructor = Complex$1;
  Complex$1.prototype.type = "Complex";
  Complex$1.prototype.isComplex = true;
  Complex$1.prototype.toJSON = function() {
    return {
      mathjs: "Complex",
      re: this.re,
      im: this.im
    };
  };
  Complex$1.prototype.toPolar = function() {
    return {
      r: this.abs(),
      phi: this.arg()
    };
  };
  Complex$1.prototype.format = function(options) {
    var str = "";
    var im2 = this.im;
    var re2 = this.re;
    var strRe = format$3(this.re, options);
    var strIm = format$3(this.im, options);
    var precision = isNumber(options) ? options : options ? options.precision : null;
    if (precision !== null) {
      var epsilon = Math.pow(10, -precision);
      if (Math.abs(re2 / im2) < epsilon) {
        re2 = 0;
      }
      if (Math.abs(im2 / re2) < epsilon) {
        im2 = 0;
      }
    }
    if (im2 === 0) {
      str = strRe;
    } else if (re2 === 0) {
      if (im2 === 1) {
        str = "i";
      } else if (im2 === -1) {
        str = "-i";
      } else {
        str = strIm + "i";
      }
    } else {
      if (im2 < 0) {
        if (im2 === -1) {
          str = strRe + " - i";
        } else {
          str = strRe + " - " + strIm.substring(1) + "i";
        }
      } else {
        if (im2 === 1) {
          str = strRe + " + i";
        } else {
          str = strRe + " + " + strIm + "i";
        }
      }
    }
    return str;
  };
  Complex$1.fromPolar = function(args) {
    switch (arguments.length) {
      case 1: {
        var arg2 = arguments[0];
        if (typeof arg2 === "object") {
          return Complex$1(arg2);
        } else {
          throw new TypeError("Input has to be an object with r and phi keys.");
        }
      }
      case 2: {
        var r = arguments[0];
        var phi2 = arguments[1];
        if (isNumber(r)) {
          if (isUnit(phi2) && phi2.hasBase("ANGLE")) {
            phi2 = phi2.toNumber("rad");
          }
          if (isNumber(phi2)) {
            return new Complex$1({
              r,
              phi: phi2
            });
          }
          throw new TypeError("Phi is not a number nor an angle unit.");
        } else {
          throw new TypeError("Radius r is not a number.");
        }
      }
      default:
        throw new SyntaxError("Wrong number of arguments in function fromPolar");
    }
  };
  Complex$1.prototype.valueOf = Complex$1.prototype.toString;
  Complex$1.fromJSON = function(json) {
    return new Complex$1(json);
  };
  Complex$1.compare = function(a, b) {
    if (a.re > b.re) {
      return 1;
    }
    if (a.re < b.re) {
      return -1;
    }
    if (a.im > b.im) {
      return 1;
    }
    if (a.im < b.im) {
      return -1;
    }
    return 0;
  };
  return Complex$1;
}, {
  isClass: true
});
var fraction$1 = { exports: {} };
/**
 * @license Fraction.js v4.3.0 20/08/2023
 * https://www.xarg.org/2014/03/rational-numbers-in-javascript/
 *
 * Copyright (c) 2023, Robert Eisele (robert@raw.org)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 **/
(function(module, exports) {
  (function(root) {
    var MAX_CYCLE_LEN = 2e3;
    var P2 = {
      "s": 1,
      "n": 0,
      "d": 1
    };
    function assign2(n, s) {
      if (isNaN(n = parseInt(n, 10))) {
        throw InvalidParameter();
      }
      return n * s;
    }
    function newFraction(n, d) {
      if (d === 0) {
        throw DivisionByZero();
      }
      var f = Object.create(Fraction2.prototype);
      f["s"] = n < 0 ? -1 : 1;
      n = n < 0 ? -n : n;
      var a = gcd2(n, d);
      f["n"] = n / a;
      f["d"] = d / a;
      return f;
    }
    function factorize(num) {
      var factors = {};
      var n = num;
      var i2 = 2;
      var s = 4;
      while (s <= n) {
        while (n % i2 === 0) {
          n /= i2;
          factors[i2] = (factors[i2] || 0) + 1;
        }
        s += 1 + 2 * i2++;
      }
      if (n !== num) {
        if (n > 1)
          factors[n] = (factors[n] || 0) + 1;
      } else {
        factors[num] = (factors[num] || 0) + 1;
      }
      return factors;
    }
    var parse2 = function(p1, p2) {
      var n = 0, d = 1, s = 1;
      var v = 0, w = 0, x = 0, y = 1, z = 1;
      var A = 0, B = 1;
      var C = 1, D = 1;
      var N = 1e7;
      var M;
      if (p1 === void 0 || p1 === null)
        ;
      else if (p2 !== void 0) {
        n = p1;
        d = p2;
        s = n * d;
        if (n % 1 !== 0 || d % 1 !== 0) {
          throw NonIntegerParameter();
        }
      } else
        switch (typeof p1) {
          case "object": {
            if ("d" in p1 && "n" in p1) {
              n = p1["n"];
              d = p1["d"];
              if ("s" in p1)
                n *= p1["s"];
            } else if (0 in p1) {
              n = p1[0];
              if (1 in p1)
                d = p1[1];
            } else {
              throw InvalidParameter();
            }
            s = n * d;
            break;
          }
          case "number": {
            if (p1 < 0) {
              s = p1;
              p1 = -p1;
            }
            if (p1 % 1 === 0) {
              n = p1;
            } else if (p1 > 0) {
              if (p1 >= 1) {
                z = Math.pow(10, Math.floor(1 + Math.log(p1) / Math.LN10));
                p1 /= z;
              }
              while (B <= N && D <= N) {
                M = (A + C) / (B + D);
                if (p1 === M) {
                  if (B + D <= N) {
                    n = A + C;
                    d = B + D;
                  } else if (D > B) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                  break;
                } else {
                  if (p1 > M) {
                    A += C;
                    B += D;
                  } else {
                    C += A;
                    D += B;
                  }
                  if (B > N) {
                    n = C;
                    d = D;
                  } else {
                    n = A;
                    d = B;
                  }
                }
              }
              n *= z;
            } else if (isNaN(p1) || isNaN(p2)) {
              d = n = NaN;
            }
            break;
          }
          case "string": {
            B = p1.match(/\d+|./g);
            if (B === null)
              throw InvalidParameter();
            if (B[A] === "-") {
              s = -1;
              A++;
            } else if (B[A] === "+") {
              A++;
            }
            if (B.length === A + 1) {
              w = assign2(B[A++], s);
            } else if (B[A + 1] === "." || B[A] === ".") {
              if (B[A] !== ".") {
                v = assign2(B[A++], s);
              }
              A++;
              if (A + 1 === B.length || B[A + 1] === "(" && B[A + 3] === ")" || B[A + 1] === "'" && B[A + 3] === "'") {
                w = assign2(B[A], s);
                y = Math.pow(10, B[A].length);
                A++;
              }
              if (B[A] === "(" && B[A + 2] === ")" || B[A] === "'" && B[A + 2] === "'") {
                x = assign2(B[A + 1], s);
                z = Math.pow(10, B[A + 1].length) - 1;
                A += 3;
              }
            } else if (B[A + 1] === "/" || B[A + 1] === ":") {
              w = assign2(B[A], s);
              y = assign2(B[A + 2], 1);
              A += 3;
            } else if (B[A + 3] === "/" && B[A + 1] === " ") {
              v = assign2(B[A], s);
              w = assign2(B[A + 2], s);
              y = assign2(B[A + 4], 1);
              A += 5;
            }
            if (B.length <= A) {
              d = y * z;
              s = /* void */
              n = x + d * v + z * w;
              break;
            }
          }
          default:
            throw InvalidParameter();
        }
      if (d === 0) {
        throw DivisionByZero();
      }
      P2["s"] = s < 0 ? -1 : 1;
      P2["n"] = Math.abs(n);
      P2["d"] = Math.abs(d);
    };
    function modpow(b, e2, m) {
      var r = 1;
      for (; e2 > 0; b = b * b % m, e2 >>= 1) {
        if (e2 & 1) {
          r = r * b % m;
        }
      }
      return r;
    }
    function cycleLen(n, d) {
      for (; d % 2 === 0; d /= 2) {
      }
      for (; d % 5 === 0; d /= 5) {
      }
      if (d === 1)
        return 0;
      var rem = 10 % d;
      var t = 1;
      for (; rem !== 1; t++) {
        rem = rem * 10 % d;
        if (t > MAX_CYCLE_LEN)
          return 0;
      }
      return t;
    }
    function cycleStart(n, d, len) {
      var rem1 = 1;
      var rem2 = modpow(10, len, d);
      for (var t = 0; t < 300; t++) {
        if (rem1 === rem2)
          return t;
        rem1 = rem1 * 10 % d;
        rem2 = rem2 * 10 % d;
      }
      return 0;
    }
    function gcd2(a, b) {
      if (!a)
        return b;
      if (!b)
        return a;
      while (1) {
        a %= b;
        if (!a)
          return b;
        b %= a;
        if (!b)
          return a;
      }
    }
    function Fraction2(a, b) {
      parse2(a, b);
      if (this instanceof Fraction2) {
        a = gcd2(P2["d"], P2["n"]);
        this["s"] = P2["s"];
        this["n"] = P2["n"] / a;
        this["d"] = P2["d"] / a;
      } else {
        return newFraction(P2["s"] * P2["n"], P2["d"]);
      }
    }
    var DivisionByZero = function() {
      return new Error("Division by Zero");
    };
    var InvalidParameter = function() {
      return new Error("Invalid argument");
    };
    var NonIntegerParameter = function() {
      return new Error("Parameters must be integer");
    };
    Fraction2.prototype = {
      "s": 1,
      "n": 0,
      "d": 1,
      /**
       * Calculates the absolute value
       *
       * Ex: new Fraction(-4).abs() => 4
       **/
      "abs": function() {
        return newFraction(this["n"], this["d"]);
      },
      /**
       * Inverts the sign of the current fraction
       *
       * Ex: new Fraction(-4).neg() => 4
       **/
      "neg": function() {
        return newFraction(-this["s"] * this["n"], this["d"]);
      },
      /**
       * Adds two rational numbers
       *
       * Ex: new Fraction({n: 2, d: 3}).add("14.9") => 467 / 30
       **/
      "add": function(a, b) {
        parse2(a, b);
        return newFraction(
          this["s"] * this["n"] * P2["d"] + P2["s"] * this["d"] * P2["n"],
          this["d"] * P2["d"]
        );
      },
      /**
       * Subtracts two rational numbers
       *
       * Ex: new Fraction({n: 2, d: 3}).add("14.9") => -427 / 30
       **/
      "sub": function(a, b) {
        parse2(a, b);
        return newFraction(
          this["s"] * this["n"] * P2["d"] - P2["s"] * this["d"] * P2["n"],
          this["d"] * P2["d"]
        );
      },
      /**
       * Multiplies two rational numbers
       *
       * Ex: new Fraction("-17.(345)").mul(3) => 5776 / 111
       **/
      "mul": function(a, b) {
        parse2(a, b);
        return newFraction(
          this["s"] * P2["s"] * this["n"] * P2["n"],
          this["d"] * P2["d"]
        );
      },
      /**
       * Divides two rational numbers
       *
       * Ex: new Fraction("-17.(345)").inverse().div(3)
       **/
      "div": function(a, b) {
        parse2(a, b);
        return newFraction(
          this["s"] * P2["s"] * this["n"] * P2["d"],
          this["d"] * P2["n"]
        );
      },
      /**
       * Clones the actual object
       *
       * Ex: new Fraction("-17.(345)").clone()
       **/
      "clone": function() {
        return newFraction(this["s"] * this["n"], this["d"]);
      },
      /**
       * Calculates the modulo of two rational numbers - a more precise fmod
       *
       * Ex: new Fraction('4.(3)').mod([7, 8]) => (13/3) % (7/8) = (5/6)
       **/
      "mod": function(a, b) {
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction2(NaN);
        }
        if (a === void 0) {
          return newFraction(this["s"] * this["n"] % this["d"], 1);
        }
        parse2(a, b);
        if (0 === P2["n"] && 0 === this["d"]) {
          throw DivisionByZero();
        }
        return newFraction(
          this["s"] * (P2["d"] * this["n"]) % (P2["n"] * this["d"]),
          P2["d"] * this["d"]
        );
      },
      /**
       * Calculates the fractional gcd of two rational numbers
       *
       * Ex: new Fraction(5,8).gcd(3,7) => 1/56
       */
      "gcd": function(a, b) {
        parse2(a, b);
        return newFraction(gcd2(P2["n"], this["n"]) * gcd2(P2["d"], this["d"]), P2["d"] * this["d"]);
      },
      /**
       * Calculates the fractional lcm of two rational numbers
       *
       * Ex: new Fraction(5,8).lcm(3,7) => 15
       */
      "lcm": function(a, b) {
        parse2(a, b);
        if (P2["n"] === 0 && this["n"] === 0) {
          return newFraction(0, 1);
        }
        return newFraction(P2["n"] * this["n"], gcd2(P2["n"], this["n"]) * gcd2(P2["d"], this["d"]));
      },
      /**
       * Calculates the ceil of a rational number
       *
       * Ex: new Fraction('4.(3)').ceil() => (5 / 1)
       **/
      "ceil": function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction2(NaN);
        }
        return newFraction(Math.ceil(places * this["s"] * this["n"] / this["d"]), places);
      },
      /**
       * Calculates the floor of a rational number
       *
       * Ex: new Fraction('4.(3)').floor() => (4 / 1)
       **/
      "floor": function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction2(NaN);
        }
        return newFraction(Math.floor(places * this["s"] * this["n"] / this["d"]), places);
      },
      /**
       * Rounds a rational numbers
       *
       * Ex: new Fraction('4.(3)').round() => (4 / 1)
       **/
      "round": function(places) {
        places = Math.pow(10, places || 0);
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return new Fraction2(NaN);
        }
        return newFraction(Math.round(places * this["s"] * this["n"] / this["d"]), places);
      },
      /**
       * Gets the inverse of the fraction, means numerator and denominator are exchanged
       *
       * Ex: new Fraction([-3, 4]).inverse() => -4 / 3
       **/
      "inverse": function() {
        return newFraction(this["s"] * this["d"], this["n"]);
      },
      /**
       * Calculates the fraction to some rational exponent, if possible
       *
       * Ex: new Fraction(-1,2).pow(-3) => -8
       */
      "pow": function(a, b) {
        parse2(a, b);
        if (P2["d"] === 1) {
          if (P2["s"] < 0) {
            return newFraction(Math.pow(this["s"] * this["d"], P2["n"]), Math.pow(this["n"], P2["n"]));
          } else {
            return newFraction(Math.pow(this["s"] * this["n"], P2["n"]), Math.pow(this["d"], P2["n"]));
          }
        }
        if (this["s"] < 0)
          return null;
        var N = factorize(this["n"]);
        var D = factorize(this["d"]);
        var n = 1;
        var d = 1;
        for (var k in N) {
          if (k === "1")
            continue;
          if (k === "0") {
            n = 0;
            break;
          }
          N[k] *= P2["n"];
          if (N[k] % P2["d"] === 0) {
            N[k] /= P2["d"];
          } else
            return null;
          n *= Math.pow(k, N[k]);
        }
        for (var k in D) {
          if (k === "1")
            continue;
          D[k] *= P2["n"];
          if (D[k] % P2["d"] === 0) {
            D[k] /= P2["d"];
          } else
            return null;
          d *= Math.pow(k, D[k]);
        }
        if (P2["s"] < 0) {
          return newFraction(d, n);
        }
        return newFraction(n, d);
      },
      /**
       * Check if two rational numbers are the same
       *
       * Ex: new Fraction(19.6).equals([98, 5]);
       **/
      "equals": function(a, b) {
        parse2(a, b);
        return this["s"] * this["n"] * P2["d"] === P2["s"] * P2["n"] * this["d"];
      },
      /**
       * Check if two rational numbers are the same
       *
       * Ex: new Fraction(19.6).equals([98, 5]);
       **/
      "compare": function(a, b) {
        parse2(a, b);
        var t = this["s"] * this["n"] * P2["d"] - P2["s"] * P2["n"] * this["d"];
        return (0 < t) - (t < 0);
      },
      "simplify": function(eps) {
        if (isNaN(this["n"]) || isNaN(this["d"])) {
          return this;
        }
        eps = eps || 1e-3;
        var thisABS = this["abs"]();
        var cont = thisABS["toContinued"]();
        for (var i2 = 1; i2 < cont.length; i2++) {
          var s = newFraction(cont[i2 - 1], 1);
          for (var k = i2 - 2; k >= 0; k--) {
            s = s["inverse"]()["add"](cont[k]);
          }
          if (Math.abs(s["sub"](thisABS).valueOf()) < eps) {
            return s["mul"](this["s"]);
          }
        }
        return this;
      },
      /**
       * Check if two rational numbers are divisible
       *
       * Ex: new Fraction(19.6).divisible(1.5);
       */
      "divisible": function(a, b) {
        parse2(a, b);
        return !(!(P2["n"] * this["d"]) || this["n"] * P2["d"] % (P2["n"] * this["d"]));
      },
      /**
       * Returns a decimal representation of the fraction
       *
       * Ex: new Fraction("100.'91823'").valueOf() => 100.91823918239183
       **/
      "valueOf": function() {
        return this["s"] * this["n"] / this["d"];
      },
      /**
       * Returns a string-fraction representation of a Fraction object
       *
       * Ex: new Fraction("1.'3'").toFraction(true) => "4 1/3"
       **/
      "toFraction": function(excludeWhole) {
        var whole, str = "";
        var n = this["n"];
        var d = this["d"];
        if (this["s"] < 0) {
          str += "-";
        }
        if (d === 1) {
          str += n;
        } else {
          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
            str += whole;
            str += " ";
            n %= d;
          }
          str += n;
          str += "/";
          str += d;
        }
        return str;
      },
      /**
       * Returns a latex representation of a Fraction object
       *
       * Ex: new Fraction("1.'3'").toLatex() => "\frac{4}{3}"
       **/
      "toLatex": function(excludeWhole) {
        var whole, str = "";
        var n = this["n"];
        var d = this["d"];
        if (this["s"] < 0) {
          str += "-";
        }
        if (d === 1) {
          str += n;
        } else {
          if (excludeWhole && (whole = Math.floor(n / d)) > 0) {
            str += whole;
            n %= d;
          }
          str += "\\frac{";
          str += n;
          str += "}{";
          str += d;
          str += "}";
        }
        return str;
      },
      /**
       * Returns an array of continued fraction elements
       *
       * Ex: new Fraction("7/8").toContinued() => [0,1,7]
       */
      "toContinued": function() {
        var t;
        var a = this["n"];
        var b = this["d"];
        var res = [];
        if (isNaN(a) || isNaN(b)) {
          return res;
        }
        do {
          res.push(Math.floor(a / b));
          t = a % b;
          a = b;
          b = t;
        } while (a !== 1);
        return res;
      },
      /**
       * Creates a string representation of a fraction with all digits
       *
       * Ex: new Fraction("100.'91823'").toString() => "100.(91823)"
       **/
      "toString": function(dec) {
        var N = this["n"];
        var D = this["d"];
        if (isNaN(N) || isNaN(D)) {
          return "NaN";
        }
        dec = dec || 15;
        var cycLen = cycleLen(N, D);
        var cycOff = cycleStart(N, D, cycLen);
        var str = this["s"] < 0 ? "-" : "";
        str += N / D | 0;
        N %= D;
        N *= 10;
        if (N)
          str += ".";
        if (cycLen) {
          for (var i2 = cycOff; i2--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
          str += "(";
          for (var i2 = cycLen; i2--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
          str += ")";
        } else {
          for (var i2 = dec; N && i2--; ) {
            str += N / D | 0;
            N %= D;
            N *= 10;
          }
        }
        return str;
      }
    };
    {
      Object.defineProperty(Fraction2, "__esModule", { "value": true });
      Fraction2["default"] = Fraction2;
      Fraction2["Fraction"] = Fraction2;
      module["exports"] = Fraction2;
    }
  })();
})(fraction$1);
var fractionExports = fraction$1.exports;
const Fraction$1 = /* @__PURE__ */ getDefaultExportFromCjs(fractionExports);
var name$4R = "Fraction";
var dependencies$4Q = [];
var createFractionClass = /* @__PURE__ */ factory(name$4R, dependencies$4Q, () => {
  Object.defineProperty(Fraction$1, "name", {
    value: "Fraction"
  });
  Fraction$1.prototype.constructor = Fraction$1;
  Fraction$1.prototype.type = "Fraction";
  Fraction$1.prototype.isFraction = true;
  Fraction$1.prototype.toJSON = function() {
    return {
      mathjs: "Fraction",
      n: this.s * this.n,
      d: this.d
    };
  };
  Fraction$1.fromJSON = function(json) {
    return new Fraction$1(json);
  };
  return Fraction$1;
}, {
  isClass: true
});
var name$4Q = "Range";
var dependencies$4P = [];
var createRangeClass = /* @__PURE__ */ factory(name$4Q, dependencies$4P, () => {
  function Range2(start, end, step) {
    if (!(this instanceof Range2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    var hasStart = start !== null && start !== void 0;
    var hasEnd = end !== null && end !== void 0;
    var hasStep = step !== null && step !== void 0;
    if (hasStart) {
      if (isBigNumber(start)) {
        start = start.toNumber();
      } else if (typeof start !== "number") {
        throw new TypeError("Parameter start must be a number");
      }
    }
    if (hasEnd) {
      if (isBigNumber(end)) {
        end = end.toNumber();
      } else if (typeof end !== "number") {
        throw new TypeError("Parameter end must be a number");
      }
    }
    if (hasStep) {
      if (isBigNumber(step)) {
        step = step.toNumber();
      } else if (typeof step !== "number") {
        throw new TypeError("Parameter step must be a number");
      }
    }
    this.start = hasStart ? parseFloat(start) : 0;
    this.end = hasEnd ? parseFloat(end) : 0;
    this.step = hasStep ? parseFloat(step) : 1;
  }
  Range2.prototype.type = "Range";
  Range2.prototype.isRange = true;
  Range2.parse = function(str) {
    if (typeof str !== "string") {
      return null;
    }
    var args = str.split(":");
    var nums = args.map(function(arg2) {
      return parseFloat(arg2);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return new Range2(nums[0], nums[1]);
      case 3:
        return new Range2(nums[0], nums[2], nums[1]);
      default:
        return null;
    }
  };
  Range2.prototype.clone = function() {
    return new Range2(this.start, this.end, this.step);
  };
  Range2.prototype.size = function() {
    var len = 0;
    var start = this.start;
    var step = this.step;
    var end = this.end;
    var diff2 = end - start;
    if (sign$2(step) === sign$2(diff2)) {
      len = Math.ceil(diff2 / step);
    } else if (diff2 === 0) {
      len = 0;
    }
    if (isNaN(len)) {
      len = 0;
    }
    return [len];
  };
  Range2.prototype.min = function() {
    var size2 = this.size()[0];
    if (size2 > 0) {
      if (this.step > 0) {
        return this.start;
      } else {
        return this.start + (size2 - 1) * this.step;
      }
    } else {
      return void 0;
    }
  };
  Range2.prototype.max = function() {
    var size2 = this.size()[0];
    if (size2 > 0) {
      if (this.step > 0) {
        return this.start + (size2 - 1) * this.step;
      } else {
        return this.start;
      }
    } else {
      return void 0;
    }
  };
  Range2.prototype.forEach = function(callback) {
    var x = this.start;
    var step = this.step;
    var end = this.end;
    var i2 = 0;
    if (step > 0) {
      while (x < end) {
        callback(x, [i2], this);
        x += step;
        i2++;
      }
    } else if (step < 0) {
      while (x > end) {
        callback(x, [i2], this);
        x += step;
        i2++;
      }
    }
  };
  Range2.prototype.map = function(callback) {
    var array = [];
    this.forEach(function(value, index2, obj) {
      array[index2[0]] = callback(value, index2, obj);
    });
    return array;
  };
  Range2.prototype.toArray = function() {
    var array = [];
    this.forEach(function(value, index2) {
      array[index2[0]] = value;
    });
    return array;
  };
  Range2.prototype.valueOf = function() {
    return this.toArray();
  };
  Range2.prototype.format = function(options) {
    var str = format$3(this.start, options);
    if (this.step !== 1) {
      str += ":" + format$3(this.step, options);
    }
    str += ":" + format$3(this.end, options);
    return str;
  };
  Range2.prototype.toString = function() {
    return this.format();
  };
  Range2.prototype.toJSON = function() {
    return {
      mathjs: "Range",
      start: this.start,
      end: this.end,
      step: this.step
    };
  };
  Range2.fromJSON = function(json) {
    return new Range2(json.start, json.end, json.step);
  };
  return Range2;
}, {
  isClass: true
});
var name$4P = "Matrix";
var dependencies$4O = [];
var createMatrixClass = /* @__PURE__ */ factory(name$4P, dependencies$4O, () => {
  function Matrix2() {
    if (!(this instanceof Matrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
  }
  Matrix2.prototype.type = "Matrix";
  Matrix2.prototype.isMatrix = true;
  Matrix2.prototype.storage = function() {
    throw new Error("Cannot invoke storage on a Matrix interface");
  };
  Matrix2.prototype.datatype = function() {
    throw new Error("Cannot invoke datatype on a Matrix interface");
  };
  Matrix2.prototype.create = function(data, datatype) {
    throw new Error("Cannot invoke create on a Matrix interface");
  };
  Matrix2.prototype.subset = function(index2, replacement, defaultValue) {
    throw new Error("Cannot invoke subset on a Matrix interface");
  };
  Matrix2.prototype.get = function(index2) {
    throw new Error("Cannot invoke get on a Matrix interface");
  };
  Matrix2.prototype.set = function(index2, value, defaultValue) {
    throw new Error("Cannot invoke set on a Matrix interface");
  };
  Matrix2.prototype.resize = function(size2, defaultValue) {
    throw new Error("Cannot invoke resize on a Matrix interface");
  };
  Matrix2.prototype.reshape = function(size2, defaultValue) {
    throw new Error("Cannot invoke reshape on a Matrix interface");
  };
  Matrix2.prototype.clone = function() {
    throw new Error("Cannot invoke clone on a Matrix interface");
  };
  Matrix2.prototype.size = function() {
    throw new Error("Cannot invoke size on a Matrix interface");
  };
  Matrix2.prototype.map = function(callback, skipZeros) {
    throw new Error("Cannot invoke map on a Matrix interface");
  };
  Matrix2.prototype.forEach = function(callback) {
    throw new Error("Cannot invoke forEach on a Matrix interface");
  };
  Matrix2.prototype[Symbol.iterator] = function() {
    throw new Error("Cannot iterate a Matrix interface");
  };
  Matrix2.prototype.toArray = function() {
    throw new Error("Cannot invoke toArray on a Matrix interface");
  };
  Matrix2.prototype.valueOf = function() {
    throw new Error("Cannot invoke valueOf on a Matrix interface");
  };
  Matrix2.prototype.format = function(options) {
    throw new Error("Cannot invoke format on a Matrix interface");
  };
  Matrix2.prototype.toString = function() {
    throw new Error("Cannot invoke toString on a Matrix interface");
  };
  return Matrix2;
}, {
  isClass: true
});
function lruQueue(limit) {
  var size2 = 0;
  var base = 1;
  var queue = /* @__PURE__ */ Object.create(null);
  var map2 = /* @__PURE__ */ Object.create(null);
  var index2 = 0;
  var del = function del2(id) {
    var oldIndex = map2[id];
    if (!oldIndex)
      return;
    delete queue[oldIndex];
    delete map2[id];
    --size2;
    if (base !== oldIndex)
      return;
    if (!size2) {
      index2 = 0;
      base = 1;
      return;
    }
    while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
    }
  };
  limit = Math.abs(limit);
  return {
    hit: function hit(id) {
      var oldIndex = map2[id];
      var nuIndex = ++index2;
      queue[nuIndex] = id;
      map2[id] = nuIndex;
      if (!oldIndex) {
        ++size2;
        if (size2 <= limit)
          return void 0;
        id = queue[base];
        del(id);
        return id;
      }
      delete queue[oldIndex];
      if (base !== oldIndex)
        return void 0;
      while (!Object.prototype.hasOwnProperty.call(queue, ++base)) {
      }
      return void 0;
    },
    delete: del,
    clear: function clear() {
      size2 = index2 = 0;
      base = 1;
      queue = /* @__PURE__ */ Object.create(null);
      map2 = /* @__PURE__ */ Object.create(null);
    }
  };
}
function memoize(fn) {
  var {
    hasher: hasher2,
    limit
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  limit = limit == null ? Number.POSITIVE_INFINITY : limit;
  hasher2 = hasher2 == null ? JSON.stringify : hasher2;
  return function memoize2() {
    if (typeof memoize2.cache !== "object") {
      memoize2.cache = {
        values: /* @__PURE__ */ new Map(),
        lru: lruQueue(limit || Number.POSITIVE_INFINITY)
      };
    }
    var args = [];
    for (var i2 = 0; i2 < arguments.length; i2++) {
      args[i2] = arguments[i2];
    }
    var hash2 = hasher2(args);
    if (memoize2.cache.values.has(hash2)) {
      memoize2.cache.lru.hit(hash2);
      return memoize2.cache.values.get(hash2);
    }
    var newVal = fn.apply(fn, args);
    memoize2.cache.values.set(hash2, newVal);
    memoize2.cache.values.delete(memoize2.cache.lru.hit(hash2));
    return newVal;
  };
}
function maxArgumentCount(fn) {
  return Object.keys(fn.signatures || {}).reduce(function(args, signature) {
    var count2 = (signature.match(/,/g) || []).length + 1;
    return Math.max(args, count2);
  }, -1);
}
var name$4O = "DenseMatrix";
var dependencies$4N = ["Matrix"];
var createDenseMatrixClass = /* @__PURE__ */ factory(name$4O, dependencies$4N, (_ref) => {
  var {
    Matrix: Matrix2
  } = _ref;
  function DenseMatrix2(data, datatype) {
    if (!(this instanceof DenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      if (data.type === "DenseMatrix") {
        this._data = clone$3(data._data);
        this._size = clone$3(data._size);
        this._datatype = datatype || data._datatype;
      } else {
        this._data = data.toArray();
        this._size = data.size();
        this._datatype = datatype || data._datatype;
      }
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      validate(this._data, this._size);
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      this._data = preprocess(data);
      this._size = arraySize(this._data);
      validate(this._data, this._size);
      this._datatype = datatype;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf$1(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
    }
  }
  DenseMatrix2.prototype = new Matrix2();
  DenseMatrix2.prototype.createDenseMatrix = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  Object.defineProperty(DenseMatrix2, "name", {
    value: "DenseMatrix"
  });
  DenseMatrix2.prototype.constructor = DenseMatrix2;
  DenseMatrix2.prototype.type = "DenseMatrix";
  DenseMatrix2.prototype.isDenseMatrix = true;
  DenseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._data, typeOf$1);
  };
  DenseMatrix2.prototype.storage = function() {
    return "dense";
  };
  DenseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  DenseMatrix2.prototype.create = function(data, datatype) {
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    switch (arguments.length) {
      case 1:
        return _get(this, index2);
      case 2:
      case 3:
        return _set(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  DenseMatrix2.prototype.get = function(index2) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    for (var x = 0; x < index2.length; x++) {
      validateIndex(index2[x], this._size[x]);
    }
    var data = this._data;
    for (var i2 = 0, ii = index2.length; i2 < ii; i2++) {
      var indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    return data;
  };
  DenseMatrix2.prototype.set = function(index2, value, defaultValue) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length < this._size.length) {
      throw new DimensionError(index2.length, this._size.length, "<");
    }
    var i2, ii, indexI;
    var size2 = index2.map(function(i3) {
      return i3 + 1;
    });
    _fit(this, size2, defaultValue);
    var data = this._data;
    for (i2 = 0, ii = index2.length - 1; i2 < ii; i2++) {
      indexI = index2[i2];
      validateIndex(indexI, data.length);
      data = data[indexI];
    }
    indexI = index2[index2.length - 1];
    validateIndex(indexI, data.length);
    data[indexI] = value;
    return this;
  };
  function _get(matrix2, index2) {
    if (!isIndex(index2)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = index2.isScalar();
    if (isScalar) {
      return matrix2.get(index2.min());
    } else {
      var size2 = index2.size();
      if (size2.length !== matrix2._size.length) {
        throw new DimensionError(size2.length, matrix2._size.length);
      }
      var min2 = index2.min();
      var max2 = index2.max();
      for (var i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
        validateIndex(min2[i2], matrix2._size[i2]);
        validateIndex(max2[i2], matrix2._size[i2]);
      }
      return new DenseMatrix2(_getSubmatrix(matrix2._data, index2, size2.length, 0), matrix2._datatype);
    }
  }
  function _getSubmatrix(data, index2, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last) {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        return data[i2];
      }).valueOf();
    } else {
      return range2.map(function(i2) {
        validateIndex(i2, data.length);
        var child = data[i2];
        return _getSubmatrix(child, index2, dims, dim + 1);
      }).valueOf();
    }
  }
  function _set(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.valueOf();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (!deepStrictEqual(sSize, iSize)) {
        try {
          if (sSize.length === 0) {
            submatrix = broadcastTo([submatrix], iSize);
          } else {
            submatrix = broadcastTo(submatrix, iSize);
          }
          sSize = arraySize(submatrix);
        } catch (_unused) {
        }
      }
      if (iSize.length < matrix2._size.length) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      var size2 = index2.max().map(function(i3) {
        return i3 + 1;
      });
      _fit(matrix2, size2, defaultValue);
      var dims = iSize.length;
      var dim = 0;
      _setSubmatrix(matrix2._data, index2, submatrix, dims, dim);
    }
    return matrix2;
  }
  function _setSubmatrix(data, index2, submatrix, dims, dim) {
    var last = dim === dims - 1;
    var range2 = index2.dimension(dim);
    if (last) {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        data[dataIndex] = submatrix[subIndex[0]];
      });
    } else {
      range2.forEach(function(dataIndex, subIndex) {
        validateIndex(dataIndex);
        _setSubmatrix(data[dataIndex], index2, submatrix[subIndex[0]], dims, dim + 1);
      });
    }
  }
  DenseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    var m = copy ? this.clone() : this;
    return _resize2(m, sizeArray, defaultValue);
  };
  function _resize2(matrix2, size2, defaultValue) {
    if (size2.length === 0) {
      var v = matrix2._data;
      while (isArray(v)) {
        v = v[0];
      }
      return v;
    }
    matrix2._size = size2.slice(0);
    matrix2._data = resize$1(matrix2._data, matrix2._size, defaultValue);
    return matrix2;
  }
  DenseMatrix2.prototype.reshape = function(size2, copy) {
    var m = copy ? this.clone() : this;
    m._data = reshape$1(m._data, size2);
    var currentLength = m._size.reduce((length, size3) => length * size3);
    m._size = processSizesWildcard(size2, currentLength);
    return m;
  };
  function _fit(matrix2, size2, defaultValue) {
    var newSize = matrix2._size.slice(0);
    var changed = false;
    while (newSize.length < size2.length) {
      newSize.push(0);
      changed = true;
    }
    for (var i2 = 0, ii = size2.length; i2 < ii; i2++) {
      if (size2[i2] > newSize[i2]) {
        newSize[i2] = size2[i2];
        changed = true;
      }
    }
    if (changed) {
      _resize2(matrix2, newSize, defaultValue);
    }
  }
  DenseMatrix2.prototype.clone = function() {
    var m = new DenseMatrix2({
      data: clone$3(this._data),
      size: clone$3(this._size),
      datatype: this._datatype
    });
    return m;
  };
  DenseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  DenseMatrix2.prototype.map = function(callback) {
    var me = this;
    var args = maxArgumentCount(callback);
    var recurse = function recurse2(value, index2) {
      if (isArray(value)) {
        return value.map(function(child, i2) {
          return recurse2(child, index2.concat(i2));
        });
      } else {
        if (args === 1) {
          return callback(value);
        } else if (args === 2) {
          return callback(value, index2);
        } else {
          return callback(value, index2, me);
        }
      }
    };
    var data = recurse(this._data, []);
    var datatype = this._datatype !== void 0 ? getArrayDataType(data, typeOf$1) : void 0;
    return new DenseMatrix2(data, datatype);
  };
  DenseMatrix2.prototype.forEach = function(callback) {
    var me = this;
    var recurse = function recurse2(value, index2) {
      if (isArray(value)) {
        value.forEach(function(child, i2) {
          recurse2(child, index2.concat(i2));
        });
      } else {
        callback(value, index2, me);
      }
    };
    recurse(this._data, []);
  };
  DenseMatrix2.prototype[Symbol.iterator] = function* () {
    var recurse = function* recurse2(value, index2) {
      if (isArray(value)) {
        for (var i2 = 0; i2 < value.length; i2++) {
          yield* recurse2(value[i2], index2.concat(i2));
        }
      } else {
        yield {
          value,
          index: index2
        };
      }
    };
    yield* recurse(this._data, []);
  };
  DenseMatrix2.prototype.rows = function() {
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    for (var row2 of data) {
      result.push(new DenseMatrix2([row2], this._datatype));
    }
    return result;
  };
  DenseMatrix2.prototype.columns = function() {
    var _this = this;
    var result = [];
    var s = this.size();
    if (s.length !== 2) {
      throw new TypeError("Rows can only be returned for a 2D matrix.");
    }
    var data = this._data;
    var _loop = function _loop2(i3) {
      var col = data.map((row2) => [row2[i3]]);
      result.push(new DenseMatrix2(col, _this._datatype));
    };
    for (var i2 = 0; i2 < s[1]; i2++) {
      _loop(i2);
    }
    return result;
  };
  DenseMatrix2.prototype.toArray = function() {
    return clone$3(this._data);
  };
  DenseMatrix2.prototype.valueOf = function() {
    return this._data;
  };
  DenseMatrix2.prototype.format = function(options) {
    return format$1(this._data, options);
  };
  DenseMatrix2.prototype.toString = function() {
    return format$1(this._data);
  };
  DenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "DenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  DenseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger$1(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var data = [];
    for (var i2 = 0; i2 < n; i2++) {
      data[i2] = this._data[i2 + kSub][i2 + kSuper];
    }
    return new DenseMatrix2({
      data,
      size: [n],
      datatype: this._datatype
    });
  };
  DenseMatrix2.diagonal = function(size2, value, k, defaultValue) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger$1(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger$1(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i2) {
        return value[i2];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i2) {
        return value.get([i2]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    if (!defaultValue) {
      defaultValue = isBigNumber(_value(0)) ? _value(0).mul(0) : 0;
    }
    var data = [];
    if (size2.length > 0) {
      data = resize$1(data, size2, defaultValue);
      for (var d = 0; d < n; d++) {
        data[d + kSub][d + kSuper] = _value(d);
      }
    }
    return new DenseMatrix2({
      data,
      size: [rows, columns]
    });
  };
  DenseMatrix2.fromJSON = function(json) {
    return new DenseMatrix2(json);
  };
  DenseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger$1(i2) || !isNumber(j) || !isInteger$1(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    DenseMatrix2._swapRows(i2, j, this._data);
    return this;
  };
  DenseMatrix2._swapRows = function(i2, j, data) {
    var vi = data[i2];
    data[i2] = data[j];
    data[j] = vi;
  };
  function preprocess(data) {
    if (isMatrix(data)) {
      return preprocess(data.valueOf());
    }
    if (isArray(data)) {
      return data.map(preprocess);
    }
    return data;
  }
  return DenseMatrix2;
}, {
  isClass: true
});
var name$4N = "clone";
var dependencies$4M = ["typed"];
var createClone = /* @__PURE__ */ factory(name$4N, dependencies$4M, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4N, {
    any: clone$3
  });
});
function _switch$1(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i2, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i2 = 0; i2 < I; i2++) {
      tmp.push(mat[i2][j]);
    }
    ret.push(tmp);
  }
  return ret;
}
function containsCollections(array) {
  for (var i2 = 0; i2 < array.length; i2++) {
    if (isCollection(array[i2])) {
      return true;
    }
  }
  return false;
}
function deepForEach(array, callback) {
  if (isMatrix(array)) {
    array = array.valueOf();
  }
  for (var i2 = 0, ii = array.length; i2 < ii; i2++) {
    var value = array[i2];
    if (Array.isArray(value)) {
      deepForEach(value, callback);
    } else {
      callback(value);
    }
  }
}
function deepMap(array, callback, skipZeros) {
  if (array && typeof array.map === "function") {
    return array.map(function(x) {
      return deepMap(x, callback);
    });
  } else {
    return callback(array);
  }
}
function reduce(mat, dim, callback) {
  var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
  if (dim < 0 || dim >= size2.length) {
    throw new IndexError(dim, size2.length);
  }
  if (isMatrix(mat)) {
    return mat.create(_reduce(mat.valueOf(), dim, callback));
  } else {
    return _reduce(mat, dim, callback);
  }
}
function _reduce(mat, dim, callback) {
  var i2, ret, val, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      val = mat[0];
      for (i2 = 1; i2 < mat.length; i2++) {
        val = callback(val, mat[i2]);
      }
      return val;
    } else {
      tran = _switch$1(mat);
      ret = [];
      for (i2 = 0; i2 < tran.length; i2++) {
        ret[i2] = _reduce(tran[i2], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i2 = 0; i2 < mat.length; i2++) {
      ret[i2] = _reduce(mat[i2], dim - 1, callback);
    }
    return ret;
  }
}
function scatter(a, j, w, x, u, mark, cindex, f, inverse, update2, value) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var k, k0, k1, i2;
  if (x) {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i2 = aindex[k];
      if (w[i2] !== mark) {
        w[i2] = mark;
        cindex.push(i2);
        if (update2) {
          x[i2] = inverse ? f(avalues[k], value) : f(value, avalues[k]);
          u[i2] = mark;
        } else {
          x[i2] = avalues[k];
        }
      } else {
        x[i2] = inverse ? f(avalues[k], x[i2]) : f(x[i2], avalues[k]);
        u[i2] = mark;
      }
    }
  } else {
    for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
      i2 = aindex[k];
      if (w[i2] !== mark) {
        w[i2] = mark;
        cindex.push(i2);
      } else {
        u[i2] = mark;
      }
    }
  }
}
var name$4M = "isInteger";
var dependencies$4L = ["typed"];
var createIsInteger = /* @__PURE__ */ factory(name$4M, dependencies$4L, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4M, {
    number: isInteger$1,
    // TODO: what to do with isInteger(add(0.1, 0.2))  ?
    BigNumber: function BigNumber2(x) {
      return x.isInt();
    },
    Fraction: function Fraction2(x) {
      return x.d === 1 && isFinite(x.n);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var n1$4 = "number";
var n2$2 = "number, number";
function absNumber(a) {
  return Math.abs(a);
}
absNumber.signature = n1$4;
function addNumber(a, b) {
  return a + b;
}
addNumber.signature = n2$2;
function subtractNumber(a, b) {
  return a - b;
}
subtractNumber.signature = n2$2;
function multiplyNumber(a, b) {
  return a * b;
}
multiplyNumber.signature = n2$2;
function unaryMinusNumber(x) {
  return -x;
}
unaryMinusNumber.signature = n1$4;
function unaryPlusNumber(x) {
  return x;
}
unaryPlusNumber.signature = n1$4;
function cbrtNumber(x) {
  return cbrt$2(x);
}
cbrtNumber.signature = n1$4;
function cubeNumber(x) {
  return x * x * x;
}
cubeNumber.signature = n1$4;
function expNumber(x) {
  return Math.exp(x);
}
expNumber.signature = n1$4;
function expm1Number(x) {
  return expm1$1(x);
}
expm1Number.signature = n1$4;
function lcmNumber(a, b) {
  if (!isInteger$1(a) || !isInteger$1(b)) {
    throw new Error("Parameters in function lcm must be integer numbers");
  }
  if (a === 0 || b === 0) {
    return 0;
  }
  var t;
  var prod2 = a * b;
  while (b !== 0) {
    t = b;
    b = a % t;
    a = t;
  }
  return Math.abs(prod2 / a);
}
lcmNumber.signature = n2$2;
function logNumber(x, y) {
  if (y) {
    return Math.log(x) / Math.log(y);
  }
  return Math.log(x);
}
function log10Number(x) {
  return log10$2(x);
}
log10Number.signature = n1$4;
function log2Number(x) {
  return log2$2(x);
}
log2Number.signature = n1$4;
function nthRootNumber(a) {
  var root = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 2;
  var inv2 = root < 0;
  if (inv2) {
    root = -root;
  }
  if (root === 0) {
    throw new Error("Root must be non-zero");
  }
  if (a < 0 && Math.abs(root) % 2 !== 1) {
    throw new Error("Root must be odd when a is negative.");
  }
  if (a === 0) {
    return inv2 ? Infinity : 0;
  }
  if (!isFinite(a)) {
    return inv2 ? 0 : a;
  }
  var x = Math.pow(Math.abs(a), 1 / root);
  x = a < 0 ? -x : x;
  return inv2 ? 1 / x : x;
}
function signNumber(x) {
  return sign$2(x);
}
signNumber.signature = n1$4;
function squareNumber(x) {
  return x * x;
}
squareNumber.signature = n1$4;
function xgcdNumber(a, b) {
  var t;
  var q;
  var r;
  var x = 0;
  var lastx = 1;
  var y = 1;
  var lasty = 0;
  if (!isInteger$1(a) || !isInteger$1(b)) {
    throw new Error("Parameters in function xgcd must be integer numbers");
  }
  while (b) {
    q = Math.floor(a / b);
    r = a - q * b;
    t = x;
    x = lastx - q * x;
    lastx = t;
    t = y;
    y = lasty - q * y;
    lasty = t;
    a = b;
    b = r;
  }
  var res;
  if (a < 0) {
    res = [-a, -lastx, -lasty];
  } else {
    res = [a, a ? lastx : 0, lasty];
  }
  return res;
}
xgcdNumber.signature = n2$2;
function powNumber(x, y) {
  if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
    return 0;
  }
  return Math.pow(x, y);
}
powNumber.signature = n2$2;
function roundNumber(value) {
  var decimals = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;
  if (!isInteger$1(decimals) || decimals < 0 || decimals > 15) {
    throw new Error("Number of decimals in function round must be an integer from 0 to 15 inclusive");
  }
  return parseFloat(toFixed$1(value, decimals));
}
var n1$3 = "number";
var n2$1 = "number, number";
function bitAndNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function bitAnd");
  }
  return x & y;
}
bitAndNumber.signature = n2$1;
function bitNotNumber(x) {
  if (!isInteger$1(x)) {
    throw new Error("Integer expected in function bitNot");
  }
  return ~x;
}
bitNotNumber.signature = n1$3;
function bitOrNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function bitOr");
  }
  return x | y;
}
bitOrNumber.signature = n2$1;
function bitXorNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function bitXor");
  }
  return x ^ y;
}
bitXorNumber.signature = n2$1;
function leftShiftNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function leftShift");
  }
  return x << y;
}
leftShiftNumber.signature = n2$1;
function rightArithShiftNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function rightArithShift");
  }
  return x >> y;
}
rightArithShiftNumber.signature = n2$1;
function rightLogShiftNumber(x, y) {
  if (!isInteger$1(x) || !isInteger$1(y)) {
    throw new Error("Integers expected in function rightLogShift");
  }
  return x >>> y;
}
rightLogShiftNumber.signature = n2$1;
function product(i2, n) {
  if (n < i2) {
    return 1;
  }
  if (n === i2) {
    return n;
  }
  var half = n + i2 >> 1;
  return product(i2, half) * product(half + 1, n);
}
function combinationsNumber(n, k) {
  if (!isInteger$1(n) || n < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (!isInteger$1(k) || k < 0) {
    throw new TypeError("Positive integer value expected in function combinations");
  }
  if (k > n) {
    throw new TypeError("k must be less than or equal to n");
  }
  var nMinusk = n - k;
  var answer = 1;
  var firstnumerator = k < nMinusk ? nMinusk + 1 : k + 1;
  var nextdivisor = 2;
  var lastdivisor = k < nMinusk ? k : nMinusk;
  for (var nextnumerator = firstnumerator; nextnumerator <= n; ++nextnumerator) {
    answer *= nextnumerator;
    while (nextdivisor <= lastdivisor && answer % nextdivisor === 0) {
      answer /= nextdivisor;
      ++nextdivisor;
    }
  }
  if (nextdivisor <= lastdivisor) {
    answer /= product(nextdivisor, lastdivisor);
  }
  return answer;
}
combinationsNumber.signature = "number, number";
var pi$1 = Math.PI;
var tau$1 = 2 * Math.PI;
var e$1 = Math.E;
var phi$1 = 1.618033988749895;
var n1$2 = "number";
var n2 = "number, number";
function notNumber(x) {
  return !x;
}
notNumber.signature = n1$2;
function orNumber(x, y) {
  return !!(x || y);
}
orNumber.signature = n2;
function xorNumber(x, y) {
  return !!x !== !!y;
}
xorNumber.signature = n2;
function andNumber(x, y) {
  return !!(x && y);
}
andNumber.signature = n2;
function gammaNumber(n) {
  var x;
  if (isInteger$1(n)) {
    if (n <= 0) {
      return isFinite(n) ? Infinity : NaN;
    }
    if (n > 171) {
      return Infinity;
    }
    return product(1, n - 1);
  }
  if (n < 0.5) {
    return Math.PI / (Math.sin(Math.PI * n) * gammaNumber(1 - n));
  }
  if (n >= 171.35) {
    return Infinity;
  }
  if (n > 85) {
    var twoN = n * n;
    var threeN = twoN * n;
    var fourN = threeN * n;
    var fiveN = fourN * n;
    return Math.sqrt(2 * Math.PI / n) * Math.pow(n / Math.E, n) * (1 + 1 / (12 * n) + 1 / (288 * twoN) - 139 / (51840 * threeN) - 571 / (2488320 * fourN) + 163879 / (209018880 * fiveN) + 5246819 / (75246796800 * fiveN * n));
  }
  --n;
  x = gammaP[0];
  for (var i2 = 1; i2 < gammaP.length; ++i2) {
    x += gammaP[i2] / (n + i2);
  }
  var t = n + gammaG + 0.5;
  return Math.sqrt(2 * Math.PI) * Math.pow(t, n + 0.5) * Math.exp(-t) * x;
}
gammaNumber.signature = "number";
var gammaG = 4.7421875;
var gammaP = [0.9999999999999971, 57.15623566586292, -59.59796035547549, 14.136097974741746, -0.4919138160976202, 3399464998481189e-20, 4652362892704858e-20, -9837447530487956e-20, 1580887032249125e-19, -21026444172410488e-20, 21743961811521265e-20, -1643181065367639e-19, 8441822398385275e-20, -26190838401581408e-21, 36899182659531625e-22];
var lnSqrt2PI = 0.9189385332046728;
var lgammaG = 5;
var lgammaN = 7;
var lgammaSeries = [1.000000000190015, 76.18009172947146, -86.50532032941678, 24.01409824083091, -1.231739572450155, 0.001208650973866179, -5395239384953e-18];
function lgammaNumber(n) {
  if (n < 0)
    return NaN;
  if (n === 0)
    return Infinity;
  if (!isFinite(n))
    return n;
  if (n < 0.5) {
    return Math.log(Math.PI / Math.sin(Math.PI * n)) - lgammaNumber(1 - n);
  }
  n = n - 1;
  var base = n + lgammaG + 0.5;
  var sum2 = lgammaSeries[0];
  for (var i2 = lgammaN - 1; i2 >= 1; i2--) {
    sum2 += lgammaSeries[i2] / (n + i2);
  }
  return lnSqrt2PI + (n + 0.5) * Math.log(base) - base + Math.log(sum2);
}
lgammaNumber.signature = "number";
var n1$1 = "number";
function acoshNumber(x) {
  return acosh$2(x);
}
acoshNumber.signature = n1$1;
function acotNumber(x) {
  return Math.atan(1 / x);
}
acotNumber.signature = n1$1;
function acothNumber(x) {
  return isFinite(x) ? (Math.log((x + 1) / x) + Math.log(x / (x - 1))) / 2 : 0;
}
acothNumber.signature = n1$1;
function acscNumber(x) {
  return Math.asin(1 / x);
}
acscNumber.signature = n1$1;
function acschNumber(x) {
  var xInv = 1 / x;
  return Math.log(xInv + Math.sqrt(xInv * xInv + 1));
}
acschNumber.signature = n1$1;
function asecNumber(x) {
  return Math.acos(1 / x);
}
asecNumber.signature = n1$1;
function asechNumber(x) {
  var xInv = 1 / x;
  var ret = Math.sqrt(xInv * xInv - 1);
  return Math.log(ret + xInv);
}
asechNumber.signature = n1$1;
function asinhNumber(x) {
  return asinh$2(x);
}
asinhNumber.signature = n1$1;
function atanhNumber(x) {
  return atanh$2(x);
}
atanhNumber.signature = n1$1;
function cotNumber(x) {
  return 1 / Math.tan(x);
}
cotNumber.signature = n1$1;
function cothNumber(x) {
  var e2 = Math.exp(2 * x);
  return (e2 + 1) / (e2 - 1);
}
cothNumber.signature = n1$1;
function cscNumber(x) {
  return 1 / Math.sin(x);
}
cscNumber.signature = n1$1;
function cschNumber(x) {
  if (x === 0) {
    return Number.POSITIVE_INFINITY;
  } else {
    return Math.abs(2 / (Math.exp(x) - Math.exp(-x))) * sign$2(x);
  }
}
cschNumber.signature = n1$1;
function secNumber(x) {
  return 1 / Math.cos(x);
}
secNumber.signature = n1$1;
function sechNumber(x) {
  return 2 / (Math.exp(x) + Math.exp(-x));
}
sechNumber.signature = n1$1;
function sinhNumber(x) {
  return sinh$2(x);
}
sinhNumber.signature = n1$1;
var n1 = "number";
function isNegativeNumber(x) {
  return x < 0;
}
isNegativeNumber.signature = n1;
function isPositiveNumber(x) {
  return x > 0;
}
isPositiveNumber.signature = n1;
function isZeroNumber(x) {
  return x === 0;
}
isZeroNumber.signature = n1;
function isNaNNumber(x) {
  return Number.isNaN(x);
}
isNaNNumber.signature = n1;
var name$4L = "isNegative";
var dependencies$4K = ["typed"];
var createIsNegative = /* @__PURE__ */ factory(name$4L, dependencies$4K, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4L, {
    number: isNegativeNumber,
    BigNumber: function BigNumber2(x) {
      return x.isNeg() && !x.isZero() && !x.isNaN();
    },
    Fraction: function Fraction2(x) {
      return x.s < 0;
    },
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4K = "isNumeric";
var dependencies$4J = ["typed"];
var createIsNumeric = /* @__PURE__ */ factory(name$4K, dependencies$4J, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4K, {
    "number | BigNumber | Fraction | boolean": () => true,
    "Complex | Unit | string | null | undefined | Node": () => false,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4J = "hasNumericValue";
var dependencies$4I = ["typed", "isNumeric"];
var createHasNumericValue = /* @__PURE__ */ factory(name$4J, dependencies$4I, (_ref) => {
  var {
    typed: typed2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name$4J, {
    boolean: () => true,
    string: function string2(x) {
      return x.trim().length > 0 && !isNaN(Number(x));
    },
    any: function any(x) {
      return isNumeric2(x);
    }
  });
});
var name$4I = "isPositive";
var dependencies$4H = ["typed"];
var createIsPositive = /* @__PURE__ */ factory(name$4I, dependencies$4H, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4I, {
    number: isPositiveNumber,
    BigNumber: function BigNumber2(x) {
      return !x.isNeg() && !x.isZero() && !x.isNaN();
    },
    Fraction: function Fraction2(x) {
      return x.s > 0 && x.n > 0;
    },
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4H = "isZero";
var dependencies$4G = ["typed"];
var createIsZero = /* @__PURE__ */ factory(name$4H, dependencies$4G, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4H, {
    number: isZeroNumber,
    BigNumber: function BigNumber2(x) {
      return x.isZero();
    },
    Complex: function Complex2(x) {
      return x.re === 0 && x.im === 0;
    },
    Fraction: function Fraction2(x) {
      return x.d === 1 && x.n === 0;
    },
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4G = "isNaN";
var dependencies$4F = ["typed"];
var createIsNaN = /* @__PURE__ */ factory(name$4G, dependencies$4F, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4G, {
    number: isNaNNumber,
    BigNumber: function BigNumber2(x) {
      return x.isNaN();
    },
    Fraction: function Fraction2(x) {
      return false;
    },
    Complex: function Complex2(x) {
      return x.isNaN();
    },
    Unit: function Unit2(x) {
      return Number.isNaN(x.value);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4F = "typeOf";
var dependencies$4E = ["typed"];
var createTypeOf = /* @__PURE__ */ factory(name$4F, dependencies$4E, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4F, {
    any: typeOf$1
  });
});
function nearlyEqual(x, y, epsilon) {
  if (epsilon === null || epsilon === void 0) {
    return x.eq(y);
  }
  if (x.eq(y)) {
    return true;
  }
  if (x.isNaN() || y.isNaN()) {
    return false;
  }
  if (x.isFinite() && y.isFinite()) {
    var diff2 = x.minus(y).abs();
    if (diff2.isZero()) {
      return true;
    } else {
      var max2 = x.constructor.max(x.abs(), y.abs());
      return diff2.lte(max2.times(epsilon));
    }
  }
  return false;
}
function complexEquals(x, y, epsilon) {
  return nearlyEqual$1(x.re, y.re, epsilon) && nearlyEqual$1(x.im, y.im, epsilon);
}
var createCompareUnits = /* @__PURE__ */ factory("compareUnits", ["typed"], (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return {
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (!x.equalBase(y)) {
        throw new Error("Cannot compare units with different base");
      }
      return typed2.find(self2, [x.valueType(), y.valueType()])(x.value, y.value);
    })
  };
});
var name$4E = "equalScalar";
var dependencies$4D = ["typed", "config"];
var createEqualScalar = /* @__PURE__ */ factory(name$4E, dependencies$4D, (_ref) => {
  var {
    typed: typed2,
    config: config3
  } = _ref;
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$4E, {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y;
    },
    "number, number": function numberNumber(x, y) {
      return nearlyEqual$1(x, y, config3.epsilon);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.eq(y) || nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.equals(y);
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return complexEquals(x, y, config3.epsilon);
    }
  }, compareUnits);
});
factory(name$4E, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$4E, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$4D = "SparseMatrix";
var dependencies$4C = ["typed", "equalScalar", "Matrix"];
var createSparseMatrixClass = /* @__PURE__ */ factory(name$4D, dependencies$4C, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    Matrix: Matrix2
  } = _ref;
  function SparseMatrix2(data, datatype) {
    if (!(this instanceof SparseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data)) {
      _createFromMatrix(this, data, datatype);
    } else if (data && isArray(data.index) && isArray(data.ptr) && isArray(data.size)) {
      this._values = data.values;
      this._index = data.index;
      this._ptr = data.ptr;
      this._size = data.size;
      this._datatype = datatype || data.datatype;
    } else if (isArray(data)) {
      _createFromArray(this, data, datatype);
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf$1(data) + ")");
    } else {
      this._values = [];
      this._index = [];
      this._ptr = [0];
      this._size = [0, 0];
      this._datatype = datatype;
    }
  }
  function _createFromMatrix(matrix2, source, datatype) {
    if (source.type === "SparseMatrix") {
      matrix2._values = source._values ? clone$3(source._values) : void 0;
      matrix2._index = clone$3(source._index);
      matrix2._ptr = clone$3(source._ptr);
      matrix2._size = clone$3(source._size);
      matrix2._datatype = datatype || source._datatype;
    } else {
      _createFromArray(matrix2, source.valueOf(), datatype || source._datatype);
    }
  }
  function _createFromArray(matrix2, data, datatype) {
    matrix2._values = [];
    matrix2._index = [];
    matrix2._ptr = [];
    matrix2._datatype = datatype;
    var rows = data.length;
    var columns = 0;
    var eq = equalScalar2;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero = typed2.convert(0, datatype);
    }
    if (rows > 0) {
      var j = 0;
      do {
        matrix2._ptr.push(matrix2._index.length);
        for (var i2 = 0; i2 < rows; i2++) {
          var row2 = data[i2];
          if (isArray(row2)) {
            if (j === 0 && columns < row2.length) {
              columns = row2.length;
            }
            if (j < row2.length) {
              var v = row2[j];
              if (!eq(v, zero)) {
                matrix2._values.push(v);
                matrix2._index.push(i2);
              }
            }
          } else {
            if (j === 0 && columns < 1) {
              columns = 1;
            }
            if (!eq(row2, zero)) {
              matrix2._values.push(row2);
              matrix2._index.push(i2);
            }
          }
        }
        j++;
      } while (j < columns);
    }
    matrix2._ptr.push(matrix2._index.length);
    matrix2._size = [rows, columns];
  }
  SparseMatrix2.prototype = new Matrix2();
  SparseMatrix2.prototype.createSparseMatrix = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  Object.defineProperty(SparseMatrix2, "name", {
    value: "SparseMatrix"
  });
  SparseMatrix2.prototype.constructor = SparseMatrix2;
  SparseMatrix2.prototype.type = "SparseMatrix";
  SparseMatrix2.prototype.isSparseMatrix = true;
  SparseMatrix2.prototype.getDataType = function() {
    return getArrayDataType(this._values, typeOf$1);
  };
  SparseMatrix2.prototype.storage = function() {
    return "sparse";
  };
  SparseMatrix2.prototype.datatype = function() {
    return this._datatype;
  };
  SparseMatrix2.prototype.create = function(data, datatype) {
    return new SparseMatrix2(data, datatype);
  };
  SparseMatrix2.prototype.density = function() {
    var rows = this._size[0];
    var columns = this._size[1];
    return rows !== 0 && columns !== 0 ? this._index.length / (rows * columns) : 0;
  };
  SparseMatrix2.prototype.subset = function(index2, replacement, defaultValue) {
    if (!this._values) {
      throw new Error("Cannot invoke subset on a Pattern only matrix");
    }
    switch (arguments.length) {
      case 1:
        return _getsubset(this, index2);
      case 2:
      case 3:
        return _setsubset(this, index2, replacement, defaultValue);
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  function _getsubset(matrix2, idx) {
    if (!isIndex(idx)) {
      throw new TypeError("Invalid index");
    }
    var isScalar = idx.isScalar();
    if (isScalar) {
      return matrix2.get(idx.min());
    }
    var size2 = idx.size();
    if (size2.length !== matrix2._size.length) {
      throw new DimensionError(size2.length, matrix2._size.length);
    }
    var i2, ii, k, kk;
    var min2 = idx.min();
    var max2 = idx.max();
    for (i2 = 0, ii = matrix2._size.length; i2 < ii; i2++) {
      validateIndex(min2[i2], matrix2._size[i2]);
      validateIndex(max2[i2], matrix2._size[i2]);
    }
    var mvalues = matrix2._values;
    var mindex = matrix2._index;
    var mptr = matrix2._ptr;
    var rows = idx.dimension(0);
    var columns = idx.dimension(1);
    var w = [];
    var pv = [];
    rows.forEach(function(i3, r) {
      pv[i3] = r[0];
      w[i3] = true;
    });
    var values = mvalues ? [] : void 0;
    var index2 = [];
    var ptr = [];
    columns.forEach(function(j) {
      ptr.push(index2.length);
      for (k = mptr[j], kk = mptr[j + 1]; k < kk; k++) {
        i2 = mindex[k];
        if (w[i2] === true) {
          index2.push(pv[i2]);
          if (values) {
            values.push(mvalues[k]);
          }
        }
      }
    });
    ptr.push(index2.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: size2,
      datatype: matrix2._datatype
    });
  }
  function _setsubset(matrix2, index2, submatrix, defaultValue) {
    if (!index2 || index2.isIndex !== true) {
      throw new TypeError("Invalid index");
    }
    var iSize = index2.size();
    var isScalar = index2.isScalar();
    var sSize;
    if (isMatrix(submatrix)) {
      sSize = submatrix.size();
      submatrix = submatrix.toArray();
    } else {
      sSize = arraySize(submatrix);
    }
    if (isScalar) {
      if (sSize.length !== 0) {
        throw new TypeError("Scalar expected");
      }
      matrix2.set(index2.min(), submatrix, defaultValue);
    } else {
      if (iSize.length !== 1 && iSize.length !== 2) {
        throw new DimensionError(iSize.length, matrix2._size.length, "<");
      }
      if (sSize.length < iSize.length) {
        var i2 = 0;
        var outer = 0;
        while (iSize[i2] === 1 && sSize[i2] === 1) {
          i2++;
        }
        while (iSize[i2] === 1) {
          outer++;
          i2++;
        }
        submatrix = unsqueeze(submatrix, iSize.length, outer, sSize);
      }
      if (!deepStrictEqual(iSize, sSize)) {
        throw new DimensionError(iSize, sSize, ">");
      }
      if (iSize.length === 1) {
        var range2 = index2.dimension(0);
        range2.forEach(function(dataIndex, subIndex) {
          validateIndex(dataIndex);
          matrix2.set([dataIndex, 0], submatrix[subIndex[0]], defaultValue);
        });
      } else {
        var firstDimensionRange = index2.dimension(0);
        var secondDimensionRange = index2.dimension(1);
        firstDimensionRange.forEach(function(firstDataIndex, firstSubIndex) {
          validateIndex(firstDataIndex);
          secondDimensionRange.forEach(function(secondDataIndex, secondSubIndex) {
            validateIndex(secondDataIndex);
            matrix2.set([firstDataIndex, secondDataIndex], submatrix[firstSubIndex[0]][secondSubIndex[0]], defaultValue);
          });
        });
      }
    }
    return matrix2;
  }
  SparseMatrix2.prototype.get = function(index2) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke get on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[1]);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      return this._values[k];
    }
    return 0;
  };
  SparseMatrix2.prototype.set = function(index2, v, defaultValue) {
    if (!isArray(index2)) {
      throw new TypeError("Array expected");
    }
    if (index2.length !== this._size.length) {
      throw new DimensionError(index2.length, this._size.length);
    }
    if (!this._values) {
      throw new Error("Cannot invoke set on a Pattern only matrix");
    }
    var i2 = index2[0];
    var j = index2[1];
    var rows = this._size[0];
    var columns = this._size[1];
    var eq = equalScalar2;
    var zero = 0;
    if (isString(this._datatype)) {
      eq = typed2.find(equalScalar2, [this._datatype, this._datatype]) || equalScalar2;
      zero = typed2.convert(0, this._datatype);
    }
    if (i2 > rows - 1 || j > columns - 1) {
      _resize2(this, Math.max(i2 + 1, rows), Math.max(j + 1, columns), defaultValue);
      rows = this._size[0];
      columns = this._size[1];
    }
    validateIndex(i2, rows);
    validateIndex(j, columns);
    var k = _getValueIndex(i2, this._ptr[j], this._ptr[j + 1], this._index);
    if (k < this._ptr[j + 1] && this._index[k] === i2) {
      if (!eq(v, zero)) {
        this._values[k] = v;
      } else {
        _remove(k, j, this._values, this._index, this._ptr);
      }
    } else {
      if (!eq(v, zero)) {
        _insert(k, i2, j, v, this._values, this._index, this._ptr);
      }
    }
    return this;
  };
  function _getValueIndex(i2, top, bottom, index2) {
    if (bottom - top === 0) {
      return bottom;
    }
    for (var r = top; r < bottom; r++) {
      if (index2[r] === i2) {
        return r;
      }
    }
    return top;
  }
  function _remove(k, j, values, index2, ptr) {
    values.splice(k, 1);
    index2.splice(k, 1);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]--;
    }
  }
  function _insert(k, i2, j, v, values, index2, ptr) {
    values.splice(k, 0, v);
    index2.splice(k, 0, i2);
    for (var x = j + 1; x < ptr.length; x++) {
      ptr[x]++;
    }
  }
  SparseMatrix2.prototype.resize = function(size2, defaultValue, copy) {
    if (!isCollection(size2)) {
      throw new TypeError("Array or Matrix expected");
    }
    var sizeArray = size2.valueOf().map((value) => {
      return Array.isArray(value) && value.length === 1 ? value[0] : value;
    });
    if (sizeArray.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    sizeArray.forEach(function(value) {
      if (!isNumber(value) || !isInteger$1(value) || value < 0) {
        throw new TypeError("Invalid size, must contain positive integers (size: " + format$1(sizeArray) + ")");
      }
    });
    var m = copy ? this.clone() : this;
    return _resize2(m, sizeArray[0], sizeArray[1], defaultValue);
  };
  function _resize2(matrix2, rows, columns, defaultValue) {
    var value = defaultValue || 0;
    var eq = equalScalar2;
    var zero = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero = typed2.convert(0, matrix2._datatype);
      value = typed2.convert(value, matrix2._datatype);
    }
    var ins = !eq(value, zero);
    var r = matrix2._size[0];
    var c = matrix2._size[1];
    var i2, j, k;
    if (columns > c) {
      for (j = c; j < columns; j++) {
        matrix2._ptr[j] = matrix2._values.length;
        if (ins) {
          for (i2 = 0; i2 < r; i2++) {
            matrix2._values.push(value);
            matrix2._index.push(i2);
          }
        }
      }
      matrix2._ptr[columns] = matrix2._values.length;
    } else if (columns < c) {
      matrix2._ptr.splice(columns + 1, c - columns);
      matrix2._values.splice(matrix2._ptr[columns], matrix2._values.length);
      matrix2._index.splice(matrix2._ptr[columns], matrix2._index.length);
    }
    c = columns;
    if (rows > r) {
      if (ins) {
        var n = 0;
        for (j = 0; j < c; j++) {
          matrix2._ptr[j] = matrix2._ptr[j] + n;
          k = matrix2._ptr[j + 1] + n;
          var p = 0;
          for (i2 = r; i2 < rows; i2++, p++) {
            matrix2._values.splice(k + p, 0, value);
            matrix2._index.splice(k + p, 0, i2);
            n++;
          }
        }
        matrix2._ptr[c] = matrix2._values.length;
      }
    } else if (rows < r) {
      var d = 0;
      for (j = 0; j < c; j++) {
        matrix2._ptr[j] = matrix2._ptr[j] - d;
        var k0 = matrix2._ptr[j];
        var k1 = matrix2._ptr[j + 1] - d;
        for (k = k0; k < k1; k++) {
          i2 = matrix2._index[k];
          if (i2 > rows - 1) {
            matrix2._values.splice(k, 1);
            matrix2._index.splice(k, 1);
            d++;
          }
        }
      }
      matrix2._ptr[j] = matrix2._values.length;
    }
    matrix2._size[0] = rows;
    matrix2._size[1] = columns;
    return matrix2;
  }
  SparseMatrix2.prototype.reshape = function(sizes, copy) {
    if (!isArray(sizes)) {
      throw new TypeError("Array expected");
    }
    if (sizes.length !== 2) {
      throw new Error("Sparse matrices can only be reshaped in two dimensions");
    }
    sizes.forEach(function(value) {
      if (!isNumber(value) || !isInteger$1(value) || value <= -2 || value === 0) {
        throw new TypeError("Invalid size, must contain positive integers or -1 (size: " + format$1(sizes) + ")");
      }
    });
    var currentLength = this._size[0] * this._size[1];
    sizes = processSizesWildcard(sizes, currentLength);
    var newLength = sizes[0] * sizes[1];
    if (currentLength !== newLength) {
      throw new Error("Reshaping sparse matrix will result in the wrong number of elements");
    }
    var m = copy ? this.clone() : this;
    if (this._size[0] === sizes[0] && this._size[1] === sizes[1]) {
      return m;
    }
    var colIndex = [];
    for (var i2 = 0; i2 < m._ptr.length; i2++) {
      for (var j = 0; j < m._ptr[i2 + 1] - m._ptr[i2]; j++) {
        colIndex.push(i2);
      }
    }
    var values = m._values.slice();
    var rowIndex = m._index.slice();
    for (var _i = 0; _i < m._index.length; _i++) {
      var r1 = rowIndex[_i];
      var c1 = colIndex[_i];
      var flat = r1 * m._size[1] + c1;
      colIndex[_i] = flat % sizes[1];
      rowIndex[_i] = Math.floor(flat / sizes[1]);
    }
    m._values.length = 0;
    m._index.length = 0;
    m._ptr.length = sizes[1] + 1;
    m._size = sizes.slice();
    for (var _i2 = 0; _i2 < m._ptr.length; _i2++) {
      m._ptr[_i2] = 0;
    }
    for (var h = 0; h < values.length; h++) {
      var _i3 = rowIndex[h];
      var _j = colIndex[h];
      var v = values[h];
      var k = _getValueIndex(_i3, m._ptr[_j], m._ptr[_j + 1], m._index);
      _insert(k, _i3, _j, v, m._values, m._index, m._ptr);
    }
    return m;
  };
  SparseMatrix2.prototype.clone = function() {
    var m = new SparseMatrix2({
      values: this._values ? clone$3(this._values) : void 0,
      index: clone$3(this._index),
      ptr: clone$3(this._ptr),
      size: clone$3(this._size),
      datatype: this._datatype
    });
    return m;
  };
  SparseMatrix2.prototype.size = function() {
    return this._size.slice(0);
  };
  SparseMatrix2.prototype.map = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke map on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    var args = maxArgumentCount(callback);
    var invoke = function invoke2(v, i2, j) {
      if (args === 1)
        return callback(v);
      if (args === 2)
        return callback(v, [i2, j]);
      return callback(v, [i2, j], me);
    };
    return _map2(this, 0, rows - 1, 0, columns - 1, invoke, skipZeros);
  };
  function _map2(matrix2, minRow, maxRow, minColumn, maxColumn, callback, skipZeros) {
    var values = [];
    var index2 = [];
    var ptr = [];
    var eq = equalScalar2;
    var zero = 0;
    if (isString(matrix2._datatype)) {
      eq = typed2.find(equalScalar2, [matrix2._datatype, matrix2._datatype]) || equalScalar2;
      zero = typed2.convert(0, matrix2._datatype);
    }
    var invoke = function invoke2(v, x, y) {
      v = callback(v, x, y);
      if (!eq(v, zero)) {
        values.push(v);
        index2.push(x);
      }
    };
    for (var j = minColumn; j <= maxColumn; j++) {
      ptr.push(values.length);
      var k0 = matrix2._ptr[j];
      var k1 = matrix2._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = matrix2._index[k];
          if (i2 >= minRow && i2 <= maxRow) {
            invoke(matrix2._values[k], i2 - minRow, j - minColumn);
          }
        }
      } else {
        var _values = {};
        for (var _k = k0; _k < k1; _k++) {
          var _i4 = matrix2._index[_k];
          _values[_i4] = matrix2._values[_k];
        }
        for (var _i5 = minRow; _i5 <= maxRow; _i5++) {
          var value = _i5 in _values ? _values[_i5] : 0;
          invoke(value, _i5 - minRow, j - minColumn);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [maxRow - minRow + 1, maxColumn - minColumn + 1]
    });
  }
  SparseMatrix2.prototype.forEach = function(callback, skipZeros) {
    if (!this._values) {
      throw new Error("Cannot invoke forEach on a Pattern only matrix");
    }
    var me = this;
    var rows = this._size[0];
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      if (skipZeros) {
        for (var k = k0; k < k1; k++) {
          var i2 = this._index[k];
          callback(this._values[k], [i2, j], me);
        }
      } else {
        var values = {};
        for (var _k2 = k0; _k2 < k1; _k2++) {
          var _i6 = this._index[_k2];
          values[_i6] = this._values[_k2];
        }
        for (var _i7 = 0; _i7 < rows; _i7++) {
          var value = _i7 in values ? values[_i7] : 0;
          callback(value, [_i7, j], me);
        }
      }
    }
  };
  SparseMatrix2.prototype[Symbol.iterator] = function* () {
    if (!this._values) {
      throw new Error("Cannot iterate a Pattern only matrix");
    }
    var columns = this._size[1];
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        yield {
          value: this._values[k],
          index: [i2, j]
        };
      }
    }
  };
  SparseMatrix2.prototype.toArray = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, true);
  };
  SparseMatrix2.prototype.valueOf = function() {
    return _toArray(this._values, this._index, this._ptr, this._size, false);
  };
  function _toArray(values, index2, ptr, size2, copy) {
    var rows = size2[0];
    var columns = size2[1];
    var a = [];
    var i2, j;
    for (i2 = 0; i2 < rows; i2++) {
      a[i2] = [];
      for (j = 0; j < columns; j++) {
        a[i2][j] = 0;
      }
    }
    for (j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        i2 = index2[k];
        a[i2][j] = values ? copy ? clone$3(values[k]) : values[k] : 1;
      }
    }
    return a;
  }
  SparseMatrix2.prototype.format = function(options) {
    var rows = this._size[0];
    var columns = this._size[1];
    var density = this.density();
    var str = "Sparse Matrix [" + format$1(rows, options) + " x " + format$1(columns, options) + "] density: " + format$1(density, options) + "\n";
    for (var j = 0; j < columns; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var k = k0; k < k1; k++) {
        var i2 = this._index[k];
        str += "\n    (" + format$1(i2, options) + ", " + format$1(j, options) + ") ==> " + (this._values ? format$1(this._values[k], options) : "X");
      }
    }
    return str;
  };
  SparseMatrix2.prototype.toString = function() {
    return format$1(this.toArray());
  };
  SparseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "SparseMatrix",
      values: this._values,
      index: this._index,
      ptr: this._ptr,
      size: this._size,
      datatype: this._datatype
    };
  };
  SparseMatrix2.prototype.diagonal = function(k) {
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger$1(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = this._size[0];
    var columns = this._size[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var values = [];
    var index2 = [];
    var ptr = [];
    ptr[0] = 0;
    for (var j = kSuper; j < columns && values.length < n; j++) {
      var k0 = this._ptr[j];
      var k1 = this._ptr[j + 1];
      for (var x = k0; x < k1; x++) {
        var i2 = this._index[x];
        if (i2 === j - kSuper + kSub) {
          values.push(this._values[x]);
          index2[values.length - 1] = i2 - kSub;
          break;
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [n, 1]
    });
  };
  SparseMatrix2.fromJSON = function(json) {
    return new SparseMatrix2(json);
  };
  SparseMatrix2.diagonal = function(size2, value, k, defaultValue, datatype) {
    if (!isArray(size2)) {
      throw new TypeError("Array expected, size parameter");
    }
    if (size2.length !== 2) {
      throw new Error("Only two dimensions matrix are supported");
    }
    size2 = size2.map(function(s) {
      if (isBigNumber(s)) {
        s = s.toNumber();
      }
      if (!isNumber(s) || !isInteger$1(s) || s < 1) {
        throw new Error("Size values must be positive integers");
      }
      return s;
    });
    if (k) {
      if (isBigNumber(k)) {
        k = k.toNumber();
      }
      if (!isNumber(k) || !isInteger$1(k)) {
        throw new TypeError("The parameter k must be an integer number");
      }
    } else {
      k = 0;
    }
    var eq = equalScalar2;
    var zero = 0;
    if (isString(datatype)) {
      eq = typed2.find(equalScalar2, [datatype, datatype]) || equalScalar2;
      zero = typed2.convert(0, datatype);
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    var rows = size2[0];
    var columns = size2[1];
    var n = Math.min(rows - kSub, columns - kSuper);
    var _value;
    if (isArray(value)) {
      if (value.length !== n) {
        throw new Error("Invalid value array length");
      }
      _value = function _value2(i3) {
        return value[i3];
      };
    } else if (isMatrix(value)) {
      var ms = value.size();
      if (ms.length !== 1 || ms[0] !== n) {
        throw new Error("Invalid matrix length");
      }
      _value = function _value2(i3) {
        return value.get([i3]);
      };
    } else {
      _value = function _value2() {
        return value;
      };
    }
    var values = [];
    var index2 = [];
    var ptr = [];
    for (var j = 0; j < columns; j++) {
      ptr.push(values.length);
      var i2 = j - kSuper;
      if (i2 >= 0 && i2 < n) {
        var v = _value(i2);
        if (!eq(v, zero)) {
          index2.push(i2 + kSub);
          values.push(v);
        }
      }
    }
    ptr.push(values.length);
    return new SparseMatrix2({
      values,
      index: index2,
      ptr,
      size: [rows, columns]
    });
  };
  SparseMatrix2.prototype.swapRows = function(i2, j) {
    if (!isNumber(i2) || !isInteger$1(i2) || !isNumber(j) || !isInteger$1(j)) {
      throw new Error("Row index must be positive integers");
    }
    if (this._size.length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(i2, this._size[0]);
    validateIndex(j, this._size[0]);
    SparseMatrix2._swapRows(i2, j, this._size[1], this._values, this._index, this._ptr);
    return this;
  };
  SparseMatrix2._forEachRow = function(j, values, index2, ptr, callback) {
    var k0 = ptr[j];
    var k1 = ptr[j + 1];
    for (var k = k0; k < k1; k++) {
      callback(index2[k], values[k]);
    }
  };
  SparseMatrix2._swapRows = function(x, y, columns, values, index2, ptr) {
    for (var j = 0; j < columns; j++) {
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      var kx = _getValueIndex(x, k0, k1, index2);
      var ky = _getValueIndex(y, k0, k1, index2);
      if (kx < k1 && ky < k1 && index2[kx] === x && index2[ky] === y) {
        if (values) {
          var v = values[kx];
          values[kx] = values[ky];
          values[ky] = v;
        }
        continue;
      }
      if (kx < k1 && index2[kx] === x && (ky >= k1 || index2[ky] !== y)) {
        var vx = values ? values[kx] : void 0;
        index2.splice(ky, 0, y);
        if (values) {
          values.splice(ky, 0, vx);
        }
        index2.splice(ky <= kx ? kx + 1 : kx, 1);
        if (values) {
          values.splice(ky <= kx ? kx + 1 : kx, 1);
        }
        continue;
      }
      if (ky < k1 && index2[ky] === y && (kx >= k1 || index2[kx] !== x)) {
        var vy = values ? values[ky] : void 0;
        index2.splice(kx, 0, x);
        if (values) {
          values.splice(kx, 0, vy);
        }
        index2.splice(kx <= ky ? ky + 1 : ky, 1);
        if (values) {
          values.splice(kx <= ky ? ky + 1 : ky, 1);
        }
      }
    }
  };
  return SparseMatrix2;
}, {
  isClass: true
});
var name$4C = "number";
var dependencies$4B = ["typed"];
function getNonDecimalNumberParts(input) {
  var nonDecimalWithRadixMatch = input.match(/(0[box])([0-9a-fA-F]*)\.([0-9a-fA-F]*)/);
  if (nonDecimalWithRadixMatch) {
    var radix = {
      "0b": 2,
      "0o": 8,
      "0x": 16
    }[nonDecimalWithRadixMatch[1]];
    var integerPart = nonDecimalWithRadixMatch[2];
    var fractionalPart = nonDecimalWithRadixMatch[3];
    return {
      input,
      radix,
      integerPart,
      fractionalPart
    };
  } else {
    return null;
  }
}
function makeNumberFromNonDecimalParts(parts) {
  var n = parseInt(parts.integerPart, parts.radix);
  var f = 0;
  for (var i2 = 0; i2 < parts.fractionalPart.length; i2++) {
    var digitValue = parseInt(parts.fractionalPart[i2], parts.radix);
    f += digitValue / Math.pow(parts.radix, i2 + 1);
  }
  var result = n + f;
  if (isNaN(result)) {
    throw new SyntaxError('String "' + parts.input + '" is not a valid number');
  }
  return result;
}
var createNumber = /* @__PURE__ */ factory(name$4C, dependencies$4B, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var number2 = typed2("number", {
    "": function _() {
      return 0;
    },
    number: function number3(x) {
      return x;
    },
    string: function string2(x) {
      if (x === "NaN")
        return NaN;
      var nonDecimalNumberParts = getNonDecimalNumberParts(x);
      if (nonDecimalNumberParts) {
        return makeNumberFromNonDecimalParts(nonDecimalNumberParts);
      }
      var size2 = 0;
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        size2 = Number(wordSizeSuffixMatch[2]);
        x = wordSizeSuffixMatch[1];
      }
      var num = Number(x);
      if (isNaN(num)) {
        throw new SyntaxError('String "' + x + '" is not a valid number');
      }
      if (wordSizeSuffixMatch) {
        if (num > 2 ** size2 - 1) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        if (num >= 2 ** (size2 - 1)) {
          num = num - 2 ** size2;
        }
      }
      return num;
    },
    BigNumber: function BigNumber2(x) {
      return x.toNumber();
    },
    Fraction: function Fraction2(x) {
      return x.valueOf();
    },
    Unit: typed2.referToSelf((self2) => (x) => {
      var clone2 = x.clone();
      clone2.value = self2(x.value);
      return clone2;
    }),
    null: function _null2(x) {
      return 0;
    },
    "Unit, string | Unit": function UnitStringUnit(unit2, valuelessUnit) {
      return unit2.toNumber(valuelessUnit);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  number2.fromJSON = function(json) {
    return parseFloat(json.value);
  };
  return number2;
});
var name$4B = "string";
var dependencies$4A = ["typed"];
var createString = /* @__PURE__ */ factory(name$4B, dependencies$4A, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4B, {
    "": function _() {
      return "";
    },
    number: format$3,
    null: function _null2(x) {
      return "null";
    },
    boolean: function boolean2(x) {
      return x + "";
    },
    string: function string2(x) {
      return x;
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    any: function any(x) {
      return String(x);
    }
  });
});
var name$4A = "boolean";
var dependencies$4z = ["typed"];
var createBoolean = /* @__PURE__ */ factory(name$4A, dependencies$4z, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4A, {
    "": function _() {
      return false;
    },
    boolean: function boolean2(x) {
      return x;
    },
    number: function number2(x) {
      return !!x;
    },
    null: function _null2(x) {
      return false;
    },
    BigNumber: function BigNumber2(x) {
      return !x.isZero();
    },
    string: function string2(x) {
      var lcase = x.toLowerCase();
      if (lcase === "true") {
        return true;
      } else if (lcase === "false") {
        return false;
      }
      var num = Number(x);
      if (x !== "" && !isNaN(num)) {
        return !!num;
      }
      throw new Error('Cannot convert "' + x + '" to a boolean');
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4z = "bignumber";
var dependencies$4y = ["typed", "BigNumber"];
var createBignumber = /* @__PURE__ */ factory(name$4z, dependencies$4y, (_ref) => {
  var {
    typed: typed2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("bignumber", {
    "": function _() {
      return new BigNumber2(0);
    },
    number: function number2(x) {
      return new BigNumber2(x + "");
    },
    string: function string2(x) {
      var wordSizeSuffixMatch = x.match(/(0[box][0-9a-fA-F]*)i([0-9]*)/);
      if (wordSizeSuffixMatch) {
        var size2 = wordSizeSuffixMatch[2];
        var n = BigNumber2(wordSizeSuffixMatch[1]);
        var twoPowSize = new BigNumber2(2).pow(Number(size2));
        if (n.gt(twoPowSize.sub(1))) {
          throw new SyntaxError('String "'.concat(x, '" is out of range'));
        }
        var twoPowSizeSubOne = new BigNumber2(2).pow(Number(size2) - 1);
        if (n.gte(twoPowSizeSubOne)) {
          return n.sub(twoPowSize);
        } else {
          return n;
        }
      }
      return new BigNumber2(x);
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    Unit: typed2.referToSelf((self2) => (x) => {
      var clone2 = x.clone();
      clone2.value = self2(x.value);
      return clone2;
    }),
    Fraction: function Fraction2(x) {
      return new BigNumber2(x.n).div(x.d).times(x.s);
    },
    null: function _null2(x) {
      return new BigNumber2(0);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4y = "complex";
var dependencies$4x = ["typed", "Complex"];
var createComplex = /* @__PURE__ */ factory(name$4y, dependencies$4x, (_ref) => {
  var {
    typed: typed2,
    Complex: Complex2
  } = _ref;
  return typed2("complex", {
    "": function _() {
      return Complex2.ZERO;
    },
    number: function number2(x) {
      return new Complex2(x, 0);
    },
    "number, number": function numberNumber(re2, im2) {
      return new Complex2(re2, im2);
    },
    // TODO: this signature should be redundant
    "BigNumber, BigNumber": function BigNumberBigNumber(re2, im2) {
      return new Complex2(re2.toNumber(), im2.toNumber());
    },
    Fraction: function Fraction2(x) {
      return new Complex2(x.valueOf(), 0);
    },
    Complex: function Complex3(x) {
      return x.clone();
    },
    string: function string2(x) {
      return Complex2(x);
    },
    null: function _null2(x) {
      return Complex2(0);
    },
    Object: function Object2(x) {
      if ("re" in x && "im" in x) {
        return new Complex2(x.re, x.im);
      }
      if ("r" in x && "phi" in x || "abs" in x && "arg" in x) {
        return new Complex2(x);
      }
      throw new Error("Expected object with properties (re and im) or (r and phi) or (abs and arg)");
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4x = "fraction";
var dependencies$4w = ["typed", "Fraction"];
var createFraction = /* @__PURE__ */ factory(name$4x, dependencies$4w, (_ref) => {
  var {
    typed: typed2,
    Fraction: Fraction2
  } = _ref;
  return typed2("fraction", {
    number: function number2(x) {
      if (!isFinite(x) || isNaN(x)) {
        throw new Error(x + " cannot be represented as a fraction");
      }
      return new Fraction2(x);
    },
    string: function string2(x) {
      return new Fraction2(x);
    },
    "number, number": function numberNumber(numerator, denominator) {
      return new Fraction2(numerator, denominator);
    },
    null: function _null2(x) {
      return new Fraction2(0);
    },
    BigNumber: function BigNumber2(x) {
      return new Fraction2(x.toString());
    },
    Fraction: function Fraction3(x) {
      return x;
    },
    Unit: typed2.referToSelf((self2) => (x) => {
      var clone2 = x.clone();
      clone2.value = self2(x.value);
      return clone2;
    }),
    Object: function Object2(x) {
      return new Fraction2(x);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4w = "matrix";
var dependencies$4v = ["typed", "Matrix", "DenseMatrix", "SparseMatrix"];
var createMatrix = /* @__PURE__ */ factory(name$4w, dependencies$4v, (_ref) => {
  var {
    typed: typed2,
    Matrix: Matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$4w, {
    "": function _() {
      return _create([]);
    },
    string: function string2(format2) {
      return _create([], format2);
    },
    "string, string": function stringString(format2, datatype) {
      return _create([], format2, datatype);
    },
    Array: function Array2(data) {
      return _create(data);
    },
    Matrix: function Matrix3(data) {
      return _create(data, data.storage());
    },
    "Array | Matrix, string": _create,
    "Array | Matrix, string, string": _create
  });
  function _create(data, format2, datatype) {
    if (format2 === "dense" || format2 === "default" || format2 === void 0) {
      return new DenseMatrix2(data, datatype);
    }
    if (format2 === "sparse") {
      return new SparseMatrix2(data, datatype);
    }
    throw new TypeError("Unknown matrix type " + JSON.stringify(format2) + ".");
  }
});
var name$4v = "matrixFromFunction";
var dependencies$4u = ["typed", "matrix", "isZero"];
var createMatrixFromFunction = /* @__PURE__ */ factory(name$4v, dependencies$4u, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isZero: isZero2
  } = _ref;
  return typed2(name$4v, {
    "Array | Matrix, function, string, string": function ArrayMatrixFunctionStringString(size2, fn, format2, datatype) {
      return _create(size2, fn, format2, datatype);
    },
    "Array | Matrix, function, string": function ArrayMatrixFunctionString(size2, fn, format2) {
      return _create(size2, fn, format2);
    },
    "Matrix, function": function MatrixFunction(size2, fn) {
      return _create(size2, fn, "dense");
    },
    "Array, function": function ArrayFunction(size2, fn) {
      return _create(size2, fn, "dense").toArray();
    },
    "Array | Matrix, string, function": function ArrayMatrixStringFunction(size2, format2, fn) {
      return _create(size2, fn, format2);
    },
    "Array | Matrix, string, string, function": function ArrayMatrixStringStringFunction(size2, format2, datatype, fn) {
      return _create(size2, fn, format2, datatype);
    }
  });
  function _create(size2, fn, format2, datatype) {
    var m;
    if (datatype !== void 0) {
      m = matrix2(format2, datatype);
    } else {
      m = matrix2(format2);
    }
    m.resize(size2);
    m.forEach(function(_, index2) {
      var val = fn(index2);
      if (isZero2(val))
        return;
      m.set(index2, val);
    });
    return m;
  }
});
var name$4u = "matrixFromRows";
var dependencies$4t = ["typed", "matrix", "flatten", "size"];
var createMatrixFromRows = /* @__PURE__ */ factory(name$4u, dependencies$4t, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    flatten: flatten2,
    size: size2
  } = _ref;
  return typed2(name$4u, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one row is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var row2 of arr) {
      var rowLength = checkVectorTypeAndReturnLength(row2);
      if (rowLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + "  " + (rowLength | 0));
      }
      result.push(flatten2(row2));
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});
var name$4t = "matrixFromColumns";
var dependencies$4s = ["typed", "matrix", "flatten", "size"];
var createMatrixFromColumns = /* @__PURE__ */ factory(name$4t, dependencies$4s, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    flatten: flatten2,
    size: size2
  } = _ref;
  return typed2(name$4t, {
    "...Array": function Array2(arr) {
      return _createArray(arr);
    },
    "...Matrix": function Matrix2(arr) {
      return matrix2(_createArray(arr.map((m) => m.toArray())));
    }
    // TODO implement this properly for SparseMatrix
  });
  function _createArray(arr) {
    if (arr.length === 0)
      throw new TypeError("At least one column is needed to construct a matrix.");
    var N = checkVectorTypeAndReturnLength(arr[0]);
    var result = [];
    for (var i2 = 0; i2 < N; i2++) {
      result[i2] = [];
    }
    for (var col of arr) {
      var colLength = checkVectorTypeAndReturnLength(col);
      if (colLength !== N) {
        throw new TypeError("The vectors had different length: " + (N | 0) + "  " + (colLength | 0));
      }
      var f = flatten2(col);
      for (var _i = 0; _i < N; _i++) {
        result[_i].push(f[_i]);
      }
    }
    return result;
  }
  function checkVectorTypeAndReturnLength(vec) {
    var s = size2(vec);
    if (s.length === 1) {
      return s[0];
    } else if (s.length === 2) {
      if (s[0] === 1) {
        return s[1];
      } else if (s[1] === 1) {
        return s[0];
      } else {
        throw new TypeError("At least one of the arguments is not a vector.");
      }
    } else {
      throw new TypeError("Only one- or two-dimensional vectors are supported.");
    }
  }
});
var name$4s = "splitUnit";
var dependencies$4r = ["typed"];
var createSplitUnit = /* @__PURE__ */ factory(name$4s, dependencies$4r, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4s, {
    "Unit, Array": function UnitArray(unit2, parts) {
      return unit2.splitUnit(parts);
    }
  });
});
var name$4r = "unaryMinus";
var dependencies$4q = ["typed"];
var createUnaryMinus = /* @__PURE__ */ factory(name$4r, dependencies$4q, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4r, {
    number: unaryMinusNumber,
    "Complex | BigNumber | Fraction": (x) => x.neg(),
    Unit: typed2.referToSelf((self2) => (x) => {
      var res = x.clone();
      res.value = typed2.find(self2, res.valueType())(x.value);
      return res;
    }),
    // deep map collection, skip zeros since unaryMinus(0) = 0
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
    // TODO: add support for string
  });
});
var name$4q = "unaryPlus";
var dependencies$4p = ["typed", "config", "BigNumber"];
var createUnaryPlus = /* @__PURE__ */ factory(name$4q, dependencies$4p, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name$4q, {
    number: unaryPlusNumber,
    Complex: function Complex2(x) {
      return x;
    },
    BigNumber: function BigNumber3(x) {
      return x;
    },
    Fraction: function Fraction2(x) {
      return x;
    },
    Unit: function Unit2(x) {
      return x.clone();
    },
    // deep map collection, skip zeros since unaryPlus(0) = 0
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    "boolean | string": function booleanString(x) {
      return config3.number === "BigNumber" ? new BigNumber2(+x) : +x;
    }
  });
});
var name$4p = "abs";
var dependencies$4o = ["typed"];
var createAbs = /* @__PURE__ */ factory(name$4p, dependencies$4o, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4p, {
    number: absNumber,
    "Complex | BigNumber | Fraction | Unit": (x) => x.abs(),
    // deep map collection, skip zeros since abs(0) = 0
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$4o = "apply";
var dependencies$4n = ["typed", "isInteger"];
var createApply = /* @__PURE__ */ factory(name$4o, dependencies$4n, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$4o, {
    "Array | Matrix, number | BigNumber, function": function ArrayMatrixNumberBigNumberFunction(mat, dim, callback) {
      if (!isInteger2(dim)) {
        throw new TypeError("Integer number expected for dimension");
      }
      var size2 = Array.isArray(mat) ? arraySize(mat) : mat.size();
      if (dim < 0 || dim >= size2.length) {
        throw new IndexError(dim, size2.length);
      }
      if (isMatrix(mat)) {
        return mat.create(_apply(mat.valueOf(), dim, callback));
      } else {
        return _apply(mat, dim, callback);
      }
    }
  });
});
function _apply(mat, dim, callback) {
  var i2, ret, tran;
  if (dim <= 0) {
    if (!Array.isArray(mat[0])) {
      return callback(mat);
    } else {
      tran = _switch(mat);
      ret = [];
      for (i2 = 0; i2 < tran.length; i2++) {
        ret[i2] = _apply(tran[i2], dim - 1, callback);
      }
      return ret;
    }
  } else {
    ret = [];
    for (i2 = 0; i2 < mat.length; i2++) {
      ret[i2] = _apply(mat[i2], dim - 1, callback);
    }
    return ret;
  }
}
function _switch(mat) {
  var I = mat.length;
  var J = mat[0].length;
  var i2, j;
  var ret = [];
  for (j = 0; j < J; j++) {
    var tmp = [];
    for (i2 = 0; i2 < I; i2++) {
      tmp.push(mat[i2][j]);
    }
    ret.push(tmp);
  }
  return ret;
}
var name$4n = "addScalar";
var dependencies$4m = ["typed"];
var createAddScalar = /* @__PURE__ */ factory(name$4n, dependencies$4m, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4n, {
    "number, number": addNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.add(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.plus(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.add(y);
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (x.value === null || x.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});
var name$4m = "subtractScalar";
var dependencies$4l = ["typed"];
var createSubtractScalar = /* @__PURE__ */ factory(name$4m, dependencies$4l, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4m, {
    "number, number": subtractNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.sub(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.minus(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.sub(y);
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => {
      if (x.value === null || x.value === void 0) {
        throw new Error("Parameter x contains a unit with undefined value");
      }
      if (y.value === null || y.value === void 0) {
        throw new Error("Parameter y contains a unit with undefined value");
      }
      if (!x.equalBase(y))
        throw new Error("Units do not match");
      var res = x.clone();
      res.value = typed2.find(self2, [res.valueType(), y.valueType()])(res.value, y.value);
      res.fixPrefix = false;
      return res;
    })
  });
});
var name$4l = "cbrt";
var dependencies$4k = ["config", "typed", "isNegative", "unaryMinus", "matrix", "Complex", "BigNumber", "Fraction"];
var createCbrt = /* @__PURE__ */ factory(name$4l, dependencies$4k, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    isNegative: isNegative2,
    unaryMinus: unaryMinus2,
    matrix: matrix2,
    Complex: Complex2,
    BigNumber: BigNumber2,
    Fraction: Fraction2
  } = _ref;
  return typed2(name$4l, {
    number: cbrtNumber,
    // note: signature 'number, boolean' is also supported,
    //       created by typed as it knows how to convert number to Complex
    Complex: _cbrtComplex,
    "Complex, boolean": _cbrtComplex,
    BigNumber: function BigNumber3(x) {
      return x.cbrt();
    },
    Unit: _cbrtUnit
  });
  function _cbrtComplex(x, allRoots) {
    var arg3 = x.arg() / 3;
    var abs2 = x.abs();
    var principal = new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3).exp());
    if (allRoots) {
      var all = [principal, new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 + Math.PI * 2 / 3).exp()), new Complex2(cbrtNumber(abs2), 0).mul(new Complex2(0, arg3 - Math.PI * 2 / 3).exp())];
      return config3.matrix === "Array" ? all : matrix2(all);
    } else {
      return principal;
    }
  }
  function _cbrtUnit(x) {
    if (x.value && isComplex(x.value)) {
      var result = x.clone();
      result.value = 1;
      result = result.pow(1 / 3);
      result.value = _cbrtComplex(x.value);
      return result;
    } else {
      var negate = isNegative2(x.value);
      if (negate) {
        x.value = unaryMinus2(x.value);
      }
      var third;
      if (isBigNumber(x.value)) {
        third = new BigNumber2(1).div(3);
      } else if (isFraction(x.value)) {
        third = new Fraction2(1, 3);
      } else {
        third = 1 / 3;
      }
      var _result = x.pow(third);
      if (negate) {
        _result.value = unaryMinus2(_result.value);
      }
      return _result;
    }
  }
});
var name$4k = "matAlgo11xS0s";
var dependencies$4j = ["typed", "equalScalar"];
var createMatAlgo11xS0s = /* @__PURE__ */ factory(name$4k, dependencies$4j, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo11xS0s(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var i2 = aindex[k];
        var v = inverse ? cf(b, avalues[k]) : cf(avalues[k], b);
        if (!eq(v, zero)) {
          cindex.push(i2);
          cvalues.push(v);
        }
      }
    }
    cptr[columns] = cindex.length;
    return s.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$4j = "matAlgo12xSfs";
var dependencies$4i = ["typed", "DenseMatrix"];
var createMatAlgo12xSfs = /* @__PURE__ */ factory(name$4j, dependencies$4i, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo12xSfs(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          cdata[i2] = [];
        }
        if (w[i2] === mark) {
          cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
        } else {
          cdata[i2][j] = inverse ? cf(b, 0) : cf(0, b);
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
var name$4i = "matAlgo14xDs";
var dependencies$4h = ["typed"];
var createMatAlgo14xDs = /* @__PURE__ */ factory(name$4i, dependencies$4h, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo14xDs(a, b, callback, inverse) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = asize.length > 0 ? _iterate(cf, 0, asize, asize[0], adata, b, inverse) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: clone$3(asize),
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv, inverse) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i2 = 0; i2 < n; i2++) {
        cv[i2] = inverse ? f(bv, av[i2]) : f(av[i2], bv);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv, inverse);
      }
    }
    return cv;
  }
});
var name$4h = "ceil";
var dependencies$4g = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createCeilNumber = /* @__PURE__ */ factory(name$4h, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed2,
    config: config3,
    round: round2
  } = _ref;
  return typed2(name$4h, {
    number: function number2(x) {
      if (nearlyEqual$1(x, round2(x), config3.epsilon)) {
        return round2(x);
      } else {
        return Math.ceil(x);
      }
    },
    "number, number": function numberNumber(x, n) {
      if (nearlyEqual$1(x, round2(x, n), config3.epsilon)) {
        return round2(x, n);
      } else {
        var [number2, exponent] = "".concat(x, "e").split("e");
        var result = Math.ceil(Number("".concat(number2, "e").concat(Number(exponent) + n)));
        [number2, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number2, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createCeil = /* @__PURE__ */ factory(name$4h, dependencies$4g, (_ref2) => {
  var {
    typed: typed2,
    config: config3,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var ceilNumber = createCeilNumber({
    typed: typed2,
    config: config3,
    round: round2
  });
  return typed2("ceil", {
    number: ceilNumber.signatures.number,
    "number,number": ceilNumber.signatures["number,number"],
    Complex: function Complex2(x) {
      return x.ceil();
    },
    "Complex, number": function ComplexNumber(x, n) {
      return x.ceil(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    BigNumber: function BigNumber2(x) {
      if (nearlyEqual(x, round2(x), config3.epsilon)) {
        return round2(x);
      } else {
        return x.ceil();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (nearlyEqual(x, round2(x, n), config3.epsilon)) {
        return round2(x, n);
      } else {
        return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_CEIL);
      }
    },
    Fraction: function Fraction2(x) {
      return x.ceil();
    },
    "Fraction, number": function FractionNumber(x, n) {
      return x.ceil(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      return x.ceil(n.toNumber());
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n));
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
var name$4g = "cube";
var dependencies$4f = ["typed"];
var createCube = /* @__PURE__ */ factory(name$4g, dependencies$4f, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4g, {
    number: cubeNumber,
    Complex: function Complex2(x) {
      return x.mul(x).mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x).times(x);
    },
    Fraction: function Fraction2(x) {
      return x.pow(3);
    },
    Unit: function Unit2(x) {
      return x.pow(3);
    }
  });
});
var name$4f = "exp";
var dependencies$4e = ["typed"];
var createExp = /* @__PURE__ */ factory(name$4f, dependencies$4e, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$4f, {
    number: expNumber,
    Complex: function Complex2(x) {
      return x.exp();
    },
    BigNumber: function BigNumber2(x) {
      return x.exp();
    }
  });
});
var name$4e = "expm1";
var dependencies$4d = ["typed", "Complex"];
var createExpm1 = /* @__PURE__ */ factory(name$4e, dependencies$4d, (_ref) => {
  var {
    typed: typed2,
    Complex: _Complex
  } = _ref;
  return typed2(name$4e, {
    number: expm1Number,
    Complex: function Complex2(x) {
      var r = Math.exp(x.re);
      return new _Complex(r * Math.cos(x.im) - 1, r * Math.sin(x.im));
    },
    BigNumber: function BigNumber2(x) {
      return x.exp().minus(1);
    }
  });
});
var name$4d = "fix";
var dependencies$4c = ["typed", "Complex", "matrix", "ceil", "floor", "equalScalar", "zeros", "DenseMatrix"];
var createFixNumber = /* @__PURE__ */ factory(name$4d, ["typed", "ceil", "floor"], (_ref) => {
  var {
    typed: typed2,
    ceil: ceil2,
    floor: floor2
  } = _ref;
  return typed2(name$4d, {
    number: function number2(x) {
      return x > 0 ? floor2(x) : ceil2(x);
    },
    "number, number": function numberNumber(x, n) {
      return x > 0 ? floor2(x, n) : ceil2(x, n);
    }
  });
});
var createFix = /* @__PURE__ */ factory(name$4d, dependencies$4c, (_ref2) => {
  var {
    typed: typed2,
    Complex: _Complex,
    matrix: matrix2,
    ceil: ceil2,
    floor: floor2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var fixNumber = createFixNumber({
    typed: typed2,
    ceil: ceil2,
    floor: floor2
  });
  return typed2("fix", {
    number: fixNumber.signatures.number,
    "number, number | BigNumber": fixNumber.signatures["number,number"],
    Complex: function Complex2(x) {
      return new _Complex(x.re > 0 ? Math.floor(x.re) : Math.ceil(x.re), x.im > 0 ? Math.floor(x.im) : Math.ceil(x.im));
    },
    "Complex, number": function ComplexNumber(x, n) {
      return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
    },
    "Complex, BigNumber": function ComplexBigNumber(x, bn) {
      var n = bn.toNumber();
      return new _Complex(x.re > 0 ? floor2(x.re, n) : ceil2(x.re, n), x.im > 0 ? floor2(x.im, n) : ceil2(x.im, n));
    },
    BigNumber: function BigNumber2(x) {
      return x.isNegative() ? ceil2(x) : floor2(x);
    },
    "BigNumber, number | BigNumber": function BigNumberNumberBigNumber(x, n) {
      return x.isNegative() ? ceil2(x, n) : floor2(x, n);
    },
    Fraction: function Fraction2(x) {
      return x.s < 0 ? x.ceil() : x.floor();
    },
    "Fraction, number | BigNumber": function FractionNumberBigNumber(x, n) {
      return x.s < 0 ? ceil2(x, n) : floor2(x, n);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2);
    }),
    "Array | Matrix, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n));
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
var name$4c = "floor";
var dependencies$4b = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix"];
var createFloorNumber = /* @__PURE__ */ factory(name$4c, ["typed", "config", "round"], (_ref) => {
  var {
    typed: typed2,
    config: config3,
    round: round2
  } = _ref;
  return typed2(name$4c, {
    number: function number2(x) {
      if (nearlyEqual$1(x, round2(x), config3.epsilon)) {
        return round2(x);
      } else {
        return Math.floor(x);
      }
    },
    "number, number": function numberNumber(x, n) {
      if (nearlyEqual$1(x, round2(x, n), config3.epsilon)) {
        return round2(x, n);
      } else {
        var [number2, exponent] = "".concat(x, "e").split("e");
        var result = Math.floor(Number("".concat(number2, "e").concat(Number(exponent) + n)));
        [number2, exponent] = "".concat(result, "e").split("e");
        return Number("".concat(number2, "e").concat(Number(exponent) - n));
      }
    }
  });
});
var createFloor = /* @__PURE__ */ factory(name$4c, dependencies$4b, (_ref2) => {
  var {
    typed: typed2,
    config: config3,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  } = _ref2;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var floorNumber = createFloorNumber({
    typed: typed2,
    config: config3,
    round: round2
  });
  return typed2("floor", {
    number: floorNumber.signatures.number,
    "number,number": floorNumber.signatures["number,number"],
    Complex: function Complex2(x) {
      return x.floor();
    },
    "Complex, number": function ComplexNumber(x, n) {
      return x.floor(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    BigNumber: function BigNumber2(x) {
      if (nearlyEqual(x, round2(x), config3.epsilon)) {
        return round2(x);
      } else {
        return x.floor();
      }
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (nearlyEqual(x, round2(x, n), config3.epsilon)) {
        return round2(x, n);
      } else {
        return x.toDecimalPlaces(n.toNumber(), Decimal.ROUND_FLOOR);
      }
    },
    Fraction: function Fraction2(x) {
      return x.floor();
    },
    "Fraction, number": function FractionNumber(x, n) {
      return x.floor(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      return x.floor(n.toNumber());
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return deepMap(x, (i2) => self2(i2, n));
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | Complex | Fraction | BigNumber, Array": typed2.referToSelf((self2) => (x, y) => {
      return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
    }),
    "number | Complex | Fraction | BigNumber, Matrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0))
        return zeros2(y.size(), y.storage());
      if (y.storage() === "dense") {
        return matAlgo14xDs(y, x, self2, true);
      }
      return matAlgo12xSfs(y, x, self2, true);
    })
  });
});
var name$4b = "matAlgo02xDS0";
var dependencies$4a = ["typed", "equalScalar"];
var createMatAlgo02xDS0 = /* @__PURE__ */ factory(name$4b, dependencies$4a, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo02xDS0(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i2 = bindex[k];
        var cij = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        if (!eq(cij, zero)) {
          cindex.push(i2);
          cvalues.push(cij);
        }
      }
    }
    cptr[columns] = cindex.length;
    return sparseMatrix.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
    });
  };
});
var name$4a = "matAlgo03xDSf";
var dependencies$49 = ["typed"];
var createMatAlgo03xDSf = /* @__PURE__ */ factory(name$4a, dependencies$49, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo03xDSf(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    for (var z = 0; z < rows; z++) {
      cdata[z] = [];
    }
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        var i2 = bindex[k];
        x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        w[i2] = mark;
      }
      for (var y = 0; y < rows; y++) {
        if (w[y] === mark) {
          cdata[y][j] = x[y];
        } else {
          cdata[y][j] = inverse ? cf(zero, adata[y][j]) : cf(adata[y][j], zero);
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
    });
  };
});
var name$49 = "matAlgo05xSfSf";
var dependencies$48 = ["typed", "equalScalar"];
var createMatAlgo05xSfSf = /* @__PURE__ */ factory(name$49, dependencies$48, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo05xSfSf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = cvalues ? [] : void 0;
    var xb = cvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i2, j, k, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k = aptr[j], k1 = aptr[j + 1]; k < k1; k++) {
        i2 = aindex[k];
        cindex.push(i2);
        wa[i2] = mark;
        if (xa) {
          xa[i2] = avalues[k];
        }
      }
      for (k = bptr[j], k1 = bptr[j + 1]; k < k1; k++) {
        i2 = bindex[k];
        if (wa[i2] !== mark) {
          cindex.push(i2);
        }
        wb[i2] = mark;
        if (xb) {
          xb[i2] = bvalues[k];
        }
      }
      if (cvalues) {
        k = cptr[j];
        while (k < cindex.length) {
          i2 = cindex[k];
          var wai = wa[i2];
          var wbi = wb[i2];
          if (wai === mark || wbi === mark) {
            var va = wai === mark ? xa[i2] : zero;
            var vb = wbi === mark ? xb[i2] : zero;
            var vc = cf(va, vb);
            if (!eq(vc, zero)) {
              cvalues.push(vc);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});
var name$48 = "matAlgo13xDD";
var dependencies$47 = ["typed"];
var createMatAlgo13xDD = /* @__PURE__ */ factory(name$48, dependencies$47, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function matAlgo13xDD(a, b, callback) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype;
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype;
    var csize = [];
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    for (var s = 0; s < asize.length; s++) {
      if (asize[s] !== bsize[s]) {
        throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
      }
      csize[s] = asize[s];
    }
    var dt;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt) {
      dt = adt;
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = csize.length > 0 ? _iterate(cf, 0, csize, csize[0], adata, bdata) : [];
    return a.createDenseMatrix({
      data: cdata,
      size: csize,
      datatype: dt
    });
  };
  function _iterate(f, level, s, n, av, bv) {
    var cv = [];
    if (level === s.length - 1) {
      for (var i2 = 0; i2 < n; i2++) {
        cv[i2] = f(av[i2], bv[i2]);
      }
    } else {
      for (var j = 0; j < n; j++) {
        cv[j] = _iterate(f, level + 1, s, s[level + 1], av[j], bv[j]);
      }
    }
    return cv;
  }
});
var name$47 = "broadcast";
var dependancies = ["concat"];
var createBroadcast = /* @__PURE__ */ factory(name$47, dependancies, (_ref) => {
  var {
    concat: concat2
  } = _ref;
  return function(A, B) {
    var N = Math.max(A._size.length, B._size.length);
    if (A._size.length === B._size.length) {
      if (A._size.every((dim2, i2) => dim2 === B._size[i2])) {
        return [A, B];
      }
    }
    var sizeA = _padLeft(A._size, N, 0);
    var sizeB = _padLeft(B._size, N, 0);
    var sizeMax = [];
    for (var dim = 0; dim < N; dim++) {
      sizeMax[dim] = Math.max(sizeA[dim], sizeB[dim]);
    }
    checkBroadcastingRules(sizeA, sizeMax);
    checkBroadcastingRules(sizeB, sizeMax);
    var AA = A.clone();
    var BB = B.clone();
    if (AA._size.length < N) {
      AA.reshape(_padLeft(AA._size, N, 1));
    } else if (BB._size.length < N) {
      BB.reshape(_padLeft(BB._size, N, 1));
    }
    for (var _dim = 0; _dim < N; _dim++) {
      if (AA._size[_dim] < sizeMax[_dim]) {
        AA = _stretch(AA, sizeMax[_dim], _dim);
      }
      if (BB._size[_dim] < sizeMax[_dim]) {
        BB = _stretch(BB, sizeMax[_dim], _dim);
      }
    }
    return [AA, BB];
  };
  function _padLeft(shape, N, filler) {
    return [...Array(N - shape.length).fill(filler), ...shape];
  }
  function _stretch(arrayToStretch, sizeToStretch, dimToStretch) {
    return concat2(...Array(sizeToStretch).fill(arrayToStretch), dimToStretch);
  }
});
var name$46 = "matrixAlgorithmSuite";
var dependencies$46 = ["typed", "matrix", "concat"];
var createMatrixAlgorithmSuite = /* @__PURE__ */ factory(name$46, dependencies$46, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  } = _ref;
  var matAlgo13xDD = createMatAlgo13xDD({
    typed: typed2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var broadcast = createBroadcast({
    concat: concat2
  });
  return function matrixAlgorithmSuite(options) {
    var elop = options.elop;
    var SD = options.SD || options.DS;
    var matrixSignatures;
    if (elop) {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": (x, y) => matAlgo13xDD(...broadcast(x, y), elop),
        "Array, Array": (x, y) => matAlgo13xDD(...broadcast(matrix2(x), matrix2(y)), elop).valueOf(),
        "Array, DenseMatrix": (x, y) => matAlgo13xDD(...broadcast(matrix2(x), y), elop),
        "DenseMatrix, Array": (x, y) => matAlgo13xDD(...broadcast(x, matrix2(y)), elop)
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = (x, y) => options.SS(...broadcast(x, y), elop, false);
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = (x, y) => options.DS(...broadcast(x, y), elop, false);
        matrixSignatures["Array, SparseMatrix"] = (x, y) => options.DS(...broadcast(matrix2(x), y), elop, false);
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = (x, y) => SD(...broadcast(y, x), elop, true);
        matrixSignatures["SparseMatrix, Array"] = (x, y) => SD(...broadcast(matrix2(y), x), elop, true);
      }
    } else {
      matrixSignatures = {
        "DenseMatrix, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(x, y), self2);
        }),
        "Array, Array": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(matrix2(x), matrix2(y)), self2).valueOf();
        }),
        "Array, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(matrix2(x), y), self2);
        }),
        "DenseMatrix, Array": typed2.referToSelf((self2) => (x, y) => {
          return matAlgo13xDD(...broadcast(x, matrix2(y)), self2);
        })
      };
      if (options.SS) {
        matrixSignatures["SparseMatrix, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.SS(...broadcast(x, y), self2, false);
        });
      }
      if (options.DS) {
        matrixSignatures["DenseMatrix, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.DS(...broadcast(x, y), self2, false);
        });
        matrixSignatures["Array, SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return options.DS(...broadcast(matrix2(x), y), self2, false);
        });
      }
      if (SD) {
        matrixSignatures["SparseMatrix, DenseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return SD(...broadcast(y, x), self2, true);
        });
        matrixSignatures["SparseMatrix, Array"] = typed2.referToSelf((self2) => (x, y) => {
          return SD(...broadcast(matrix2(y), x), self2, true);
        });
      }
    }
    var scalar = options.scalar || "any";
    var Ds = options.Ds || options.Ss;
    if (Ds) {
      if (elop) {
        matrixSignatures["DenseMatrix," + scalar] = (x, y) => matAlgo14xDs(x, y, elop, false);
        matrixSignatures[scalar + ", DenseMatrix"] = (x, y) => matAlgo14xDs(y, x, elop, true);
        matrixSignatures["Array," + scalar] = (x, y) => matAlgo14xDs(matrix2(x), y, elop, false).valueOf();
        matrixSignatures[scalar + ", Array"] = (x, y) => matAlgo14xDs(matrix2(y), x, elop, true).valueOf();
      } else {
        matrixSignatures["DenseMatrix," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(x, y, self2, false);
        });
        matrixSignatures[scalar + ", DenseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(y, x, self2, true);
        });
        matrixSignatures["Array," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(matrix2(x), y, self2, false).valueOf();
        });
        matrixSignatures[scalar + ", Array"] = typed2.referToSelf((self2) => (x, y) => {
          return matAlgo14xDs(matrix2(y), x, self2, true).valueOf();
        });
      }
    }
    var sS = options.sS !== void 0 ? options.sS : options.Ss;
    if (elop) {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = (x, y) => options.Ss(x, y, elop, false);
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = (x, y) => sS(y, x, elop, true);
      }
    } else {
      if (options.Ss) {
        matrixSignatures["SparseMatrix," + scalar] = typed2.referToSelf((self2) => (x, y) => {
          return options.Ss(x, y, self2, false);
        });
      }
      if (sS) {
        matrixSignatures[scalar + ", SparseMatrix"] = typed2.referToSelf((self2) => (x, y) => {
          return sS(y, x, self2, true);
        });
      }
    }
    if (elop && elop.signatures) {
      extend(matrixSignatures, elop.signatures);
    }
    return matrixSignatures;
  };
});
var name$45 = "mod";
var dependencies$45 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createMod = /* @__PURE__ */ factory(name$45, dependencies$45, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var floor2 = createFloor({
    typed: typed2,
    config: config3,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$45, {
    "number, number": _modNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return y.isZero() ? x : x.sub(y.mul(floor2(x.div(y))));
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return y.equals(0) ? x : x.sub(y.mul(floor2(x.div(y))));
    }
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
  function _modNumber(x, y) {
    return y === 0 ? x : x - y * floor2(x / y);
  }
});
var name$44 = "matAlgo01xDSid";
var dependencies$44 = ["typed"];
var createMatAlgo01xDSid = /* @__PURE__ */ factory(name$44, dependencies$44, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return function algorithm1(denseMatrix, sparseMatrix, callback, inverse) {
    var adata = denseMatrix._data;
    var asize = denseMatrix._size;
    var adt = denseMatrix._datatype || denseMatrix.getDataType();
    var bvalues = sparseMatrix._values;
    var bindex = sparseMatrix._index;
    var bptr = sparseMatrix._ptr;
    var bsize = sparseMatrix._size;
    var bdt = sparseMatrix._datatype || sparseMatrix._data === void 0 ? sparseMatrix._datatype : sparseMatrix.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!bvalues) {
      throw new Error("Cannot perform operation on Dense Matrix and Pattern Sparse Matrix");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt = typeof adt === "string" && adt !== "mixed" && adt === bdt ? adt : void 0;
    var cf = dt ? typed2.find(callback, [dt, dt]) : callback;
    var i2, j;
    var cdata = [];
    for (i2 = 0; i2 < rows; i2++) {
      cdata[i2] = [];
    }
    var x = [];
    var w = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        x[i2] = inverse ? cf(bvalues[k], adata[i2][j]) : cf(adata[i2][j], bvalues[k]);
        w[i2] = mark;
      }
      for (i2 = 0; i2 < rows; i2++) {
        if (w[i2] === mark) {
          cdata[i2][j] = x[i2];
        } else {
          cdata[i2][j] = adata[i2][j];
        }
      }
    }
    return denseMatrix.createDenseMatrix({
      data: cdata,
      size: [rows, columns],
      datatype: adt === denseMatrix._datatype && bdt === sparseMatrix._datatype ? dt : void 0
    });
  };
});
var name$43 = "matAlgo04xSidSid";
var dependencies$43 = ["typed", "equalScalar"];
var createMatAlgo04xSidSid = /* @__PURE__ */ factory(name$43, dependencies$43, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo04xSidSid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var xa = avalues && bvalues ? [] : void 0;
    var xb = avalues && bvalues ? [] : void 0;
    var wa = [];
    var wb = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        cindex.push(i2);
        wa[i2] = mark;
        if (xa) {
          xa[i2] = avalues[k];
        }
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (wa[i2] === mark) {
          if (xa) {
            var v = cf(xa[i2], bvalues[k]);
            if (!eq(v, zero)) {
              xa[i2] = v;
            } else {
              wa[i2] = null;
            }
          }
        } else {
          cindex.push(i2);
          wb[i2] = mark;
          if (xb) {
            xb[i2] = bvalues[k];
          }
        }
      }
      if (xa && xb) {
        k = cptr[j];
        while (k < cindex.length) {
          i2 = cindex[k];
          if (wa[i2] === mark) {
            cvalues[k] = xa[i2];
            k++;
          } else if (wb[i2] === mark) {
            cvalues[k] = xb[i2];
            k++;
          } else {
            cindex.splice(k, 1);
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});
var name$42 = "matAlgo10xSids";
var dependencies$42 = ["typed", "DenseMatrix"];
var createMatAlgo10xSids = /* @__PURE__ */ factory(name$42, dependencies$42, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo10xSids(s, b, callback, inverse) {
    var avalues = s._values;
    var aindex = s._index;
    var aptr = s._ptr;
    var asize = s._size;
    var adt = s._datatype;
    if (!avalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrix and Scalar value");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var cf = callback;
    if (typeof adt === "string") {
      dt = adt;
      b = typed2.convert(b, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cdata = [];
    var x = [];
    var w = [];
    for (var j = 0; j < columns; j++) {
      var mark = j + 1;
      for (var k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        var r = aindex[k];
        x[r] = avalues[k];
        w[r] = mark;
      }
      for (var i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          cdata[i2] = [];
        }
        if (w[i2] === mark) {
          cdata[i2][j] = inverse ? cf(b, x[i2]) : cf(x[i2], b);
        } else {
          cdata[i2][j] = b;
        }
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: dt
    });
  };
});
function ArgumentsError(fn, count2, min2, max2) {
  if (!(this instanceof ArgumentsError)) {
    throw new SyntaxError("Constructor must be called with the new operator");
  }
  this.fn = fn;
  this.count = count2;
  this.min = min2;
  this.max = max2;
  this.message = "Wrong number of arguments in function " + fn + " (" + count2 + " provided, " + min2 + (max2 !== void 0 && max2 !== null ? "-" + max2 : "") + " expected)";
  this.stack = new Error().stack;
}
ArgumentsError.prototype = new Error();
ArgumentsError.prototype.constructor = Error;
ArgumentsError.prototype.name = "ArgumentsError";
ArgumentsError.prototype.isArgumentsError = true;
var name$41 = "gcd";
var dependencies$41 = ["typed", "config", "round", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix", "concat"];
var gcdTypes = "number | BigNumber | Fraction | Matrix | Array";
var gcdManyTypesSignature = "".concat(gcdTypes, ", ").concat(gcdTypes, ", ...").concat(gcdTypes);
function is1d(array) {
  return !array.some((element2) => Array.isArray(element2));
}
var createGcd = /* @__PURE__ */ factory(name$41, dependencies$41, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    config: config3,
    round: round2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var mod2 = createMod({
    typed: typed2,
    config: config3,
    round: round2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  });
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$41, {
    "number, number": _gcdNumber,
    "BigNumber, BigNumber": _gcdBigNumber,
    "Fraction, Fraction": (x, y) => x.gcd(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }), {
    [gcdManyTypesSignature]: typed2.referToSelf((self2) => (a, b, args) => {
      var res = self2(a, b);
      for (var i2 = 0; i2 < args.length; i2++) {
        res = self2(res, args[i2]);
      }
      return res;
    }),
    Array: typed2.referToSelf((self2) => (array) => {
      if (array.length === 1 && Array.isArray(array[0]) && is1d(array[0])) {
        return self2(...array[0]);
      }
      if (is1d(array)) {
        return self2(...array);
      }
      throw new ArgumentsError("gcd() supports only 1d matrices!");
    }),
    Matrix: typed2.referToSelf((self2) => (matrix3) => {
      return self2(matrix3.toArray());
    })
  });
  function _gcdNumber(a, b) {
    if (!isInteger$1(a) || !isInteger$1(b)) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var r;
    while (b !== 0) {
      r = mod2(a, b);
      a = b;
      b = r;
    }
    return a < 0 ? -a : a;
  }
  function _gcdBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function gcd must be integer numbers");
    }
    var zero = new BigNumber2(0);
    while (!b.isZero()) {
      var r = mod2(a, b);
      a = b;
      b = r;
    }
    return a.lt(zero) ? a.neg() : a;
  }
});
var name$40 = "matAlgo06xS0S0";
var dependencies$40 = ["typed", "equalScalar"];
var createMatAlgo06xS0S0 = /* @__PURE__ */ factory(name$40, dependencies$40, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo06xS0S0(a, b, callback) {
    var avalues = a._values;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var u = [];
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      scatter(a, j, w, x, u, mark, cindex, cf);
      scatter(b, j, w, x, u, mark, cindex, cf);
      if (x) {
        var k = cptr[j];
        while (k < cindex.length) {
          var i2 = cindex[k];
          if (u[i2] === mark) {
            var v = x[i2];
            if (!eq(v, zero)) {
              cvalues.push(v);
              k++;
            } else {
              cindex.splice(k, 1);
            }
          } else {
            cindex.splice(k, 1);
          }
        }
      } else {
        var p = cptr[j];
        while (p < cindex.length) {
          var r = cindex[p];
          if (u[r] !== mark) {
            cindex.splice(p, 1);
          } else {
            p++;
          }
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});
var name$3$ = "lcm";
var dependencies$3$ = ["typed", "matrix", "equalScalar", "concat"];
var createLcm = /* @__PURE__ */ factory(name$3$, dependencies$3$, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var lcmTypes = "number | BigNumber | Fraction | Matrix | Array";
  var lcmManySignature = {};
  lcmManySignature["".concat(lcmTypes, ", ").concat(lcmTypes, ", ...").concat(lcmTypes)] = typed2.referToSelf((self2) => (a, b, args) => {
    var res = self2(a, b);
    for (var i2 = 0; i2 < args.length; i2++) {
      res = self2(res, args[i2]);
    }
    return res;
  });
  return typed2(name$3$, {
    "number, number": lcmNumber,
    "BigNumber, BigNumber": _lcmBigNumber,
    "Fraction, Fraction": (x, y) => x.lcm(y)
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }), lcmManySignature);
  function _lcmBigNumber(a, b) {
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function lcm must be integer numbers");
    }
    if (a.isZero()) {
      return a;
    }
    if (b.isZero()) {
      return b;
    }
    var prod2 = a.times(b);
    while (!b.isZero()) {
      var t = b;
      b = a.mod(t);
      a = t;
    }
    return prod2.div(a).abs();
  }
});
var name$3_ = "log10";
var dependencies$3_ = ["typed", "config", "Complex"];
var createLog10 = /* @__PURE__ */ factory(name$3_, dependencies$3_, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: _Complex
  } = _ref;
  return typed2(name$3_, {
    number: function number2(x) {
      if (x >= 0 || config3.predictable) {
        return log10Number(x);
      } else {
        return new _Complex(x, 0).log().div(Math.LN10);
      }
    },
    Complex: function Complex2(x) {
      return new _Complex(x).log().div(Math.LN10);
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config3.predictable) {
        return x.log();
      } else {
        return new _Complex(x.toNumber(), 0).log().div(Math.LN10);
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3Z = "log2";
var dependencies$3Z = ["typed", "config", "Complex"];
var createLog2 = /* @__PURE__ */ factory(name$3Z, dependencies$3Z, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$3Z, {
    number: function number2(x) {
      if (x >= 0 || config3.predictable) {
        return log2Number(x);
      } else {
        return _log2Complex(new Complex2(x, 0));
      }
    },
    Complex: _log2Complex,
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config3.predictable) {
        return x.log(2);
      } else {
        return _log2Complex(new Complex2(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
  function _log2Complex(x) {
    var newX = Math.sqrt(x.re * x.re + x.im * x.im);
    return new Complex2(Math.log2 ? Math.log2(newX) : Math.log(newX) / Math.LN2, Math.atan2(x.im, x.re) / Math.LN2);
  }
});
var name$3Y = "multiplyScalar";
var dependencies$3Y = ["typed"];
var createMultiplyScalar = /* @__PURE__ */ factory(name$3Y, dependencies$3Y, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("multiplyScalar", {
    "number, number": multiplyNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.mul(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.times(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.mul(y);
    },
    "number | Fraction | BigNumber | Complex, Unit": (x, y) => y.multiply(x),
    "Unit, number | Fraction | BigNumber | Complex | Unit": (x, y) => x.multiply(y)
  });
});
var name$3X = "multiply";
var dependencies$3X = ["typed", "matrix", "addScalar", "multiplyScalar", "equalScalar", "dot"];
var createMultiply = /* @__PURE__ */ factory(name$3X, dependencies$3X, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    equalScalar: equalScalar2,
    dot: dot2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  function _validateMatrixDimensions(size1, size2) {
    switch (size1.length) {
      case 1:
        switch (size2.length) {
          case 1:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vectors must have the same length");
            }
            break;
          case 2:
            if (size1[0] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Vector length (" + size1[0] + ") must match Matrix rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      case 2:
        switch (size2.length) {
          case 1:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix columns (" + size1[1] + ") must match Vector length (" + size2[0] + ")");
            }
            break;
          case 2:
            if (size1[1] !== size2[0]) {
              throw new RangeError("Dimension mismatch in multiplication. Matrix A columns (" + size1[1] + ") must match Matrix B rows (" + size2[0] + ")");
            }
            break;
          default:
            throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix B has " + size2.length + " dimensions)");
        }
        break;
      default:
        throw new Error("Can only multiply a 1 or 2 dimensional matrix (Matrix A has " + size1.length + " dimensions)");
    }
  }
  function _multiplyVectorVector(a, b, n) {
    if (n === 0) {
      throw new Error("Cannot multiply two empty vectors");
    }
    return dot2(a, b);
  }
  function _multiplyVectorMatrix(a, b) {
    if (b.storage() !== "dense") {
      throw new Error("Support for SparseMatrix not implemented");
    }
    return _multiplyVectorDenseMatrix(a, b);
  }
  function _multiplyVectorDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype || b.getDataType();
    var alength = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var j = 0; j < bcolumns; j++) {
      var sum2 = mf(adata[0], bdata[0][j]);
      for (var i2 = 1; i2 < alength; i2++) {
        sum2 = af(sum2, mf(adata[i2], bdata[i2][j]));
      }
      c[j] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  var _multiplyMatrixVector = typed2("_multiplyMatrixVector", {
    "DenseMatrix, any": _multiplyDenseMatrixVector,
    "SparseMatrix, any": _multiplySparseMatrixVector
  });
  var _multiplyMatrixMatrix = typed2("_multiplyMatrixMatrix", {
    "DenseMatrix, DenseMatrix": _multiplyDenseMatrixDenseMatrix,
    "DenseMatrix, SparseMatrix": _multiplyDenseMatrixSparseMatrix,
    "SparseMatrix, DenseMatrix": _multiplySparseMatrixDenseMatrix,
    "SparseMatrix, SparseMatrix": _multiplySparseMatrixSparseMatrix
  });
  function _multiplyDenseMatrixVector(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = asize[0];
    var acolumns = asize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      var sum2 = mf(row2[0], bdata[0]);
      for (var j = 1; j < acolumns; j++) {
        sum2 = af(sum2, mf(row2[j], bdata[j]));
      }
      c[i2] = sum2;
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplyDenseMatrixDenseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bdata = b._data;
    var bsize = b._size;
    var bdt = b._datatype || b.getDataType();
    var arows = asize[0];
    var acolumns = asize[1];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var c = [];
    for (var i2 = 0; i2 < arows; i2++) {
      var row2 = adata[i2];
      c[i2] = [];
      for (var j = 0; j < bcolumns; j++) {
        var sum2 = mf(row2[0], bdata[0][j]);
        for (var x = 1; x < acolumns; x++) {
          sum2 = af(sum2, mf(row2[x], bdata[x][j]));
        }
        c[i2][j] = sum2;
      }
    }
    return a.createDenseMatrix({
      data: c,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplyDenseMatrixSparseMatrix(a, b) {
    var adata = a._data;
    var asize = a._size;
    var adt = a._datatype || a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (!bvalues) {
      throw new Error("Cannot multiply Dense Matrix times Pattern only Matrix");
    }
    var arows = asize[0];
    var bcolumns = bsize[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = b.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var kb0 = bptr[jb];
      var kb1 = bptr[jb + 1];
      if (kb1 > kb0) {
        var last = 0;
        for (var i2 = 0; i2 < arows; i2++) {
          var mark = i2 + 1;
          var cij = void 0;
          for (var kb = kb0; kb < kb1; kb++) {
            var ib = bindex[kb];
            if (last !== mark) {
              cij = mf(adata[i2][ib], bvalues[kb]);
              last = mark;
            } else {
              cij = af(cij, mf(adata[i2][ib], bvalues[kb]));
            }
          }
          if (last === mark && !eq(cij, zero)) {
            cindex.push(i2);
            cvalues.push(cij);
          }
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixVector(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = a._size[0];
    var brows = b._size[0];
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var x = [];
    var w = [];
    cptr[0] = 0;
    for (var ib = 0; ib < brows; ib++) {
      var vbi = bdata[ib];
      if (!eq(vbi, zero)) {
        for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
          var ia = aindex[ka];
          if (!w[ia]) {
            w[ia] = true;
            cindex.push(ia);
            x[ia] = mf(vbi, avalues[ka]);
          } else {
            x[ia] = af(x[ia], mf(vbi, avalues[ka]));
          }
        }
      }
    }
    for (var p1 = cindex.length, p = 0; p < p1; p++) {
      var ic = cindex[p];
      cvalues[p] = x[ic];
    }
    cptr[1] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, 1],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  }
  function _multiplySparseMatrixDenseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    if (!avalues) {
      throw new Error("Cannot multiply Pattern only Matrix times Dense Matrix");
    }
    var bdata = b._data;
    var bdt = b._datatype || b.getDataType();
    var arows = a._size[0];
    var brows = b._size[0];
    var bcolumns = b._size[1];
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    var eq = equalScalar2;
    var zero = 0;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    var x = [];
    var w = [];
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (var ib = 0; ib < brows; ib++) {
        var vbij = bdata[ib][jb];
        if (!eq(vbij, zero)) {
          for (var ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            var ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(vbij, avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(vbij, avalues[ka]));
            }
          }
        }
      }
      for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
        var ic = cindex[p];
        cvalues[p] = x[ic];
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  function _multiplySparseMatrixSparseMatrix(a, b) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    var arows = a._size[0];
    var bcolumns = b._size[1];
    var values = avalues && bvalues;
    var dt;
    var af = addScalar2;
    var mf = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      dt = adt;
      af = typed2.find(addScalar2, [dt, dt]);
      mf = typed2.find(multiplyScalar2, [dt, dt]);
    }
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var c = a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [arows, bcolumns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
    var x = values ? [] : void 0;
    var w = [];
    var ka, ka0, ka1, kb, kb0, kb1, ia, ib;
    for (var jb = 0; jb < bcolumns; jb++) {
      cptr[jb] = cindex.length;
      var mark = jb + 1;
      for (kb0 = bptr[jb], kb1 = bptr[jb + 1], kb = kb0; kb < kb1; kb++) {
        ib = bindex[kb];
        if (values) {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
              x[ia] = mf(bvalues[kb], avalues[ka]);
            } else {
              x[ia] = af(x[ia], mf(bvalues[kb], avalues[ka]));
            }
          }
        } else {
          for (ka0 = aptr[ib], ka1 = aptr[ib + 1], ka = ka0; ka < ka1; ka++) {
            ia = aindex[ka];
            if (w[ia] !== mark) {
              w[ia] = mark;
              cindex.push(ia);
            }
          }
        }
      }
      if (values) {
        for (var p0 = cptr[jb], p1 = cindex.length, p = p0; p < p1; p++) {
          var ic = cindex[p];
          cvalues[p] = x[ic];
        }
      }
    }
    cptr[bcolumns] = cindex.length;
    return c;
  }
  return typed2(name$3X, multiplyScalar2, {
    // we extend the signatures of multiplyScalar with signatures dealing with matrices
    "Array, Array": typed2.referTo("Matrix, Matrix", (selfMM) => (x, y) => {
      _validateMatrixDimensions(arraySize(x), arraySize(y));
      var m = selfMM(matrix2(x), matrix2(y));
      return isMatrix(m) ? m.valueOf() : m;
    }),
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      var xsize = x.size();
      var ysize = y.size();
      _validateMatrixDimensions(xsize, ysize);
      if (xsize.length === 1) {
        if (ysize.length === 1) {
          return _multiplyVectorVector(x, y, xsize[0]);
        }
        return _multiplyVectorMatrix(x, y);
      }
      if (ysize.length === 1) {
        return _multiplyMatrixVector(x, y);
      }
      return _multiplyMatrixMatrix(x, y);
    },
    "Matrix, Array": typed2.referTo("Matrix,Matrix", (selfMM) => (x, y) => selfMM(x, matrix2(y))),
    "Array, Matrix": typed2.referToSelf((self2) => (x, y) => {
      return self2(matrix2(x, y.storage()), y);
    }),
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s(x, y, multiplyScalar2, false);
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs(x, y, multiplyScalar2, false);
    },
    "any, SparseMatrix": function anySparseMatrix(x, y) {
      return matAlgo11xS0s(y, x, multiplyScalar2, true);
    },
    "any, DenseMatrix": function anyDenseMatrix(x, y) {
      return matAlgo14xDs(y, x, multiplyScalar2, true);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs(matrix2(x), y, multiplyScalar2, false).valueOf();
    },
    "any, Array": function anyArray(x, y) {
      return matAlgo14xDs(matrix2(y), x, multiplyScalar2, true).valueOf();
    },
    "any, any": multiplyScalar2,
    "any, any, ...any": typed2.referToSelf((self2) => (x, y, rest) => {
      var result = self2(x, y);
      for (var i2 = 0; i2 < rest.length; i2++) {
        result = self2(result, rest[i2]);
      }
      return result;
    })
  });
});
var name$3W = "nthRoot";
var dependencies$3W = ["typed", "matrix", "equalScalar", "BigNumber", "concat"];
var createNthRoot = /* @__PURE__ */ factory(name$3W, dependencies$3W, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: _BigNumber,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  function complexErr() {
    throw new Error("Complex number not supported in function nthRoot. Use nthRoots instead.");
  }
  return typed2(name$3W, {
    number: nthRootNumber,
    "number, number": nthRootNumber,
    BigNumber: (x) => _bigNthRoot(x, new _BigNumber(2)),
    "BigNumber, BigNumber": _bigNthRoot,
    Complex: complexErr,
    "Complex, number": complexErr,
    Array: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(matrix2(x), 2).valueOf()),
    DenseMatrix: typed2.referTo("DenseMatrix,number", (selfDn) => (x) => selfDn(x, 2)),
    SparseMatrix: typed2.referTo("SparseMatrix,number", (selfSn) => (x) => selfSn(x, 2)),
    "SparseMatrix, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo06xS0S0(x, y, self2);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "DenseMatrix, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo01xDSid(x, y, self2, false);
      } else {
        throw new Error("Root must be non-zero");
      }
    }),
    "Array, SparseMatrix": typed2.referTo("DenseMatrix,SparseMatrix", (selfDS) => (x, y) => selfDS(matrix2(x), y)),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (y.density() === 1) {
        return matAlgo11xS0s(y, x, self2, true);
      } else {
        throw new Error("Root must be non-zero");
      }
    })
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: false
  }));
  function _bigNthRoot(a, root) {
    var precision = _BigNumber.precision;
    var Big = _BigNumber.clone({
      precision: precision + 2
    });
    var zero = new _BigNumber(0);
    var one = new Big(1);
    var inv2 = root.isNegative();
    if (inv2) {
      root = root.neg();
    }
    if (root.isZero()) {
      throw new Error("Root must be non-zero");
    }
    if (a.isNegative() && !root.abs().mod(2).equals(1)) {
      throw new Error("Root must be odd when a is negative.");
    }
    if (a.isZero()) {
      return inv2 ? new Big(Infinity) : 0;
    }
    if (!a.isFinite()) {
      return inv2 ? zero : a;
    }
    var x = a.abs().pow(one.div(root));
    x = a.isNeg() ? x.neg() : x;
    return new _BigNumber((inv2 ? one.div(x) : x).toPrecision(precision));
  }
});
var name$3V = "sign";
var dependencies$3V = ["typed", "BigNumber", "Fraction", "complex"];
var createSign = /* @__PURE__ */ factory(name$3V, dependencies$3V, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber,
    complex: complex2,
    Fraction: _Fraction
  } = _ref;
  return typed2(name$3V, {
    number: signNumber,
    Complex: function Complex2(x) {
      return x.im === 0 ? complex2(signNumber(x.re)) : x.sign();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(x.cmp(0));
    },
    Fraction: function Fraction2(x) {
      return new _Fraction(x.s, 1);
    },
    // deep map collection, skip zeros since sign(0) = 0
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    Unit: typed2.referToSelf((self2) => (x) => {
      if (!x._isDerived() && x.units[0].unit.offset !== 0) {
        throw new TypeError("sign is ambiguous for units with offset");
      }
      return typed2.find(self2, x.valueType())(x.value);
    })
  });
});
var name$3U = "sqrt";
var dependencies$3U = ["config", "typed", "Complex"];
var createSqrt = /* @__PURE__ */ factory(name$3U, dependencies$3U, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    Complex: Complex2
  } = _ref;
  return typed2("sqrt", {
    number: _sqrtNumber,
    Complex: function Complex3(x) {
      return x.sqrt();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config3.predictable) {
        return x.sqrt();
      } else {
        return _sqrtNumber(x.toNumber());
      }
    },
    Unit: function Unit2(x) {
      return x.pow(0.5);
    }
  });
  function _sqrtNumber(x) {
    if (isNaN(x)) {
      return NaN;
    } else if (x >= 0 || config3.predictable) {
      return Math.sqrt(x);
    } else {
      return new Complex2(x, 0).sqrt();
    }
  }
});
var name$3T = "square";
var dependencies$3T = ["typed"];
var createSquare = /* @__PURE__ */ factory(name$3T, dependencies$3T, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3T, {
    number: squareNumber,
    Complex: function Complex2(x) {
      return x.mul(x);
    },
    BigNumber: function BigNumber2(x) {
      return x.times(x);
    },
    Fraction: function Fraction2(x) {
      return x.mul(x);
    },
    Unit: function Unit2(x) {
      return x.pow(2);
    }
  });
});
var name$3S = "subtract";
var dependencies$3S = ["typed", "matrix", "equalScalar", "subtractScalar", "unaryMinus", "DenseMatrix", "concat"];
var createSubtract = /* @__PURE__ */ factory(name$3S, dependencies$3S, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    subtractScalar: subtractScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$3S, {
    "any, any": subtractScalar2
  }, matrixAlgorithmSuite({
    elop: subtractScalar2,
    SS: matAlgo05xSfSf,
    DS: matAlgo01xDSid,
    SD: matAlgo03xDSf,
    Ss: matAlgo12xSfs,
    sS: matAlgo10xSids
  }));
});
var name$3R = "xgcd";
var dependencies$3R = ["typed", "config", "matrix", "BigNumber"];
var createXgcd = /* @__PURE__ */ factory(name$3R, dependencies$3R, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name$3R, {
    "number, number": function numberNumber(a, b) {
      var res = xgcdNumber(a, b);
      return config3.matrix === "Array" ? res : matrix2(res);
    },
    "BigNumber, BigNumber": _xgcdBigNumber
    // TODO: implement support for Fraction
  });
  function _xgcdBigNumber(a, b) {
    var t;
    var q;
    var r;
    var zero = new BigNumber2(0);
    var one = new BigNumber2(1);
    var x = zero;
    var lastx = one;
    var y = one;
    var lasty = zero;
    if (!a.isInt() || !b.isInt()) {
      throw new Error("Parameters in function xgcd must be integer numbers");
    }
    while (!b.isZero()) {
      q = a.div(b).floor();
      r = a.mod(b);
      t = x;
      x = lastx.minus(q.times(x));
      lastx = t;
      t = y;
      y = lasty.minus(q.times(y));
      lasty = t;
      a = b;
      b = r;
    }
    var res;
    if (a.lt(zero)) {
      res = [a.neg(), lastx.neg(), lasty.neg()];
    } else {
      res = [a, !a.isZero() ? lastx : 0, lasty];
    }
    return config3.matrix === "Array" ? res : matrix2(res);
  }
});
var name$3Q = "invmod";
var dependencies$3Q = ["typed", "config", "BigNumber", "xgcd", "equal", "smaller", "mod", "add", "isInteger"];
var createInvmod = /* @__PURE__ */ factory(name$3Q, dependencies$3Q, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    BigNumber: BigNumber2,
    xgcd: xgcd2,
    equal: equal2,
    smaller: smaller2,
    mod: mod2,
    add: add2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$3Q, {
    "number, number": invmod2,
    "BigNumber, BigNumber": invmod2
  });
  function invmod2(a, b) {
    if (!isInteger2(a) || !isInteger2(b))
      throw new Error("Parameters in function invmod must be integer numbers");
    a = mod2(a, b);
    if (equal2(b, 0))
      throw new Error("Divisor must be non zero");
    var res = xgcd2(a, b);
    res = res.valueOf();
    var [gcd2, inv2] = res;
    if (!equal2(gcd2, BigNumber2(1)))
      return NaN;
    inv2 = mod2(inv2, b);
    if (smaller2(inv2, BigNumber2(0)))
      inv2 = add2(inv2, b);
    return inv2;
  }
});
var name$3P = "matAlgo09xS0Sf";
var dependencies$3P = ["typed", "equalScalar"];
var createMatAlgo09xS0Sf = /* @__PURE__ */ factory(name$3P, dependencies$3P, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo09xS0Sf(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = avalues && bvalues ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var x = cvalues ? [] : void 0;
    var w = [];
    var i2, j, k, k0, k1;
    for (j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      if (x) {
        for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
          i2 = bindex[k];
          w[i2] = mark;
          x[i2] = bvalues[k];
        }
      }
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        if (x) {
          var vb = w[i2] === mark ? x[i2] : zero;
          var vc = cf(avalues[k], vb);
          if (!eq(vc, zero)) {
            cindex.push(i2);
            cvalues.push(vc);
          }
        } else {
          cindex.push(i2);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});
var name$3O = "dotMultiply";
var dependencies$3O = ["typed", "matrix", "equalScalar", "multiplyScalar", "concat"];
var createDotMultiply = /* @__PURE__ */ factory(name$3O, dependencies$3O, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    multiplyScalar: multiplyScalar2,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$3O, matrixAlgorithmSuite({
    elop: multiplyScalar2,
    SS: matAlgo09xS0Sf,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});
function bitAndBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitAnd");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.eq(-1) || x.eq(y)) {
    return x;
  }
  if (y.isZero() || x.eq(-1)) {
    return y;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      if (x.isNegative() === y.isNegative()) {
        return x;
      }
      return new BigNumber2(0);
    }
    if (!x.isFinite()) {
      if (y.isNegative()) {
        return x;
      }
      if (x.isNegative()) {
        return new BigNumber2(0);
      }
      return y;
    }
    if (!y.isFinite()) {
      if (x.isNegative()) {
        return y;
      }
      if (y.isNegative()) {
        return new BigNumber2(0);
      }
      return x;
    }
  }
  return bitwise(x, y, function(a, b) {
    return a & b;
  });
}
function bitNotBigNumber(x) {
  if (x.isFinite() && !x.isInteger()) {
    throw new Error("Integer expected in function bitNot");
  }
  var BigNumber2 = x.constructor;
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  var result = x.plus(new BigNumber2(1));
  result.s = -result.s || null;
  BigNumber2.config({
    precision: prevPrec
  });
  return result;
}
function bitOrBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitOr");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  var negOne = new BigNumber2(-1);
  if (x.isZero() || y.eq(negOne) || x.eq(y)) {
    return y;
  }
  if (y.isZero() || x.eq(negOne)) {
    return x;
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !x.isNegative() && y.isNegative() || x.isNegative() && !y.isNegative() && !y.isFinite()) {
      return negOne;
    }
    if (x.isNegative() && y.isNegative()) {
      return x.isFinite() ? x : y;
    }
    return x.isFinite() ? y : x;
  }
  return bitwise(x, y, function(a, b) {
    return a | b;
  });
}
function bitwise(x, y, func) {
  var BigNumber2 = x.constructor;
  var xBits, yBits;
  var xSign = +(x.s < 0);
  var ySign = +(y.s < 0);
  if (xSign) {
    xBits = decCoefficientToBinaryString(bitNotBigNumber(x));
    for (var i2 = 0; i2 < xBits.length; ++i2) {
      xBits[i2] ^= 1;
    }
  } else {
    xBits = decCoefficientToBinaryString(x);
  }
  if (ySign) {
    yBits = decCoefficientToBinaryString(bitNotBigNumber(y));
    for (var _i = 0; _i < yBits.length; ++_i) {
      yBits[_i] ^= 1;
    }
  } else {
    yBits = decCoefficientToBinaryString(y);
  }
  var minBits, maxBits, minSign;
  if (xBits.length <= yBits.length) {
    minBits = xBits;
    maxBits = yBits;
    minSign = xSign;
  } else {
    minBits = yBits;
    maxBits = xBits;
    minSign = ySign;
  }
  var shortLen = minBits.length;
  var longLen = maxBits.length;
  var expFuncVal = func(xSign, ySign) ^ 1;
  var outVal = new BigNumber2(expFuncVal ^ 1);
  var twoPower = new BigNumber2(1);
  var two = new BigNumber2(2);
  var prevPrec = BigNumber2.precision;
  BigNumber2.config({
    precision: 1e9
  });
  while (shortLen > 0) {
    if (func(minBits[--shortLen], maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  while (longLen > 0) {
    if (func(minSign, maxBits[--longLen]) === expFuncVal) {
      outVal = outVal.plus(twoPower);
    }
    twoPower = twoPower.times(two);
  }
  BigNumber2.config({
    precision: prevPrec
  });
  if (expFuncVal === 0) {
    outVal.s = -outVal.s;
  }
  return outVal;
}
function decCoefficientToBinaryString(x) {
  var a = x.d;
  var r = a[0] + "";
  for (var i2 = 1; i2 < a.length; ++i2) {
    var s = a[i2] + "";
    for (var z = 7 - s.length; z--; ) {
      s = "0" + s;
    }
    r += s;
  }
  var j = r.length;
  while (r.charAt(j) === "0") {
    j--;
  }
  var xe = x.e;
  var str = r.slice(0, j + 1 || 1);
  var strL = str.length;
  if (xe > 0) {
    if (++xe > strL) {
      xe -= strL;
      while (xe--) {
        str += "0";
      }
    } else if (xe < strL) {
      str = str.slice(0, xe) + "." + str.slice(xe);
    }
  }
  var arr = [0];
  for (var _i2 = 0; _i2 < str.length; ) {
    var arrL = arr.length;
    while (arrL--) {
      arr[arrL] *= 10;
    }
    arr[0] += parseInt(str.charAt(_i2++));
    for (var _j = 0; _j < arr.length; ++_j) {
      if (arr[_j] > 1) {
        if (arr[_j + 1] === null || arr[_j + 1] === void 0) {
          arr[_j + 1] = 0;
        }
        arr[_j + 1] += arr[_j] >> 1;
        arr[_j] &= 1;
      }
    }
  }
  return arr.reverse();
}
function bitXor$1(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function bitXor");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero()) {
    return y;
  }
  if (y.isZero()) {
    return x;
  }
  if (x.eq(y)) {
    return new BigNumber2(0);
  }
  var negOne = new BigNumber2(-1);
  if (x.eq(negOne)) {
    return bitNotBigNumber(y);
  }
  if (y.eq(negOne)) {
    return bitNotBigNumber(x);
  }
  if (!x.isFinite() || !y.isFinite()) {
    if (!x.isFinite() && !y.isFinite()) {
      return negOne;
    }
    return new BigNumber2(x.isNegative() === y.isNegative() ? Infinity : -Infinity);
  }
  return bitwise(x, y, function(a, b) {
    return a ^ b;
  });
}
function leftShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function leftShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!x.isFinite() && !y.isFinite()) {
    return new BigNumber2(NaN);
  }
  if (y.lt(55)) {
    return x.times(Math.pow(2, y.toNumber()) + "");
  }
  return x.times(new BigNumber2(2).pow(y));
}
function rightArithShiftBigNumber(x, y) {
  if (x.isFinite() && !x.isInteger() || y.isFinite() && !y.isInteger()) {
    throw new Error("Integers expected in function rightArithShift");
  }
  var BigNumber2 = x.constructor;
  if (x.isNaN() || y.isNaN() || y.isNegative() && !y.isZero()) {
    return new BigNumber2(NaN);
  }
  if (x.isZero() || y.isZero()) {
    return x;
  }
  if (!y.isFinite()) {
    if (x.isNegative()) {
      return new BigNumber2(-1);
    }
    if (!x.isFinite()) {
      return new BigNumber2(NaN);
    }
    return new BigNumber2(0);
  }
  if (y.lt(55)) {
    return x.div(Math.pow(2, y.toNumber()) + "").floor();
  }
  return x.div(new BigNumber2(2).pow(y)).floor();
}
var name$3N = "bitAnd";
var dependencies$3N = ["typed", "matrix", "equalScalar", "concat"];
var createBitAnd = /* @__PURE__ */ factory(name$3N, dependencies$3N, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$3N, {
    "number, number": bitAndNumber,
    "BigNumber, BigNumber": bitAndBigNumber
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0,
    Ss: matAlgo11xS0s
  }));
});
var name$3M = "bitNot";
var dependencies$3M = ["typed"];
var createBitNot = /* @__PURE__ */ factory(name$3M, dependencies$3M, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3M, {
    number: bitNotNumber,
    BigNumber: bitNotBigNumber,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3L = "bitOr";
var dependencies$3L = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOr = /* @__PURE__ */ factory(name$3L, dependencies$3L, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$3L, {
    "number, number": bitOrNumber,
    "BigNumber, BigNumber": bitOrBigNumber
  }, matrixAlgorithmSuite({
    SS: matAlgo04xSidSid,
    DS: matAlgo01xDSid,
    Ss: matAlgo10xSids
  }));
});
var name$3K = "matAlgo07xSSf";
var dependencies$3K = ["typed", "DenseMatrix"];
var createMatAlgo07xSSf = /* @__PURE__ */ factory(name$3K, dependencies$3K, (_ref) => {
  var {
    typed: typed2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function matAlgo07xSSf(a, b, callback) {
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var i2, j;
    var cdata = [];
    for (i2 = 0; i2 < rows; i2++) {
      cdata[i2] = [];
    }
    var xa = [];
    var xb = [];
    var wa = [];
    var wb = [];
    for (j = 0; j < columns; j++) {
      var mark = j + 1;
      _scatter(a, j, wa, xa, mark);
      _scatter(b, j, wb, xb, mark);
      for (i2 = 0; i2 < rows; i2++) {
        var va = wa[i2] === mark ? xa[i2] : zero;
        var vb = wb[i2] === mark ? xb[i2] : zero;
        cdata[i2][j] = cf(va, vb);
      }
    }
    return new DenseMatrix2({
      data: cdata,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
  function _scatter(m, j, w, x, mark) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var k = ptr[j], k1 = ptr[j + 1]; k < k1; k++) {
      var i2 = index2[k];
      w[i2] = mark;
      x[i2] = values[k];
    }
  }
});
var name$3J = "bitXor";
var dependencies$3J = ["typed", "matrix", "DenseMatrix", "concat"];
var createBitXor = /* @__PURE__ */ factory(name$3J, dependencies$3J, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$3J, {
    "number, number": bitXorNumber,
    "BigNumber, BigNumber": bitXor$1
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var name$3I = "arg";
var dependencies$3I = ["typed"];
var createArg = /* @__PURE__ */ factory(name$3I, dependencies$3I, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3I, {
    number: function number2(x) {
      return Math.atan2(0, x);
    },
    BigNumber: function BigNumber2(x) {
      return x.constructor.atan2(0, x);
    },
    Complex: function Complex2(x) {
      return x.arg();
    },
    // TODO: implement BigNumber support for function arg
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3H = "conj";
var dependencies$3H = ["typed"];
var createConj = /* @__PURE__ */ factory(name$3H, dependencies$3H, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3H, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.conjugate(),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3G = "im";
var dependencies$3G = ["typed"];
var createIm = /* @__PURE__ */ factory(name$3G, dependencies$3G, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3G, {
    number: () => 0,
    "BigNumber | Fraction": (x) => x.mul(0),
    Complex: (x) => x.im,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3F = "re";
var dependencies$3F = ["typed"];
var createRe = /* @__PURE__ */ factory(name$3F, dependencies$3F, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3F, {
    "number | BigNumber | Fraction": (x) => x,
    Complex: (x) => x.re,
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3E = "not";
var dependencies$3E = ["typed"];
var createNot = /* @__PURE__ */ factory(name$3E, dependencies$3E, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3E, {
    "null | undefined": () => true,
    number: notNumber,
    Complex: function Complex2(x) {
      return x.re === 0 && x.im === 0;
    },
    BigNumber: function BigNumber2(x) {
      return x.isZero() || x.isNaN();
    },
    Unit: typed2.referToSelf((self2) => (x) => typed2.find(self2, x.valueType())(x.value)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$3D = "or";
var dependencies$3D = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOr = /* @__PURE__ */ factory(name$3D, dependencies$3D, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$3D, {
    "number, number": orNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.re !== 0 || x.im !== 0 || y.re !== 0 || y.im !== 0;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !x.isNaN() || !y.isZero() && !y.isNaN();
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var name$3C = "xor";
var dependencies$3C = ["typed", "matrix", "DenseMatrix", "concat"];
var createXor = /* @__PURE__ */ factory(name$3C, dependencies$3C, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$3C, {
    "number, number": xorNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) !== (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return (!x.isZero() && !x.isNaN()) !== (!y.isZero() && !y.isNaN());
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0))
  }, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var name$3B = "concat";
var dependencies$3B = ["typed", "matrix", "isInteger"];
var createConcat = /* @__PURE__ */ factory(name$3B, dependencies$3B, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$3B, {
    // TODO: change signature to '...Array | Matrix, dim?' when supported
    "...Array | Matrix | number | BigNumber": function ArrayMatrixNumberBigNumber(args) {
      var i2;
      var len = args.length;
      var dim = -1;
      var prevDim;
      var asMatrix = false;
      var matrices = [];
      for (i2 = 0; i2 < len; i2++) {
        var arg2 = args[i2];
        if (isMatrix(arg2)) {
          asMatrix = true;
        }
        if (isNumber(arg2) || isBigNumber(arg2)) {
          if (i2 !== len - 1) {
            throw new Error("Dimension must be specified as last argument");
          }
          prevDim = dim;
          dim = arg2.valueOf();
          if (!isInteger2(dim)) {
            throw new TypeError("Integer number expected for dimension");
          }
          if (dim < 0 || i2 > 0 && dim > prevDim) {
            throw new IndexError(dim, prevDim + 1);
          }
        } else {
          var m = clone$3(arg2).valueOf();
          var size2 = arraySize(m);
          matrices[i2] = m;
          prevDim = dim;
          dim = size2.length - 1;
          if (i2 > 0 && dim !== prevDim) {
            throw new DimensionError(prevDim + 1, dim + 1);
          }
        }
      }
      if (matrices.length === 0) {
        throw new SyntaxError("At least one matrix expected");
      }
      var res = matrices.shift();
      while (matrices.length) {
        res = concat$1(res, matrices.shift(), dim);
      }
      return asMatrix ? matrix2(res) : res;
    },
    "...string": function string2(args) {
      return args.join("");
    }
  });
});
var name$3A = "column";
var dependencies$3A = ["typed", "Index", "matrix", "range"];
var createColumn = /* @__PURE__ */ factory(name$3A, dependencies$3A, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed2(name$3A, {
    "Matrix, number": _column,
    "Array, number": function ArrayNumber(value, column2) {
      return _column(matrix2(clone$3(value)), column2).valueOf();
    }
  });
  function _column(value, column2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(column2, value.size()[1]);
    var rowRange = range2(0, value.size()[0]);
    var index2 = new Index2(rowRange, column2);
    var result = value.subset(index2);
    return isMatrix(result) ? result : matrix2([[result]]);
  }
});
var name$3z = "count";
var dependencies$3z = ["typed", "size", "prod"];
var createCount = /* @__PURE__ */ factory(name$3z, dependencies$3z, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    prod: prod2
  } = _ref;
  return typed2(name$3z, {
    string: function string2(x) {
      return x.length;
    },
    "Matrix | Array": function MatrixArray(x) {
      return prod2(size2(x));
    }
  });
});
var name$3y = "cross";
var dependencies$3y = ["typed", "matrix", "subtract", "multiply"];
var createCross = /* @__PURE__ */ factory(name$3y, dependencies$3y, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    multiply: multiply2
  } = _ref;
  return typed2(name$3y, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix2(_cross(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix2(_cross(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix2(_cross(x, y.toArray()));
    },
    "Array, Array": _cross
  });
  function _cross(x, y) {
    var highestDimension = Math.max(arraySize(x).length, arraySize(y).length);
    x = squeeze$1(x);
    y = squeeze$1(y);
    var xSize = arraySize(x);
    var ySize = arraySize(y);
    if (xSize.length !== 1 || ySize.length !== 1 || xSize[0] !== 3 || ySize[0] !== 3) {
      throw new RangeError("Vectors with length 3 expected (Size A = [" + xSize.join(", ") + "], B = [" + ySize.join(", ") + "])");
    }
    var product2 = [subtract2(multiply2(x[1], y[2]), multiply2(x[2], y[1])), subtract2(multiply2(x[2], y[0]), multiply2(x[0], y[2])), subtract2(multiply2(x[0], y[1]), multiply2(x[1], y[0]))];
    if (highestDimension > 1) {
      return [product2];
    } else {
      return product2;
    }
  }
});
var name$3x = "diag";
var dependencies$3x = ["typed", "matrix", "DenseMatrix", "SparseMatrix"];
var createDiag = /* @__PURE__ */ factory(name$3x, dependencies$3x, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$3x, {
    // FIXME: simplify this huge amount of signatures as soon as typed-function supports optional arguments
    Array: function Array2(x) {
      return _diag(x, 0, arraySize(x), null);
    },
    "Array, number": function ArrayNumber(x, k) {
      return _diag(x, k, arraySize(x), null);
    },
    "Array, BigNumber": function ArrayBigNumber(x, k) {
      return _diag(x, k.toNumber(), arraySize(x), null);
    },
    "Array, string": function ArrayString(x, format2) {
      return _diag(x, 0, arraySize(x), format2);
    },
    "Array, number, string": function ArrayNumberString(x, k, format2) {
      return _diag(x, k, arraySize(x), format2);
    },
    "Array, BigNumber, string": function ArrayBigNumberString(x, k, format2) {
      return _diag(x, k.toNumber(), arraySize(x), format2);
    },
    Matrix: function Matrix2(x) {
      return _diag(x, 0, x.size(), x.storage());
    },
    "Matrix, number": function MatrixNumber(x, k) {
      return _diag(x, k, x.size(), x.storage());
    },
    "Matrix, BigNumber": function MatrixBigNumber(x, k) {
      return _diag(x, k.toNumber(), x.size(), x.storage());
    },
    "Matrix, string": function MatrixString(x, format2) {
      return _diag(x, 0, x.size(), format2);
    },
    "Matrix, number, string": function MatrixNumberString(x, k, format2) {
      return _diag(x, k, x.size(), format2);
    },
    "Matrix, BigNumber, string": function MatrixBigNumberString(x, k, format2) {
      return _diag(x, k.toNumber(), x.size(), format2);
    }
  });
  function _diag(x, k, size2, format2) {
    if (!isInteger$1(k)) {
      throw new TypeError("Second parameter in function diag must be an integer");
    }
    var kSuper = k > 0 ? k : 0;
    var kSub = k < 0 ? -k : 0;
    switch (size2.length) {
      case 1:
        return _createDiagonalMatrix(x, k, format2, size2[0], kSub, kSuper);
      case 2:
        return _getDiagonal(x, k, format2, size2, kSub, kSuper);
    }
    throw new RangeError("Matrix for function diag must be 2 dimensional");
  }
  function _createDiagonalMatrix(x, k, format2, l, kSub, kSuper) {
    var ms = [l + kSub, l + kSuper];
    if (format2 && format2 !== "sparse" && format2 !== "dense") {
      throw new TypeError("Unknown matrix type ".concat(format2, '"'));
    }
    var m = format2 === "sparse" ? SparseMatrix2.diagonal(ms, x, k) : DenseMatrix2.diagonal(ms, x, k);
    return format2 !== null ? m : m.valueOf();
  }
  function _getDiagonal(x, k, format2, s, kSub, kSuper) {
    if (isMatrix(x)) {
      var dm = x.diagonal(k);
      if (format2 !== null) {
        if (format2 !== dm.storage()) {
          return matrix2(dm, format2);
        }
        return dm;
      }
      return dm.valueOf();
    }
    var n = Math.min(s[0] - kSub, s[1] - kSuper);
    var vector = [];
    for (var i2 = 0; i2 < n; i2++) {
      vector[i2] = x[i2 + kSub][i2 + kSuper];
    }
    return format2 !== null ? matrix2(vector) : vector;
  }
});
function applyCallback(callback, value, index2, array, mappingFnName) {
  if (typedFunction.isTypedFunction(callback)) {
    var args3 = [value, index2, array];
    var signature3 = typedFunction.resolve(callback, args3);
    if (signature3) {
      return tryWithArgs(signature3.implementation, args3);
    }
    var args2 = [value, index2];
    var signature2 = typedFunction.resolve(callback, args2);
    if (signature2) {
      return tryWithArgs(signature2.implementation, args2);
    }
    var args1 = [value];
    var signature1 = typedFunction.resolve(callback, args1);
    if (signature1) {
      return tryWithArgs(signature1.implementation, args1);
    }
    return tryWithArgs(callback, args3);
  } else {
    return callback(value, index2, array);
  }
  function tryWithArgs(signature, args) {
    try {
      return signature.apply(signature, args);
    } catch (err) {
      var _err$data;
      if (err instanceof TypeError && ((_err$data = err.data) === null || _err$data === void 0 ? void 0 : _err$data.category) === "wrongType") {
        var argsDesc = [];
        argsDesc.push("value: ".concat(typeOf$1(value)));
        if (args.length >= 2) {
          argsDesc.push("index: ".concat(typeOf$1(index2)));
        }
        if (args.length >= 3) {
          argsDesc.push("array: ".concat(typeOf$1(array)));
        }
        throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "".concat(callback.name, "(").concat(argsDesc.join(", "), ") at index ").concat(JSON.stringify(index2)));
      } else {
        throw new TypeError("Function ".concat(mappingFnName, " cannot apply callback arguments ") + "to function ".concat(callback.name, ": ").concat(err.message));
      }
    }
  }
}
var name$3w = "filter";
var dependencies$3w = ["typed"];
var createFilter = /* @__PURE__ */ factory(name$3w, dependencies$3w, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("filter", {
    "Array, function": _filterCallback,
    "Matrix, function": function MatrixFunction(x, test) {
      return x.create(_filterCallback(x.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x, test) {
      return x.create(filterRegExp(x.toArray(), test));
    }
  });
});
function _filterCallback(x, callback) {
  return filter$1(x, function(value, index2, array) {
    return applyCallback(callback, value, [index2], array, "filter");
  });
}
var name$3v = "flatten";
var dependencies$3v = ["typed", "matrix"];
var createFlatten = /* @__PURE__ */ factory(name$3v, dependencies$3v, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name$3v, {
    Array: function Array2(x) {
      return flatten$1(x);
    },
    Matrix: function Matrix2(x) {
      var flat = flatten$1(x.toArray());
      return matrix2(flat);
    }
  });
});
var name$3u = "forEach";
var dependencies$3u = ["typed"];
var createForEach = /* @__PURE__ */ factory(name$3u, dependencies$3u, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3u, {
    "Array, function": _forEach,
    "Matrix, function": function MatrixFunction(x, callback) {
      x.forEach(callback);
    }
  });
});
function _forEach(array, callback) {
  var recurse = function recurse2(value, index2) {
    if (Array.isArray(value)) {
      forEach$1(value, function(child, i2) {
        recurse2(child, index2.concat(i2));
      });
    } else {
      return applyCallback(callback, value, index2, array, "forEach");
    }
  };
  recurse(array, []);
}
var name$3t = "getMatrixDataType";
var dependencies$3t = ["typed"];
var createGetMatrixDataType = /* @__PURE__ */ factory(name$3t, dependencies$3t, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3t, {
    Array: function Array2(x) {
      return getArrayDataType(x, typeOf$1);
    },
    Matrix: function Matrix2(x) {
      return x.getDataType();
    }
  });
});
var name$3s = "identity";
var dependencies$3s = ["typed", "config", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix"];
var createIdentity = /* @__PURE__ */ factory(name$3s, dependencies$3s, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$3s, {
    "": function _() {
      return config3.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format2) {
      return matrix2(format2);
    },
    "number | BigNumber": function numberBigNumber(rows) {
      return _identity(rows, rows, config3.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, string": function numberBigNumberString(rows, format2) {
      return _identity(rows, rows, format2);
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(rows, cols) {
      return _identity(rows, cols, config3.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber, number | BigNumber, string": function numberBigNumberNumberBigNumberString(rows, cols, format2) {
      return _identity(rows, cols, format2);
    },
    Array: function Array2(size2) {
      return _identityVector(size2);
    },
    "Array, string": function ArrayString(size2, format2) {
      return _identityVector(size2, format2);
    },
    Matrix: function Matrix2(size2) {
      return _identityVector(size2.valueOf(), size2.storage());
    },
    "Matrix, string": function MatrixString(size2, format2) {
      return _identityVector(size2.valueOf(), format2);
    }
  });
  function _identityVector(size2, format2) {
    switch (size2.length) {
      case 0:
        return format2 ? matrix2(format2) : [];
      case 1:
        return _identity(size2[0], size2[0], format2);
      case 2:
        return _identity(size2[0], size2[1], format2);
      default:
        throw new Error("Vector containing two values expected");
    }
  }
  function _identity(rows, cols, format2) {
    var Big = isBigNumber(rows) || isBigNumber(cols) ? BigNumber2 : null;
    if (isBigNumber(rows))
      rows = rows.toNumber();
    if (isBigNumber(cols))
      cols = cols.toNumber();
    if (!isInteger$1(rows) || rows < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    if (!isInteger$1(cols) || cols < 1) {
      throw new Error("Parameters in function identity must be positive integers");
    }
    var one = Big ? new BigNumber2(1) : 1;
    var defaultValue = Big ? new Big(0) : 0;
    var size2 = [rows, cols];
    if (format2) {
      if (format2 === "sparse") {
        return SparseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      if (format2 === "dense") {
        return DenseMatrix2.diagonal(size2, one, 0, defaultValue);
      }
      throw new TypeError('Unknown matrix type "'.concat(format2, '"'));
    }
    var res = resize$1([], size2, defaultValue);
    var minimum = rows < cols ? rows : cols;
    for (var d = 0; d < minimum; d++) {
      res[d][d] = one;
    }
    return res;
  }
});
var name$3r = "kron";
var dependencies$3r = ["typed", "matrix", "multiplyScalar"];
var createKron = /* @__PURE__ */ factory(name$3r, dependencies$3r, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiplyScalar: multiplyScalar2
  } = _ref;
  return typed2(name$3r, {
    "Matrix, Matrix": function MatrixMatrix(x, y) {
      return matrix2(_kron(x.toArray(), y.toArray()));
    },
    "Matrix, Array": function MatrixArray(x, y) {
      return matrix2(_kron(x.toArray(), y));
    },
    "Array, Matrix": function ArrayMatrix(x, y) {
      return matrix2(_kron(x, y.toArray()));
    },
    "Array, Array": _kron
  });
  function _kron(a, b) {
    if (arraySize(a).length === 1) {
      a = [a];
    }
    if (arraySize(b).length === 1) {
      b = [b];
    }
    if (arraySize(a).length > 2 || arraySize(b).length > 2) {
      throw new RangeError("Vectors with dimensions greater then 2 are not supported expected (Size x = " + JSON.stringify(a.length) + ", y = " + JSON.stringify(b.length) + ")");
    }
    var t = [];
    var r = [];
    return a.map(function(a2) {
      return b.map(function(b2) {
        r = [];
        t.push(r);
        return a2.map(function(y) {
          return b2.map(function(x) {
            return r.push(multiplyScalar2(y, x));
          });
        });
      });
    }) && t;
  }
});
var name$3q = "map";
var dependencies$3q = ["typed"];
var createMap = /* @__PURE__ */ factory(name$3q, dependencies$3q, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$3q, {
    "Array, function": _map$1,
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.map(callback);
    }
  });
});
function _map$1(array, callback) {
  var recurse = function recurse2(value, index2) {
    if (Array.isArray(value)) {
      return value.map(function(child, i2) {
        return recurse2(child, index2.concat(i2));
      });
    } else {
      return applyCallback(callback, value, index2, array, "map");
    }
  };
  return recurse(array, []);
}
var name$3p = "diff";
var dependencies$3p = ["typed", "matrix", "subtract", "number"];
var createDiff = /* @__PURE__ */ factory(name$3p, dependencies$3p, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2
  } = _ref;
  return typed2(name$3p, {
    "Array | Matrix": function ArrayMatrix(arr) {
      if (isMatrix(arr)) {
        return matrix2(_diff(arr.toArray()));
      } else {
        return _diff(arr);
      }
    },
    "Array | Matrix, number": function ArrayMatrixNumber(arr, dim) {
      if (!isInteger$1(dim))
        throw new RangeError("Dimension must be a whole number");
      if (isMatrix(arr)) {
        return matrix2(_recursive(arr.toArray(), dim));
      } else {
        return _recursive(arr, dim);
      }
    },
    "Array, BigNumber": typed2.referTo("Array,number", (selfAn) => (arr, dim) => selfAn(arr, number2(dim))),
    "Matrix, BigNumber": typed2.referTo("Matrix,number", (selfMn) => (arr, dim) => selfMn(arr, number2(dim)))
  });
  function _recursive(arr, dim) {
    if (isMatrix(arr)) {
      arr = arr.toArray();
    }
    if (!Array.isArray(arr)) {
      throw RangeError("Array/Matrix does not have that many dimensions");
    }
    if (dim > 0) {
      var result = [];
      arr.forEach((element2) => {
        result.push(_recursive(element2, dim - 1));
      });
      return result;
    } else if (dim === 0) {
      return _diff(arr);
    } else {
      throw RangeError("Cannot have negative dimension");
    }
  }
  function _diff(arr) {
    var result = [];
    var size2 = arr.length;
    for (var i2 = 1; i2 < size2; i2++) {
      result.push(_ElementDiff(arr[i2 - 1], arr[i2]));
    }
    return result;
  }
  function _ElementDiff(obj1, obj2) {
    if (isMatrix(obj1))
      obj1 = obj1.toArray();
    if (isMatrix(obj2))
      obj2 = obj2.toArray();
    var obj1IsArray = Array.isArray(obj1);
    var obj2IsArray = Array.isArray(obj2);
    if (obj1IsArray && obj2IsArray) {
      return _ArrayDiff(obj1, obj2);
    }
    if (!obj1IsArray && !obj2IsArray) {
      return subtract2(obj2, obj1);
    }
    throw TypeError("Cannot calculate difference between 1 array and 1 non-array");
  }
  function _ArrayDiff(arr1, arr2) {
    if (arr1.length !== arr2.length) {
      throw RangeError("Not all sub-arrays have the same length");
    }
    var result = [];
    var size2 = arr1.length;
    for (var i2 = 0; i2 < size2; i2++) {
      result.push(_ElementDiff(arr1[i2], arr2[i2]));
    }
    return result;
  }
});
var name$3o = "ones";
var dependencies$3o = ["typed", "config", "matrix", "BigNumber"];
var createOnes = /* @__PURE__ */ factory(name$3o, dependencies$3o, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2("ones", {
    "": function _() {
      return config3.matrix === "Array" ? _ones([]) : _ones([], "default");
    },
    // math.ones(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function numberBigNumberString(size2) {
      var last = size2[size2.length - 1];
      if (typeof last === "string") {
        var format2 = size2.pop();
        return _ones(size2, format2);
      } else if (config3.matrix === "Array") {
        return _ones(size2);
      } else {
        return _ones(size2, "default");
      }
    },
    Array: _ones,
    Matrix: function Matrix2(size2) {
      var format2 = size2.storage();
      return _ones(size2.valueOf(), format2);
    },
    "Array | Matrix, string": function ArrayMatrixString(size2, format2) {
      return _ones(size2.valueOf(), format2);
    }
  });
  function _ones(size2, format2) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(1) : 1;
    _validate2(size2);
    if (format2) {
      var m = matrix2(format2);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize$1(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger$1(value) || value < 0) {
        throw new Error("Parameters in function ones must be positive integers");
      }
    });
  }
});
function noBignumber() {
  throw new Error('No "bignumber" implementation available');
}
function noFraction() {
  throw new Error('No "fraction" implementation available');
}
function noMatrix() {
  throw new Error('No "matrix" implementation available');
}
var name$3n = "range";
var dependencies$3n = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
var createRange = /* @__PURE__ */ factory(name$3n, dependencies$3n, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2,
    add: add2,
    isPositive: isPositive2
  } = _ref;
  return typed2(name$3n, {
    // TODO: simplify signatures when typed-function supports default values and optional arguments
    // TODO: a number or boolean should not be converted to string here
    string: _strRange,
    "string, boolean": _strRange,
    "number, number": function numberNumber(start, end) {
      return _out(_range(start, end, 1, false));
    },
    "number, number, number": function numberNumberNumber(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "number, number, boolean": function numberNumberBoolean(start, end, includeEnd) {
      return _out(_range(start, end, 1, includeEnd));
    },
    "number, number, number, boolean": function numberNumberNumberBoolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(start, end) {
      var BigNumber2 = start.constructor;
      return _out(_range(start, end, new BigNumber2(1), false));
    },
    "BigNumber, BigNumber, BigNumber": function BigNumberBigNumberBigNumber(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "BigNumber, BigNumber, boolean": function BigNumberBigNumberBoolean(start, end, includeEnd) {
      var BigNumber2 = start.constructor;
      return _out(_range(start, end, new BigNumber2(1), includeEnd));
    },
    "BigNumber, BigNumber, BigNumber, boolean": function BigNumberBigNumberBigNumberBoolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    },
    "Unit, Unit, Unit": function UnitUnitUnit(start, end, step) {
      return _out(_range(start, end, step, false));
    },
    "Unit, Unit, Unit, boolean": function UnitUnitUnitBoolean(start, end, step, includeEnd) {
      return _out(_range(start, end, step, includeEnd));
    }
  });
  function _out(arr) {
    if (config3.matrix === "Matrix") {
      return matrix2 ? matrix2(arr) : noMatrix();
    }
    return arr;
  }
  function _strRange(str, includeEnd) {
    var r = _parse(str);
    if (!r) {
      throw new SyntaxError('String "' + str + '" is no valid range');
    }
    if (config3.number === "BigNumber") {
      if (bignumber2 === void 0) {
        noBignumber();
      }
      return _out(_range(bignumber2(r.start), bignumber2(r.end), bignumber2(r.step)));
    } else {
      return _out(_range(r.start, r.end, r.step, includeEnd));
    }
  }
  function _range(start, end, step, includeEnd) {
    var array = [];
    var ongoing = isPositive2(step) ? includeEnd ? smallerEq2 : smaller2 : includeEnd ? largerEq2 : larger2;
    var x = start;
    while (ongoing(x, end)) {
      array.push(x);
      x = add2(x, step);
    }
    return array;
  }
  function _parse(str) {
    var args = str.split(":");
    var nums = args.map(function(arg2) {
      return Number(arg2);
    });
    var invalid = nums.some(function(num) {
      return isNaN(num);
    });
    if (invalid) {
      return null;
    }
    switch (nums.length) {
      case 2:
        return {
          start: nums[0],
          end: nums[1],
          step: 1
        };
      case 3:
        return {
          start: nums[0],
          end: nums[2],
          step: nums[1]
        };
      default:
        return null;
    }
  }
});
var name$3m = "reshape";
var dependencies$3m = ["typed", "isInteger", "matrix"];
var createReshape = /* @__PURE__ */ factory(name$3m, dependencies$3m, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$3m, {
    "Matrix, Array": function MatrixArray(x, sizes) {
      return x.reshape(sizes, true);
    },
    "Array, Array": function ArrayArray(x, sizes) {
      sizes.forEach(function(size2) {
        if (!isInteger2(size2)) {
          throw new TypeError("Invalid size for dimension: " + size2);
        }
      });
      return reshape$1(x, sizes);
    }
  });
});
var name$3l = "resize";
var dependencies$3l = ["config", "matrix"];
var createResize = /* @__PURE__ */ factory(name$3l, dependencies$3l, (_ref) => {
  var {
    config: config3,
    matrix: matrix2
  } = _ref;
  return function resize2(x, size2, defaultValue) {
    if (arguments.length !== 2 && arguments.length !== 3) {
      throw new ArgumentsError("resize", arguments.length, 2, 3);
    }
    if (isMatrix(size2)) {
      size2 = size2.valueOf();
    }
    if (isBigNumber(size2[0])) {
      size2 = size2.map(function(value) {
        return !isBigNumber(value) ? value : value.toNumber();
      });
    }
    if (isMatrix(x)) {
      return x.resize(size2, defaultValue, true);
    }
    if (typeof x === "string") {
      return _resizeString(x, size2, defaultValue);
    }
    var asMatrix = Array.isArray(x) ? false : config3.matrix !== "Array";
    if (size2.length === 0) {
      while (Array.isArray(x)) {
        x = x[0];
      }
      return clone$3(x);
    } else {
      if (!Array.isArray(x)) {
        x = [x];
      }
      x = clone$3(x);
      var res = resize$1(x, size2, defaultValue);
      return asMatrix ? matrix2(res) : res;
    }
  };
  function _resizeString(str, size2, defaultChar) {
    if (defaultChar !== void 0) {
      if (typeof defaultChar !== "string" || defaultChar.length !== 1) {
        throw new TypeError("Single character expected as defaultValue");
      }
    } else {
      defaultChar = " ";
    }
    if (size2.length !== 1) {
      throw new DimensionError(size2.length, 1);
    }
    var len = size2[0];
    if (typeof len !== "number" || !isInteger$1(len)) {
      throw new TypeError("Invalid size, must contain positive integers (size: " + format$1(size2) + ")");
    }
    if (str.length > len) {
      return str.substring(0, len);
    } else if (str.length < len) {
      var res = str;
      for (var i2 = 0, ii = len - str.length; i2 < ii; i2++) {
        res += defaultChar;
      }
      return res;
    } else {
      return str;
    }
  }
});
var name$3k = "rotate";
var dependencies$3k = ["typed", "multiply", "rotationMatrix"];
var createRotate = /* @__PURE__ */ factory(name$3k, dependencies$3k, (_ref) => {
  var {
    typed: typed2,
    multiply: multiply2,
    rotationMatrix: rotationMatrix2
  } = _ref;
  return typed2(name$3k, {
    "Array , number | BigNumber | Complex | Unit": function ArrayNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      var matrixRes = multiply2(rotationMatrix2(theta), w);
      return matrixRes.toArray();
    },
    "Matrix , number | BigNumber | Complex | Unit": function MatrixNumberBigNumberComplexUnit(w, theta) {
      _validateSize(w, 2);
      return multiply2(rotationMatrix2(theta), w);
    },
    "Array, number | BigNumber | Complex | Unit, Array | Matrix": function ArrayNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      var matrixRes = multiply2(rotationMatrix2(theta, v), w);
      return matrixRes;
    },
    "Matrix, number | BigNumber | Complex | Unit, Array | Matrix": function MatrixNumberBigNumberComplexUnitArrayMatrix(w, theta, v) {
      _validateSize(w, 3);
      return multiply2(rotationMatrix2(theta, v), w);
    }
  });
  function _validateSize(v, expectedSize) {
    var actualSize = Array.isArray(v) ? arraySize(v) : v.size();
    if (actualSize.length > 2) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize.length === 2 && actualSize[1] !== 1) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
    if (actualSize[0] !== expectedSize) {
      throw new RangeError("Vector must be of dimensions 1x".concat(expectedSize));
    }
  }
});
var name$3j = "rotationMatrix";
var dependencies$3j = ["typed", "config", "multiplyScalar", "addScalar", "unaryMinus", "norm", "matrix", "BigNumber", "DenseMatrix", "SparseMatrix", "cos", "sin"];
var createRotationMatrix = /* @__PURE__ */ factory(name$3j, dependencies$3j, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    multiplyScalar: multiplyScalar2,
    addScalar: addScalar2,
    unaryMinus: unaryMinus2,
    norm: norm2,
    BigNumber: BigNumber2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    cos: cos2,
    sin: sin2
  } = _ref;
  return typed2(name$3j, {
    "": function _() {
      return config3.matrix === "Matrix" ? matrix2([]) : [];
    },
    string: function string2(format2) {
      return matrix2(format2);
    },
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(theta) {
      return _rotationMatrix2x2(theta, config3.matrix === "Matrix" ? "dense" : void 0);
    },
    "number | BigNumber | Complex | Unit, string": function numberBigNumberComplexUnitString(theta, format2) {
      return _rotationMatrix2x2(theta, format2);
    },
    "number | BigNumber | Complex | Unit, Array": function numberBigNumberComplexUnitArray(theta, v) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, void 0);
    },
    "number | BigNumber | Complex | Unit, Matrix": function numberBigNumberComplexUnitMatrix(theta, v) {
      _validateVector(v);
      var storageType = v.storage() || (config3.matrix === "Matrix" ? "dense" : void 0);
      return _rotationMatrix3x3(theta, v, storageType);
    },
    "number | BigNumber | Complex | Unit, Array, string": function numberBigNumberComplexUnitArrayString(theta, v, format2) {
      var matrixV = matrix2(v);
      _validateVector(matrixV);
      return _rotationMatrix3x3(theta, matrixV, format2);
    },
    "number | BigNumber | Complex | Unit, Matrix, string": function numberBigNumberComplexUnitMatrixString(theta, v, format2) {
      _validateVector(v);
      return _rotationMatrix3x3(theta, v, format2);
    }
  });
  function _rotationMatrix2x2(theta, format2) {
    var Big = isBigNumber(theta);
    var minusOne = Big ? new BigNumber2(-1) : -1;
    var cosTheta = cos2(theta);
    var sinTheta = sin2(theta);
    var data = [[cosTheta, multiplyScalar2(minusOne, sinTheta)], [sinTheta, cosTheta]];
    return _convertToFormat(data, format2);
  }
  function _validateVector(v) {
    var size2 = v.size();
    if (size2.length < 1 || size2[0] !== 3) {
      throw new RangeError("Vector must be of dimensions 1x3");
    }
  }
  function _mul(array) {
    return array.reduce((p, curr) => multiplyScalar2(p, curr));
  }
  function _convertToFormat(data, format2) {
    if (format2) {
      if (format2 === "sparse") {
        return new SparseMatrix2(data);
      }
      if (format2 === "dense") {
        return new DenseMatrix2(data);
      }
      throw new TypeError('Unknown matrix type "'.concat(format2, '"'));
    }
    return data;
  }
  function _rotationMatrix3x3(theta, v, format2) {
    var normV = norm2(v);
    if (normV === 0) {
      throw new RangeError("Rotation around zero vector");
    }
    var Big = isBigNumber(theta) ? BigNumber2 : null;
    var one = Big ? new Big(1) : 1;
    var minusOne = Big ? new Big(-1) : -1;
    var vx = Big ? new Big(v.get([0]) / normV) : v.get([0]) / normV;
    var vy = Big ? new Big(v.get([1]) / normV) : v.get([1]) / normV;
    var vz = Big ? new Big(v.get([2]) / normV) : v.get([2]) / normV;
    var c = cos2(theta);
    var oneMinusC = addScalar2(one, unaryMinus2(c));
    var s = sin2(theta);
    var r11 = addScalar2(c, _mul([vx, vx, oneMinusC]));
    var r12 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([minusOne, vz, s]));
    var r13 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([vy, s]));
    var r21 = addScalar2(_mul([vx, vy, oneMinusC]), _mul([vz, s]));
    var r22 = addScalar2(c, _mul([vy, vy, oneMinusC]));
    var r23 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([minusOne, vx, s]));
    var r31 = addScalar2(_mul([vx, vz, oneMinusC]), _mul([minusOne, vy, s]));
    var r32 = addScalar2(_mul([vy, vz, oneMinusC]), _mul([vx, s]));
    var r33 = addScalar2(c, _mul([vz, vz, oneMinusC]));
    var data = [[r11, r12, r13], [r21, r22, r23], [r31, r32, r33]];
    return _convertToFormat(data, format2);
  }
});
var name$3i = "row";
var dependencies$3i = ["typed", "Index", "matrix", "range"];
var createRow = /* @__PURE__ */ factory(name$3i, dependencies$3i, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  return typed2(name$3i, {
    "Matrix, number": _row,
    "Array, number": function ArrayNumber(value, row2) {
      return _row(matrix2(clone$3(value)), row2).valueOf();
    }
  });
  function _row(value, row2) {
    if (value.size().length !== 2) {
      throw new Error("Only two dimensional matrix is supported");
    }
    validateIndex(row2, value.size()[0]);
    var columnRange = range2(0, value.size()[1]);
    var index2 = new Index2(row2, columnRange);
    var result = value.subset(index2);
    return isMatrix(result) ? result : matrix2([[result]]);
  }
});
var name$3h = "size";
var dependencies$3h = ["typed", "config", "?matrix"];
var createSize = /* @__PURE__ */ factory(name$3h, dependencies$3h, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2
  } = _ref;
  return typed2(name$3h, {
    Matrix: function Matrix2(x) {
      return x.create(x.size());
    },
    Array: arraySize,
    string: function string2(x) {
      return config3.matrix === "Array" ? [x.length] : matrix2([x.length]);
    },
    "number | Complex | BigNumber | Unit | boolean | null": function numberComplexBigNumberUnitBooleanNull(x) {
      return config3.matrix === "Array" ? [] : matrix2 ? matrix2([]) : noMatrix();
    }
  });
});
var name$3g = "squeeze";
var dependencies$3g = ["typed", "matrix"];
var createSqueeze = /* @__PURE__ */ factory(name$3g, dependencies$3g, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name$3g, {
    Array: function Array2(x) {
      return squeeze$1(clone$3(x));
    },
    Matrix: function Matrix2(x) {
      var res = squeeze$1(x.toArray());
      return Array.isArray(res) ? matrix2(res) : res;
    },
    any: function any(x) {
      return clone$3(x);
    }
  });
});
var name$3f = "subset";
var dependencies$3f = ["typed", "matrix", "zeros", "add"];
var createSubset = /* @__PURE__ */ factory(name$3f, dependencies$3f, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  } = _ref;
  return typed2(name$3f, {
    // get subset
    "Matrix, Index": function MatrixIndex(value, index2) {
      if (isEmptyIndex(index2)) {
        return matrix2();
      }
      validateIndexSourceSize(value, index2);
      return value.subset(index2);
    },
    "Array, Index": typed2.referTo("Matrix, Index", function(subsetRef) {
      return function(value, index2) {
        var subsetResult = subsetRef(matrix2(value), index2);
        return index2.isScalar() ? subsetResult : subsetResult.valueOf();
      };
    }),
    "Object, Index": _getObjectProperty,
    "string, Index": _getSubstring,
    // set subset
    "Matrix, Index, any, any": function MatrixIndexAnyAny(value, index2, replacement, defaultValue) {
      if (isEmptyIndex(index2)) {
        return value;
      }
      validateIndexSourceSize(value, index2);
      return value.clone().subset(index2, _broadcastReplacement(replacement, index2), defaultValue);
    },
    "Array, Index, any, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement, defaultValue) {
        var subsetResult = subsetRef(matrix2(value), index2, replacement, defaultValue);
        return subsetResult.isMatrix ? subsetResult.valueOf() : subsetResult;
      };
    }),
    "Array, Index, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement) {
        return subsetRef(matrix2(value), index2, replacement, void 0).valueOf();
      };
    }),
    "Matrix, Index, any": typed2.referTo("Matrix, Index, any, any", function(subsetRef) {
      return function(value, index2, replacement) {
        return subsetRef(value, index2, replacement, void 0);
      };
    }),
    "string, Index, string": _setSubstring,
    "string, Index, string, string": _setSubstring,
    "Object, Index, any": _setObjectProperty
  });
  function _broadcastReplacement(replacement, index2) {
    if (typeof replacement === "string") {
      throw new Error("can't boradcast a string");
    }
    if (index2._isScalar) {
      return replacement;
    }
    var indexSize = index2.size();
    if (indexSize.every((d) => d > 0)) {
      try {
        return add2(replacement, zeros2(indexSize));
      } catch (error) {
        return replacement;
      }
    } else {
      return replacement;
    }
  }
});
function _getSubstring(str, index2) {
  if (!isIndex(index2)) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index2)) {
    return "";
  }
  validateIndexSourceSize(Array.from(str), index2);
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0], strLen);
  validateIndex(index2.max()[0], strLen);
  var range2 = index2.dimension(0);
  var substr = "";
  range2.forEach(function(v) {
    substr += str.charAt(v);
  });
  return substr;
}
function _setSubstring(str, index2, replacement, defaultValue) {
  if (!index2 || index2.isIndex !== true) {
    throw new TypeError("Index expected");
  }
  if (isEmptyIndex(index2)) {
    return str;
  }
  validateIndexSourceSize(Array.from(str), index2);
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size().length, 1);
  }
  if (defaultValue !== void 0) {
    if (typeof defaultValue !== "string" || defaultValue.length !== 1) {
      throw new TypeError("Single character expected as defaultValue");
    }
  } else {
    defaultValue = " ";
  }
  var range2 = index2.dimension(0);
  var len = range2.size()[0];
  if (len !== replacement.length) {
    throw new DimensionError(range2.size()[0], replacement.length);
  }
  var strLen = str.length;
  validateIndex(index2.min()[0]);
  validateIndex(index2.max()[0]);
  var chars = [];
  for (var i2 = 0; i2 < strLen; i2++) {
    chars[i2] = str.charAt(i2);
  }
  range2.forEach(function(v, i3) {
    chars[v] = replacement.charAt(i3[0]);
  });
  if (chars.length > strLen) {
    for (var _i = strLen - 1, _len = chars.length; _i < _len; _i++) {
      if (!chars[_i]) {
        chars[_i] = defaultValue;
      }
    }
  }
  return chars.join("");
}
function _getObjectProperty(object, index2) {
  if (isEmptyIndex(index2)) {
    return void 0;
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  return getSafeProperty(object, key);
}
function _setObjectProperty(object, index2, replacement) {
  if (isEmptyIndex(index2)) {
    return object;
  }
  if (index2.size().length !== 1) {
    throw new DimensionError(index2.size(), 1);
  }
  var key = index2.dimension(0);
  if (typeof key !== "string") {
    throw new TypeError("String expected as index to retrieve an object property");
  }
  var updated = clone$3(object);
  setSafeProperty(updated, key, replacement);
  return updated;
}
var name$3e = "transpose";
var dependencies$3e = ["typed", "matrix"];
var createTranspose = /* @__PURE__ */ factory(name$3e, dependencies$3e, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return typed2(name$3e, {
    Array: (x) => transposeMatrix(matrix2(x)).valueOf(),
    Matrix: transposeMatrix,
    any: clone$3
    // scalars
  });
  function transposeMatrix(x) {
    var size2 = x.size();
    var c;
    switch (size2.length) {
      case 1:
        c = x.clone();
        break;
      case 2:
        {
          var rows = size2[0];
          var columns = size2[1];
          if (columns === 0) {
            throw new RangeError("Cannot transpose a 2D matrix with no columns (size: " + format$1(size2) + ")");
          }
          switch (x.storage()) {
            case "dense":
              c = _denseTranspose(x, rows, columns);
              break;
            case "sparse":
              c = _sparseTranspose(x, rows, columns);
              break;
          }
        }
        break;
      default:
        throw new RangeError("Matrix must be a vector or two dimensional (size: " + format$1(size2) + ")");
    }
    return c;
  }
  function _denseTranspose(m, rows, columns) {
    var data = m._data;
    var transposed = [];
    var transposedRow;
    for (var j = 0; j < columns; j++) {
      transposedRow = transposed[j] = [];
      for (var i2 = 0; i2 < rows; i2++) {
        transposedRow[i2] = clone$3(data[i2][j]);
      }
    }
    return m.createDenseMatrix({
      data: transposed,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
  function _sparseTranspose(m, rows, columns) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var cvalues = values ? [] : void 0;
    var cindex = [];
    var cptr = [];
    var w = [];
    for (var x = 0; x < rows; x++) {
      w[x] = 0;
    }
    var p, l, j;
    for (p = 0, l = index2.length; p < l; p++) {
      w[index2[p]]++;
    }
    var sum2 = 0;
    for (var i2 = 0; i2 < rows; i2++) {
      cptr.push(sum2);
      sum2 += w[i2];
      w[i2] = cptr[i2];
    }
    cptr.push(sum2);
    for (j = 0; j < columns; j++) {
      for (var k0 = ptr[j], k1 = ptr[j + 1], k = k0; k < k1; k++) {
        var q = w[index2[k]]++;
        cindex[q] = j;
        if (values) {
          cvalues[q] = clone$3(values[k]);
        }
      }
    }
    return m.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [columns, rows],
      datatype: m._datatype
    });
  }
});
var name$3d = "ctranspose";
var dependencies$3d = ["typed", "transpose", "conj"];
var createCtranspose = /* @__PURE__ */ factory(name$3d, dependencies$3d, (_ref) => {
  var {
    typed: typed2,
    transpose: transpose2,
    conj: conj2
  } = _ref;
  return typed2(name$3d, {
    any: function any(x) {
      return conj2(transpose2(x));
    }
  });
});
var name$3c = "zeros";
var dependencies$3c = ["typed", "config", "matrix", "BigNumber"];
var createZeros = /* @__PURE__ */ factory(name$3c, dependencies$3c, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    BigNumber: BigNumber2
  } = _ref;
  return typed2(name$3c, {
    "": function _() {
      return config3.matrix === "Array" ? _zeros([]) : _zeros([], "default");
    },
    // math.zeros(m, n, p, ..., format)
    // TODO: more accurate signature '...number | BigNumber, string' as soon as typed-function supports this
    "...number | BigNumber | string": function numberBigNumberString(size2) {
      var last = size2[size2.length - 1];
      if (typeof last === "string") {
        var format2 = size2.pop();
        return _zeros(size2, format2);
      } else if (config3.matrix === "Array") {
        return _zeros(size2);
      } else {
        return _zeros(size2, "default");
      }
    },
    Array: _zeros,
    Matrix: function Matrix2(size2) {
      var format2 = size2.storage();
      return _zeros(size2.valueOf(), format2);
    },
    "Array | Matrix, string": function ArrayMatrixString(size2, format2) {
      return _zeros(size2.valueOf(), format2);
    }
  });
  function _zeros(size2, format2) {
    var hasBigNumbers = _normalize(size2);
    var defaultValue = hasBigNumbers ? new BigNumber2(0) : 0;
    _validate2(size2);
    if (format2) {
      var m = matrix2(format2);
      if (size2.length > 0) {
        return m.resize(size2, defaultValue);
      }
      return m;
    } else {
      var arr = [];
      if (size2.length > 0) {
        return resize$1(arr, size2, defaultValue);
      }
      return arr;
    }
  }
  function _normalize(size2) {
    var hasBigNumbers = false;
    size2.forEach(function(value, index2, arr) {
      if (isBigNumber(value)) {
        hasBigNumbers = true;
        arr[index2] = value.toNumber();
      }
    });
    return hasBigNumbers;
  }
  function _validate2(size2) {
    size2.forEach(function(value) {
      if (typeof value !== "number" || !isInteger$1(value) || value < 0) {
        throw new Error("Parameters in function zeros must be positive integers");
      }
    });
  }
});
var name$3b = "fft";
var dependencies$3b = ["typed", "matrix", "addScalar", "multiplyScalar", "divideScalar", "exp", "tau", "i", "dotDivide", "conj", "pow", "ceil", "log2"];
var createFft = /* @__PURE__ */ factory(name$3b, dependencies$3b, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    exp: exp2,
    tau: tau2,
    i: I,
    dotDivide: dotDivide2,
    conj: conj2,
    pow: pow2,
    ceil: ceil2,
    log2: log23
  } = _ref;
  return typed2(name$3b, {
    Array: _ndFft,
    Matrix: function Matrix2(matrix3) {
      return matrix3.create(_ndFft(matrix3.toArray()));
    }
  });
  function _ndFft(arr) {
    var size2 = arraySize(arr);
    if (size2.length === 1)
      return _fft(arr, size2[0]);
    return _1dFft(arr.map((slice) => _ndFft(slice, size2.slice(1))), 0);
  }
  function _1dFft(arr, dim) {
    var size2 = arraySize(arr);
    if (dim !== 0)
      return new Array(size2[0]).fill(0).map((_, i2) => _1dFft(arr[i2], dim - 1));
    if (size2.length === 1)
      return _fft(arr);
    function _transpose(arr2) {
      var size3 = arraySize(arr2);
      return new Array(size3[1]).fill(0).map((_, j) => new Array(size3[0]).fill(0).map((_2, i2) => arr2[i2][j]));
    }
    return _transpose(_1dFft(_transpose(arr), 1));
  }
  function _czt(arr) {
    var n = arr.length;
    var w = exp2(divideScalar2(multiplyScalar2(-1, multiplyScalar2(I, tau2)), n));
    var chirp = [];
    for (var i2 = 1 - n; i2 < n; i2++) {
      chirp.push(pow2(w, divideScalar2(pow2(i2, 2), 2)));
    }
    var N2 = pow2(2, ceil2(log23(n + n - 1)));
    var xp = [...new Array(n).fill(0).map((_, i3) => multiplyScalar2(arr[i3], chirp[n - 1 + i3])), ...new Array(N2 - n).fill(0)];
    var ichirp = [...new Array(n + n - 1).fill(0).map((_, i3) => divideScalar2(1, chirp[i3])), ...new Array(N2 - (n + n - 1)).fill(0)];
    var fftXp = _fft(xp);
    var fftIchirp = _fft(ichirp);
    var fftProduct = new Array(N2).fill(0).map((_, i3) => multiplyScalar2(fftXp[i3], fftIchirp[i3]));
    var ifftProduct = dotDivide2(conj2(_ndFft(conj2(fftProduct))), N2);
    var ret = [];
    for (var _i = n - 1; _i < n + n - 1; _i++) {
      ret.push(multiplyScalar2(ifftProduct[_i], chirp[_i]));
    }
    return ret;
  }
  function _fft(arr) {
    var len = arr.length;
    if (len === 1)
      return [arr[0]];
    if (len % 2 === 0) {
      var ret = [..._fft(arr.filter((_, i2) => i2 % 2 === 0)), ..._fft(arr.filter((_, i2) => i2 % 2 === 1))];
      for (var k = 0; k < len / 2; k++) {
        var p = ret[k];
        var q = multiplyScalar2(ret[k + len / 2], exp2(multiplyScalar2(multiplyScalar2(tau2, I), divideScalar2(-k, len))));
        ret[k] = addScalar2(p, q);
        ret[k + len / 2] = addScalar2(p, multiplyScalar2(-1, q));
      }
      return ret;
    } else {
      return _czt(arr);
    }
  }
});
var name$3a = "ifft";
var dependencies$3a = ["typed", "fft", "dotDivide", "conj"];
var createIfft = /* @__PURE__ */ factory(name$3a, dependencies$3a, (_ref) => {
  var {
    typed: typed2,
    fft: fft2,
    dotDivide: dotDivide2,
    conj: conj2
  } = _ref;
  return typed2(name$3a, {
    "Array | Matrix": function ArrayMatrix(arr) {
      var size2 = isMatrix(arr) ? arr.size() : arraySize(arr);
      return dotDivide2(conj2(fft2(conj2(arr))), size2.reduce((acc, curr) => acc * curr, 1));
    }
  });
});
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t)
    return t;
  var e2 = t[Symbol.toPrimitive];
  if (void 0 !== e2) {
    var i2 = e2.call(t, r || "default");
    if ("object" != _typeof(i2))
      return i2;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
function toPropertyKey(t) {
  var i2 = toPrimitive(t, "string");
  return "symbol" == _typeof(i2) ? i2 : i2 + "";
}
function _defineProperty(e2, r, t) {
  return (r = toPropertyKey(r)) in e2 ? Object.defineProperty(e2, r, {
    value: t,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e2[r] = t, e2;
}
function ownKeys$2(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$2(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$2(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys$2(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name$39 = "solveODE";
var dependencies$39 = ["typed", "add", "subtract", "multiply", "divide", "max", "map", "abs", "isPositive", "isNegative", "larger", "smaller", "matrix", "bignumber", "unaryMinus"];
var createSolveODE = /* @__PURE__ */ factory(name$39, dependencies$39, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    max: max2,
    map: map2,
    abs: abs2,
    isPositive: isPositive2,
    isNegative: isNegative2,
    larger: larger2,
    smaller: smaller2,
    matrix: matrix2,
    bignumber: bignumber2,
    unaryMinus: unaryMinus2
  } = _ref;
  function _rk(butcherTableau) {
    return function(f, tspan, y0, options) {
      var wrongTSpan = !(tspan.length === 2 && (tspan.every(isNumOrBig) || tspan.every(isUnit)));
      if (wrongTSpan) {
        throw new Error('"tspan" must be an Array of two numeric values or two units [tStart, tEnd]');
      }
      var t0 = tspan[0];
      var tf = tspan[1];
      var isForwards = larger2(tf, t0);
      var firstStep = options.firstStep;
      if (firstStep !== void 0 && !isPositive2(firstStep)) {
        throw new Error('"firstStep" must be positive');
      }
      var maxStep = options.maxStep;
      if (maxStep !== void 0 && !isPositive2(maxStep)) {
        throw new Error('"maxStep" must be positive');
      }
      var minStep = options.minStep;
      if (minStep && isNegative2(minStep)) {
        throw new Error('"minStep" must be positive or zero');
      }
      var timeVars = [t0, tf, firstStep, minStep, maxStep].filter((x) => x !== void 0);
      if (!(timeVars.every(isNumOrBig) || timeVars.every(isUnit))) {
        throw new Error('Inconsistent type of "t" dependant variables');
      }
      var steps = 1;
      var tol = options.tol ? options.tol : 1e-4;
      var minDelta = options.minDelta ? options.minDelta : 0.2;
      var maxDelta = options.maxDelta ? options.maxDelta : 5;
      var maxIter = options.maxIter ? options.maxIter : 1e4;
      var hasBigNumbers = [t0, tf, ...y0, maxStep, minStep].some(isBigNumber);
      var [a, c, b, bp] = hasBigNumbers ? [bignumber2(butcherTableau.a), bignumber2(butcherTableau.c), bignumber2(butcherTableau.b), bignumber2(butcherTableau.bp)] : [butcherTableau.a, butcherTableau.c, butcherTableau.b, butcherTableau.bp];
      var h = firstStep ? isForwards ? firstStep : unaryMinus2(firstStep) : divide2(subtract2(tf, t0), steps);
      var t = [t0];
      var y = [y0];
      var deltaB = subtract2(b, bp);
      var n = 0;
      var iter = 0;
      var ongoing = _createOngoing(isForwards);
      var trimStep = _createTrimStep(isForwards);
      while (ongoing(t[n], tf)) {
        var k = [];
        h = trimStep(t[n], tf, h);
        k.push(f(t[n], y[n]));
        for (var i2 = 1; i2 < c.length; ++i2) {
          k.push(f(add2(t[n], multiply2(c[i2], h)), add2(y[n], multiply2(h, a[i2], k))));
        }
        var TE = max2(abs2(map2(multiply2(deltaB, k), (X) => isUnit(X) ? X.value : X)));
        if (TE < tol && tol / TE > 1 / 4) {
          t.push(add2(t[n], h));
          y.push(add2(y[n], multiply2(h, b, k)));
          n++;
        }
        var delta = 0.84 * (tol / TE) ** (1 / 5);
        if (smaller2(delta, minDelta)) {
          delta = minDelta;
        } else if (larger2(delta, maxDelta)) {
          delta = maxDelta;
        }
        delta = hasBigNumbers ? bignumber2(delta) : delta;
        h = multiply2(h, delta);
        if (maxStep && larger2(abs2(h), maxStep)) {
          h = isForwards ? maxStep : unaryMinus2(maxStep);
        } else if (minStep && smaller2(abs2(h), minStep)) {
          h = isForwards ? minStep : unaryMinus2(minStep);
        }
        iter++;
        if (iter > maxIter) {
          throw new Error("Maximum number of iterations reached, try changing options");
        }
      }
      return {
        t,
        y
      };
    };
  }
  function _rk23(f, tspan, y0, options) {
    var a = [[], [1 / 2], [0, 3 / 4], [2 / 9, 1 / 3, 4 / 9]];
    var c = [null, 1 / 2, 3 / 4, 1];
    var b = [2 / 9, 1 / 3, 4 / 9, 0];
    var bp = [7 / 24, 1 / 4, 1 / 3, 1 / 8];
    var butcherTableau = {
      a,
      c,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options);
  }
  function _rk45(f, tspan, y0, options) {
    var a = [[], [1 / 5], [3 / 40, 9 / 40], [44 / 45, -56 / 15, 32 / 9], [19372 / 6561, -25360 / 2187, 64448 / 6561, -212 / 729], [9017 / 3168, -355 / 33, 46732 / 5247, 49 / 176, -5103 / 18656], [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84]];
    var c = [null, 1 / 5, 3 / 10, 4 / 5, 8 / 9, 1, 1];
    var b = [35 / 384, 0, 500 / 1113, 125 / 192, -2187 / 6784, 11 / 84, 0];
    var bp = [5179 / 57600, 0, 7571 / 16695, 393 / 640, -92097 / 339200, 187 / 2100, 1 / 40];
    var butcherTableau = {
      a,
      c,
      b,
      bp
    };
    return _rk(butcherTableau)(f, tspan, y0, options);
  }
  function _solveODE(f, tspan, y0, opt) {
    var method = opt.method ? opt.method : "RK45";
    var methods = {
      RK23: _rk23,
      RK45: _rk45
    };
    if (method.toUpperCase() in methods) {
      var methodOptions = _objectSpread$2({}, opt);
      delete methodOptions.method;
      return methods[method.toUpperCase()](f, tspan, y0, methodOptions);
    } else {
      var methodsWithQuotes = Object.keys(methods).map((x) => '"'.concat(x, '"'));
      var availableMethodsString = "".concat(methodsWithQuotes.slice(0, -1).join(", "), " and ").concat(methodsWithQuotes.slice(-1));
      throw new Error('Unavailable method "'.concat(method, '". Available methods are ').concat(availableMethodsString));
    }
  }
  function _createOngoing(isForwards) {
    return isForwards ? smaller2 : larger2;
  }
  function _createTrimStep(isForwards) {
    var outOfBounds = isForwards ? larger2 : smaller2;
    return function(t, tf, h) {
      var next = add2(t, h);
      return outOfBounds(next, tf) ? subtract2(tf, t) : h;
    };
  }
  function isNumOrBig(x) {
    return isBigNumber(x) || isNumber(x);
  }
  function _matrixSolveODE(f, T, y0, options) {
    var sol = _solveODE(f, T.toArray(), y0.toArray(), options);
    return {
      t: matrix2(sol.t),
      y: matrix2(sol.y)
    };
  }
  return typed2("solveODE", {
    "function, Array, Array, Object": _solveODE,
    "function, Matrix, Matrix, Object": _matrixSolveODE,
    "function, Array, Array": (f, T, y0) => _solveODE(f, T, y0, {}),
    "function, Matrix, Matrix": (f, T, y0) => _matrixSolveODE(f, T, y0, {}),
    "function, Array, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T, [y0], {});
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit": (f, T, y0) => {
      var sol = _solveODE(f, T.toArray(), [y0], {});
      return {
        t: matrix2(sol.t),
        y: matrix2(sol.y.map((Y) => Y[0]))
      };
    },
    "function, Array, number | BigNumber | Unit, Object": (f, T, y0, options) => {
      var sol = _solveODE(f, T, [y0], options);
      return {
        t: sol.t,
        y: sol.y.map((Y) => Y[0])
      };
    },
    "function, Matrix, number | BigNumber | Unit, Object": (f, T, y0, options) => {
      var sol = _solveODE(f, T.toArray(), [y0], options);
      return {
        t: matrix2(sol.t),
        y: matrix2(sol.y.map((Y) => Y[0]))
      };
    }
  });
});
var name$38 = "erf";
var dependencies$38 = ["typed"];
var createErf = /* @__PURE__ */ factory(name$38, dependencies$38, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("name", {
    number: function number2(x) {
      var y = Math.abs(x);
      if (y >= MAX_NUM) {
        return sign$2(x);
      }
      if (y <= THRESH) {
        return sign$2(x) * erf1(y);
      }
      if (y <= 4) {
        return sign$2(x) * (1 - erfc2(y));
      }
      return sign$2(x) * (1 - erfc3(y));
    },
    "Array | Matrix": typed2.referToSelf((self2) => (n) => deepMap(n, self2))
    // TODO: For complex numbers, use the approximation for the Faddeeva function
    //  from "More Efficient Computation of the Complex Error Function" (AMS)
  });
  function erf1(y) {
    var ysq = y * y;
    var xnum = P[0][4] * ysq;
    var xden = ysq;
    var i2;
    for (i2 = 0; i2 < 3; i2 += 1) {
      xnum = (xnum + P[0][i2]) * ysq;
      xden = (xden + Q[0][i2]) * ysq;
    }
    return y * (xnum + P[0][3]) / (xden + Q[0][3]);
  }
  function erfc2(y) {
    var xnum = P[1][8] * y;
    var xden = y;
    var i2;
    for (i2 = 0; i2 < 7; i2 += 1) {
      xnum = (xnum + P[1][i2]) * y;
      xden = (xden + Q[1][i2]) * y;
    }
    var result = (xnum + P[1][7]) / (xden + Q[1][7]);
    var ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
  function erfc3(y) {
    var ysq = 1 / (y * y);
    var xnum = P[2][5] * ysq;
    var xden = ysq;
    var i2;
    for (i2 = 0; i2 < 4; i2 += 1) {
      xnum = (xnum + P[2][i2]) * ysq;
      xden = (xden + Q[2][i2]) * ysq;
    }
    var result = ysq * (xnum + P[2][4]) / (xden + Q[2][4]);
    result = (SQRPI - result) / y;
    ysq = parseInt(y * 16) / 16;
    var del = (y - ysq) * (y + ysq);
    return Math.exp(-ysq * ysq) * Math.exp(-del) * result;
  }
});
var THRESH = 0.46875;
var SQRPI = 0.5641895835477563;
var P = [[3.1611237438705655, 113.86415415105016, 377.485237685302, 3209.3775891384694, 0.18577770618460315], [0.5641884969886701, 8.883149794388377, 66.11919063714163, 298.6351381974001, 881.952221241769, 1712.0476126340707, 2051.0783778260716, 1230.3393547979972, 21531153547440383e-24], [0.30532663496123236, 0.36034489994980445, 0.12578172611122926, 0.016083785148742275, 6587491615298378e-19, 0.016315387137302097]];
var Q = [[23.601290952344122, 244.02463793444417, 1282.6165260773723, 2844.236833439171], [15.744926110709835, 117.6939508913125, 537.1811018620099, 1621.3895745666903, 3290.7992357334597, 4362.619090143247, 3439.3676741437216, 1230.3393548037495], [2.568520192289822, 1.8729528499234604, 0.5279051029514285, 0.06051834131244132, 0.0023352049762686918]];
var MAX_NUM = Math.pow(2, 53);
var name$37 = "zeta";
var dependencies$37 = ["typed", "config", "multiply", "pow", "divide", "factorial", "equal", "smallerEq", "isNegative", "gamma", "sin", "subtract", "add", "?Complex", "?BigNumber", "pi"];
var createZeta = /* @__PURE__ */ factory(name$37, dependencies$37, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    multiply: multiply2,
    pow: pow2,
    divide: divide2,
    factorial: factorial2,
    equal: equal2,
    smallerEq: smallerEq2,
    isNegative: isNegative2,
    gamma: gamma2,
    sin: sin2,
    subtract: subtract2,
    add: add2,
    Complex: Complex2,
    BigNumber: _BigNumber,
    pi: pi2
  } = _ref;
  return typed2(name$37, {
    number: (s) => zetaNumeric(s, (value) => value, () => 20),
    BigNumber: (s) => zetaNumeric(s, (value) => new _BigNumber(value), () => {
      return Math.abs(Math.log10(config3.epsilon));
    }),
    Complex: zetaComplex
  });
  function zetaNumeric(s, createValue, determineDigits) {
    if (equal2(s, 0)) {
      return createValue(-0.5);
    }
    if (equal2(s, 1)) {
      return createValue(NaN);
    }
    if (!isFinite(s)) {
      return isNegative2(s) ? createValue(NaN) : createValue(1);
    }
    return zeta2(s, createValue, determineDigits, (s2) => s2);
  }
  function zetaComplex(s) {
    if (s.re === 0 && s.im === 0) {
      return new Complex2(-0.5);
    }
    if (s.re === 1) {
      return new Complex2(NaN, NaN);
    }
    if (s.re === Infinity && s.im === 0) {
      return new Complex2(1);
    }
    if (s.im === Infinity || s.re === -Infinity) {
      return new Complex2(NaN, NaN);
    }
    return zeta2(s, (value) => value, (s2) => Math.round(1.3 * 15 + 0.9 * Math.abs(s2.im)), (s2) => s2.re);
  }
  function zeta2(s, createValue, determineDigits, getRe) {
    var n = determineDigits(s);
    if (getRe(s) > -(n - 1) / 2) {
      return f(s, createValue(n), createValue);
    } else {
      var c = multiply2(pow2(2, s), pow2(createValue(pi2), subtract2(s, 1)));
      c = multiply2(c, sin2(multiply2(divide2(createValue(pi2), 2), s)));
      c = multiply2(c, gamma2(subtract2(1, s)));
      return multiply2(c, zeta2(subtract2(1, s), createValue, determineDigits, getRe));
    }
  }
  function d(k, n) {
    var S = k;
    for (var j = k; smallerEq2(j, n); j = add2(j, 1)) {
      var factor = divide2(multiply2(factorial2(add2(n, subtract2(j, 1))), pow2(4, j)), multiply2(factorial2(subtract2(n, j)), factorial2(multiply2(2, j))));
      S = add2(S, factor);
    }
    return multiply2(n, S);
  }
  function f(s, n, createValue) {
    var c = divide2(1, multiply2(d(createValue(0), n), subtract2(1, pow2(2, subtract2(1, s)))));
    var S = createValue(0);
    for (var k = createValue(1); smallerEq2(k, n); k = add2(k, 1)) {
      S = add2(S, divide2(multiply2((-1) ** (k - 1), d(k, n)), pow2(k, s)));
    }
    return multiply2(c, S);
  }
});
var name$36 = "mode";
var dependencies$36 = ["typed", "isNaN", "isNumeric"];
var createMode = /* @__PURE__ */ factory(name$36, dependencies$36, (_ref) => {
  var {
    typed: typed2,
    isNaN: isNaN2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name$36, {
    "Array | Matrix": _mode,
    "...": function _(args) {
      return _mode(args);
    }
  });
  function _mode(values) {
    values = flatten$1(values.valueOf());
    var num = values.length;
    if (num === 0) {
      throw new Error("Cannot calculate mode of an empty array");
    }
    var count2 = {};
    var mode2 = [];
    var max2 = 0;
    for (var i2 = 0; i2 < values.length; i2++) {
      var value = values[i2];
      if (isNumeric2(value) && isNaN2(value)) {
        throw new Error("Cannot calculate mode of an array containing NaN values");
      }
      if (!(value in count2)) {
        count2[value] = 0;
      }
      count2[value]++;
      if (count2[value] === max2) {
        mode2.push(value);
      } else if (count2[value] > max2) {
        max2 = count2[value];
        mode2 = [value];
      }
    }
    return mode2;
  }
});
function improveErrorMessage(err, fnName, value) {
  var details;
  if (String(err).indexOf("Unexpected type") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf$1(value) + ", value: " + JSON.stringify(value) + ")" : " (type: " + err.data.actual + ")";
    return new TypeError("Cannot calculate " + fnName + ", unexpected type of argument" + details);
  }
  if (String(err).indexOf("complex numbers") !== -1) {
    details = arguments.length > 2 ? " (type: " + typeOf$1(value) + ", value: " + JSON.stringify(value) + ")" : "";
    return new TypeError("Cannot calculate " + fnName + ", no ordering relation is defined for complex numbers" + details);
  }
  return err;
}
var name$35 = "prod";
var dependencies$35 = ["typed", "config", "multiplyScalar", "numeric"];
var createProd = /* @__PURE__ */ factory(name$35, dependencies$35, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    multiplyScalar: multiplyScalar2,
    numeric: numeric3
  } = _ref;
  return typed2(name$35, {
    // prod([a, b, c, d, ...])
    "Array | Matrix": _prod,
    // prod([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      throw new Error("prod(A, dim) is not yet supported");
    },
    // prod(a, b, c, d, ...)
    "...": function _(args) {
      return _prod(args);
    }
  });
  function _prod(array) {
    var prod2;
    deepForEach(array, function(value) {
      try {
        prod2 = prod2 === void 0 ? value : multiplyScalar2(prod2, value);
      } catch (err) {
        throw improveErrorMessage(err, "prod", value);
      }
    });
    if (typeof prod2 === "string") {
      prod2 = numeric3(prod2, config3.number);
    }
    if (prod2 === void 0) {
      throw new Error("Cannot calculate prod of an empty array");
    }
    return prod2;
  }
});
var name$34 = "format";
var dependencies$34 = ["typed"];
var createFormat = /* @__PURE__ */ factory(name$34, dependencies$34, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$34, {
    any: format$1,
    "any, Object | function | number | BigNumber": format$1
  });
});
var name$33 = "bin";
var dependencies$33 = ["typed", "format"];
var createBin = factory(name$33, dependencies$33, (_ref) => {
  var {
    typed: typed2,
    format: format2
  } = _ref;
  return typed2(name$33, {
    "number | BigNumber": function numberBigNumber(n) {
      return format2(n, {
        notation: "bin"
      });
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
      return format2(n, {
        notation: "bin",
        wordSize
      });
    }
  });
});
var name$32 = "oct";
var dependencies$32 = ["typed", "format"];
var createOct = factory(name$32, dependencies$32, (_ref) => {
  var {
    typed: typed2,
    format: format2
  } = _ref;
  return typed2(name$32, {
    "number | BigNumber": function numberBigNumber(n) {
      return format2(n, {
        notation: "oct"
      });
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
      return format2(n, {
        notation: "oct",
        wordSize
      });
    }
  });
});
var name$31 = "hex";
var dependencies$31 = ["typed", "format"];
var createHex = factory(name$31, dependencies$31, (_ref) => {
  var {
    typed: typed2,
    format: format2
  } = _ref;
  return typed2(name$31, {
    "number | BigNumber": function numberBigNumber(n) {
      return format2(n, {
        notation: "hex"
      });
    },
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, wordSize) {
      return format2(n, {
        notation: "hex",
        wordSize
      });
    }
  });
});
var printTemplate = /\$([\w.]+)/g;
var name$30 = "print";
var dependencies$30 = ["typed"];
var createPrint = /* @__PURE__ */ factory(name$30, dependencies$30, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$30, {
    // note: Matrix will be converted automatically to an Array
    "string, Object | Array": _print,
    "string, Object | Array, number | Object": _print
  });
});
function _print(template, values, options) {
  return template.replace(printTemplate, function(original, key) {
    var keys = key.split(".");
    var value = values[keys.shift()];
    if (value !== void 0 && value.isMatrix) {
      value = value.toArray();
    }
    while (keys.length && value !== void 0) {
      var k = keys.shift();
      value = k ? value[k] : value + ".";
    }
    if (value !== void 0) {
      if (!isString(value)) {
        return format$1(value, options);
      } else {
        return value;
      }
    }
    return original;
  });
}
var name$2$ = "to";
var dependencies$2$ = ["typed", "matrix", "concat"];
var createTo = /* @__PURE__ */ factory(name$2$, dependencies$2$, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$2$, {
    "Unit, Unit | string": (x, unit2) => x.to(unit2)
  }, matrixAlgorithmSuite({
    Ds: true
  }));
});
var name$2_ = "isPrime";
var dependencies$2_ = ["typed"];
var createIsPrime = /* @__PURE__ */ factory(name$2_, dependencies$2_, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$2_, {
    number: function number2(x) {
      if (x * 0 !== 0) {
        return false;
      }
      if (x <= 3) {
        return x > 1;
      }
      if (x % 2 === 0 || x % 3 === 0) {
        return false;
      }
      for (var i2 = 5; i2 * i2 <= x; i2 += 6) {
        if (x % i2 === 0 || x % (i2 + 2) === 0) {
          return false;
        }
      }
      return true;
    },
    BigNumber: function BigNumber2(n) {
      if (n.toNumber() * 0 !== 0) {
        return false;
      }
      if (n.lte(3))
        return n.gt(1);
      if (n.mod(2).eq(0) || n.mod(3).eq(0))
        return false;
      if (n.lt(Math.pow(2, 32))) {
        var x = n.toNumber();
        for (var i2 = 5; i2 * i2 <= x; i2 += 6) {
          if (x % i2 === 0 || x % (i2 + 2) === 0) {
            return false;
          }
        }
        return true;
      }
      function modPow(base, exponent, modulus) {
        var accumulator = 1;
        while (!exponent.eq(0)) {
          if (exponent.mod(2).eq(0)) {
            exponent = exponent.div(2);
            base = base.mul(base).mod(modulus);
          } else {
            exponent = exponent.sub(1);
            accumulator = base.mul(accumulator).mod(modulus);
          }
        }
        return accumulator;
      }
      var Decimal2 = n.constructor.clone({
        precision: n.toFixed(0).length * 2
      });
      n = new Decimal2(n);
      var r = 0;
      var d = n.sub(1);
      while (d.mod(2).eq(0)) {
        d = d.div(2);
        r += 1;
      }
      var bases = null;
      if (n.lt("3317044064679887385961981")) {
        bases = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41].filter((x2) => x2 < n);
      } else {
        var max2 = Math.min(n.toNumber() - 2, Math.floor(2 * Math.pow(n.toFixed(0).length * Math.log(10), 2)));
        bases = [];
        for (var _i = 2; _i <= max2; _i += 1) {
          bases.push(max2);
        }
      }
      for (var _i2 = 0; _i2 < bases.length; _i2 += 1) {
        var a = bases[_i2];
        var adn = modPow(n.sub(n).add(a), d, n);
        if (!adn.eq(1)) {
          for (var _i3 = 0, _x = adn; !_x.eq(n.sub(1)); _i3 += 1, _x = _x.mul(_x).mod(n)) {
            if (_i3 === r - 1) {
              return false;
            }
          }
        }
      }
      return true;
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$2Z = "numeric";
var dependencies$2Z = ["number", "?bignumber", "?fraction"];
var createNumeric = /* @__PURE__ */ factory(name$2Z, dependencies$2Z, (_ref) => {
  var {
    number: _number,
    bignumber: bignumber2,
    fraction: fraction2
  } = _ref;
  var validInputTypes = {
    string: true,
    number: true,
    BigNumber: true,
    Fraction: true
  };
  var validOutputTypes = {
    number: (x) => _number(x),
    BigNumber: bignumber2 ? (x) => bignumber2(x) : noBignumber,
    Fraction: fraction2 ? (x) => fraction2(x) : noFraction
  };
  return function numeric3(value) {
    var outputType = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "number";
    var check = arguments.length > 2 ? arguments[2] : void 0;
    if (check !== void 0) {
      throw new SyntaxError("numeric() takes one or two arguments");
    }
    var inputType = typeOf$1(value);
    if (!(inputType in validInputTypes)) {
      throw new TypeError("Cannot convert " + value + ' of type "' + inputType + '"; valid input types are ' + Object.keys(validInputTypes).join(", "));
    }
    if (!(outputType in validOutputTypes)) {
      throw new TypeError("Cannot convert " + value + ' to type "' + outputType + '"; valid output types are ' + Object.keys(validOutputTypes).join(", "));
    }
    if (outputType === inputType) {
      return value;
    } else {
      return validOutputTypes[outputType](value);
    }
  };
});
var name$2Y = "divideScalar";
var dependencies$2Y = ["typed", "numeric"];
var createDivideScalar = /* @__PURE__ */ factory(name$2Y, dependencies$2Y, (_ref) => {
  var {
    typed: typed2,
    numeric: numeric3
  } = _ref;
  return typed2(name$2Y, {
    "number, number": function numberNumber(x, y) {
      return x / y;
    },
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.div(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.div(y);
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return x.div(y);
    },
    "Unit, number | Complex | Fraction | BigNumber | Unit": (x, y) => x.divide(y),
    "number | Fraction | Complex | BigNumber, Unit": (x, y) => y.divideInto(x)
  });
});
var name$2X = "pow";
var dependencies$2X = ["typed", "config", "identity", "multiply", "matrix", "inv", "fraction", "number", "Complex"];
var createPow = /* @__PURE__ */ factory(name$2X, dependencies$2X, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    identity: identity2,
    multiply: multiply2,
    matrix: matrix2,
    inv: inv2,
    number: number2,
    fraction: fraction2,
    Complex: Complex2
  } = _ref;
  return typed2(name$2X, {
    "number, number": _pow,
    "Complex, Complex": function ComplexComplex(x, y) {
      return x.pow(y);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      if (y.isInteger() || x >= 0 || config3.predictable) {
        return x.pow(y);
      } else {
        return new Complex2(x.toNumber(), 0).pow(y.toNumber(), 0);
      }
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      var result = x.pow(y);
      if (result != null) {
        return result;
      }
      if (config3.predictable) {
        throw new Error("Result of pow is non-rational and cannot be expressed as a fraction");
      } else {
        return _pow(x.valueOf(), y.valueOf());
      }
    },
    "Array, number": _powArray,
    "Array, BigNumber": function ArrayBigNumber(x, y) {
      return _powArray(x, y.toNumber());
    },
    "Matrix, number": _powMatrix,
    "Matrix, BigNumber": function MatrixBigNumber(x, y) {
      return _powMatrix(x, y.toNumber());
    },
    "Unit, number | BigNumber": function UnitNumberBigNumber(x, y) {
      return x.pow(y);
    }
  });
  function _pow(x, y) {
    if (config3.predictable && !isInteger$1(y) && x < 0) {
      try {
        var yFrac = fraction2(y);
        var yNum = number2(yFrac);
        if (y === yNum || Math.abs((y - yNum) / y) < 1e-14) {
          if (yFrac.d % 2 === 1) {
            return (yFrac.n % 2 === 0 ? 1 : -1) * Math.pow(-x, y);
          }
        }
      } catch (ex) {
      }
    }
    if (config3.predictable && (x < -1 && y === Infinity || x > -1 && x < 0 && y === -Infinity)) {
      return NaN;
    }
    if (isInteger$1(y) || x >= 0 || config3.predictable) {
      return powNumber(x, y);
    } else {
      if (x * x < 1 && y === Infinity || x * x > 1 && y === -Infinity) {
        return 0;
      }
      return new Complex2(x, 0).pow(y, 0);
    }
  }
  function _powArray(x, y) {
    if (!isInteger$1(y)) {
      throw new TypeError("For A^b, b must be an integer (value is " + y + ")");
    }
    var s = arraySize(x);
    if (s.length !== 2) {
      throw new Error("For A^b, A must be 2 dimensional (A has " + s.length + " dimensions)");
    }
    if (s[0] !== s[1]) {
      throw new Error("For A^b, A must be square (size is " + s[0] + "x" + s[1] + ")");
    }
    if (y < 0) {
      try {
        return _powArray(inv2(x), -y);
      } catch (error) {
        if (error.message === "Cannot calculate inverse, determinant is zero") {
          throw new TypeError("For A^b, when A is not invertible, b must be a positive integer (value is " + y + ")");
        }
        throw error;
      }
    }
    var res = identity2(s[0]).valueOf();
    var px = x;
    while (y >= 1) {
      if ((y & 1) === 1) {
        res = multiply2(px, res);
      }
      y >>= 1;
      px = multiply2(px, px);
    }
    return res;
  }
  function _powMatrix(x, y) {
    return matrix2(_powArray(x.valueOf(), y));
  }
});
var NO_INT = "Number of decimals in function round must be an integer";
var name$2W = "round";
var dependencies$2W = ["typed", "config", "matrix", "equalScalar", "zeros", "BigNumber", "DenseMatrix"];
var createRound = /* @__PURE__ */ factory(name$2W, dependencies$2W, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    BigNumber: _BigNumber,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  function toExponent(epsilon) {
    return Math.abs(splitNumber(epsilon).exponent);
  }
  return typed2(name$2W, {
    number: function number2(x) {
      var xEpsilon = roundNumber(x, toExponent(config3.epsilon));
      var xSelected = nearlyEqual$1(x, xEpsilon, config3.epsilon) ? xEpsilon : x;
      return roundNumber(xSelected);
    },
    "number, number": function numberNumber(x, n) {
      var epsilonExponent = toExponent(config3.epsilon);
      if (n >= epsilonExponent) {
        return roundNumber(x, n);
      }
      var xEpsilon = roundNumber(x, epsilonExponent);
      var xSelected = nearlyEqual$1(x, xEpsilon, config3.epsilon) ? xEpsilon : x;
      return roundNumber(xSelected, n);
    },
    "number, BigNumber": function numberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return new _BigNumber(x).toDecimalPlaces(n.toNumber());
    },
    Complex: function Complex2(x) {
      return x.round();
    },
    "Complex, number": function ComplexNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Complex, BigNumber": function ComplexBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var _n = n.toNumber();
      return x.round(_n);
    },
    BigNumber: function BigNumber2(x) {
      var xEpsilon = new _BigNumber(x).toDecimalPlaces(toExponent(config3.epsilon));
      var xSelected = nearlyEqual(x, xEpsilon, config3.epsilon) ? xEpsilon : x;
      return xSelected.toDecimalPlaces(0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      var epsilonExponent = toExponent(config3.epsilon);
      if (n >= epsilonExponent) {
        return x.toDecimalPlaces(n.toNumber());
      }
      var xEpsilon = x.toDecimalPlaces(epsilonExponent);
      var xSelected = nearlyEqual(x, xEpsilon, config3.epsilon) ? xEpsilon : x;
      return xSelected.toDecimalPlaces(n.toNumber());
    },
    Fraction: function Fraction2(x) {
      return x.round();
    },
    "Fraction, number": function FractionNumber(x, n) {
      if (n % 1) {
        throw new TypeError(NO_INT);
      }
      return x.round(n);
    },
    "Fraction, BigNumber": function FractionBigNumber(x, n) {
      if (!n.isInteger()) {
        throw new TypeError(NO_INT);
      }
      return x.round(n.toNumber());
    },
    "Unit, number, Unit": typed2.referToSelf((self2) => function(x, n, unit2) {
      var valueless = x.toNumeric(unit2);
      return unit2.multiply(self2(valueless, n));
    }),
    "Unit, BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit2) => self2(x, n.toNumber(), unit2)),
    "Unit, Unit": typed2.referToSelf((self2) => (x, unit2) => self2(x, 0, unit2)),
    "Array | Matrix, number, Unit": typed2.referToSelf((self2) => (x, n, unit2) => {
      return deepMap(x, (value) => self2(value, n, unit2));
    }),
    "Array | Matrix, BigNumber, Unit": typed2.referToSelf((self2) => (x, n, unit2) => self2(x, n.toNumber(), unit2)),
    "Array | Matrix, Unit": typed2.referToSelf((self2) => (x, unit2) => self2(x, 0, unit2)),
    "Array | Matrix": typed2.referToSelf((self2) => (x) => {
      return deepMap(x, self2);
    }),
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return matAlgo11xS0s(x, n, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(x, n, self2, false);
    }),
    "Array, number | BigNumber": typed2.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(matrix2(x), n, self2, false).valueOf();
    }),
    "number | Complex | BigNumber | Fraction, SparseMatrix": typed2.referToSelf((self2) => (x, n) => {
      if (equalScalar2(x, 0)) {
        return zeros2(n.size(), n.storage());
      }
      return matAlgo12xSfs(n, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, DenseMatrix": typed2.referToSelf((self2) => (x, n) => {
      if (equalScalar2(x, 0)) {
        return zeros2(n.size(), n.storage());
      }
      return matAlgo14xDs(n, x, self2, true);
    }),
    "number | Complex | BigNumber | Fraction, Array": typed2.referToSelf((self2) => (x, n) => {
      return matAlgo14xDs(matrix2(n), x, self2, true).valueOf();
    })
  });
});
var name$2V = "log";
var dependencies$2V = ["config", "typed", "divideScalar", "Complex"];
var createLog = /* @__PURE__ */ factory(name$2V, dependencies$2V, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    divideScalar: divideScalar2,
    Complex: Complex2
  } = _ref;
  return typed2(name$2V, {
    number: function number2(x) {
      if (x >= 0 || config3.predictable) {
        return logNumber(x);
      } else {
        return new Complex2(x, 0).log();
      }
    },
    Complex: function Complex3(x) {
      return x.log();
    },
    BigNumber: function BigNumber2(x) {
      if (!x.isNegative() || config3.predictable) {
        return x.ln();
      } else {
        return new Complex2(x.toNumber(), 0).log();
      }
    },
    "any, any": typed2.referToSelf((self2) => (x, base) => {
      return divideScalar2(self2(x), self2(base));
    })
  });
});
var name$2U = "log1p";
var dependencies$2U = ["typed", "config", "divideScalar", "log", "Complex"];
var createLog1p = /* @__PURE__ */ factory(name$2U, dependencies$2U, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    divideScalar: divideScalar2,
    log: log3,
    Complex: Complex2
  } = _ref;
  return typed2(name$2U, {
    number: function number2(x) {
      if (x >= -1 || config3.predictable) {
        return log1p$1(x);
      } else {
        return _log1pComplex(new Complex2(x, 0));
      }
    },
    Complex: _log1pComplex,
    BigNumber: function BigNumber2(x) {
      var y = x.plus(1);
      if (!y.isNegative() || config3.predictable) {
        return y.ln();
      } else {
        return _log1pComplex(new Complex2(x.toNumber(), 0));
      }
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2)),
    "any, any": typed2.referToSelf((self2) => (x, base) => {
      return divideScalar2(self2(x), log3(base));
    })
  });
  function _log1pComplex(x) {
    var xRe1p = x.re + 1;
    return new Complex2(Math.log(Math.sqrt(xRe1p * xRe1p + x.im * x.im)), Math.atan2(x.im, xRe1p));
  }
});
var name$2T = "nthRoots";
var dependencies$2T = ["config", "typed", "divideScalar", "Complex"];
var createNthRoots = /* @__PURE__ */ factory(name$2T, dependencies$2T, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    divideScalar: divideScalar2,
    Complex: Complex2
  } = _ref;
  var _calculateExactResult = [function realPos(val) {
    return new Complex2(val, 0);
  }, function imagPos(val) {
    return new Complex2(0, val);
  }, function realNeg(val) {
    return new Complex2(-val, 0);
  }, function imagNeg(val) {
    return new Complex2(0, -val);
  }];
  function _nthComplexRoots(a, root) {
    if (root < 0)
      throw new Error("Root must be greater than zero");
    if (root === 0)
      throw new Error("Root must be non-zero");
    if (root % 1 !== 0)
      throw new Error("Root must be an integer");
    if (a === 0 || a.abs() === 0)
      return [new Complex2(0, 0)];
    var aIsNumeric = typeof a === "number";
    var offset;
    if (aIsNumeric || a.re === 0 || a.im === 0) {
      if (aIsNumeric) {
        offset = 2 * +(a < 0);
      } else if (a.im === 0) {
        offset = 2 * +(a.re < 0);
      } else {
        offset = 2 * +(a.im < 0) + 1;
      }
    }
    var arg2 = a.arg();
    var abs2 = a.abs();
    var roots = [];
    var r = Math.pow(abs2, 1 / root);
    for (var k = 0; k < root; k++) {
      var halfPiFactor = (offset + 4 * k) / root;
      if (halfPiFactor === Math.round(halfPiFactor)) {
        roots.push(_calculateExactResult[halfPiFactor % 4](r));
        continue;
      }
      roots.push(new Complex2({
        r,
        phi: (arg2 + 2 * Math.PI * k) / root
      }));
    }
    return roots;
  }
  return typed2(name$2T, {
    Complex: function Complex3(x) {
      return _nthComplexRoots(x, 2);
    },
    "Complex, number": _nthComplexRoots
  });
});
var name$2S = "dotPow";
var dependencies$2S = ["typed", "equalScalar", "matrix", "pow", "DenseMatrix", "concat"];
var createDotPow = /* @__PURE__ */ factory(name$2S, dependencies$2S, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2,
    matrix: matrix2,
    pow: pow2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var powScalarSignatures = {};
  for (var signature in pow2.signatures) {
    if (Object.prototype.hasOwnProperty.call(pow2.signatures, signature)) {
      if (!signature.includes("Matrix") && !signature.includes("Array")) {
        powScalarSignatures[signature] = pow2.signatures[signature];
      }
    }
  }
  var powScalar = typed2(powScalarSignatures);
  return typed2(name$2S, matrixAlgorithmSuite({
    elop: powScalar,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
var name$2R = "dotDivide";
var dependencies$2R = ["typed", "matrix", "equalScalar", "divideScalar", "DenseMatrix", "concat"];
var createDotDivide = /* @__PURE__ */ factory(name$2R, dependencies$2R, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$2R, matrixAlgorithmSuite({
    elop: divideScalar2,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
function createSolveValidation(_ref) {
  var {
    DenseMatrix: DenseMatrix2
  } = _ref;
  return function solveValidation(m, b, copy) {
    var mSize = m.size();
    if (mSize.length !== 2) {
      throw new RangeError("Matrix must be two dimensional (size: " + format$1(mSize) + ")");
    }
    var rows = mSize[0];
    var columns = mSize[1];
    if (rows !== columns) {
      throw new RangeError("Matrix must be square (size: " + format$1(mSize) + ")");
    }
    var data = [];
    if (isMatrix(b)) {
      var bSize = b.size();
      var bdata = b._data;
      if (bSize.length === 1) {
        if (bSize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var i2 = 0; i2 < rows; i2++) {
          data[i2] = [bdata[i2]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1],
          datatype: b._datatype
        });
      }
      if (bSize.length === 2) {
        if (bSize[0] !== rows || bSize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        if (isDenseMatrix(b)) {
          if (copy) {
            data = [];
            for (var _i = 0; _i < rows; _i++) {
              data[_i] = [bdata[_i][0]];
            }
            return new DenseMatrix2({
              data,
              size: [rows, 1],
              datatype: b._datatype
            });
          }
          return b;
        }
        if (isSparseMatrix(b)) {
          for (var _i2 = 0; _i2 < rows; _i2++) {
            data[_i2] = [0];
          }
          var values = b._values;
          var index2 = b._index;
          var ptr = b._ptr;
          for (var k1 = ptr[1], k = ptr[0]; k < k1; k++) {
            var _i3 = index2[k];
            data[_i3][0] = values[k];
          }
          return new DenseMatrix2({
            data,
            size: [rows, 1],
            datatype: b._datatype
          });
        }
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
    if (isArray(b)) {
      var bsize = arraySize(b);
      if (bsize.length === 1) {
        if (bsize[0] !== rows) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i4 = 0; _i4 < rows; _i4++) {
          data[_i4] = [b[_i4]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      if (bsize.length === 2) {
        if (bsize[0] !== rows || bsize[1] !== 1) {
          throw new RangeError("Dimension mismatch. Matrix columns must match vector length.");
        }
        for (var _i5 = 0; _i5 < rows; _i5++) {
          data[_i5] = [b[_i5][0]];
        }
        return new DenseMatrix2({
          data,
          size: [rows, 1]
        });
      }
      throw new RangeError("Dimension mismatch. The right side has to be either 1- or 2-dimensional vector.");
    }
  };
}
var name$2Q = "lsolve";
var dependencies$2Q = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolve = /* @__PURE__ */ factory(name$2Q, dependencies$2Q, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$2Q, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var r = _denseForwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j + 1; i2 < rows; i2++) {
          bdata[i2] = [subtractScalar2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseForwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = 0; j < columns; j++) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = firstIndex; k < lastIndex; k++) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values[k];
          } else if (i2 > j) {
            jValues.push(values[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, l = jIndices.length; _k < l; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar2(bdata[_i][0] || 0, multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});
var name$2P = "usolve";
var dependencies$2P = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolve = /* @__PURE__ */ factory(name$2P, dependencies$2P, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$2P, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var r = _denseBackwardSubstitution(m, b);
      return r.valueOf();
    }
  });
  function _denseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var x = [];
    var mdata = m._data;
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      var xj = void 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = mdata[j][j];
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        xj = divideScalar2(bj, vjj);
        for (var i2 = j - 1; i2 >= 0; i2--) {
          bdata[i2] = [subtractScalar2(bdata[i2][0] || 0, multiplyScalar2(xj, mdata[i2][j]))];
        }
      } else {
        xj = 0;
      }
      x[j] = [xj];
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
  function _sparseBackwardSubstitution(m, b) {
    b = solveValidation(m, b, true);
    var bdata = b._data;
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var x = [];
    for (var j = columns - 1; j >= 0; j--) {
      var bj = bdata[j][0] || 0;
      if (!equalScalar2(bj, 0)) {
        var vjj = 0;
        var jValues = [];
        var jIndices = [];
        var firstIndex = ptr[j];
        var lastIndex = ptr[j + 1];
        for (var k = lastIndex - 1; k >= firstIndex; k--) {
          var i2 = index2[k];
          if (i2 === j) {
            vjj = values[k];
          } else if (i2 < j) {
            jValues.push(values[k]);
            jIndices.push(i2);
          }
        }
        if (equalScalar2(vjj, 0)) {
          throw new Error("Linear system cannot be solved since matrix is singular");
        }
        var xj = divideScalar2(bj, vjj);
        for (var _k = 0, _lastIndex = jIndices.length; _k < _lastIndex; _k++) {
          var _i = jIndices[_k];
          bdata[_i] = [subtractScalar2(bdata[_i][0], multiplyScalar2(xj, jValues[_k]))];
        }
        x[j] = [xj];
      } else {
        x[j] = [0];
      }
    }
    return new DenseMatrix2({
      data: x,
      size: [rows, 1]
    });
  }
});
var name$2O = "lsolveAll";
var dependencies$2O = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createLsolveAll = /* @__PURE__ */ factory(name$2O, dependencies$2O, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$2O, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseForwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseForwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var R = _denseForwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 + 1; j < columns; j++) {
            b[j] = subtractScalar2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 + 1; _j < columns; _j++) {
            bNew[_j] = subtractScalar2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseForwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = 0; i2 < columns; i2++) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = firstIndex; j < lastIndex; j++) {
          var J = index2[j];
          if (J === i2) {
            Mii = values[j];
          } else if (J > i2) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});
var name$2N = "usolveAll";
var dependencies$2N = ["typed", "matrix", "divideScalar", "multiplyScalar", "subtractScalar", "equalScalar", "DenseMatrix"];
var createUsolveAll = /* @__PURE__ */ factory(name$2N, dependencies$2N, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$2N, {
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(m, b) {
      return _sparseBackwardSubstitution(m, b);
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(m, b) {
      return _denseBackwardSubstitution(m, b);
    },
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      var m = matrix2(a);
      var R = _denseBackwardSubstitution(m, b);
      return R.map((r) => r.valueOf());
    }
  });
  function _denseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var M = m._data;
    var rows = m._size[0];
    var columns = m._size[1];
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        if (!equalScalar2(M[i2][i2], 0)) {
          b[i2] = divideScalar2(b[i2], M[i2][i2]);
          for (var j = i2 - 1; j >= 0; j--) {
            b[j] = subtractScalar2(b[j], multiplyScalar2(b[i2], M[j][i2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j = i2 - 1; _j >= 0; _j--) {
            bNew[_j] = subtractScalar2(bNew[_j], M[_j][i2]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
  function _sparseBackwardSubstitution(m, b_) {
    var B = [solveValidation(m, b_, true)._data.map((e2) => e2[0])];
    var rows = m._size[0];
    var columns = m._size[1];
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    for (var i2 = columns - 1; i2 >= 0; i2--) {
      var L = B.length;
      for (var k = 0; k < L; k++) {
        var b = B[k];
        var iValues = [];
        var iIndices = [];
        var firstIndex = ptr[i2];
        var lastIndex = ptr[i2 + 1];
        var Mii = 0;
        for (var j = lastIndex - 1; j >= firstIndex; j--) {
          var J = index2[j];
          if (J === i2) {
            Mii = values[j];
          } else if (J < i2) {
            iValues.push(values[j]);
            iIndices.push(J);
          }
        }
        if (!equalScalar2(Mii, 0)) {
          b[i2] = divideScalar2(b[i2], Mii);
          for (var _j2 = 0, _lastIndex = iIndices.length; _j2 < _lastIndex; _j2++) {
            var _J = iIndices[_j2];
            b[_J] = subtractScalar2(b[_J], multiplyScalar2(b[i2], iValues[_j2]));
          }
        } else if (!equalScalar2(b[i2], 0)) {
          if (k === 0) {
            return [];
          } else {
            B.splice(k, 1);
            k -= 1;
            L -= 1;
          }
        } else if (k === 0) {
          var bNew = [...b];
          bNew[i2] = 1;
          for (var _j3 = 0, _lastIndex2 = iIndices.length; _j3 < _lastIndex2; _j3++) {
            var _J2 = iIndices[_j3];
            bNew[_J2] = subtractScalar2(bNew[_J2], iValues[_j3]);
          }
          B.push(bNew);
        }
      }
    }
    return B.map((x) => new DenseMatrix2({
      data: x.map((e2) => [e2]),
      size: [rows, 1]
    }));
  }
});
var name$2M = "matAlgo08xS0Sid";
var dependencies$2M = ["typed", "equalScalar"];
var createMatAlgo08xS0Sid = /* @__PURE__ */ factory(name$2M, dependencies$2M, (_ref) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref;
  return function matAlgo08xS0Sid(a, b, callback) {
    var avalues = a._values;
    var aindex = a._index;
    var aptr = a._ptr;
    var asize = a._size;
    var adt = a._datatype || a._data === void 0 ? a._datatype : a.getDataType();
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var bsize = b._size;
    var bdt = b._datatype || b._data === void 0 ? b._datatype : b.getDataType();
    if (asize.length !== bsize.length) {
      throw new DimensionError(asize.length, bsize.length);
    }
    if (asize[0] !== bsize[0] || asize[1] !== bsize[1]) {
      throw new RangeError("Dimension mismatch. Matrix A (" + asize + ") must match Matrix B (" + bsize + ")");
    }
    if (!avalues || !bvalues) {
      throw new Error("Cannot perform operation on Pattern Sparse Matrices");
    }
    var rows = asize[0];
    var columns = asize[1];
    var dt;
    var eq = equalScalar2;
    var zero = 0;
    var cf = callback;
    if (typeof adt === "string" && adt === bdt && adt !== "mixed") {
      dt = adt;
      eq = typed2.find(equalScalar2, [dt, dt]);
      zero = typed2.convert(0, dt);
      cf = typed2.find(callback, [dt, dt]);
    }
    var cvalues = [];
    var cindex = [];
    var cptr = [];
    var x = [];
    var w = [];
    var k, k0, k1, i2;
    for (var j = 0; j < columns; j++) {
      cptr[j] = cindex.length;
      var mark = j + 1;
      for (k0 = aptr[j], k1 = aptr[j + 1], k = k0; k < k1; k++) {
        i2 = aindex[k];
        w[i2] = mark;
        x[i2] = avalues[k];
        cindex.push(i2);
      }
      for (k0 = bptr[j], k1 = bptr[j + 1], k = k0; k < k1; k++) {
        i2 = bindex[k];
        if (w[i2] === mark) {
          x[i2] = cf(x[i2], bvalues[k]);
        }
      }
      k = cptr[j];
      while (k < cindex.length) {
        i2 = cindex[k];
        var v = x[i2];
        if (!eq(v, zero)) {
          cvalues.push(v);
          k++;
        } else {
          cindex.splice(k, 1);
        }
      }
    }
    cptr[columns] = cindex.length;
    return a.createSparseMatrix({
      values: cvalues,
      index: cindex,
      ptr: cptr,
      size: [rows, columns],
      datatype: adt === a._datatype && bdt === b._datatype ? dt : void 0
    });
  };
});
var createUseMatrixForArrayScalar = /* @__PURE__ */ factory("useMatrixForArrayScalar", ["typed", "matrix"], (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2
  } = _ref;
  return {
    "Array, number": typed2.referTo("DenseMatrix, number", (selfDn) => (x, y) => selfDn(matrix2(x), y).valueOf()),
    "Array, BigNumber": typed2.referTo("DenseMatrix, BigNumber", (selfDB) => (x, y) => selfDB(matrix2(x), y).valueOf()),
    "number, Array": typed2.referTo("number, DenseMatrix", (selfnD) => (x, y) => selfnD(x, matrix2(y)).valueOf()),
    "BigNumber, Array": typed2.referTo("BigNumber, DenseMatrix", (selfBD) => (x, y) => selfBD(x, matrix2(y)).valueOf())
  };
});
var name$2L = "leftShift";
var dependencies$2L = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createLeftShift = /* @__PURE__ */ factory(name$2L, dependencies$2L, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2L, {
    "number, number": leftShiftNumber,
    "BigNumber, BigNumber": leftShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
var name$2K = "rightArithShift";
var dependencies$2K = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightArithShift = /* @__PURE__ */ factory(name$2K, dependencies$2K, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2K, {
    "number, number": rightArithShiftNumber,
    "BigNumber, BigNumber": rightArithShiftBigNumber,
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
var name$2J = "rightLogShift";
var dependencies$2J = ["typed", "matrix", "equalScalar", "zeros", "DenseMatrix", "concat"];
var createRightLogShift = /* @__PURE__ */ factory(name$2J, dependencies$2J, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo08xS0Sid = createMatAlgo08xS0Sid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var useMatrixForArrayScalar = createUseMatrixForArrayScalar({
    typed: typed2,
    matrix: matrix2
  });
  return typed2(name$2J, {
    "number, number": rightLogShiftNumber,
    // 'BigNumber, BigNumber': ..., // TODO: implement BigNumber support for rightLogShift
    "SparseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, number | BigNumber": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(y, 0)) {
        return x.clone();
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "number | BigNumber, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo10xSids(y, x, self2, true);
    }),
    "number | BigNumber, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (equalScalar2(x, 0)) {
        return zeros2(y.size(), y.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    })
  }, useMatrixForArrayScalar, matrixAlgorithmSuite({
    SS: matAlgo08xS0Sid,
    DS: matAlgo01xDSid,
    SD: matAlgo02xDS0
  }));
});
var name$2I = "and";
var dependencies$2I = ["typed", "matrix", "equalScalar", "zeros", "not", "concat"];
var createAnd = /* @__PURE__ */ factory(name$2I, dependencies$2I, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo06xS0S0 = createMatAlgo06xS0S0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$2I, {
    "number, number": andNumber,
    "Complex, Complex": function ComplexComplex(x, y) {
      return (x.re !== 0 || x.im !== 0) && (y.re !== 0 || y.im !== 0);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return !x.isZero() && !y.isZero() && !x.isNaN() && !y.isNaN();
    },
    "Unit, Unit": typed2.referToSelf((self2) => (x, y) => self2(x.value || 0, y.value || 0)),
    "SparseMatrix, any": typed2.referToSelf((self2) => (x, y) => {
      if (not2(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(x, y, self2, false);
    }),
    "DenseMatrix, any": typed2.referToSelf((self2) => (x, y) => {
      if (not2(y)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(x, y, self2, false);
    }),
    "any, SparseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (not2(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo11xS0s(y, x, self2, true);
    }),
    "any, DenseMatrix": typed2.referToSelf((self2) => (x, y) => {
      if (not2(x)) {
        return zeros2(x.size(), x.storage());
      }
      return matAlgo14xDs(y, x, self2, true);
    }),
    "Array, any": typed2.referToSelf((self2) => (x, y) => {
      return self2(matrix2(x), y).valueOf();
    }),
    "any, Array": typed2.referToSelf((self2) => (x, y) => {
      return self2(x, matrix2(y)).valueOf();
    })
  }, matrixAlgorithmSuite({
    SS: matAlgo06xS0S0,
    DS: matAlgo02xDS0
  }));
});
var name$2H = "compare";
var dependencies$2H = ["typed", "config", "matrix", "equalScalar", "BigNumber", "Fraction", "DenseMatrix", "concat"];
var createCompare = /* @__PURE__ */ factory(name$2H, dependencies$2H, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    equalScalar: equalScalar2,
    matrix: matrix2,
    BigNumber: BigNumber2,
    Fraction: Fraction2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo05xSfSf = createMatAlgo05xSfSf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2H, createCompareNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": function booleanBoolean(x, y) {
      return x === y ? 0 : x > y ? 1 : -1;
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return nearlyEqual(x, y, config3.epsilon) ? new BigNumber2(0) : new BigNumber2(x.cmp(y));
    },
    "Fraction, Fraction": function FractionFraction(x, y) {
      return new Fraction2(x.compare(y));
    },
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo05xSfSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createCompareNumber = /* @__PURE__ */ factory(name$2H, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2H, {
    "number, number": function numberNumber(x, y) {
      return nearlyEqual$1(x, y, config3.epsilon) ? 0 : x > y ? 1 : -1;
    }
  });
});
var naturalSort = function naturalSort2(a, b) {
  var re2 = /(^([+\-]?(?:0|[1-9]\d*)(?:\.\d*)?(?:[eE][+\-]?\d+)?)?$|^0x[0-9a-f]+$|\d+)/gi, sre = /(^[ ]*|[ ]*$)/g, dre = /(^([\w ]+,?[\w ]+)?[\w ]+,?[\w ]+\d+:\d+(:\d+)?[\w ]?|^\d{1,4}[\/\-]\d{1,4}[\/\-]\d{1,4}|^\w+, \w+ \d+, \d{4})/, hre = /^0x[0-9a-f]+$/i, ore = /^0/, i2 = function(s) {
    return naturalSort2.insensitive && ("" + s).toLowerCase() || "" + s;
  }, x = i2(a).replace(sre, "") || "", y = i2(b).replace(sre, "") || "", xN = x.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), yN = y.replace(re2, "\0$1\0").replace(/\0$/, "").replace(/^\0/, "").split("\0"), xD = parseInt(x.match(hre), 16) || xN.length !== 1 && x.match(dre) && Date.parse(x), yD = parseInt(y.match(hre), 16) || xD && y.match(dre) && Date.parse(y) || null, oFxNcL, oFyNcL;
  if (yD) {
    if (xD < yD) {
      return -1;
    } else if (xD > yD) {
      return 1;
    }
  }
  for (var cLoc = 0, numS = Math.max(xN.length, yN.length); cLoc < numS; cLoc++) {
    oFxNcL = !(xN[cLoc] || "").match(ore) && parseFloat(xN[cLoc]) || xN[cLoc] || 0;
    oFyNcL = !(yN[cLoc] || "").match(ore) && parseFloat(yN[cLoc]) || yN[cLoc] || 0;
    if (isNaN(oFxNcL) !== isNaN(oFyNcL)) {
      return isNaN(oFxNcL) ? 1 : -1;
    } else if (typeof oFxNcL !== typeof oFyNcL) {
      oFxNcL += "";
      oFyNcL += "";
    }
    if (oFxNcL < oFyNcL) {
      return -1;
    }
    if (oFxNcL > oFyNcL) {
      return 1;
    }
  }
  return 0;
};
const naturalSort$1 = /* @__PURE__ */ getDefaultExportFromCjs(naturalSort);
var name$2G = "compareNatural";
var dependencies$2G = ["typed", "compare"];
var createCompareNatural = /* @__PURE__ */ factory(name$2G, dependencies$2G, (_ref) => {
  var {
    typed: typed2,
    compare: compare2
  } = _ref;
  var compareBooleans = compare2.signatures["boolean,boolean"];
  return typed2(name$2G, {
    "any, any": _compareNatural
  });
  function _compareNatural(x, y) {
    var typeX = typeOf$1(x);
    var typeY = typeOf$1(y);
    var c;
    if ((typeX === "number" || typeX === "BigNumber" || typeX === "Fraction") && (typeY === "number" || typeY === "BigNumber" || typeY === "Fraction")) {
      c = compare2(x, y);
      if (c.toString() !== "0") {
        return c > 0 ? 1 : -1;
      } else {
        return naturalSort$1(typeX, typeY);
      }
    }
    var matTypes = ["Array", "DenseMatrix", "SparseMatrix"];
    if (matTypes.includes(typeX) || matTypes.includes(typeY)) {
      c = compareMatricesAndArrays(_compareNatural, x, y);
      if (c !== 0) {
        return c;
      } else {
        return naturalSort$1(typeX, typeY);
      }
    }
    if (typeX !== typeY) {
      return naturalSort$1(typeX, typeY);
    }
    if (typeX === "Complex") {
      return compareComplexNumbers(x, y);
    }
    if (typeX === "Unit") {
      if (x.equalBase(y)) {
        return _compareNatural(x.value, y.value);
      }
      return compareArrays(_compareNatural, x.formatUnits(), y.formatUnits());
    }
    if (typeX === "boolean") {
      return compareBooleans(x, y);
    }
    if (typeX === "string") {
      return naturalSort$1(x, y);
    }
    if (typeX === "Object") {
      return compareObjects(_compareNatural, x, y);
    }
    if (typeX === "null") {
      return 0;
    }
    if (typeX === "undefined") {
      return 0;
    }
    throw new TypeError('Unsupported type of value "' + typeX + '"');
  }
  function compareMatricesAndArrays(compareNatural2, x, y) {
    if (isSparseMatrix(x) && isSparseMatrix(y)) {
      return compareArrays(compareNatural2, x.toJSON().values, y.toJSON().values);
    }
    if (isSparseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural2, x.toArray(), y);
    }
    if (isSparseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural2, x, y.toArray());
    }
    if (isDenseMatrix(x)) {
      return compareMatricesAndArrays(compareNatural2, x.toJSON().data, y);
    }
    if (isDenseMatrix(y)) {
      return compareMatricesAndArrays(compareNatural2, x, y.toJSON().data);
    }
    if (!Array.isArray(x)) {
      return compareMatricesAndArrays(compareNatural2, [x], y);
    }
    if (!Array.isArray(y)) {
      return compareMatricesAndArrays(compareNatural2, x, [y]);
    }
    return compareArrays(compareNatural2, x, y);
  }
  function compareArrays(compareNatural2, x, y) {
    for (var i2 = 0, ii = Math.min(x.length, y.length); i2 < ii; i2++) {
      var v = compareNatural2(x[i2], y[i2]);
      if (v !== 0) {
        return v;
      }
    }
    if (x.length > y.length) {
      return 1;
    }
    if (x.length < y.length) {
      return -1;
    }
    return 0;
  }
  function compareObjects(compareNatural2, x, y) {
    var keysX = Object.keys(x);
    var keysY = Object.keys(y);
    keysX.sort(naturalSort$1);
    keysY.sort(naturalSort$1);
    var c = compareArrays(compareNatural2, keysX, keysY);
    if (c !== 0) {
      return c;
    }
    for (var i2 = 0; i2 < keysX.length; i2++) {
      var v = compareNatural2(x[keysX[i2]], y[keysY[i2]]);
      if (v !== 0) {
        return v;
      }
    }
    return 0;
  }
});
function compareComplexNumbers(x, y) {
  if (x.re > y.re) {
    return 1;
  }
  if (x.re < y.re) {
    return -1;
  }
  if (x.im > y.im) {
    return 1;
  }
  if (x.im < y.im) {
    return -1;
  }
  return 0;
}
var name$2F = "compareText";
var dependencies$2F = ["typed", "matrix", "concat"];
compareText$1.signature = "any, any";
var createCompareText = /* @__PURE__ */ factory(name$2F, dependencies$2F, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  } = _ref;
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$2F, compareText$1, matrixAlgorithmSuite({
    elop: compareText$1,
    Ds: true
  }));
});
var name$2E = "equal";
var dependencies$2E = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createEqual = /* @__PURE__ */ factory(name$2E, dependencies$2E, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$2E, createEqualNumber({
    typed: typed2,
    equalScalar: equalScalar2
  }), matrixAlgorithmSuite({
    elop: equalScalar2,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createEqualNumber = factory(name$2E, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref2;
  return typed2(name$2E, {
    "any, any": function anyAny(x, y) {
      if (x === null) {
        return y === null;
      }
      if (y === null) {
        return x === null;
      }
      if (x === void 0) {
        return y === void 0;
      }
      if (y === void 0) {
        return x === void 0;
      }
      return equalScalar2(x, y);
    }
  });
});
var name$2D = "equalText";
var dependencies$2D = ["typed", "compareText", "isZero"];
var createEqualText = /* @__PURE__ */ factory(name$2D, dependencies$2D, (_ref) => {
  var {
    typed: typed2,
    compareText: compareText2,
    isZero: isZero2
  } = _ref;
  return typed2(name$2D, {
    "any, any": function anyAny(x, y) {
      return isZero2(compareText2(x, y));
    }
  });
});
var name$2C = "smaller";
var dependencies$2C = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createSmaller = /* @__PURE__ */ factory(name$2C, dependencies$2C, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2C, createSmallerNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": (x, y) => x < y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lt(y) && !nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) === -1,
    "Complex, Complex": function ComplexComplex(x, y) {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerNumber = /* @__PURE__ */ factory(name$2C, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2C, {
    "number, number": function numberNumber(x, y) {
      return x < y && !nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$2B = "smallerEq";
var dependencies$2B = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createSmallerEq = /* @__PURE__ */ factory(name$2B, dependencies$2B, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2B, createSmallerEqNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": (x, y) => x <= y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.lte(y) || nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) !== 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createSmallerEqNumber = /* @__PURE__ */ factory(name$2B, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2B, {
    "number, number": function numberNumber(x, y) {
      return x <= y || nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$2A = "larger";
var dependencies$2A = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createLarger = /* @__PURE__ */ factory(name$2A, dependencies$2A, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2A, createLargerNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": (x, y) => x > y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gt(y) && !nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) === 1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerNumber = /* @__PURE__ */ factory(name$2A, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2A, {
    "number, number": function numberNumber(x, y) {
      return x > y && !nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$2z = "largerEq";
var dependencies$2z = ["typed", "config", "matrix", "DenseMatrix", "concat"];
var createLargerEq = /* @__PURE__ */ factory(name$2z, dependencies$2z, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  var compareUnits = createCompareUnits({
    typed: typed2
  });
  return typed2(name$2z, createLargerEqNumber({
    typed: typed2,
    config: config3
  }), {
    "boolean, boolean": (x, y) => x >= y,
    "BigNumber, BigNumber": function BigNumberBigNumber(x, y) {
      return x.gte(y) || nearlyEqual(x, y, config3.epsilon);
    },
    "Fraction, Fraction": (x, y) => x.compare(y) !== -1,
    "Complex, Complex": function ComplexComplex() {
      throw new TypeError("No ordering relation is defined for complex numbers");
    }
  }, compareUnits, matrixAlgorithmSuite({
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
});
var createLargerEqNumber = /* @__PURE__ */ factory(name$2z, ["typed", "config"], (_ref2) => {
  var {
    typed: typed2,
    config: config3
  } = _ref2;
  return typed2(name$2z, {
    "number, number": function numberNumber(x, y) {
      return x >= y || nearlyEqual$1(x, y, config3.epsilon);
    }
  });
});
var name$2y = "deepEqual";
var dependencies$2y = ["typed", "equal"];
var createDeepEqual = /* @__PURE__ */ factory(name$2y, dependencies$2y, (_ref) => {
  var {
    typed: typed2,
    equal: equal2
  } = _ref;
  return typed2(name$2y, {
    "any, any": function anyAny(x, y) {
      return _deepEqual(x.valueOf(), y.valueOf());
    }
  });
  function _deepEqual(x, y) {
    if (Array.isArray(x)) {
      if (Array.isArray(y)) {
        var len = x.length;
        if (len !== y.length) {
          return false;
        }
        for (var i2 = 0; i2 < len; i2++) {
          if (!_deepEqual(x[i2], y[i2])) {
            return false;
          }
        }
        return true;
      } else {
        return false;
      }
    } else {
      if (Array.isArray(y)) {
        return false;
      } else {
        return equal2(x, y);
      }
    }
  }
});
var name$2x = "unequal";
var dependencies$2x = ["typed", "config", "equalScalar", "matrix", "DenseMatrix", "concat"];
var createUnequal = /* @__PURE__ */ factory(name$2x, dependencies$2x, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    equalScalar: equalScalar2,
    matrix: matrix2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo07xSSf = createMatAlgo07xSSf({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$2x, createUnequalNumber({
    typed: typed2,
    equalScalar: equalScalar2
  }), matrixAlgorithmSuite({
    elop: _unequal,
    SS: matAlgo07xSSf,
    DS: matAlgo03xDSf,
    Ss: matAlgo12xSfs
  }));
  function _unequal(x, y) {
    return !equalScalar2(x, y);
  }
});
var createUnequalNumber = factory(name$2x, ["typed", "equalScalar"], (_ref2) => {
  var {
    typed: typed2,
    equalScalar: equalScalar2
  } = _ref2;
  return typed2(name$2x, {
    "any, any": function anyAny(x, y) {
      if (x === null) {
        return y !== null;
      }
      if (y === null) {
        return x !== null;
      }
      if (x === void 0) {
        return y !== void 0;
      }
      if (y === void 0) {
        return x !== void 0;
      }
      return !equalScalar2(x, y);
    }
  });
});
var name$2w = "partitionSelect";
var dependencies$2w = ["typed", "isNumeric", "isNaN", "compare"];
var createPartitionSelect = /* @__PURE__ */ factory(name$2w, dependencies$2w, (_ref) => {
  var {
    typed: typed2,
    isNumeric: isNumeric2,
    isNaN: isNaN2,
    compare: compare2
  } = _ref;
  var asc = compare2;
  var desc = (a, b) => -compare2(a, b);
  return typed2(name$2w, {
    "Array | Matrix, number": function ArrayMatrixNumber(x, k) {
      return _partitionSelect(x, k, asc);
    },
    "Array | Matrix, number, string": function ArrayMatrixNumberString(x, k, compare3) {
      if (compare3 === "asc") {
        return _partitionSelect(x, k, asc);
      } else if (compare3 === "desc") {
        return _partitionSelect(x, k, desc);
      } else {
        throw new Error('Compare string must be "asc" or "desc"');
      }
    },
    "Array | Matrix, number, function": _partitionSelect
  });
  function _partitionSelect(x, k, compare3) {
    if (!isInteger$1(k) || k < 0) {
      throw new Error("k must be a non-negative integer");
    }
    if (isMatrix(x)) {
      var size2 = x.size();
      if (size2.length > 1) {
        throw new Error("Only one dimensional matrices supported");
      }
      return quickSelect(x.valueOf(), k, compare3);
    }
    if (Array.isArray(x)) {
      return quickSelect(x, k, compare3);
    }
  }
  function quickSelect(arr, k, compare3) {
    if (k >= arr.length) {
      throw new Error("k out of bounds");
    }
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (isNumeric2(arr[i2]) && isNaN2(arr[i2])) {
        return arr[i2];
      }
    }
    var from = 0;
    var to2 = arr.length - 1;
    while (from < to2) {
      var r = from;
      var w = to2;
      var pivot = arr[Math.floor(Math.random() * (to2 - from + 1)) + from];
      while (r < w) {
        if (compare3(arr[r], pivot) >= 0) {
          var tmp = arr[w];
          arr[w] = arr[r];
          arr[r] = tmp;
          --w;
        } else {
          ++r;
        }
      }
      if (compare3(arr[r], pivot) > 0) {
        --r;
      }
      if (k <= r) {
        to2 = r;
      } else {
        from = r + 1;
      }
    }
    return arr[k];
  }
});
var name$2v = "sort";
var dependencies$2v = ["typed", "matrix", "compare", "compareNatural"];
var createSort = /* @__PURE__ */ factory(name$2v, dependencies$2v, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    compare: compare2,
    compareNatural: compareNatural2
  } = _ref;
  var compareAsc = compare2;
  var compareDesc = (a, b) => -compare2(a, b);
  return typed2(name$2v, {
    Array: function Array2(x) {
      _arrayIsVector(x);
      return x.sort(compareAsc);
    },
    Matrix: function Matrix2(x) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(compareAsc), x.storage());
    },
    "Array, function": function ArrayFunction(x, _comparator2) {
      _arrayIsVector(x);
      return x.sort(_comparator2);
    },
    "Matrix, function": function MatrixFunction(x, _comparator2) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator2), x.storage());
    },
    "Array, string": function ArrayString(x, order) {
      _arrayIsVector(x);
      return x.sort(_comparator(order));
    },
    "Matrix, string": function MatrixString(x, order) {
      _matrixIsVector(x);
      return matrix2(x.toArray().sort(_comparator(order)), x.storage());
    }
  });
  function _comparator(order) {
    if (order === "asc") {
      return compareAsc;
    } else if (order === "desc") {
      return compareDesc;
    } else if (order === "natural") {
      return compareNatural2;
    } else {
      throw new Error('String "asc", "desc", or "natural" expected');
    }
  }
  function _arrayIsVector(array) {
    if (arraySize(array).length !== 1) {
      throw new Error("One dimensional array expected");
    }
  }
  function _matrixIsVector(matrix3) {
    if (matrix3.size().length !== 1) {
      throw new Error("One dimensional matrix expected");
    }
  }
});
var name$2u = "max";
var dependencies$2u = ["typed", "config", "numeric", "larger"];
var createMax = /* @__PURE__ */ factory(name$2u, dependencies$2u, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    numeric: numeric3,
    larger: larger2
  } = _ref;
  return typed2(name$2u, {
    // max([a, b, c, d, ...])
    "Array | Matrix": _max,
    // max([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return reduce(array, dim.valueOf(), _largest);
    },
    // max(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function max");
      }
      return _max(args);
    }
  });
  function _largest(x, y) {
    try {
      return larger2(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "max", y);
    }
  }
  function _max(array) {
    var res;
    deepForEach(array, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          res = NaN;
        } else if (res === void 0 || larger2(value, res)) {
          res = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "max", value);
      }
    });
    if (res === void 0) {
      throw new Error("Cannot calculate max of an empty array");
    }
    if (typeof res === "string") {
      res = numeric3(res, config3.number);
    }
    return res;
  }
});
var name$2t = "min";
var dependencies$2t = ["typed", "config", "numeric", "smaller"];
var createMin = /* @__PURE__ */ factory(name$2t, dependencies$2t, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    numeric: numeric3,
    smaller: smaller2
  } = _ref;
  return typed2(name$2t, {
    // min([a, b, c, d, ...])
    "Array | Matrix": _min,
    // min([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return reduce(array, dim.valueOf(), _smallest);
    },
    // min(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function min");
      }
      return _min(args);
    }
  });
  function _smallest(x, y) {
    try {
      return smaller2(x, y) ? x : y;
    } catch (err) {
      throw improveErrorMessage(err, "min", y);
    }
  }
  function _min(array) {
    var min2;
    deepForEach(array, function(value) {
      try {
        if (isNaN(value) && typeof value === "number") {
          min2 = NaN;
        } else if (min2 === void 0 || smaller2(value, min2)) {
          min2 = value;
        }
      } catch (err) {
        throw improveErrorMessage(err, "min", value);
      }
    });
    if (min2 === void 0) {
      throw new Error("Cannot calculate min of an empty array");
    }
    if (typeof min2 === "string") {
      min2 = numeric3(min2, config3.number);
    }
    return min2;
  }
});
var name$2s = "ImmutableDenseMatrix";
var dependencies$2s = ["smaller", "DenseMatrix"];
var createImmutableDenseMatrixClass = /* @__PURE__ */ factory(name$2s, dependencies$2s, (_ref) => {
  var {
    smaller: smaller2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  function ImmutableDenseMatrix2(data, datatype) {
    if (!(this instanceof ImmutableDenseMatrix2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (datatype && !isString(datatype)) {
      throw new Error("Invalid datatype: " + datatype);
    }
    if (isMatrix(data) || isArray(data)) {
      var matrix2 = new DenseMatrix2(data, datatype);
      this._data = matrix2._data;
      this._size = matrix2._size;
      this._datatype = matrix2._datatype;
      this._min = null;
      this._max = null;
    } else if (data && isArray(data.data) && isArray(data.size)) {
      this._data = data.data;
      this._size = data.size;
      this._datatype = data.datatype;
      this._min = typeof data.min !== "undefined" ? data.min : null;
      this._max = typeof data.max !== "undefined" ? data.max : null;
    } else if (data) {
      throw new TypeError("Unsupported type of data (" + typeOf$1(data) + ")");
    } else {
      this._data = [];
      this._size = [0];
      this._datatype = datatype;
      this._min = null;
      this._max = null;
    }
  }
  ImmutableDenseMatrix2.prototype = new DenseMatrix2();
  ImmutableDenseMatrix2.prototype.type = "ImmutableDenseMatrix";
  ImmutableDenseMatrix2.prototype.isImmutableDenseMatrix = true;
  ImmutableDenseMatrix2.prototype.subset = function(index2) {
    switch (arguments.length) {
      case 1: {
        var m = DenseMatrix2.prototype.subset.call(this, index2);
        if (isMatrix(m)) {
          return new ImmutableDenseMatrix2({
            data: m._data,
            size: m._size,
            datatype: m._datatype
          });
        }
        return m;
      }
      case 2:
      case 3:
        throw new Error("Cannot invoke set subset on an Immutable Matrix instance");
      default:
        throw new SyntaxError("Wrong number of arguments");
    }
  };
  ImmutableDenseMatrix2.prototype.set = function() {
    throw new Error("Cannot invoke set on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.resize = function() {
    throw new Error("Cannot invoke resize on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.reshape = function() {
    throw new Error("Cannot invoke reshape on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.clone = function() {
    return new ImmutableDenseMatrix2({
      data: clone$3(this._data),
      size: clone$3(this._size),
      datatype: this._datatype
    });
  };
  ImmutableDenseMatrix2.prototype.toJSON = function() {
    return {
      mathjs: "ImmutableDenseMatrix",
      data: this._data,
      size: this._size,
      datatype: this._datatype
    };
  };
  ImmutableDenseMatrix2.fromJSON = function(json) {
    return new ImmutableDenseMatrix2(json);
  };
  ImmutableDenseMatrix2.prototype.swapRows = function() {
    throw new Error("Cannot invoke swapRows on an Immutable Matrix instance");
  };
  ImmutableDenseMatrix2.prototype.min = function() {
    if (this._min === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(v, m)) {
          m = v;
        }
      });
      this._min = m !== null ? m : void 0;
    }
    return this._min;
  };
  ImmutableDenseMatrix2.prototype.max = function() {
    if (this._max === null) {
      var m = null;
      this.forEach(function(v) {
        if (m === null || smaller2(m, v)) {
          m = v;
        }
      });
      this._max = m !== null ? m : void 0;
    }
    return this._max;
  };
  return ImmutableDenseMatrix2;
}, {
  isClass: true
});
var name$2r = "Index";
var dependencies$2r = ["ImmutableDenseMatrix", "getMatrixDataType"];
var createIndexClass = /* @__PURE__ */ factory(name$2r, dependencies$2r, (_ref) => {
  var {
    ImmutableDenseMatrix: ImmutableDenseMatrix2,
    getMatrixDataType: getMatrixDataType2
  } = _ref;
  function Index2(ranges) {
    if (!(this instanceof Index2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._dimensions = [];
    this._sourceSize = [];
    this._isScalar = true;
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      var argIsArray = isArray(arg2);
      var argIsMatrix = isMatrix(arg2);
      var sourceSize = null;
      if (isRange(arg2)) {
        this._dimensions.push(arg2);
        this._isScalar = false;
      } else if (argIsArray || argIsMatrix) {
        var m = void 0;
        if (getMatrixDataType2(arg2) === "boolean") {
          if (argIsArray)
            m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2).valueOf());
          if (argIsMatrix)
            m = _createImmutableMatrix(_booleansArrayToNumbersForIndex(arg2._data).valueOf());
          sourceSize = arg2.valueOf().length;
        } else {
          m = _createImmutableMatrix(arg2.valueOf());
        }
        this._dimensions.push(m);
        var size2 = m.size();
        if (size2.length !== 1 || size2[0] !== 1 || sourceSize !== null) {
          this._isScalar = false;
        }
      } else if (typeof arg2 === "number") {
        this._dimensions.push(_createImmutableMatrix([arg2]));
      } else if (typeof arg2 === "string") {
        this._dimensions.push(arg2);
      } else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      this._sourceSize.push(sourceSize);
    }
  }
  Index2.prototype.type = "Index";
  Index2.prototype.isIndex = true;
  function _createImmutableMatrix(arg2) {
    for (var i2 = 0, l = arg2.length; i2 < l; i2++) {
      if (typeof arg2[i2] !== "number" || !isInteger$1(arg2[i2])) {
        throw new TypeError("Index parameters must be positive integer numbers");
      }
    }
    return new ImmutableDenseMatrix2(arg2);
  }
  Index2.prototype.clone = function() {
    var index2 = new Index2();
    index2._dimensions = clone$3(this._dimensions);
    index2._isScalar = this._isScalar;
    index2._sourceSize = this._sourceSize;
    return index2;
  };
  Index2.create = function(ranges) {
    var index2 = new Index2();
    Index2.apply(index2, ranges);
    return index2;
  };
  Index2.prototype.size = function() {
    var size2 = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var d = this._dimensions[i2];
      size2[i2] = typeof d === "string" ? 1 : d.size()[0];
    }
    return size2;
  };
  Index2.prototype.max = function() {
    var values = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values[i2] = typeof range2 === "string" ? range2 : range2.max();
    }
    return values;
  };
  Index2.prototype.min = function() {
    var values = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var range2 = this._dimensions[i2];
      values[i2] = typeof range2 === "string" ? range2 : range2.min();
    }
    return values;
  };
  Index2.prototype.forEach = function(callback) {
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      callback(this._dimensions[i2], i2, this);
    }
  };
  Index2.prototype.dimension = function(dim) {
    return this._dimensions[dim] || null;
  };
  Index2.prototype.isObjectProperty = function() {
    return this._dimensions.length === 1 && typeof this._dimensions[0] === "string";
  };
  Index2.prototype.getObjectProperty = function() {
    return this.isObjectProperty() ? this._dimensions[0] : null;
  };
  Index2.prototype.isScalar = function() {
    return this._isScalar;
  };
  Index2.prototype.toArray = function() {
    var array = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      array.push(typeof dimension === "string" ? dimension : dimension.toArray());
    }
    return array;
  };
  Index2.prototype.valueOf = Index2.prototype.toArray;
  Index2.prototype.toString = function() {
    var strings = [];
    for (var i2 = 0, ii = this._dimensions.length; i2 < ii; i2++) {
      var dimension = this._dimensions[i2];
      if (typeof dimension === "string") {
        strings.push(JSON.stringify(dimension));
      } else {
        strings.push(dimension.toString());
      }
    }
    return "[" + strings.join(", ") + "]";
  };
  Index2.prototype.toJSON = function() {
    return {
      mathjs: "Index",
      dimensions: this._dimensions
    };
  };
  Index2.fromJSON = function(json) {
    return Index2.create(json.dimensions);
  };
  return Index2;
}, {
  isClass: true
});
function _booleansArrayToNumbersForIndex(booleanArrayIndex) {
  var indexOfNumbers = [];
  booleanArrayIndex.forEach((bool, idx) => {
    if (bool) {
      indexOfNumbers.push(idx);
    }
  });
  return indexOfNumbers;
}
var name$2q = "FibonacciHeap";
var dependencies$2q = ["smaller", "larger"];
var createFibonacciHeapClass = /* @__PURE__ */ factory(name$2q, dependencies$2q, (_ref) => {
  var {
    smaller: smaller2,
    larger: larger2
  } = _ref;
  var oneOverLogPhi = 1 / Math.log((1 + Math.sqrt(5)) / 2);
  function FibonacciHeap2() {
    if (!(this instanceof FibonacciHeap2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._minimum = null;
    this._size = 0;
  }
  FibonacciHeap2.prototype.type = "FibonacciHeap";
  FibonacciHeap2.prototype.isFibonacciHeap = true;
  FibonacciHeap2.prototype.insert = function(key, value) {
    var node = {
      key,
      value,
      degree: 0
    };
    if (this._minimum) {
      var minimum = this._minimum;
      node.left = minimum;
      node.right = minimum.right;
      minimum.right = node;
      node.right.left = node;
      if (smaller2(key, minimum.key)) {
        this._minimum = node;
      }
    } else {
      node.left = node;
      node.right = node;
      this._minimum = node;
    }
    this._size++;
    return node;
  };
  FibonacciHeap2.prototype.size = function() {
    return this._size;
  };
  FibonacciHeap2.prototype.clear = function() {
    this._minimum = null;
    this._size = 0;
  };
  FibonacciHeap2.prototype.isEmpty = function() {
    return this._size === 0;
  };
  FibonacciHeap2.prototype.extractMinimum = function() {
    var node = this._minimum;
    if (node === null) {
      return node;
    }
    var minimum = this._minimum;
    var numberOfChildren = node.degree;
    var x = node.child;
    while (numberOfChildren > 0) {
      var tempRight = x.right;
      x.left.right = x.right;
      x.right.left = x.left;
      x.left = minimum;
      x.right = minimum.right;
      minimum.right = x;
      x.right.left = x;
      x.parent = null;
      x = tempRight;
      numberOfChildren--;
    }
    node.left.right = node.right;
    node.right.left = node.left;
    if (node === node.right) {
      minimum = null;
    } else {
      minimum = node.right;
      minimum = _findMinimumNode(minimum, this._size);
    }
    this._size--;
    this._minimum = minimum;
    return node;
  };
  FibonacciHeap2.prototype.remove = function(node) {
    this._minimum = _decreaseKey(this._minimum, node, -1);
    this.extractMinimum();
  };
  function _decreaseKey(minimum, node, key) {
    node.key = key;
    var parent = node.parent;
    if (parent && smaller2(node.key, parent.key)) {
      _cut(minimum, node, parent);
      _cascadingCut(minimum, parent);
    }
    if (smaller2(node.key, minimum.key)) {
      minimum = node;
    }
    return minimum;
  }
  function _cut(minimum, node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    parent.degree--;
    if (parent.child === node) {
      parent.child = node.right;
    }
    if (parent.degree === 0) {
      parent.child = null;
    }
    node.left = minimum;
    node.right = minimum.right;
    minimum.right = node;
    node.right.left = node;
    node.parent = null;
    node.mark = false;
  }
  function _cascadingCut(minimum, node) {
    var parent = node.parent;
    if (!parent) {
      return;
    }
    if (!node.mark) {
      node.mark = true;
    } else {
      _cut(minimum, node, parent);
      _cascadingCut(parent);
    }
  }
  var _linkNodes = function _linkNodes2(node, parent) {
    node.left.right = node.right;
    node.right.left = node.left;
    node.parent = parent;
    if (!parent.child) {
      parent.child = node;
      node.right = node;
      node.left = node;
    } else {
      node.left = parent.child;
      node.right = parent.child.right;
      parent.child.right = node;
      node.right.left = node;
    }
    parent.degree++;
    node.mark = false;
  };
  function _findMinimumNode(minimum, size2) {
    var arraySize2 = Math.floor(Math.log(size2) * oneOverLogPhi) + 1;
    var array = new Array(arraySize2);
    var numRoots = 0;
    var x = minimum;
    if (x) {
      numRoots++;
      x = x.right;
      while (x !== minimum) {
        numRoots++;
        x = x.right;
      }
    }
    var y;
    while (numRoots > 0) {
      var d = x.degree;
      var next = x.right;
      while (true) {
        y = array[d];
        if (!y) {
          break;
        }
        if (larger2(x.key, y.key)) {
          var temp = y;
          y = x;
          x = temp;
        }
        _linkNodes(y, x);
        array[d] = null;
        d++;
      }
      array[d] = x;
      x = next;
      numRoots--;
    }
    minimum = null;
    for (var i2 = 0; i2 < arraySize2; i2++) {
      y = array[i2];
      if (!y) {
        continue;
      }
      if (minimum) {
        y.left.right = y.right;
        y.right.left = y.left;
        y.left = minimum;
        y.right = minimum.right;
        minimum.right = y;
        y.right.left = y;
        if (smaller2(y.key, minimum.key)) {
          minimum = y;
        }
      } else {
        minimum = y;
      }
    }
    return minimum;
  }
  return FibonacciHeap2;
}, {
  isClass: true
});
var name$2p = "Spa";
var dependencies$2p = ["addScalar", "equalScalar", "FibonacciHeap"];
var createSpaClass = /* @__PURE__ */ factory(name$2p, dependencies$2p, (_ref) => {
  var {
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    FibonacciHeap: FibonacciHeap2
  } = _ref;
  function Spa2() {
    if (!(this instanceof Spa2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    this._values = [];
    this._heap = new FibonacciHeap2();
  }
  Spa2.prototype.type = "Spa";
  Spa2.prototype.isSpa = true;
  Spa2.prototype.set = function(i2, v) {
    if (!this._values[i2]) {
      var node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      this._values[i2].value = v;
    }
  };
  Spa2.prototype.get = function(i2) {
    var node = this._values[i2];
    if (node) {
      return node.value;
    }
    return 0;
  };
  Spa2.prototype.accumulate = function(i2, v) {
    var node = this._values[i2];
    if (!node) {
      node = this._heap.insert(i2, v);
      this._values[i2] = node;
    } else {
      node.value = addScalar2(node.value, v);
    }
  };
  Spa2.prototype.forEach = function(from, to2, callback) {
    var heap = this._heap;
    var values = this._values;
    var nodes = [];
    var node = heap.extractMinimum();
    if (node) {
      nodes.push(node);
    }
    while (node && node.key <= to2) {
      if (node.key >= from) {
        if (!equalScalar2(node.value, 0)) {
          callback(node.key, node.value, this);
        }
      }
      node = heap.extractMinimum();
      if (node) {
        nodes.push(node);
      }
    }
    for (var i2 = 0; i2 < nodes.length; i2++) {
      var n = nodes[i2];
      node = heap.insert(n.key, n.value);
      values[node.key] = node;
    }
  };
  Spa2.prototype.swap = function(i2, j) {
    var nodei = this._values[i2];
    var nodej = this._values[j];
    if (!nodei && nodej) {
      nodei = this._heap.insert(i2, nodej.value);
      this._heap.remove(nodej);
      this._values[i2] = nodei;
      this._values[j] = void 0;
    } else if (nodei && !nodej) {
      nodej = this._heap.insert(j, nodei.value);
      this._heap.remove(nodei);
      this._values[j] = nodej;
      this._values[i2] = void 0;
    } else if (nodei && nodej) {
      var v = nodei.value;
      nodei.value = nodej.value;
      nodej.value = v;
    }
  };
  return Spa2;
}, {
  isClass: true
});
var createBigNumberE = memoize(function(BigNumber2) {
  return new BigNumber2(1).exp();
}, {
  hasher
});
var createBigNumberPhi = memoize(function(BigNumber2) {
  return new BigNumber2(1).plus(new BigNumber2(5).sqrt()).div(2);
}, {
  hasher
});
var createBigNumberPi = memoize(function(BigNumber2) {
  return BigNumber2.acos(-1);
}, {
  hasher
});
var createBigNumberTau = memoize(function(BigNumber2) {
  return createBigNumberPi(BigNumber2).times(2);
}, {
  hasher
});
function hasher(args) {
  return args[0].precision;
}
function ownKeys$1(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread$1(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys$1(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys$1(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name$2o = "Unit";
var dependencies$2o = ["?on", "config", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "abs", "fix", "round", "equal", "isNumeric", "format", "number", "Complex", "BigNumber", "Fraction"];
var createUnitClass = /* @__PURE__ */ factory(name$2o, dependencies$2o, (_ref) => {
  var {
    on,
    config: config3,
    addScalar: addScalar2,
    subtractScalar: subtractScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    pow: pow2,
    abs: abs2,
    fix: fix2,
    round: round2,
    equal: equal2,
    isNumeric: isNumeric2,
    format: format2,
    number: _number,
    Complex: Complex2,
    BigNumber: _BigNumber,
    Fraction: _Fraction
  } = _ref;
  var toNumber = _number;
  function Unit2(value, valuelessUnit) {
    if (!(this instanceof Unit2)) {
      throw new Error("Constructor must be called with the new operator");
    }
    if (!(value === null || value === void 0 || isNumeric2(value) || isComplex(value))) {
      throw new TypeError("First parameter in Unit constructor must be number, BigNumber, Fraction, Complex, or undefined");
    }
    this.fixPrefix = false;
    this.skipAutomaticSimplification = true;
    if (valuelessUnit === void 0) {
      this.units = [];
      this.dimensions = BASE_DIMENSIONS.map((x) => 0);
    } else if (typeof valuelessUnit === "string") {
      var u = Unit2.parse(valuelessUnit);
      this.units = u.units;
      this.dimensions = u.dimensions;
    } else if (isUnit(valuelessUnit) && valuelessUnit.value === null) {
      this.fixPrefix = valuelessUnit.fixPrefix;
      this.skipAutomaticSimplification = valuelessUnit.skipAutomaticSimplification;
      this.dimensions = valuelessUnit.dimensions.slice(0);
      this.units = valuelessUnit.units.map((u2) => _extends$1({}, u2));
    } else {
      throw new TypeError("Second parameter in Unit constructor must be a string or valueless Unit");
    }
    this.value = this._normalize(value);
  }
  Object.defineProperty(Unit2, "name", {
    value: "Unit"
  });
  Unit2.prototype.constructor = Unit2;
  Unit2.prototype.type = "Unit";
  Unit2.prototype.isUnit = true;
  var text2, index2, c;
  function skipWhitespace() {
    while (c === " " || c === "	") {
      next();
    }
  }
  function isDigitDot(c2) {
    return c2 >= "0" && c2 <= "9" || c2 === ".";
  }
  function isDigit(c2) {
    return c2 >= "0" && c2 <= "9";
  }
  function next() {
    index2++;
    c = text2.charAt(index2);
  }
  function revert(oldIndex) {
    index2 = oldIndex;
    c = text2.charAt(index2);
  }
  function parseNumber() {
    var number2 = "";
    var oldIndex = index2;
    if (c === "+") {
      next();
    } else if (c === "-") {
      number2 += c;
      next();
    }
    if (!isDigitDot(c)) {
      revert(oldIndex);
      return null;
    }
    if (c === ".") {
      number2 += c;
      next();
      if (!isDigit(c)) {
        revert(oldIndex);
        return null;
      }
    } else {
      while (isDigit(c)) {
        number2 += c;
        next();
      }
      if (c === ".") {
        number2 += c;
        next();
      }
    }
    while (isDigit(c)) {
      number2 += c;
      next();
    }
    if (c === "E" || c === "e") {
      var tentativeNumber = "";
      var tentativeIndex = index2;
      tentativeNumber += c;
      next();
      if (c === "+" || c === "-") {
        tentativeNumber += c;
        next();
      }
      if (!isDigit(c)) {
        revert(tentativeIndex);
        return number2;
      }
      number2 = number2 + tentativeNumber;
      while (isDigit(c)) {
        number2 += c;
        next();
      }
    }
    return number2;
  }
  function parseUnit() {
    var unitName = "";
    while (isDigit(c) || Unit2.isValidAlpha(c)) {
      unitName += c;
      next();
    }
    var firstC = unitName.charAt(0);
    if (Unit2.isValidAlpha(firstC)) {
      return unitName;
    } else {
      return null;
    }
  }
  function parseCharacter(toFind) {
    if (c === toFind) {
      next();
      return toFind;
    } else {
      return null;
    }
  }
  Unit2.parse = function(str, options) {
    options = options || {};
    text2 = str;
    index2 = -1;
    c = "";
    if (typeof text2 !== "string") {
      throw new TypeError("Invalid argument in Unit.parse, string expected");
    }
    var unit3 = new Unit2();
    unit3.units = [];
    var powerMultiplierCurrent = 1;
    var expectingUnit = false;
    next();
    skipWhitespace();
    var valueStr = parseNumber();
    var value = null;
    if (valueStr) {
      if (config3.number === "BigNumber") {
        value = new _BigNumber(valueStr);
      } else if (config3.number === "Fraction") {
        try {
          value = new _Fraction(valueStr);
        } catch (err) {
          value = parseFloat(valueStr);
        }
      } else {
        value = parseFloat(valueStr);
      }
      skipWhitespace();
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      }
    }
    var powerMultiplierStack = [];
    var powerMultiplierStackProduct = 1;
    while (true) {
      skipWhitespace();
      while (c === "(") {
        powerMultiplierStack.push(powerMultiplierCurrent);
        powerMultiplierStackProduct *= powerMultiplierCurrent;
        powerMultiplierCurrent = 1;
        next();
        skipWhitespace();
      }
      var uStr = void 0;
      if (c) {
        var oldC = c;
        uStr = parseUnit();
        if (uStr === null) {
          throw new SyntaxError('Unexpected "' + oldC + '" in "' + text2 + '" at index ' + index2.toString());
        }
      } else {
        break;
      }
      var res = _findUnit(uStr);
      if (res === null) {
        throw new SyntaxError('Unit "' + uStr + '" not found.');
      }
      var power = powerMultiplierCurrent * powerMultiplierStackProduct;
      skipWhitespace();
      if (parseCharacter("^")) {
        skipWhitespace();
        var p = parseNumber();
        if (p === null) {
          throw new SyntaxError('In "' + str + '", "^" must be followed by a floating-point number');
        }
        power *= p;
      }
      unit3.units.push({
        unit: res.unit,
        prefix: res.prefix,
        power
      });
      for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
        unit3.dimensions[i2] += (res.unit.dimensions[i2] || 0) * power;
      }
      skipWhitespace();
      while (c === ")") {
        if (powerMultiplierStack.length === 0) {
          throw new SyntaxError('Unmatched ")" in "' + text2 + '" at index ' + index2.toString());
        }
        powerMultiplierStackProduct /= powerMultiplierStack.pop();
        next();
        skipWhitespace();
      }
      expectingUnit = false;
      if (parseCharacter("*")) {
        powerMultiplierCurrent = 1;
        expectingUnit = true;
      } else if (parseCharacter("/")) {
        powerMultiplierCurrent = -1;
        expectingUnit = true;
      } else {
        powerMultiplierCurrent = 1;
      }
      if (res.unit.base) {
        var baseDim = res.unit.base.key;
        UNIT_SYSTEMS.auto[baseDim] = {
          unit: res.unit,
          prefix: res.prefix
        };
      }
    }
    skipWhitespace();
    if (c) {
      throw new SyntaxError('Could not parse: "' + str + '"');
    }
    if (expectingUnit) {
      throw new SyntaxError('Trailing characters: "' + str + '"');
    }
    if (powerMultiplierStack.length !== 0) {
      throw new SyntaxError('Unmatched "(" in "' + text2 + '"');
    }
    if (unit3.units.length === 0 && !options.allowNoUnits) {
      throw new SyntaxError('"' + str + '" contains no units');
    }
    unit3.value = value !== void 0 ? unit3._normalize(value) : null;
    return unit3;
  };
  Unit2.prototype.clone = function() {
    var unit3 = new Unit2();
    unit3.fixPrefix = this.fixPrefix;
    unit3.skipAutomaticSimplification = this.skipAutomaticSimplification;
    unit3.value = clone$3(this.value);
    unit3.dimensions = this.dimensions.slice(0);
    unit3.units = [];
    for (var i2 = 0; i2 < this.units.length; i2++) {
      unit3.units[i2] = {};
      for (var p in this.units[i2]) {
        if (hasOwnProperty(this.units[i2], p)) {
          unit3.units[i2][p] = this.units[i2][p];
        }
      }
    }
    return unit3;
  };
  Unit2.prototype.valueType = function() {
    return typeOf$1(this.value);
  };
  Unit2.prototype._isDerived = function() {
    if (this.units.length === 0) {
      return false;
    }
    return this.units.length > 1 || Math.abs(this.units[0].power - 1) > 1e-15;
  };
  Unit2.prototype._normalize = function(value) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf$1(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = multiplyScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  Unit2.prototype._denormalize = function(value, prefixValue) {
    if (value === null || value === void 0 || this.units.length === 0) {
      return value;
    }
    var res = value;
    var convert = Unit2._getNumberConverter(typeOf$1(value));
    for (var i2 = 0; i2 < this.units.length; i2++) {
      var unitValue = convert(this.units[i2].unit.value);
      var unitPrefixValue = convert(this.units[i2].prefix.value);
      var unitPower = convert(this.units[i2].power);
      res = divideScalar2(res, pow2(multiplyScalar2(unitValue, unitPrefixValue), unitPower));
    }
    return res;
  };
  var _findUnit = memoize((str) => {
    if (hasOwnProperty(UNITS, str)) {
      var unit3 = UNITS[str];
      var prefix = unit3.prefixes[""];
      return {
        unit: unit3,
        prefix
      };
    }
    for (var _name in UNITS) {
      if (hasOwnProperty(UNITS, _name)) {
        if (endsWith(str, _name)) {
          var _unit = UNITS[_name];
          var prefixLen = str.length - _name.length;
          var prefixName = str.substring(0, prefixLen);
          var _prefix = hasOwnProperty(_unit.prefixes, prefixName) ? _unit.prefixes[prefixName] : void 0;
          if (_prefix !== void 0) {
            return {
              unit: _unit,
              prefix: _prefix
            };
          }
        }
      }
    }
    return null;
  }, {
    hasher: (args) => args[0],
    limit: 100
  });
  Unit2.isValuelessUnit = function(name2) {
    return _findUnit(name2) !== null;
  };
  Unit2.prototype.hasBase = function(base) {
    if (typeof base === "string") {
      base = BASE_UNITS[base];
    }
    if (!base) {
      return false;
    }
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (base.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equalBase = function(other) {
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      if (Math.abs((this.dimensions[i2] || 0) - (other.dimensions[i2] || 0)) > 1e-12) {
        return false;
      }
    }
    return true;
  };
  Unit2.prototype.equals = function(other) {
    return this.equalBase(other) && equal2(this.value, other.value);
  };
  Unit2.prototype.multiply = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) + (other.dimensions[i2] || 0);
    }
    for (var _i = 0; _i < other.units.length; _i++) {
      var inverted = _objectSpread$1({}, other.units[_i]);
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = multiplyScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.divideInto = function(numerator) {
    return new Unit2(numerator).divide(this);
  };
  Unit2.prototype.divide = function(_other) {
    var res = this.clone();
    var other = isUnit(_other) ? _other : new Unit2(_other);
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) - (other.dimensions[i2] || 0);
    }
    for (var _i2 = 0; _i2 < other.units.length; _i2++) {
      var inverted = _objectSpread$1(_objectSpread$1({}, other.units[_i2]), {}, {
        power: -other.units[_i2].power
      });
      res.units.push(inverted);
    }
    if (this.value !== null || other.value !== null) {
      var valThis = this.value === null ? this._normalize(1) : this.value;
      var valOther = other.value === null ? other._normalize(1) : other.value;
      res.value = divideScalar2(valThis, valOther);
    } else {
      res.value = null;
    }
    if (isUnit(_other)) {
      res.skipAutomaticSimplification = false;
    }
    return getNumericIfUnitless(res);
  };
  Unit2.prototype.pow = function(p) {
    var res = this.clone();
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      res.dimensions[i2] = (this.dimensions[i2] || 0) * p;
    }
    for (var _i3 = 0; _i3 < res.units.length; _i3++) {
      res.units[_i3].power *= p;
    }
    if (res.value !== null) {
      res.value = pow2(res.value, p);
    } else {
      res.value = null;
    }
    res.skipAutomaticSimplification = false;
    return getNumericIfUnitless(res);
  };
  function getNumericIfUnitless(unit3) {
    if (unit3.equalBase(BASE_UNITS.NONE) && unit3.value !== null && !config3.predictable) {
      return unit3.value;
    } else {
      return unit3;
    }
  }
  Unit2.prototype.abs = function() {
    var ret = this.clone();
    if (ret.value !== null) {
      if (ret._isDerived() || ret.units.length === 0 || ret.units[0].unit.offset === 0) {
        ret.value = abs2(ret.value);
      } else {
        var convert = ret._numberConverter();
        var unitValue = convert(ret.units[0].unit.value);
        var nominalOffset = convert(ret.units[0].unit.offset);
        var unitOffset = multiplyScalar2(unitValue, nominalOffset);
        ret.value = subtractScalar2(abs2(addScalar2(ret.value, unitOffset)), unitOffset);
      }
    }
    for (var i2 in ret.units) {
      if (ret.units[i2].unit.name === "VA" || ret.units[i2].unit.name === "VAR") {
        ret.units[i2].unit = UNITS.W;
      }
    }
    return ret;
  };
  Unit2.prototype.to = function(valuelessUnit) {
    var value = this.value === null ? this._normalize(1) : this.value;
    var other;
    if (typeof valuelessUnit === "string") {
      other = Unit2.parse(valuelessUnit);
    } else if (isUnit(valuelessUnit)) {
      other = valuelessUnit.clone();
    } else {
      throw new Error("String or Unit expected as parameter");
    }
    if (!this.equalBase(other)) {
      throw new Error("Units do not match ('".concat(other.toString(), "' != '").concat(this.toString(), "')"));
    }
    if (other.value !== null) {
      throw new Error("Cannot convert to a unit with a value");
    }
    if (this.value === null || this._isDerived() || this.units.length === 0 || other.units.length === 0 || this.units[0].unit.offset === other.units[0].unit.offset) {
      other.value = clone$3(value);
    } else {
      var convert = Unit2._getNumberConverter(typeOf$1(value));
      var thisUnitValue = this.units[0].unit.value;
      var thisNominalOffset = this.units[0].unit.offset;
      var thisUnitOffset = multiplyScalar2(thisUnitValue, thisNominalOffset);
      var otherUnitValue = other.units[0].unit.value;
      var otherNominalOffset = other.units[0].unit.offset;
      var otherUnitOffset = multiplyScalar2(otherUnitValue, otherNominalOffset);
      other.value = addScalar2(value, convert(subtractScalar2(thisUnitOffset, otherUnitOffset)));
    }
    other.fixPrefix = true;
    other.skipAutomaticSimplification = true;
    return other;
  };
  Unit2.prototype.toNumber = function(valuelessUnit) {
    return toNumber(this.toNumeric(valuelessUnit));
  };
  Unit2.prototype.toNumeric = function(valuelessUnit) {
    var other;
    if (valuelessUnit) {
      other = this.to(valuelessUnit);
    } else {
      other = this.clone();
    }
    if (other._isDerived() || other.units.length === 0) {
      return other._denormalize(other.value);
    } else {
      return other._denormalize(other.value, other.units[0].prefix.value);
    }
  };
  Unit2.prototype.toString = function() {
    return this.format();
  };
  Unit2.prototype.toJSON = function() {
    return {
      mathjs: "Unit",
      value: this._denormalize(this.value),
      unit: this.formatUnits(),
      fixPrefix: this.fixPrefix
    };
  };
  Unit2.fromJSON = function(json) {
    var unit3 = new Unit2(json.value, json.unit);
    unit3.fixPrefix = json.fixPrefix || false;
    return unit3;
  };
  Unit2.prototype.valueOf = Unit2.prototype.toString;
  Unit2.prototype.simplify = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    var matchingBase;
    for (var key2 in currentUnitSystem) {
      if (hasOwnProperty(currentUnitSystem, key2)) {
        if (ret.hasBase(BASE_UNITS[key2])) {
          matchingBase = key2;
          break;
        }
      }
    }
    if (matchingBase === "NONE") {
      ret.units = [];
    } else {
      var matchingUnit;
      if (matchingBase) {
        if (hasOwnProperty(currentUnitSystem, matchingBase)) {
          matchingUnit = currentUnitSystem[matchingBase];
        }
      }
      if (matchingUnit) {
        ret.units = [{
          unit: matchingUnit.unit,
          prefix: matchingUnit.prefix,
          power: 1
        }];
      } else {
        var missingBaseDim = false;
        for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
          var baseDim = BASE_DIMENSIONS[i2];
          if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
            if (hasOwnProperty(currentUnitSystem, baseDim)) {
              proposedUnitList.push({
                unit: currentUnitSystem[baseDim].unit,
                prefix: currentUnitSystem[baseDim].prefix,
                power: ret.dimensions[i2] || 0
              });
            } else {
              missingBaseDim = true;
            }
          }
        }
        if (proposedUnitList.length < ret.units.length && !missingBaseDim) {
          ret.units = proposedUnitList;
        }
      }
    }
    return ret;
  };
  Unit2.prototype.toSI = function() {
    var ret = this.clone();
    var proposedUnitList = [];
    for (var i2 = 0; i2 < BASE_DIMENSIONS.length; i2++) {
      var baseDim = BASE_DIMENSIONS[i2];
      if (Math.abs(ret.dimensions[i2] || 0) > 1e-12) {
        if (hasOwnProperty(UNIT_SYSTEMS.si, baseDim)) {
          proposedUnitList.push({
            unit: UNIT_SYSTEMS.si[baseDim].unit,
            prefix: UNIT_SYSTEMS.si[baseDim].prefix,
            power: ret.dimensions[i2] || 0
          });
        } else {
          throw new Error("Cannot express custom unit " + baseDim + " in SI units");
        }
      }
    }
    ret.units = proposedUnitList;
    ret.fixPrefix = true;
    ret.skipAutomaticSimplification = true;
    if (this.value !== null) {
      ret.value = null;
      return this.to(ret);
    }
    return ret;
  };
  Unit2.prototype.formatUnits = function() {
    var strNum = "";
    var strDen = "";
    var nNum = 0;
    var nDen = 0;
    for (var i2 = 0; i2 < this.units.length; i2++) {
      if (this.units[i2].power > 0) {
        nNum++;
        strNum += " " + this.units[i2].prefix.name + this.units[i2].unit.name;
        if (Math.abs(this.units[i2].power - 1) > 1e-15) {
          strNum += "^" + this.units[i2].power;
        }
      } else if (this.units[i2].power < 0) {
        nDen++;
      }
    }
    if (nDen > 0) {
      for (var _i4 = 0; _i4 < this.units.length; _i4++) {
        if (this.units[_i4].power < 0) {
          if (nNum > 0) {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            if (Math.abs(this.units[_i4].power + 1) > 1e-15) {
              strDen += "^" + -this.units[_i4].power;
            }
          } else {
            strDen += " " + this.units[_i4].prefix.name + this.units[_i4].unit.name;
            strDen += "^" + this.units[_i4].power;
          }
        }
      }
    }
    strNum = strNum.substr(1);
    strDen = strDen.substr(1);
    if (nNum > 1 && nDen > 0) {
      strNum = "(" + strNum + ")";
    }
    if (nDen > 1 && nNum > 0) {
      strDen = "(" + strDen + ")";
    }
    var str = strNum;
    if (nNum > 0 && nDen > 0) {
      str += " / ";
    }
    str += strDen;
    return str;
  };
  Unit2.prototype.format = function(options) {
    var simp = this.skipAutomaticSimplification || this.value === null ? this.clone() : this.simplify();
    var isImaginary = false;
    if (typeof simp.value !== "undefined" && simp.value !== null && isComplex(simp.value)) {
      isImaginary = Math.abs(simp.value.re) < 1e-14;
    }
    for (var i2 in simp.units) {
      if (hasOwnProperty(simp.units, i2)) {
        if (simp.units[i2].unit) {
          if (simp.units[i2].unit.name === "VA" && isImaginary) {
            simp.units[i2].unit = UNITS.VAR;
          } else if (simp.units[i2].unit.name === "VAR" && !isImaginary) {
            simp.units[i2].unit = UNITS.VA;
          }
        }
      }
    }
    if (simp.units.length === 1 && !simp.fixPrefix) {
      if (Math.abs(simp.units[0].power - Math.round(simp.units[0].power)) < 1e-14) {
        simp.units[0].prefix = simp._bestPrefix();
      }
    }
    var value = simp._denormalize(simp.value);
    var str = simp.value !== null ? format2(value, options || {}) : "";
    var unitStr = simp.formatUnits();
    if (simp.value && isComplex(simp.value)) {
      str = "(" + str + ")";
    }
    if (unitStr.length > 0 && str.length > 0) {
      str += " ";
    }
    str += unitStr;
    return str;
  };
  Unit2.prototype._bestPrefix = function() {
    if (this.units.length !== 1) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    if (Math.abs(this.units[0].power - Math.round(this.units[0].power)) >= 1e-14) {
      throw new Error("Can only compute the best prefix for single units with integer powers, like kg, s^2, N^-1, and so forth!");
    }
    var absValue = this.value !== null ? abs2(this.value) : 0;
    var absUnitValue = abs2(this.units[0].unit.value);
    var bestPrefix = this.units[0].prefix;
    if (absValue === 0) {
      return bestPrefix;
    }
    var power = this.units[0].power;
    var bestDiff = Math.log(absValue / Math.pow(bestPrefix.value * absUnitValue, power)) / Math.LN10 - 1.2;
    if (bestDiff > -2.200001 && bestDiff < 1.800001)
      return bestPrefix;
    bestDiff = Math.abs(bestDiff);
    var prefixes = this.units[0].unit.prefixes;
    for (var p in prefixes) {
      if (hasOwnProperty(prefixes, p)) {
        var prefix = prefixes[p];
        if (prefix.scientific) {
          var diff2 = Math.abs(Math.log(absValue / Math.pow(prefix.value * absUnitValue, power)) / Math.LN10 - 1.2);
          if (diff2 < bestDiff || diff2 === bestDiff && prefix.name.length < bestPrefix.name.length) {
            bestPrefix = prefix;
            bestDiff = diff2;
          }
        }
      }
    }
    return bestPrefix;
  };
  Unit2.prototype.splitUnit = function(parts) {
    var x = this.clone();
    var ret = [];
    for (var i2 = 0; i2 < parts.length; i2++) {
      x = x.to(parts[i2]);
      if (i2 === parts.length - 1)
        break;
      var xNumeric = x.toNumeric();
      var xRounded = round2(xNumeric);
      var xFixed = void 0;
      var isNearlyEqual = equal2(xRounded, xNumeric);
      if (isNearlyEqual) {
        xFixed = xRounded;
      } else {
        xFixed = fix2(x.toNumeric());
      }
      var y = new Unit2(xFixed, parts[i2].toString());
      ret.push(y);
      x = subtractScalar2(x, y);
    }
    var testSum = 0;
    for (var _i5 = 0; _i5 < ret.length; _i5++) {
      testSum = addScalar2(testSum, ret[_i5].value);
    }
    if (equal2(testSum, this.value)) {
      x.value = 0;
    }
    ret.push(x);
    return ret;
  };
  var PREFIXES = {
    NONE: {
      "": {
        name: "",
        value: 1,
        scientific: true
      }
    },
    SHORT: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 10,
        scientific: false
      },
      h: {
        name: "h",
        value: 100,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e27,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e30,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.1,
        scientific: false
      },
      c: {
        name: "c",
        value: 0.01,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-3,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-6,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-9,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-12,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-15,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-18,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-21,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-24,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-27,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-30,
        scientific: true
      }
    },
    LONG: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      deca: {
        name: "deca",
        value: 10,
        scientific: false
      },
      hecto: {
        name: "hecto",
        value: 100,
        scientific: false
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      },
      ronna: {
        name: "ronna",
        value: 1e27,
        scientific: true
      },
      quetta: {
        name: "quetta",
        value: 1e30,
        scientific: true
      },
      deci: {
        name: "deci",
        value: 0.1,
        scientific: false
      },
      centi: {
        name: "centi",
        value: 0.01,
        scientific: false
      },
      milli: {
        name: "milli",
        value: 1e-3,
        scientific: true
      },
      micro: {
        name: "micro",
        value: 1e-6,
        scientific: true
      },
      nano: {
        name: "nano",
        value: 1e-9,
        scientific: true
      },
      pico: {
        name: "pico",
        value: 1e-12,
        scientific: true
      },
      femto: {
        name: "femto",
        value: 1e-15,
        scientific: true
      },
      atto: {
        name: "atto",
        value: 1e-18,
        scientific: true
      },
      zepto: {
        name: "zepto",
        value: 1e-21,
        scientific: true
      },
      yocto: {
        name: "yocto",
        value: 1e-24,
        scientific: true
      },
      ronto: {
        name: "ronto",
        value: 1e-27,
        scientific: true
      },
      quecto: {
        name: "quecto",
        value: 1e-30,
        scientific: true
      }
    },
    SQUARED: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 100,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e4,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e6,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e12,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e18,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e24,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e30,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e36,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e42,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e48,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e54,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e60,
        scientific: true
      },
      d: {
        name: "d",
        value: 0.01,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-4,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-6,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-12,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-18,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-24,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-30,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-36,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-42,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-48,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-54,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-60,
        scientific: true
      }
    },
    CUBIC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      da: {
        name: "da",
        value: 1e3,
        scientific: false
      },
      h: {
        name: "h",
        value: 1e6,
        scientific: false
      },
      k: {
        name: "k",
        value: 1e9,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e18,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e27,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e36,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e45,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e54,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e63,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e72,
        scientific: true
      },
      R: {
        name: "R",
        value: 1e81,
        scientific: true
      },
      Q: {
        name: "Q",
        value: 1e90,
        scientific: true
      },
      d: {
        name: "d",
        value: 1e-3,
        scientific: false
      },
      c: {
        name: "c",
        value: 1e-6,
        scientific: false
      },
      m: {
        name: "m",
        value: 1e-9,
        scientific: true
      },
      u: {
        name: "u",
        value: 1e-18,
        scientific: true
      },
      n: {
        name: "n",
        value: 1e-27,
        scientific: true
      },
      p: {
        name: "p",
        value: 1e-36,
        scientific: true
      },
      f: {
        name: "f",
        value: 1e-45,
        scientific: true
      },
      a: {
        name: "a",
        value: 1e-54,
        scientific: true
      },
      z: {
        name: "z",
        value: 1e-63,
        scientific: true
      },
      y: {
        name: "y",
        value: 1e-72,
        scientific: true
      },
      r: {
        name: "r",
        value: 1e-81,
        scientific: true
      },
      q: {
        name: "q",
        value: 1e-90,
        scientific: true
      }
    },
    BINARY_SHORT_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      k: {
        name: "k",
        value: 1e3,
        scientific: true
      },
      M: {
        name: "M",
        value: 1e6,
        scientific: true
      },
      G: {
        name: "G",
        value: 1e9,
        scientific: true
      },
      T: {
        name: "T",
        value: 1e12,
        scientific: true
      },
      P: {
        name: "P",
        value: 1e15,
        scientific: true
      },
      E: {
        name: "E",
        value: 1e18,
        scientific: true
      },
      Z: {
        name: "Z",
        value: 1e21,
        scientific: true
      },
      Y: {
        name: "Y",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_SHORT_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      Ki: {
        name: "Ki",
        value: 1024,
        scientific: true
      },
      Mi: {
        name: "Mi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      Gi: {
        name: "Gi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      Ti: {
        name: "Ti",
        value: Math.pow(1024, 4),
        scientific: true
      },
      Pi: {
        name: "Pi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      Ei: {
        name: "Ei",
        value: Math.pow(1024, 6),
        scientific: true
      },
      Zi: {
        name: "Zi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      Yi: {
        name: "Yi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BINARY_LONG_SI: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kilo: {
        name: "kilo",
        value: 1e3,
        scientific: true
      },
      mega: {
        name: "mega",
        value: 1e6,
        scientific: true
      },
      giga: {
        name: "giga",
        value: 1e9,
        scientific: true
      },
      tera: {
        name: "tera",
        value: 1e12,
        scientific: true
      },
      peta: {
        name: "peta",
        value: 1e15,
        scientific: true
      },
      exa: {
        name: "exa",
        value: 1e18,
        scientific: true
      },
      zetta: {
        name: "zetta",
        value: 1e21,
        scientific: true
      },
      yotta: {
        name: "yotta",
        value: 1e24,
        scientific: true
      }
    },
    BINARY_LONG_IEC: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      kibi: {
        name: "kibi",
        value: 1024,
        scientific: true
      },
      mebi: {
        name: "mebi",
        value: Math.pow(1024, 2),
        scientific: true
      },
      gibi: {
        name: "gibi",
        value: Math.pow(1024, 3),
        scientific: true
      },
      tebi: {
        name: "tebi",
        value: Math.pow(1024, 4),
        scientific: true
      },
      pebi: {
        name: "pebi",
        value: Math.pow(1024, 5),
        scientific: true
      },
      exi: {
        name: "exi",
        value: Math.pow(1024, 6),
        scientific: true
      },
      zebi: {
        name: "zebi",
        value: Math.pow(1024, 7),
        scientific: true
      },
      yobi: {
        name: "yobi",
        value: Math.pow(1024, 8),
        scientific: true
      }
    },
    BTU: {
      "": {
        name: "",
        value: 1,
        scientific: true
      },
      MM: {
        name: "MM",
        value: 1e6,
        scientific: true
      }
    }
  };
  PREFIXES.SHORTLONG = _extends$1({}, PREFIXES.SHORT, PREFIXES.LONG);
  PREFIXES.BINARY_SHORT = _extends$1({}, PREFIXES.BINARY_SHORT_SI, PREFIXES.BINARY_SHORT_IEC);
  PREFIXES.BINARY_LONG = _extends$1({}, PREFIXES.BINARY_LONG_SI, PREFIXES.BINARY_LONG_IEC);
  var BASE_DIMENSIONS = ["MASS", "LENGTH", "TIME", "CURRENT", "TEMPERATURE", "LUMINOUS_INTENSITY", "AMOUNT_OF_SUBSTANCE", "ANGLE", "BIT"];
  var BASE_UNITS = {
    NONE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    MASS: {
      dimensions: [1, 0, 0, 0, 0, 0, 0, 0, 0]
    },
    LENGTH: {
      dimensions: [0, 1, 0, 0, 0, 0, 0, 0, 0]
    },
    TIME: {
      dimensions: [0, 0, 1, 0, 0, 0, 0, 0, 0]
    },
    CURRENT: {
      dimensions: [0, 0, 0, 1, 0, 0, 0, 0, 0]
    },
    TEMPERATURE: {
      dimensions: [0, 0, 0, 0, 1, 0, 0, 0, 0]
    },
    LUMINOUS_INTENSITY: {
      dimensions: [0, 0, 0, 0, 0, 1, 0, 0, 0]
    },
    AMOUNT_OF_SUBSTANCE: {
      dimensions: [0, 0, 0, 0, 0, 0, 1, 0, 0]
    },
    FORCE: {
      dimensions: [1, 1, -2, 0, 0, 0, 0, 0, 0]
    },
    SURFACE: {
      dimensions: [0, 2, 0, 0, 0, 0, 0, 0, 0]
    },
    VOLUME: {
      dimensions: [0, 3, 0, 0, 0, 0, 0, 0, 0]
    },
    ENERGY: {
      dimensions: [1, 2, -2, 0, 0, 0, 0, 0, 0]
    },
    POWER: {
      dimensions: [1, 2, -3, 0, 0, 0, 0, 0, 0]
    },
    PRESSURE: {
      dimensions: [1, -1, -2, 0, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CHARGE: {
      dimensions: [0, 0, 1, 1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CAPACITANCE: {
      dimensions: [-1, -2, 4, 2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_POTENTIAL: {
      dimensions: [1, 2, -3, -1, 0, 0, 0, 0, 0]
    },
    ELECTRIC_RESISTANCE: {
      dimensions: [1, 2, -3, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_INDUCTANCE: {
      dimensions: [1, 2, -2, -2, 0, 0, 0, 0, 0]
    },
    ELECTRIC_CONDUCTANCE: {
      dimensions: [-1, -2, 3, 2, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX: {
      dimensions: [1, 2, -2, -1, 0, 0, 0, 0, 0]
    },
    MAGNETIC_FLUX_DENSITY: {
      dimensions: [1, 0, -2, -1, 0, 0, 0, 0, 0]
    },
    FREQUENCY: {
      dimensions: [0, 0, -1, 0, 0, 0, 0, 0, 0]
    },
    ANGLE: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 1, 0]
    },
    BIT: {
      dimensions: [0, 0, 0, 0, 0, 0, 0, 0, 1]
    }
  };
  for (var key in BASE_UNITS) {
    if (hasOwnProperty(BASE_UNITS, key)) {
      BASE_UNITS[key].key = key;
    }
  }
  var BASE_UNIT_NONE = {};
  var UNIT_NONE = {
    name: "",
    base: BASE_UNIT_NONE,
    value: 1,
    offset: 0,
    dimensions: BASE_DIMENSIONS.map((x) => 0)
  };
  var UNITS = {
    // length
    meter: {
      name: "meter",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    inch: {
      name: "inch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    foot: {
      name: "foot",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yard: {
      name: "yard",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mile: {
      name: "mile",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    link: {
      name: "link",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rod: {
      name: "rod",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.0292,
      offset: 0
    },
    chain: {
      name: "chain",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    angstrom: {
      name: "angstrom",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1e-10,
      offset: 0
    },
    m: {
      name: "m",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    in: {
      name: "in",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.0254,
      offset: 0
    },
    ft: {
      name: "ft",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.3048,
      offset: 0
    },
    yd: {
      name: "yd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.9144,
      offset: 0
    },
    mi: {
      name: "mi",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 1609.344,
      offset: 0
    },
    li: {
      name: "li",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 0.201168,
      offset: 0
    },
    rd: {
      name: "rd",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 5.02921,
      offset: 0
    },
    ch: {
      name: "ch",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 20.1168,
      offset: 0
    },
    mil: {
      name: "mil",
      base: BASE_UNITS.LENGTH,
      prefixes: PREFIXES.NONE,
      value: 254e-7,
      offset: 0
    },
    // 1/1000 inch
    // Surface
    m2: {
      name: "m2",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.SQUARED,
      value: 1,
      offset: 0
    },
    sqin: {
      name: "sqin",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-8,
      offset: 0
    },
    // 645.16 mm2
    sqft: {
      name: "sqft",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.09290304,
      offset: 0
    },
    // 0.09290304 m2
    sqyd: {
      name: "sqyd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 0.83612736,
      offset: 0
    },
    // 0.83612736 m2
    sqmi: {
      name: "sqmi",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 2589988110336e-6,
      offset: 0
    },
    // 2.589988110336 km2
    sqrd: {
      name: "sqrd",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 25.29295,
      offset: 0
    },
    // 25.29295 m2
    sqch: {
      name: "sqch",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 404.6873,
      offset: 0
    },
    // 404.6873 m2
    sqmil: {
      name: "sqmil",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 64516e-14,
      offset: 0
    },
    // 6.4516 * 10^-10 m2
    acre: {
      name: "acre",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 4046.86,
      offset: 0
    },
    // 4046.86 m2
    hectare: {
      name: "hectare",
      base: BASE_UNITS.SURFACE,
      prefixes: PREFIXES.NONE,
      value: 1e4,
      offset: 0
    },
    // 10000 m2
    // Volume
    m3: {
      name: "m3",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.CUBIC,
      value: 1,
      offset: 0
    },
    L: {
      name: "L",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    l: {
      name: "l",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    // litre
    litre: {
      name: "litre",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    cuin: {
      name: "cuin",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 16387064e-12,
      offset: 0
    },
    // 1.6387064e-5 m3
    cuft: {
      name: "cuft",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.028316846592,
      offset: 0
    },
    // 28.316 846 592 L
    cuyd: {
      name: "cuyd",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.764554857984,
      offset: 0
    },
    // 764.554 857 984 L
    teaspoon: {
      name: "teaspoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-6,
      offset: 0
    },
    // 5 mL
    tablespoon: {
      name: "tablespoon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 15e-6,
      offset: 0
    },
    // 15 mL
    // {name: 'cup', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.000240, offset: 0}, // 240 mL  // not possible, we have already another cup
    drop: {
      name: "drop",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    gtt: {
      name: "gtt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 5e-8,
      offset: 0
    },
    // 0.05 mL = 5e-8 m3
    // Liquid volume
    minim: {
      name: "minim",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 6161152e-14,
      offset: 0
    },
    // 0.06161152 mL
    fluiddram: {
      name: "fluiddram",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    fluidounce: {
      name: "fluidounce",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gill: {
      name: "gill",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cc: {
      name: "cc",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1e-6,
      offset: 0
    },
    // 1e-6 L
    cup: {
      name: "cup",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pint: {
      name: "pint",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    quart: {
      name: "quart",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gallon: {
      name: "gallon",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    beerbarrel: {
      name: "beerbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    oilbarrel: {
      name: "oilbarrel",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    hogshead: {
      name: "hogshead",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.238481,
      offset: 0
    },
    // 238.4810 L
    // {name: 'min', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.00000006161152, offset: 0}, // 0.06161152 mL // min is already in use as minute
    fldr: {
      name: "fldr",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 36966911e-13,
      offset: 0
    },
    // 3.696691 mL
    floz: {
      name: "floz",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2957353e-11,
      offset: 0
    },
    // 29.57353 mL
    gi: {
      name: "gi",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 1182941e-10,
      offset: 0
    },
    // 118.2941 mL
    cp: {
      name: "cp",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 2365882e-10,
      offset: 0
    },
    // 236.5882 mL
    pt: {
      name: "pt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 4731765e-10,
      offset: 0
    },
    // 473.1765 mL
    qt: {
      name: "qt",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 9463529e-10,
      offset: 0
    },
    // 946.3529 mL
    gal: {
      name: "gal",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 3785412e-9,
      offset: 0
    },
    // 3.785412 L
    bbl: {
      name: "bbl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1173478,
      offset: 0
    },
    // 117.3478 L
    obl: {
      name: "obl",
      base: BASE_UNITS.VOLUME,
      prefixes: PREFIXES.NONE,
      value: 0.1589873,
      offset: 0
    },
    // 158.9873 L
    // {name: 'hogshead', base: BASE_UNITS.VOLUME, prefixes: PREFIXES.NONE, value: 0.2384810, offset: 0}, // 238.4810 L // TODO: hh?
    // Mass
    g: {
      name: "g",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e-3,
      offset: 0
    },
    gram: {
      name: "gram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e-3,
      offset: 0
    },
    ton: {
      name: "ton",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 907.18474,
      offset: 0
    },
    t: {
      name: "t",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.SHORT,
      value: 1e3,
      offset: 0
    },
    tonne: {
      name: "tonne",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.LONG,
      value: 1e3,
      offset: 0
    },
    grain: {
      name: "grain",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dram: {
      name: "dram",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    ounce: {
      name: "ounce",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    poundmass: {
      name: "poundmass",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    hundredweight: {
      name: "hundredweight",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    stick: {
      name: "stick",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.115,
      offset: 0
    },
    stone: {
      name: "stone",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6.35029318,
      offset: 0
    },
    gr: {
      name: "gr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 6479891e-11,
      offset: 0
    },
    dr: {
      name: "dr",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.0017718451953125,
      offset: 0
    },
    oz: {
      name: "oz",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.028349523125,
      offset: 0
    },
    lbm: {
      name: "lbm",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 0.45359237,
      offset: 0
    },
    cwt: {
      name: "cwt",
      base: BASE_UNITS.MASS,
      prefixes: PREFIXES.NONE,
      value: 45.359237,
      offset: 0
    },
    // Time
    s: {
      name: "s",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    min: {
      name: "min",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    h: {
      name: "h",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    second: {
      name: "second",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    sec: {
      name: "sec",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    minute: {
      name: "minute",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 60,
      offset: 0
    },
    hour: {
      name: "hour",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 3600,
      offset: 0
    },
    day: {
      name: "day",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 86400,
      offset: 0
    },
    week: {
      name: "week",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 7 * 86400,
      offset: 0
    },
    month: {
      name: "month",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 2629800,
      // 1/12th of Julian year
      offset: 0
    },
    year: {
      name: "year",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 31557600,
      // Julian year
      offset: 0
    },
    decade: {
      name: "decade",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e3,
      // Julian decade
      offset: 0
    },
    century: {
      name: "century",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e4,
      // Julian century
      offset: 0
    },
    millennium: {
      name: "millennium",
      base: BASE_UNITS.TIME,
      prefixes: PREFIXES.NONE,
      value: 315576e5,
      // Julian millennium
      offset: 0
    },
    // Frequency
    hertz: {
      name: "Hertz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    Hz: {
      name: "Hz",
      base: BASE_UNITS.FREQUENCY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0,
      reciprocal: true
    },
    // Angle
    rad: {
      name: "rad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    radian: {
      name: "radian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // deg = rad / (2*pi) * 360 = rad / 0.017453292519943295769236907684888
    deg: {
      name: "deg",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    degree: {
      name: "degree",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // grad = rad / (2*pi) * 400  = rad / 0.015707963267948966192313216916399
    grad: {
      name: "grad",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.SHORT,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    gradian: {
      name: "gradian",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.LONG,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // cycle = rad / (2*pi) = rad / 6.2831853071795864769252867665793
    cycle: {
      name: "cycle",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcsec = rad / (3600 * (360 / 2 * pi)) = rad / 0.0000048481368110953599358991410235795
    arcsec: {
      name: "arcsec",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // arcmin = rad / (60 * (360 / 2 * pi)) = rad / 0.00029088820866572159615394846141477
    arcmin: {
      name: "arcmin",
      base: BASE_UNITS.ANGLE,
      prefixes: PREFIXES.NONE,
      value: null,
      // will be filled in by calculateAngleValues()
      offset: 0
    },
    // Electric current
    A: {
      name: "A",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    ampere: {
      name: "ampere",
      base: BASE_UNITS.CURRENT,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // Temperature
    // K(C) = C + 273.15
    // K(F) = (F + 459.67) * (5 / 9)
    // K(R) = R * (5 / 9)
    K: {
      name: "K",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    degC: {
      name: "degC",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 273.15
    },
    degF: {
      name: "degF",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    degR: {
      name: "degR",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.SHORT,
      value: new _Fraction(5, 9),
      offset: 0
    },
    kelvin: {
      name: "kelvin",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    celsius: {
      name: "celsius",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 273.15
    },
    fahrenheit: {
      name: "fahrenheit",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 459.67
    },
    rankine: {
      name: "rankine",
      base: BASE_UNITS.TEMPERATURE,
      prefixes: PREFIXES.LONG,
      value: new _Fraction(5, 9),
      offset: 0
    },
    // amount of substance
    mol: {
      name: "mol",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    mole: {
      name: "mole",
      base: BASE_UNITS.AMOUNT_OF_SUBSTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // luminous intensity
    cd: {
      name: "cd",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    candela: {
      name: "candela",
      base: BASE_UNITS.LUMINOUS_INTENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    // TODO: units STERADIAN
    // {name: 'sr', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // {name: 'steradian', base: BASE_UNITS.STERADIAN, prefixes: PREFIXES.NONE, value: 1, offset: 0},
    // Force
    N: {
      name: "N",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    newton: {
      name: "newton",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    dyn: {
      name: "dyn",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.SHORT,
      value: 1e-5,
      offset: 0
    },
    dyne: {
      name: "dyne",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 1e-5,
      offset: 0
    },
    lbf: {
      name: "lbf",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    poundforce: {
      name: "poundforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 4.4482216152605,
      offset: 0
    },
    kip: {
      name: "kip",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.LONG,
      value: 4448.2216,
      offset: 0
    },
    kilogramforce: {
      name: "kilogramforce",
      base: BASE_UNITS.FORCE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    // Energy
    J: {
      name: "J",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    joule: {
      name: "joule",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    erg: {
      name: "erg",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORTLONG,
      // Both kiloerg and kerg are acceptable
      value: 1e-7,
      offset: 0
    },
    Wh: {
      name: "Wh",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 3600,
      offset: 0
    },
    BTU: {
      name: "BTU",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.BTU,
      value: 1055.05585262,
      offset: 0
    },
    eV: {
      name: "eV",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.SHORT,
      value: 1602176565e-28,
      offset: 0
    },
    electronvolt: {
      name: "electronvolt",
      base: BASE_UNITS.ENERGY,
      prefixes: PREFIXES.LONG,
      value: 1602176565e-28,
      offset: 0
    },
    // Power
    W: {
      name: "W",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    watt: {
      name: "watt",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    hp: {
      name: "hp",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.NONE,
      value: 745.6998715386,
      offset: 0
    },
    // Electrical power units
    VAR: {
      name: "VAR",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: Complex2.I,
      offset: 0
    },
    VA: {
      name: "VA",
      base: BASE_UNITS.POWER,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Pressure
    Pa: {
      name: "Pa",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    psi: {
      name: "psi",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 6894.75729276459,
      offset: 0
    },
    atm: {
      name: "atm",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 101325,
      offset: 0
    },
    bar: {
      name: "bar",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.SHORTLONG,
      value: 1e5,
      offset: 0
    },
    torr: {
      name: "torr",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmHg: {
      name: "mmHg",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 133.322,
      offset: 0
    },
    mmH2O: {
      name: "mmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 9.80665,
      offset: 0
    },
    cmH2O: {
      name: "cmH2O",
      base: BASE_UNITS.PRESSURE,
      prefixes: PREFIXES.NONE,
      value: 98.0665,
      offset: 0
    },
    // Electric charge
    coulomb: {
      name: "coulomb",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    C: {
      name: "C",
      base: BASE_UNITS.ELECTRIC_CHARGE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric capacitance
    farad: {
      name: "farad",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    F: {
      name: "F",
      base: BASE_UNITS.ELECTRIC_CAPACITANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric potential
    volt: {
      name: "volt",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    V: {
      name: "V",
      base: BASE_UNITS.ELECTRIC_POTENTIAL,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric resistance
    ohm: {
      name: "ohm",
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORTLONG,
      // Both Mohm and megaohm are acceptable
      value: 1,
      offset: 0
    },
    /*
     * Unicode breaks in browsers if charset is not specified
    : {
      name: '',
      base: BASE_UNITS.ELECTRIC_RESISTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    */
    // Electric inductance
    henry: {
      name: "henry",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    H: {
      name: "H",
      base: BASE_UNITS.ELECTRIC_INDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Electric conductance
    siemens: {
      name: "siemens",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    S: {
      name: "S",
      base: BASE_UNITS.ELECTRIC_CONDUCTANCE,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux
    weber: {
      name: "weber",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    Wb: {
      name: "Wb",
      base: BASE_UNITS.MAGNETIC_FLUX,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Magnetic flux density
    tesla: {
      name: "tesla",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.LONG,
      value: 1,
      offset: 0
    },
    T: {
      name: "T",
      base: BASE_UNITS.MAGNETIC_FLUX_DENSITY,
      prefixes: PREFIXES.SHORT,
      value: 1,
      offset: 0
    },
    // Binary
    b: {
      name: "b",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 1,
      offset: 0
    },
    bits: {
      name: "bits",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 1,
      offset: 0
    },
    B: {
      name: "B",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_SHORT,
      value: 8,
      offset: 0
    },
    bytes: {
      name: "bytes",
      base: BASE_UNITS.BIT,
      prefixes: PREFIXES.BINARY_LONG,
      value: 8,
      offset: 0
    }
  };
  var ALIASES = {
    meters: "meter",
    inches: "inch",
    feet: "foot",
    yards: "yard",
    miles: "mile",
    links: "link",
    rods: "rod",
    chains: "chain",
    angstroms: "angstrom",
    lt: "l",
    litres: "litre",
    liter: "litre",
    liters: "litre",
    teaspoons: "teaspoon",
    tablespoons: "tablespoon",
    minims: "minim",
    fluiddrams: "fluiddram",
    fluidounces: "fluidounce",
    gills: "gill",
    cups: "cup",
    pints: "pint",
    quarts: "quart",
    gallons: "gallon",
    beerbarrels: "beerbarrel",
    oilbarrels: "oilbarrel",
    hogsheads: "hogshead",
    gtts: "gtt",
    grams: "gram",
    tons: "ton",
    tonnes: "tonne",
    grains: "grain",
    drams: "dram",
    ounces: "ounce",
    poundmasses: "poundmass",
    hundredweights: "hundredweight",
    sticks: "stick",
    lb: "lbm",
    lbs: "lbm",
    kips: "kip",
    kgf: "kilogramforce",
    acres: "acre",
    hectares: "hectare",
    sqfeet: "sqft",
    sqyard: "sqyd",
    sqmile: "sqmi",
    sqmiles: "sqmi",
    mmhg: "mmHg",
    mmh2o: "mmH2O",
    cmh2o: "cmH2O",
    seconds: "second",
    secs: "second",
    minutes: "minute",
    mins: "minute",
    hours: "hour",
    hr: "hour",
    hrs: "hour",
    days: "day",
    weeks: "week",
    months: "month",
    years: "year",
    decades: "decade",
    centuries: "century",
    millennia: "millennium",
    hertz: "hertz",
    radians: "radian",
    degrees: "degree",
    gradians: "gradian",
    cycles: "cycle",
    arcsecond: "arcsec",
    arcseconds: "arcsec",
    arcminute: "arcmin",
    arcminutes: "arcmin",
    BTUs: "BTU",
    watts: "watt",
    joules: "joule",
    amperes: "ampere",
    amps: "ampere",
    amp: "ampere",
    coulombs: "coulomb",
    volts: "volt",
    ohms: "ohm",
    farads: "farad",
    webers: "weber",
    teslas: "tesla",
    electronvolts: "electronvolt",
    moles: "mole",
    bit: "bits",
    byte: "bytes"
  };
  function calculateAngleValues(config4) {
    if (config4.number === "BigNumber") {
      var pi2 = createBigNumberPi(_BigNumber);
      UNITS.rad.value = new _BigNumber(1);
      UNITS.deg.value = pi2.div(180);
      UNITS.grad.value = pi2.div(200);
      UNITS.cycle.value = pi2.times(2);
      UNITS.arcsec.value = pi2.div(648e3);
      UNITS.arcmin.value = pi2.div(10800);
    } else {
      UNITS.rad.value = 1;
      UNITS.deg.value = Math.PI / 180;
      UNITS.grad.value = Math.PI / 200;
      UNITS.cycle.value = Math.PI * 2;
      UNITS.arcsec.value = Math.PI / 648e3;
      UNITS.arcmin.value = Math.PI / 10800;
    }
    UNITS.radian.value = UNITS.rad.value;
    UNITS.degree.value = UNITS.deg.value;
    UNITS.gradian.value = UNITS.grad.value;
  }
  calculateAngleValues(config3);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.number !== prev.number) {
        calculateAngleValues(curr);
      }
    });
  }
  var UNIT_SYSTEMS = {
    si: {
      // Base units
      NONE: {
        unit: UNIT_NONE,
        prefix: PREFIXES.NONE[""]
      },
      LENGTH: {
        unit: UNITS.m,
        prefix: PREFIXES.SHORT[""]
      },
      MASS: {
        unit: UNITS.g,
        prefix: PREFIXES.SHORT.k
      },
      TIME: {
        unit: UNITS.s,
        prefix: PREFIXES.SHORT[""]
      },
      CURRENT: {
        unit: UNITS.A,
        prefix: PREFIXES.SHORT[""]
      },
      TEMPERATURE: {
        unit: UNITS.K,
        prefix: PREFIXES.SHORT[""]
      },
      LUMINOUS_INTENSITY: {
        unit: UNITS.cd,
        prefix: PREFIXES.SHORT[""]
      },
      AMOUNT_OF_SUBSTANCE: {
        unit: UNITS.mol,
        prefix: PREFIXES.SHORT[""]
      },
      ANGLE: {
        unit: UNITS.rad,
        prefix: PREFIXES.SHORT[""]
      },
      BIT: {
        unit: UNITS.bits,
        prefix: PREFIXES.SHORT[""]
      },
      // Derived units
      FORCE: {
        unit: UNITS.N,
        prefix: PREFIXES.SHORT[""]
      },
      ENERGY: {
        unit: UNITS.J,
        prefix: PREFIXES.SHORT[""]
      },
      POWER: {
        unit: UNITS.W,
        prefix: PREFIXES.SHORT[""]
      },
      PRESSURE: {
        unit: UNITS.Pa,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CHARGE: {
        unit: UNITS.C,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CAPACITANCE: {
        unit: UNITS.F,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_POTENTIAL: {
        unit: UNITS.V,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_RESISTANCE: {
        unit: UNITS.ohm,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_INDUCTANCE: {
        unit: UNITS.H,
        prefix: PREFIXES.SHORT[""]
      },
      ELECTRIC_CONDUCTANCE: {
        unit: UNITS.S,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX: {
        unit: UNITS.Wb,
        prefix: PREFIXES.SHORT[""]
      },
      MAGNETIC_FLUX_DENSITY: {
        unit: UNITS.T,
        prefix: PREFIXES.SHORT[""]
      },
      FREQUENCY: {
        unit: UNITS.Hz,
        prefix: PREFIXES.SHORT[""]
      }
    }
  };
  UNIT_SYSTEMS.cgs = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.cgs.LENGTH = {
    unit: UNITS.m,
    prefix: PREFIXES.SHORT.c
  };
  UNIT_SYSTEMS.cgs.MASS = {
    unit: UNITS.g,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.FORCE = {
    unit: UNITS.dyn,
    prefix: PREFIXES.SHORT[""]
  };
  UNIT_SYSTEMS.cgs.ENERGY = {
    unit: UNITS.erg,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  UNIT_SYSTEMS.us.LENGTH = {
    unit: UNITS.ft,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.MASS = {
    unit: UNITS.lbm,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.TEMPERATURE = {
    unit: UNITS.degF,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.FORCE = {
    unit: UNITS.lbf,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.ENERGY = {
    unit: UNITS.BTU,
    prefix: PREFIXES.BTU[""]
  };
  UNIT_SYSTEMS.us.POWER = {
    unit: UNITS.hp,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.us.PRESSURE = {
    unit: UNITS.psi,
    prefix: PREFIXES.NONE[""]
  };
  UNIT_SYSTEMS.auto = JSON.parse(JSON.stringify(UNIT_SYSTEMS.si));
  var currentUnitSystem = UNIT_SYSTEMS.auto;
  Unit2.setUnitSystem = function(name2) {
    if (hasOwnProperty(UNIT_SYSTEMS, name2)) {
      currentUnitSystem = UNIT_SYSTEMS[name2];
    } else {
      throw new Error("Unit system " + name2 + " does not exist. Choices are: " + Object.keys(UNIT_SYSTEMS).join(", "));
    }
  };
  Unit2.getUnitSystem = function() {
    for (var _key in UNIT_SYSTEMS) {
      if (hasOwnProperty(UNIT_SYSTEMS, _key)) {
        if (UNIT_SYSTEMS[_key] === currentUnitSystem) {
          return _key;
        }
      }
    }
  };
  Unit2.typeConverters = {
    BigNumber: function BigNumber2(x) {
      if (x !== null && x !== void 0 && x.isFraction)
        return new _BigNumber(x.n).div(x.d).times(x.s);
      return new _BigNumber(x + "");
    },
    Fraction: function Fraction2(x) {
      return new _Fraction(x);
    },
    Complex: function Complex3(x) {
      return x;
    },
    number: function number2(x) {
      if (x !== null && x !== void 0 && x.isFraction)
        return _number(x);
      return x;
    }
  };
  Unit2.prototype._numberConverter = function() {
    var convert = Unit2.typeConverters[this.valueType()];
    if (convert) {
      return convert;
    }
    throw new TypeError('Unsupported Unit value type "' + this.valueType() + '"');
  };
  Unit2._getNumberConverter = function(type) {
    if (!Unit2.typeConverters[type]) {
      throw new TypeError('Unsupported type "' + type + '"');
    }
    return Unit2.typeConverters[type];
  };
  for (var _key2 in UNITS) {
    if (hasOwnProperty(UNITS, _key2)) {
      var unit2 = UNITS[_key2];
      unit2.dimensions = unit2.base.dimensions;
    }
  }
  for (var _name2 in ALIASES) {
    if (hasOwnProperty(ALIASES, _name2)) {
      var _unit2 = UNITS[ALIASES[_name2]];
      var alias = {};
      for (var _key3 in _unit2) {
        if (hasOwnProperty(_unit2, _key3)) {
          alias[_key3] = _unit2[_key3];
        }
      }
      alias.name = _name2;
      UNITS[_name2] = alias;
    }
  }
  Unit2.isValidAlpha = function isValidAlpha(c2) {
    return /^[a-zA-Z]$/.test(c2);
  };
  function assertUnitNameIsValid(name2) {
    for (var i2 = 0; i2 < name2.length; i2++) {
      c = name2.charAt(i2);
      if (i2 === 0 && !Unit2.isValidAlpha(c)) {
        throw new Error('Invalid unit name (must begin with alpha character): "' + name2 + '"');
      }
      if (i2 > 0 && !(Unit2.isValidAlpha(c) || isDigit(c))) {
        throw new Error('Invalid unit name (only alphanumeric characters are allowed): "' + name2 + '"');
      }
    }
  }
  Unit2.createUnit = function(obj, options) {
    if (typeof obj !== "object") {
      throw new TypeError("createUnit expects first parameter to be of type 'Object'");
    }
    if (options && options.override) {
      for (var _key4 in obj) {
        if (hasOwnProperty(obj, _key4)) {
          Unit2.deleteUnit(_key4);
        }
        if (obj[_key4].aliases) {
          for (var i2 = 0; i2 < obj[_key4].aliases.length; i2++) {
            Unit2.deleteUnit(obj[_key4].aliases[i2]);
          }
        }
      }
    }
    var lastUnit;
    for (var _key5 in obj) {
      if (hasOwnProperty(obj, _key5)) {
        lastUnit = Unit2.createUnitSingle(_key5, obj[_key5]);
      }
    }
    return lastUnit;
  };
  Unit2.createUnitSingle = function(name2, obj) {
    if (typeof obj === "undefined" || obj === null) {
      obj = {};
    }
    if (typeof name2 !== "string") {
      throw new TypeError("createUnitSingle expects first parameter to be of type 'string'");
    }
    if (hasOwnProperty(UNITS, name2)) {
      throw new Error('Cannot create unit "' + name2 + '": a unit with that name already exists');
    }
    assertUnitNameIsValid(name2);
    var defUnit = null;
    var aliases = [];
    var offset = 0;
    var definition;
    var prefixes;
    var baseName;
    if (obj && obj.type === "Unit") {
      defUnit = obj.clone();
    } else if (typeof obj === "string") {
      if (obj !== "") {
        definition = obj;
      }
    } else if (typeof obj === "object") {
      definition = obj.definition;
      prefixes = obj.prefixes;
      offset = obj.offset;
      baseName = obj.baseName;
      if (obj.aliases) {
        aliases = obj.aliases.valueOf();
      }
    } else {
      throw new TypeError('Cannot create unit "' + name2 + '" from "' + obj.toString() + '": expecting "string" or "Unit" or "Object"');
    }
    if (aliases) {
      for (var i2 = 0; i2 < aliases.length; i2++) {
        if (hasOwnProperty(UNITS, aliases[i2])) {
          throw new Error('Cannot create alias "' + aliases[i2] + '": a unit with that name already exists');
        }
      }
    }
    if (definition && typeof definition === "string" && !defUnit) {
      try {
        defUnit = Unit2.parse(definition, {
          allowNoUnits: true
        });
      } catch (ex) {
        ex.message = 'Could not create unit "' + name2 + '" from "' + definition + '": ' + ex.message;
        throw ex;
      }
    } else if (definition && definition.type === "Unit") {
      defUnit = definition.clone();
    }
    aliases = aliases || [];
    offset = offset || 0;
    if (prefixes && prefixes.toUpperCase) {
      prefixes = PREFIXES[prefixes.toUpperCase()] || PREFIXES.NONE;
    } else {
      prefixes = PREFIXES.NONE;
    }
    var newUnit = {};
    if (!defUnit) {
      baseName = baseName || name2 + "_STUFF";
      if (BASE_DIMENSIONS.indexOf(baseName) >= 0) {
        throw new Error('Cannot create new base unit "' + name2 + '": a base unit with that name already exists (and cannot be overridden)');
      }
      BASE_DIMENSIONS.push(baseName);
      for (var b in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, b)) {
          BASE_UNITS[b].dimensions[BASE_DIMENSIONS.length - 1] = 0;
        }
      }
      var newBaseUnit = {
        dimensions: []
      };
      for (var _i6 = 0; _i6 < BASE_DIMENSIONS.length; _i6++) {
        newBaseUnit.dimensions[_i6] = 0;
      }
      newBaseUnit.dimensions[BASE_DIMENSIONS.length - 1] = 1;
      newBaseUnit.key = baseName;
      BASE_UNITS[baseName] = newBaseUnit;
      newUnit = {
        name: name2,
        value: 1,
        dimensions: BASE_UNITS[baseName].dimensions.slice(0),
        prefixes,
        offset,
        base: BASE_UNITS[baseName]
      };
      currentUnitSystem[baseName] = {
        unit: newUnit,
        prefix: PREFIXES.NONE[""]
      };
    } else {
      newUnit = {
        name: name2,
        value: defUnit.value,
        dimensions: defUnit.dimensions.slice(0),
        prefixes,
        offset
      };
      var anyMatch = false;
      for (var _i7 in BASE_UNITS) {
        if (hasOwnProperty(BASE_UNITS, _i7)) {
          var match = true;
          for (var j = 0; j < BASE_DIMENSIONS.length; j++) {
            if (Math.abs((newUnit.dimensions[j] || 0) - (BASE_UNITS[_i7].dimensions[j] || 0)) > 1e-12) {
              match = false;
              break;
            }
          }
          if (match) {
            anyMatch = true;
            newUnit.base = BASE_UNITS[_i7];
            break;
          }
        }
      }
      if (!anyMatch) {
        baseName = baseName || name2 + "_STUFF";
        var _newBaseUnit = {
          dimensions: defUnit.dimensions.slice(0)
        };
        _newBaseUnit.key = baseName;
        BASE_UNITS[baseName] = _newBaseUnit;
        currentUnitSystem[baseName] = {
          unit: newUnit,
          prefix: PREFIXES.NONE[""]
        };
        newUnit.base = BASE_UNITS[baseName];
      }
    }
    Unit2.UNITS[name2] = newUnit;
    for (var _i8 = 0; _i8 < aliases.length; _i8++) {
      var aliasName = aliases[_i8];
      var _alias = {};
      for (var _key6 in newUnit) {
        if (hasOwnProperty(newUnit, _key6)) {
          _alias[_key6] = newUnit[_key6];
        }
      }
      _alias.name = aliasName;
      Unit2.UNITS[aliasName] = _alias;
    }
    delete _findUnit.cache;
    return new Unit2(null, name2);
  };
  Unit2.deleteUnit = function(name2) {
    delete Unit2.UNITS[name2];
    delete _findUnit.cache;
  };
  Unit2.PREFIXES = PREFIXES;
  Unit2.BASE_DIMENSIONS = BASE_DIMENSIONS;
  Unit2.BASE_UNITS = BASE_UNITS;
  Unit2.UNIT_SYSTEMS = UNIT_SYSTEMS;
  Unit2.UNITS = UNITS;
  return Unit2;
}, {
  isClass: true
});
var name$2n = "unit";
var dependencies$2n = ["typed", "Unit"];
var createUnitFunction = /* @__PURE__ */ factory(name$2n, dependencies$2n, (_ref) => {
  var {
    typed: typed2,
    Unit: Unit2
  } = _ref;
  return typed2(name$2n, {
    Unit: function Unit3(x) {
      return x.clone();
    },
    string: function string2(x) {
      if (Unit2.isValuelessUnit(x)) {
        return new Unit2(null, x);
      }
      return Unit2.parse(x, {
        allowNoUnits: true
      });
    },
    "number | BigNumber | Fraction | Complex, string | Unit": function numberBigNumberFractionComplexStringUnit(value, unit2) {
      return new Unit2(value, unit2);
    },
    "number | BigNumber | Fraction": function numberBigNumberFraction(value) {
      return new Unit2(value);
    },
    "Array | Matrix": typed2.referToSelf((self2) => (x) => deepMap(x, self2))
  });
});
var name$2m = "sparse";
var dependencies$2m = ["typed", "SparseMatrix"];
var createSparse = /* @__PURE__ */ factory(name$2m, dependencies$2m, (_ref) => {
  var {
    typed: typed2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  return typed2(name$2m, {
    "": function _() {
      return new SparseMatrix2([]);
    },
    string: function string2(datatype) {
      return new SparseMatrix2([], datatype);
    },
    "Array | Matrix": function ArrayMatrix(data) {
      return new SparseMatrix2(data);
    },
    "Array | Matrix, string": function ArrayMatrixString(data, datatype) {
      return new SparseMatrix2(data, datatype);
    }
  });
});
var name$2l = "createUnit";
var dependencies$2l = ["typed", "Unit"];
var createCreateUnit = /* @__PURE__ */ factory(name$2l, dependencies$2l, (_ref) => {
  var {
    typed: typed2,
    Unit: Unit2
  } = _ref;
  return typed2(name$2l, {
    // General function signature. First parameter is an object where each property is the definition of a new unit. The object keys are the unit names and the values are the definitions. The values can be objects, strings, or Units. If a property is an empty object or an empty string, a new base unit is created. The second parameter is the options.
    "Object, Object": function ObjectObject(obj, options) {
      return Unit2.createUnit(obj, options);
    },
    // Same as above but without the options.
    Object: function Object2(obj) {
      return Unit2.createUnit(obj, {});
    },
    // Shortcut method for creating one unit.
    "string, Unit | string | Object, Object": function stringUnitStringObjectObject(name2, def, options) {
      var obj = {};
      obj[name2] = def;
      return Unit2.createUnit(obj, options);
    },
    // Same as above but without the options.
    "string, Unit | string | Object": function stringUnitStringObject(name2, def) {
      var obj = {};
      obj[name2] = def;
      return Unit2.createUnit(obj, {});
    },
    // Without a definition, creates a base unit.
    string: function string2(name2) {
      var obj = {};
      obj[name2] = {};
      return Unit2.createUnit(obj, {});
    }
  });
});
var name$2k = "acos";
var dependencies$2k = ["typed", "config", "Complex"];
var createAcos = /* @__PURE__ */ factory(name$2k, dependencies$2k, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$2k, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config3.predictable) {
        return Math.acos(x);
      } else {
        return new Complex2(x, 0).acos();
      }
    },
    Complex: function Complex3(x) {
      return x.acos();
    },
    BigNumber: function BigNumber2(x) {
      return x.acos();
    }
  });
});
var name$2j = "acosh";
var dependencies$2j = ["typed", "config", "Complex"];
var createAcosh = /* @__PURE__ */ factory(name$2j, dependencies$2j, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$2j, {
    number: function number2(x) {
      if (x >= 1 || config3.predictable) {
        return acoshNumber(x);
      }
      if (x <= -1) {
        return new Complex2(Math.log(Math.sqrt(x * x - 1) - x), Math.PI);
      }
      return new Complex2(x, 0).acosh();
    },
    Complex: function Complex3(x) {
      return x.acosh();
    },
    BigNumber: function BigNumber2(x) {
      return x.acosh();
    }
  });
});
var name$2i = "acot";
var dependencies$2i = ["typed", "BigNumber"];
var createAcot = /* @__PURE__ */ factory(name$2i, dependencies$2i, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$2i, {
    number: acotNumber,
    Complex: function Complex2(x) {
      return x.acot();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atan();
    }
  });
});
var name$2h = "acoth";
var dependencies$2h = ["typed", "config", "Complex", "BigNumber"];
var createAcoth = /* @__PURE__ */ factory(name$2h, dependencies$2h, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$2h, {
    number: function number2(x) {
      if (x >= 1 || x <= -1 || config3.predictable) {
        return acothNumber(x);
      }
      return new Complex2(x, 0).acoth();
    },
    Complex: function Complex3(x) {
      return x.acoth();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).atanh();
    }
  });
});
var name$2g = "acsc";
var dependencies$2g = ["typed", "config", "Complex", "BigNumber"];
var createAcsc = /* @__PURE__ */ factory(name$2g, dependencies$2g, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$2g, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config3.predictable) {
        return acscNumber(x);
      }
      return new Complex2(x, 0).acsc();
    },
    Complex: function Complex3(x) {
      return x.acsc();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asin();
    }
  });
});
var name$2f = "acsch";
var dependencies$2f = ["typed", "BigNumber"];
var createAcsch = /* @__PURE__ */ factory(name$2f, dependencies$2f, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$2f, {
    number: acschNumber,
    Complex: function Complex2(x) {
      return x.acsch();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).asinh();
    }
  });
});
var name$2e = "asec";
var dependencies$2e = ["typed", "config", "Complex", "BigNumber"];
var createAsec = /* @__PURE__ */ factory(name$2e, dependencies$2e, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$2e, {
    number: function number2(x) {
      if (x <= -1 || x >= 1 || config3.predictable) {
        return asecNumber(x);
      }
      return new Complex2(x, 0).asec();
    },
    Complex: function Complex3(x) {
      return x.asec();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acos();
    }
  });
});
var name$2d = "asech";
var dependencies$2d = ["typed", "config", "Complex", "BigNumber"];
var createAsech = /* @__PURE__ */ factory(name$2d, dependencies$2d, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$2d, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config3.predictable) {
        var xInv = 1 / x;
        if (xInv > 0 || config3.predictable) {
          return asechNumber(x);
        }
        var ret = Math.sqrt(xInv * xInv - 1);
        return new Complex2(Math.log(ret - xInv), Math.PI);
      }
      return new Complex2(x, 0).asech();
    },
    Complex: function Complex3(x) {
      return x.asech();
    },
    BigNumber: function BigNumber2(x) {
      return new _BigNumber(1).div(x).acosh();
    }
  });
});
var name$2c = "asin";
var dependencies$2c = ["typed", "config", "Complex"];
var createAsin = /* @__PURE__ */ factory(name$2c, dependencies$2c, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$2c, {
    number: function number2(x) {
      if (x >= -1 && x <= 1 || config3.predictable) {
        return Math.asin(x);
      } else {
        return new Complex2(x, 0).asin();
      }
    },
    Complex: function Complex3(x) {
      return x.asin();
    },
    BigNumber: function BigNumber2(x) {
      return x.asin();
    }
  });
});
var name$2b = "asinh";
var dependencies$2b = ["typed"];
var createAsinh = /* @__PURE__ */ factory(name$2b, dependencies$2b, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("asinh", {
    number: asinhNumber,
    Complex: function Complex2(x) {
      return x.asinh();
    },
    BigNumber: function BigNumber2(x) {
      return x.asinh();
    }
  });
});
var name$2a = "atan";
var dependencies$2a = ["typed"];
var createAtan = /* @__PURE__ */ factory(name$2a, dependencies$2a, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("atan", {
    number: function number2(x) {
      return Math.atan(x);
    },
    Complex: function Complex2(x) {
      return x.atan();
    },
    BigNumber: function BigNumber2(x) {
      return x.atan();
    }
  });
});
var name$29 = "atan2";
var dependencies$29 = ["typed", "matrix", "equalScalar", "BigNumber", "DenseMatrix", "concat"];
var createAtan2 = /* @__PURE__ */ factory(name$29, dependencies$29, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    BigNumber: BigNumber2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo02xDS0 = createMatAlgo02xDS0({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo03xDSf = createMatAlgo03xDSf({
    typed: typed2
  });
  var matAlgo09xS0Sf = createMatAlgo09xS0Sf({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo12xSfs = createMatAlgo12xSfs({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$29, {
    "number, number": Math.atan2,
    // Complex numbers doesn't seem to have a reasonable implementation of
    // atan2(). Even Matlab removed the support, after they only calculated
    // the atan only on base of the real part of the numbers and ignored
    // the imaginary.
    "BigNumber, BigNumber": (y, x) => BigNumber2.atan2(y, x)
  }, matrixAlgorithmSuite({
    scalar: "number | BigNumber",
    SS: matAlgo09xS0Sf,
    DS: matAlgo03xDSf,
    SD: matAlgo02xDS0,
    Ss: matAlgo11xS0s,
    sS: matAlgo12xSfs
  }));
});
var name$28 = "atanh";
var dependencies$28 = ["typed", "config", "Complex"];
var createAtanh = /* @__PURE__ */ factory(name$28, dependencies$28, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    Complex: Complex2
  } = _ref;
  return typed2(name$28, {
    number: function number2(x) {
      if (x <= 1 && x >= -1 || config3.predictable) {
        return atanhNumber(x);
      }
      return new Complex2(x, 0).atanh();
    },
    Complex: function Complex3(x) {
      return x.atanh();
    },
    BigNumber: function BigNumber2(x) {
      return x.atanh();
    }
  });
});
var createTrigUnit = /* @__PURE__ */ factory("trigUnit", ["typed"], (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return {
    Unit: typed2.referToSelf((self2) => (x) => {
      if (!x.hasBase(x.constructor.BASE_UNITS.ANGLE)) {
        throw new TypeError("Unit in function cot is no angle");
      }
      return typed2.find(self2, x.valueType())(x.value);
    })
  };
});
var name$27 = "cos";
var dependencies$27 = ["typed"];
var createCos = /* @__PURE__ */ factory(name$27, dependencies$27, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$27, {
    number: Math.cos,
    "Complex | BigNumber": (x) => x.cos()
  }, trigUnit);
});
var name$26 = "cosh";
var dependencies$26 = ["typed"];
var createCosh = /* @__PURE__ */ factory(name$26, dependencies$26, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$26, {
    number: cosh$2,
    "Complex | BigNumber": (x) => x.cosh()
  });
});
var name$25 = "cot";
var dependencies$25 = ["typed", "BigNumber"];
var createCot = /* @__PURE__ */ factory(name$25, dependencies$25, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$25, {
    number: cotNumber,
    Complex: (x) => x.cot(),
    BigNumber: (x) => new _BigNumber(1).div(x.tan())
  }, trigUnit);
});
var name$24 = "coth";
var dependencies$24 = ["typed", "BigNumber"];
var createCoth = /* @__PURE__ */ factory(name$24, dependencies$24, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$24, {
    number: cothNumber,
    Complex: (x) => x.coth(),
    BigNumber: (x) => new _BigNumber(1).div(x.tanh())
  });
});
var name$23 = "csc";
var dependencies$23 = ["typed", "BigNumber"];
var createCsc = /* @__PURE__ */ factory(name$23, dependencies$23, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$23, {
    number: cscNumber,
    Complex: (x) => x.csc(),
    BigNumber: (x) => new _BigNumber(1).div(x.sin())
  }, trigUnit);
});
var name$22 = "csch";
var dependencies$22 = ["typed", "BigNumber"];
var createCsch = /* @__PURE__ */ factory(name$22, dependencies$22, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$22, {
    number: cschNumber,
    Complex: (x) => x.csch(),
    BigNumber: (x) => new _BigNumber(1).div(x.sinh())
  });
});
var name$21 = "sec";
var dependencies$21 = ["typed", "BigNumber"];
var createSec = /* @__PURE__ */ factory(name$21, dependencies$21, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$21, {
    number: secNumber,
    Complex: (x) => x.sec(),
    BigNumber: (x) => new _BigNumber(1).div(x.cos())
  }, trigUnit);
});
var name$20 = "sech";
var dependencies$20 = ["typed", "BigNumber"];
var createSech = /* @__PURE__ */ factory(name$20, dependencies$20, (_ref) => {
  var {
    typed: typed2,
    BigNumber: _BigNumber
  } = _ref;
  return typed2(name$20, {
    number: sechNumber,
    Complex: (x) => x.sech(),
    BigNumber: (x) => new _BigNumber(1).div(x.cosh())
  });
});
var name$1$ = "sin";
var dependencies$1$ = ["typed"];
var createSin = /* @__PURE__ */ factory(name$1$, dependencies$1$, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$1$, {
    number: Math.sin,
    "Complex | BigNumber": (x) => x.sin()
  }, trigUnit);
});
var name$1_ = "sinh";
var dependencies$1_ = ["typed"];
var createSinh = /* @__PURE__ */ factory(name$1_, dependencies$1_, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$1_, {
    number: sinhNumber,
    "Complex | BigNumber": (x) => x.sinh()
  });
});
var name$1Z = "tan";
var dependencies$1Z = ["typed"];
var createTan = /* @__PURE__ */ factory(name$1Z, dependencies$1Z, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  var trigUnit = createTrigUnit({
    typed: typed2
  });
  return typed2(name$1Z, {
    number: Math.tan,
    "Complex | BigNumber": (x) => x.tan()
  }, trigUnit);
});
var name$1Y = "tanh";
var dependencies$1Y = ["typed"];
var createTanh = /* @__PURE__ */ factory(name$1Y, dependencies$1Y, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2("tanh", {
    number: tanh$2,
    "Complex | BigNumber": (x) => x.tanh()
  });
});
var name$1X = "setCartesian";
var dependencies$1X = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetCartesian = /* @__PURE__ */ factory(name$1X, dependencies$1X, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name$1X, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result = [];
      if (subset2(size2(a1), new Index2(0)) !== 0 && subset2(size2(a2), new Index2(0)) !== 0) {
        var b1 = flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2);
        var b2 = flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2);
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            result.push([b1[i2], b2[j]]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});
var name$1W = "setDifference";
var dependencies$1W = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDifference = /* @__PURE__ */ factory(name$1W, dependencies$1W, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name$1W, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0) {
        result = [];
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten$1(a1.toArray());
      } else {
        var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        var inb2;
        for (var i2 = 0; i2 < b1.length; i2++) {
          inb2 = false;
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              inb2 = true;
              break;
            }
          }
          if (!inb2) {
            result.push(b1[i2]);
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});
var name$1V = "setDistinct";
var dependencies$1V = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetDistinct = /* @__PURE__ */ factory(name$1V, dependencies$1V, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name$1V, {
    "Array | Matrix": function ArrayMatrix(a) {
      var result;
      if (subset2(size2(a), new Index2(0)) === 0) {
        result = [];
      } else {
        var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        result = [];
        result.push(b[0]);
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            result.push(b[i2]);
          }
        }
      }
      if (Array.isArray(a)) {
        return result;
      }
      return new DenseMatrix2(result);
    }
  });
});
var name$1U = "setIntersect";
var dependencies$1U = ["typed", "size", "subset", "compareNatural", "Index", "DenseMatrix"];
var createSetIntersect = /* @__PURE__ */ factory(name$1U, dependencies$1U, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  return typed2(name$1U, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      var result;
      if (subset2(size2(a1), new Index2(0)) === 0 || subset2(size2(a2), new Index2(0)) === 0) {
        result = [];
      } else {
        var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
        var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
        result = [];
        for (var i2 = 0; i2 < b1.length; i2++) {
          for (var j = 0; j < b2.length; j++) {
            if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
              result.push(b1[i2]);
              break;
            }
          }
        }
      }
      if (Array.isArray(a1) && Array.isArray(a2)) {
        return generalize(result);
      }
      return new DenseMatrix2(generalize(result));
    }
  });
});
var name$1T = "setIsSubset";
var dependencies$1T = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetIsSubset = /* @__PURE__ */ factory(name$1T, dependencies$1T, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name$1T, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return true;
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return false;
      }
      var b1 = identify(flatten$1(Array.isArray(a1) ? a1 : a1.toArray()).sort(compareNatural2));
      var b2 = identify(flatten$1(Array.isArray(a2) ? a2 : a2.toArray()).sort(compareNatural2));
      var inb2;
      for (var i2 = 0; i2 < b1.length; i2++) {
        inb2 = false;
        for (var j = 0; j < b2.length; j++) {
          if (compareNatural2(b1[i2].value, b2[j].value) === 0 && b1[i2].identifier === b2[j].identifier) {
            inb2 = true;
            break;
          }
        }
        if (inb2 === false) {
          return false;
        }
      }
      return true;
    }
  });
});
var name$1S = "setMultiplicity";
var dependencies$1S = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetMultiplicity = /* @__PURE__ */ factory(name$1S, dependencies$1S, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name$1S, {
    "number | BigNumber | Fraction | Complex, Array | Matrix": function numberBigNumberFractionComplexArrayMatrix(e2, a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return 0;
      }
      var b = flatten$1(Array.isArray(a) ? a : a.toArray());
      var count2 = 0;
      for (var i2 = 0; i2 < b.length; i2++) {
        if (compareNatural2(b[i2], e2) === 0) {
          count2++;
        }
      }
      return count2;
    }
  });
});
var name$1R = "setPowerset";
var dependencies$1R = ["typed", "size", "subset", "compareNatural", "Index"];
var createSetPowerset = /* @__PURE__ */ factory(name$1R, dependencies$1R, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    subset: subset2,
    compareNatural: compareNatural2,
    Index: Index2
  } = _ref;
  return typed2(name$1R, {
    "Array | Matrix": function ArrayMatrix(a) {
      if (subset2(size2(a), new Index2(0)) === 0) {
        return [];
      }
      var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
      var result = [];
      var number2 = 0;
      while (number2.toString(2).length <= b.length) {
        result.push(_subset(b, number2.toString(2).split("").reverse()));
        number2++;
      }
      return _sort(result);
    }
  });
  function _subset(array, bitarray) {
    var result = [];
    for (var i2 = 0; i2 < bitarray.length; i2++) {
      if (bitarray[i2] === "1") {
        result.push(array[i2]);
      }
    }
    return result;
  }
  function _sort(array) {
    var temp = [];
    for (var i2 = array.length - 1; i2 > 0; i2--) {
      for (var j = 0; j < i2; j++) {
        if (array[j].length > array[j + 1].length) {
          temp = array[j];
          array[j] = array[j + 1];
          array[j + 1] = temp;
        }
      }
    }
    return array;
  }
});
var name$1Q = "setSize";
var dependencies$1Q = ["typed", "compareNatural"];
var createSetSize = /* @__PURE__ */ factory(name$1Q, dependencies$1Q, (_ref) => {
  var {
    typed: typed2,
    compareNatural: compareNatural2
  } = _ref;
  return typed2(name$1Q, {
    "Array | Matrix": function ArrayMatrix(a) {
      return Array.isArray(a) ? flatten$1(a).length : flatten$1(a.toArray()).length;
    },
    "Array | Matrix, boolean": function ArrayMatrixBoolean(a, unique) {
      if (unique === false || a.length === 0) {
        return Array.isArray(a) ? flatten$1(a).length : flatten$1(a.toArray()).length;
      } else {
        var b = flatten$1(Array.isArray(a) ? a : a.toArray()).sort(compareNatural2);
        var count2 = 1;
        for (var i2 = 1; i2 < b.length; i2++) {
          if (compareNatural2(b[i2], b[i2 - 1]) !== 0) {
            count2++;
          }
        }
        return count2;
      }
    }
  });
});
var name$1P = "setSymDifference";
var dependencies$1P = ["typed", "size", "concat", "subset", "setDifference", "Index"];
var createSetSymDifference = /* @__PURE__ */ factory(name$1P, dependencies$1P, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    concat: concat2,
    subset: subset2,
    setDifference: setDifference2,
    Index: Index2
  } = _ref;
  return typed2(name$1P, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten$1(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten$1(a1);
      }
      var b1 = flatten$1(a1);
      var b2 = flatten$1(a2);
      return concat2(setDifference2(b1, b2), setDifference2(b2, b1));
    }
  });
});
var name$1O = "setUnion";
var dependencies$1O = ["typed", "size", "concat", "subset", "setIntersect", "setSymDifference", "Index"];
var createSetUnion = /* @__PURE__ */ factory(name$1O, dependencies$1O, (_ref) => {
  var {
    typed: typed2,
    size: size2,
    concat: concat2,
    subset: subset2,
    setIntersect: setIntersect2,
    setSymDifference: setSymDifference2,
    Index: Index2
  } = _ref;
  return typed2(name$1O, {
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(a1, a2) {
      if (subset2(size2(a1), new Index2(0)) === 0) {
        return flatten$1(a2);
      } else if (subset2(size2(a2), new Index2(0)) === 0) {
        return flatten$1(a1);
      }
      var b1 = flatten$1(a1);
      var b2 = flatten$1(a2);
      return concat2(setSymDifference2(b1, b2), setIntersect2(b1, b2));
    }
  });
});
var name$1N = "add";
var dependencies$1N = ["typed", "matrix", "addScalar", "equalScalar", "DenseMatrix", "SparseMatrix", "concat"];
var createAdd = /* @__PURE__ */ factory(name$1N, dependencies$1N, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    concat: concat2
  } = _ref;
  var matAlgo01xDSid = createMatAlgo01xDSid({
    typed: typed2
  });
  var matAlgo04xSidSid = createMatAlgo04xSidSid({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo10xSids = createMatAlgo10xSids({
    typed: typed2,
    DenseMatrix: DenseMatrix2
  });
  var matrixAlgorithmSuite = createMatrixAlgorithmSuite({
    typed: typed2,
    matrix: matrix2,
    concat: concat2
  });
  return typed2(name$1N, {
    "any, any": addScalar2,
    "any, any, ...any": typed2.referToSelf((self2) => (x, y, rest) => {
      var result = self2(x, y);
      for (var i2 = 0; i2 < rest.length; i2++) {
        result = self2(result, rest[i2]);
      }
      return result;
    })
  }, matrixAlgorithmSuite({
    elop: addScalar2,
    DS: matAlgo01xDSid,
    SS: matAlgo04xSidSid,
    Ss: matAlgo10xSids
  }));
});
var name$1M = "hypot";
var dependencies$1M = ["typed", "abs", "addScalar", "divideScalar", "multiplyScalar", "sqrt", "smaller", "isPositive"];
var createHypot = /* @__PURE__ */ factory(name$1M, dependencies$1M, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    sqrt: sqrt2,
    smaller: smaller2,
    isPositive: isPositive2
  } = _ref;
  return typed2(name$1M, {
    "... number | BigNumber": _hypot,
    Array: _hypot,
    Matrix: (M) => _hypot(flatten$1(M.toArray()))
  });
  function _hypot(args) {
    var result = 0;
    var largest = 0;
    for (var i2 = 0; i2 < args.length; i2++) {
      if (isComplex(args[i2])) {
        throw new TypeError("Unexpected type of argument to hypot");
      }
      var value = abs2(args[i2]);
      if (smaller2(largest, value)) {
        result = multiplyScalar2(result, multiplyScalar2(divideScalar2(largest, value), divideScalar2(largest, value)));
        result = addScalar2(result, 1);
        largest = value;
      } else {
        result = addScalar2(result, isPositive2(value) ? multiplyScalar2(divideScalar2(value, largest), divideScalar2(value, largest)) : value);
      }
    }
    return multiplyScalar2(largest, sqrt2(result));
  }
});
var name$1L = "norm";
var dependencies$1L = ["typed", "abs", "add", "pow", "conj", "sqrt", "multiply", "equalScalar", "larger", "smaller", "matrix", "ctranspose", "eigs"];
var createNorm = /* @__PURE__ */ factory(name$1L, dependencies$1L, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    pow: pow2,
    conj: conj2,
    sqrt: sqrt2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    larger: larger2,
    smaller: smaller2,
    matrix: matrix2,
    ctranspose: ctranspose2,
    eigs: eigs2
  } = _ref;
  return typed2(name$1L, {
    number: Math.abs,
    Complex: function Complex2(x) {
      return x.abs();
    },
    BigNumber: function BigNumber2(x) {
      return x.abs();
    },
    boolean: function boolean2(x) {
      return Math.abs(x);
    },
    Array: function Array2(x) {
      return _norm(matrix2(x), 2);
    },
    Matrix: function Matrix2(x) {
      return _norm(x, 2);
    },
    "Array, number | BigNumber | string": function ArrayNumberBigNumberString(x, p) {
      return _norm(matrix2(x), p);
    },
    "Matrix, number | BigNumber | string": function MatrixNumberBigNumberString(x, p) {
      return _norm(x, p);
    }
  });
  function _vectorNormPlusInfinity(x) {
    var pinf = 0;
    x.forEach(function(value) {
      var v = abs2(value);
      if (larger2(v, pinf)) {
        pinf = v;
      }
    }, true);
    return pinf;
  }
  function _vectorNormMinusInfinity(x) {
    var ninf;
    x.forEach(function(value) {
      var v = abs2(value);
      if (!ninf || smaller2(v, ninf)) {
        ninf = v;
      }
    }, true);
    return ninf || 0;
  }
  function _vectorNorm(x, p) {
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _vectorNormPlusInfinity(x);
    }
    if (p === Number.NEGATIVE_INFINITY || p === "-inf") {
      return _vectorNormMinusInfinity(x);
    }
    if (p === "fro") {
      return _norm(x, 2);
    }
    if (typeof p === "number" && !isNaN(p)) {
      if (!equalScalar2(p, 0)) {
        var n = 0;
        x.forEach(function(value) {
          n = add2(pow2(abs2(value), p), n);
        }, true);
        return pow2(n, 1 / p);
      }
      return Number.POSITIVE_INFINITY;
    }
    throw new Error("Unsupported parameter value");
  }
  function _matrixNormFrobenius(x) {
    var fro = 0;
    x.forEach(function(value, index2) {
      fro = add2(fro, multiply2(value, conj2(value)));
    });
    return abs2(sqrt2(fro));
  }
  function _matrixNormOne(x) {
    var c = [];
    var maxc = 0;
    x.forEach(function(value, index2) {
      var j = index2[1];
      var cj = add2(c[j] || 0, abs2(value));
      if (larger2(cj, maxc)) {
        maxc = cj;
      }
      c[j] = cj;
    }, true);
    return maxc;
  }
  function _matrixNormTwo(x) {
    var sizeX = x.size();
    if (sizeX[0] !== sizeX[1]) {
      throw new RangeError("Invalid matrix dimensions");
    }
    var tx = ctranspose2(x);
    var squaredX = multiply2(tx, x);
    var eigenVals = eigs2(squaredX).values.toArray();
    var rho = eigenVals[eigenVals.length - 1];
    return abs2(sqrt2(rho));
  }
  function _matrixNormInfinity(x) {
    var r = [];
    var maxr = 0;
    x.forEach(function(value, index2) {
      var i2 = index2[0];
      var ri = add2(r[i2] || 0, abs2(value));
      if (larger2(ri, maxr)) {
        maxr = ri;
      }
      r[i2] = ri;
    }, true);
    return maxr;
  }
  function _matrixNorm(x, p) {
    if (p === 1) {
      return _matrixNormOne(x);
    }
    if (p === Number.POSITIVE_INFINITY || p === "inf") {
      return _matrixNormInfinity(x);
    }
    if (p === "fro") {
      return _matrixNormFrobenius(x);
    }
    if (p === 2) {
      return _matrixNormTwo(x);
    }
    throw new Error("Unsupported parameter value " + p);
  }
  function _norm(x, p) {
    var sizeX = x.size();
    if (sizeX.length === 1) {
      return _vectorNorm(x, p);
    }
    if (sizeX.length === 2) {
      if (sizeX[0] && sizeX[1]) {
        return _matrixNorm(x, p);
      } else {
        throw new RangeError("Invalid matrix dimensions");
      }
    }
  }
});
var name$1K = "dot";
var dependencies$1K = ["typed", "addScalar", "multiplyScalar", "conj", "size"];
var createDot = /* @__PURE__ */ factory(name$1K, dependencies$1K, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    multiplyScalar: multiplyScalar2,
    conj: conj2,
    size: size2
  } = _ref;
  return typed2(name$1K, {
    "Array | DenseMatrix, Array | DenseMatrix": _denseDot,
    "SparseMatrix, SparseMatrix": _sparseDot
  });
  function _validateDim(x, y) {
    var xSize = _size(x);
    var ySize = _size(y);
    var xLen, yLen;
    if (xSize.length === 1) {
      xLen = xSize[0];
    } else if (xSize.length === 2 && xSize[1] === 1) {
      xLen = xSize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + xSize.join(", ") + ")");
    }
    if (ySize.length === 1) {
      yLen = ySize[0];
    } else if (ySize.length === 2 && ySize[1] === 1) {
      yLen = ySize[0];
    } else {
      throw new RangeError("Expected a column vector, instead got a matrix of size (" + ySize.join(", ") + ")");
    }
    if (xLen !== yLen)
      throw new RangeError("Vectors must have equal length (" + xLen + " != " + yLen + ")");
    if (xLen === 0)
      throw new RangeError("Cannot calculate the dot product of empty vectors");
    return xLen;
  }
  function _denseDot(a, b) {
    var N = _validateDim(a, b);
    var adata = isMatrix(a) ? a._data : a;
    var adt = isMatrix(a) ? a._datatype || a.getDataType() : void 0;
    var bdata = isMatrix(b) ? b._data : b;
    var bdt = isMatrix(b) ? b._datatype || b.getDataType() : void 0;
    var aIsColumn = _size(a).length === 2;
    var bIsColumn = _size(b).length === 2;
    var add2 = addScalar2;
    var mul2 = multiplyScalar2;
    if (adt && bdt && adt === bdt && typeof adt === "string" && adt !== "mixed") {
      var dt = adt;
      add2 = typed2.find(addScalar2, [dt, dt]);
      mul2 = typed2.find(multiplyScalar2, [dt, dt]);
    }
    if (!aIsColumn && !bIsColumn) {
      var c = mul2(conj2(adata[0]), bdata[0]);
      for (var i2 = 1; i2 < N; i2++) {
        c = add2(c, mul2(conj2(adata[i2]), bdata[i2]));
      }
      return c;
    }
    if (!aIsColumn && bIsColumn) {
      var _c = mul2(conj2(adata[0]), bdata[0][0]);
      for (var _i = 1; _i < N; _i++) {
        _c = add2(_c, mul2(conj2(adata[_i]), bdata[_i][0]));
      }
      return _c;
    }
    if (aIsColumn && !bIsColumn) {
      var _c2 = mul2(conj2(adata[0][0]), bdata[0]);
      for (var _i2 = 1; _i2 < N; _i2++) {
        _c2 = add2(_c2, mul2(conj2(adata[_i2][0]), bdata[_i2]));
      }
      return _c2;
    }
    if (aIsColumn && bIsColumn) {
      var _c3 = mul2(conj2(adata[0][0]), bdata[0][0]);
      for (var _i3 = 1; _i3 < N; _i3++) {
        _c3 = add2(_c3, mul2(conj2(adata[_i3][0]), bdata[_i3][0]));
      }
      return _c3;
    }
  }
  function _sparseDot(x, y) {
    _validateDim(x, y);
    var xindex = x._index;
    var xvalues = x._values;
    var yindex = y._index;
    var yvalues = y._values;
    var c = 0;
    var add2 = addScalar2;
    var mul2 = multiplyScalar2;
    var i2 = 0;
    var j = 0;
    while (i2 < xindex.length && j < yindex.length) {
      var I = xindex[i2];
      var J = yindex[j];
      if (I < J) {
        i2++;
        continue;
      }
      if (I > J) {
        j++;
        continue;
      }
      if (I === J) {
        c = add2(c, mul2(xvalues[i2], yvalues[j]));
        i2++;
        j++;
      }
    }
    return c;
  }
  function _size(x) {
    return isMatrix(x) ? x.size() : size2(x);
  }
});
var name$1J = "trace";
var dependencies$1J = ["typed", "matrix", "add"];
var createTrace = /* @__PURE__ */ factory(name$1J, dependencies$1J, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    add: add2
  } = _ref;
  return typed2("trace", {
    Array: function _arrayTrace(x) {
      return _denseTrace(matrix2(x));
    },
    SparseMatrix: _sparseTrace,
    DenseMatrix: _denseTrace,
    any: clone$3
  });
  function _denseTrace(m) {
    var size2 = m._size;
    var data = m._data;
    switch (size2.length) {
      case 1:
        if (size2[0] === 1) {
          return clone$3(data[0]);
        }
        throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
      case 2: {
        var rows = size2[0];
        var cols = size2[1];
        if (rows === cols) {
          var sum2 = 0;
          for (var i2 = 0; i2 < rows; i2++) {
            sum2 = add2(sum2, data[i2][i2]);
          }
          return sum2;
        } else {
          throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
        }
      }
      default:
        throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
    }
  }
  function _sparseTrace(m) {
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var size2 = m._size;
    var rows = size2[0];
    var columns = size2[1];
    if (rows === columns) {
      var sum2 = 0;
      if (values.length > 0) {
        for (var j = 0; j < columns; j++) {
          var k0 = ptr[j];
          var k1 = ptr[j + 1];
          for (var k = k0; k < k1; k++) {
            var i2 = index2[k];
            if (i2 === j) {
              sum2 = add2(sum2, values[k]);
              break;
            }
            if (i2 > j) {
              break;
            }
          }
        }
      }
      return sum2;
    }
    throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
  }
});
var name$1I = "index";
var dependencies$1I = ["typed", "Index"];
var createIndex = /* @__PURE__ */ factory(name$1I, dependencies$1I, (_ref) => {
  var {
    typed: typed2,
    Index: Index2
  } = _ref;
  return typed2(name$1I, {
    "...number | string | BigNumber | Range | Array | Matrix": function numberStringBigNumberRangeArrayMatrix(args) {
      var ranges = args.map(function(arg2) {
        if (isBigNumber(arg2)) {
          return arg2.toNumber();
        } else if (isArray(arg2) || isMatrix(arg2)) {
          return arg2.map(function(elem) {
            return isBigNumber(elem) ? elem.toNumber() : elem;
          });
        } else {
          return arg2;
        }
      });
      var res = new Index2();
      Index2.apply(res, ranges);
      return res;
    }
  });
});
var keywords = /* @__PURE__ */ new Set(["end"]);
var name$1H = "Node";
var dependencies$1H = ["mathWithTransform"];
var createNode = /* @__PURE__ */ factory(name$1H, dependencies$1H, (_ref) => {
  var {
    mathWithTransform: mathWithTransform2
  } = _ref;
  function _validateScope(scope) {
    for (var symbol of [...keywords]) {
      if (scope.has(symbol)) {
        throw new Error('Scope contains an illegal symbol, "' + symbol + '" is a reserved keyword');
      }
    }
  }
  class Node2 {
    get type() {
      return "Node";
    }
    get isNode() {
      return true;
    }
    /**
     * Evaluate the node
     * @param {Object} [scope]  Scope to read/write variables
     * @return {*}              Returns the result
     */
    evaluate(scope) {
      return this.compile().evaluate(scope);
    }
    /**
     * Compile the node into an optimized, evauatable JavaScript function
     * @return {{evaluate: function([Object])}} object
     *                Returns an object with a function 'evaluate',
     *                which can be invoked as expr.evaluate([scope: Object]),
     *                where scope is an optional object with
     *                variables.
     */
    compile() {
      var expr = this._compile(mathWithTransform2, {});
      var args = {};
      var context = null;
      function evaluate2(scope) {
        var s = createMap$1(scope);
        _validateScope(s);
        return expr(s, args, context);
      }
      return {
        evaluate: evaluate2
      };
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      throw new Error("Method _compile must be implemented by type " + this.type);
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      throw new Error("Cannot run forEach on a Node interface");
    }
    /**
     * Create a new Node whose children are the results of calling the
     * provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(callback) {
      throw new Error("Cannot run map on a Node interface");
    }
    /**
     * Validate whether an object is a Node, for use with map
     * @param {Node} node
     * @returns {Node} Returns the input if it's a node, else throws an Error
     * @protected
     */
    _ifNode(node) {
      if (!isNode(node)) {
        throw new TypeError("Callback function must return a Node");
      }
      return node;
    }
    /**
     * Recursively traverse all nodes in a node tree. Executes given callback for
     * this node and each of its child nodes.
     * @param {function(node: Node, path: string, parent: Node)} callback
     *          A callback called for every node in the node tree.
     */
    traverse(callback) {
      callback(this, null, null);
      function _traverse(node, callback2) {
        node.forEach(function(child, path, parent) {
          callback2(child, path, parent);
          _traverse(child, callback2);
        });
      }
      _traverse(this, callback);
    }
    /**
     * Recursively transform a node tree via a transform function.
     *
     * For example, to replace all nodes of type SymbolNode having name 'x' with
     * a ConstantNode with value 2:
     *
     *     const res = Node.transform(function (node, path, parent) {
     *       if (node && node.isSymbolNode) && (node.name === 'x')) {
     *         return new ConstantNode(2)
     *       }
     *       else {
     *         return node
     *       }
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *          A mapping function accepting a node, and returning
     *          a replacement for the node or the original node. The "signature"
     *          of the callback must be:
     *          callback(node: Node, index: string, parent: Node) : Node
     * @return {Node} Returns the original node or its replacement
     */
    transform(callback) {
      function _transform(child, path, parent) {
        var replacement = callback(child, path, parent);
        if (replacement !== child) {
          return replacement;
        }
        return child.map(_transform);
      }
      return _transform(this, null, null);
    }
    /**
     * Find any node in the node tree matching given filter function. For
     * example, to find all nodes of type SymbolNode having name 'x':
     *
     *     const results = Node.filter(function (node) {
     *       return (node && node.isSymbolNode) && (node.name === 'x')
     *     })
     *
     * @param {function(node: Node, path: string, parent: Node) : Node} callback
     *            A test function returning true when a node matches, and false
     *            otherwise. Function signature:
     *            callback(node: Node, index: string, parent: Node) : boolean
     * @return {Node[]} nodes
     *            An array with nodes matching given filter criteria
     */
    filter(callback) {
      var nodes = [];
      this.traverse(function(node, path, parent) {
        if (callback(node, path, parent)) {
          nodes.push(node);
        }
      });
      return nodes;
    }
    /**
     * Create a shallow clone of this node
     * @return {Node}
     */
    clone() {
      throw new Error("Cannot clone a Node interface");
    }
    /**
     * Create a deep clone of this node
     * @return {Node}
     */
    cloneDeep() {
      return this.map(function(node) {
        return node.cloneDeep();
      });
    }
    /**
     * Deep compare this node with another node.
     * @param {Node} other
     * @return {boolean} Returns true when both nodes are of the same type and
     *                   contain the same values (as do their childs)
     */
    equals(other) {
      return other ? this.type === other.type && deepStrictEqual(this, other) : false;
    }
    /**
     * Get string representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toString(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toString(options);
    }
    /**
     * Internal function to generate the string output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toString() {
      throw new Error("_toString not implemented for " + this.type);
    }
    /**
     * Get a JSON representation of the node
     * Both .toJSON() and the static .fromJSON(json) should be implemented by all
     * implementations of Node
     * @returns {Object}
     */
    toJSON() {
      throw new Error("Cannot serialize object: toJSON not implemented by " + this.type);
    }
    /**
     * Get HTML representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)" or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toHTML(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toHTML(options);
    }
    /**
     * Internal function to generate the HTML output.
     * This has to be implemented by every Node
     *
     * @throws {Error}
     */
    _toHTML() {
      throw new Error("_toHTML not implemented for " + this.type);
    }
    /**
     * Get LaTeX representation. (wrapper function)
     *
     * This function can get an object of the following form:
     * {
     *    handler: //This can be a callback function of the form
     *             // "function callback(node, options)"or
     *             // a map that maps function names (used in FunctionNodes)
     *             // to callbacks
     *    parenthesis: "keep" //the parenthesis option (This is optional)
     * }
     *
     * @param {Object} [options]
     * @return {string}
     */
    toTex(options) {
      var customString = this._getCustomString(options);
      if (typeof customString !== "undefined") {
        return customString;
      }
      return this._toTex(options);
    }
    /**
     * Internal function to generate the LaTeX output.
     * This has to be implemented by every Node
     *
     * @param {Object} [options]
     * @throws {Error}
     */
    _toTex(options) {
      throw new Error("_toTex not implemented for " + this.type);
    }
    /**
     * Helper used by `to...` functions.
     */
    _getCustomString(options) {
      if (options && typeof options === "object") {
        switch (typeof options.handler) {
          case "object":
          case "undefined":
            return;
          case "function":
            return options.handler(this, options);
          default:
            throw new TypeError("Object or function expected as callback");
        }
      }
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type;
    }
    /**
     * Get the content of the current Node.
     * @return {Node} node
     **/
    getContent() {
      return this;
    }
  }
  return Node2;
}, {
  isClass: true,
  isNode: true
});
function errorTransform(err) {
  if (err && err.isIndexError) {
    return new IndexError(err.index + 1, err.min + 1, err.max !== void 0 ? err.max + 1 : void 0);
  }
  return err;
}
function accessFactory(_ref) {
  var {
    subset: subset2
  } = _ref;
  return function access(object, index2) {
    try {
      if (Array.isArray(object)) {
        return subset2(object, index2);
      } else if (object && typeof object.subset === "function") {
        return object.subset(index2);
      } else if (typeof object === "string") {
        return subset2(object, index2);
      } else if (typeof object === "object") {
        if (!index2.isObjectProperty()) {
          throw new TypeError("Cannot apply a numeric index as object property");
        }
        return getSafeProperty(object, index2.getObjectProperty());
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}
var name$1G = "AccessorNode";
var dependencies$1G = ["subset", "Node"];
var createAccessorNode = /* @__PURE__ */ factory(name$1G, dependencies$1G, (_ref) => {
  var {
    subset: subset2,
    Node: Node2
  } = _ref;
  var access = accessFactory({
    subset: subset2
  });
  function needParenthesis(node) {
    return !(isAccessorNode(node) || isArrayNode(node) || isConstantNode(node) || isFunctionNode(node) || isObjectNode(node) || isParenthesisNode(node) || isSymbolNode(node));
  }
  class AccessorNode2 extends Node2 {
    /**
     * @constructor AccessorNode
     * @extends {Node}
     * Access an object property or get a matrix subset
     *
     * @param {Node} object                 The object from which to retrieve
     *                                      a property or subset.
     * @param {IndexNode} index             IndexNode containing ranges
     */
    constructor(object, index2) {
      super();
      if (!isNode(object)) {
        throw new TypeError('Node expected for parameter "object"');
      }
      if (!isIndexNode(index2)) {
        throw new TypeError('IndexNode expected for parameter "index"');
      }
      this.object = object;
      this.index = index2;
    }
    // readonly property name
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name$1G;
    }
    get isAccessorNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalObject = this.object._compile(math2, argNames);
      var evalIndex = this.index._compile(math2, argNames);
      if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAccessorNode(scope, args, context) {
          return getSafeProperty(evalObject(scope, args, context), prop);
        };
      } else {
        return function evalAccessorNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var index2 = evalIndex(scope, args, object);
          return access(object, index2);
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.object, "object", this);
      callback(this.index, "index", this);
    }
    /**
     * Create a new AccessorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AccessorNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new AccessorNode2(this._ifNode(callback(this.object, "object", this)), this._ifNode(callback(this.index, "index", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AccessorNode}
     */
    clone() {
      return new AccessorNode2(this.object, this.index);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(options) {
      var object = this.object.toString(options);
      if (needParenthesis(this.object)) {
        object = "(" + object + ")";
      }
      return object + this.index.toString(options);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    _toHTML(options) {
      var object = this.object.toHTML(options);
      if (needParenthesis(this.object)) {
        object = '<span class="math-parenthesis math-round-parenthesis">(</span>' + object + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return object + this.index.toHTML(options);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(options) {
      var object = this.object.toTex(options);
      if (needParenthesis(this.object)) {
        object = "\\left(' + object + '\\right)";
      }
      return object + this.index.toTex(options);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1G,
        object: this.object,
        index: this.index
      };
    }
    /**
     * Instantiate an AccessorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AccessorNode", object: ..., index: ...}`,
     *     where mathjs is optional
     * @returns {AccessorNode}
     */
    static fromJSON(json) {
      return new AccessorNode2(json.object, json.index);
    }
  }
  _defineProperty(AccessorNode2, "name", name$1G);
  return AccessorNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1F = "ArrayNode";
var dependencies$1F = ["Node"];
var createArrayNode = /* @__PURE__ */ factory(name$1F, dependencies$1F, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ArrayNode2 extends Node2 {
    /**
     * @constructor ArrayNode
     * @extends {Node}
     * Holds an 1-dimensional array with items
     * @param {Node[]} [items]   1 dimensional array with items
     */
    constructor(items) {
      super();
      this.items = items || [];
      if (!Array.isArray(this.items) || !this.items.every(isNode)) {
        throw new TypeError("Array containing Nodes expected");
      }
    }
    get type() {
      return name$1F;
    }
    get isArrayNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalItems = map$1(this.items, function(item) {
        return item._compile(math2, argNames);
      });
      var asMatrix = math2.config.matrix !== "Array";
      if (asMatrix) {
        var matrix2 = math2.matrix;
        return function evalArrayNode(scope, args, context) {
          return matrix2(map$1(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          }));
        };
      } else {
        return function evalArrayNode(scope, args, context) {
          return map$1(evalItems, function(evalItem) {
            return evalItem(scope, args, context);
          });
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i2 = 0; i2 < this.items.length; i2++) {
        var node = this.items[i2];
        callback(node, "items[" + i2 + "]", this);
      }
    }
    /**
     * Create a new ArrayNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ArrayNode} Returns a transformed copy of the node
     */
    map(callback) {
      var items = [];
      for (var i2 = 0; i2 < this.items.length; i2++) {
        items[i2] = this._ifNode(callback(this.items[i2], "items[" + i2 + "]", this));
      }
      return new ArrayNode2(items);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ArrayNode}
     */
    clone() {
      return new ArrayNode2(this.items.slice(0));
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      var items = this.items.map(function(node) {
        return node.toString(options);
      });
      return "[" + items.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1F,
        items: this.items
      };
    }
    /**
     * Instantiate an ArrayNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ArrayNode", items: [...]}`,
     *                       where mathjs is optional
     * @returns {ArrayNode}
     */
    static fromJSON(json) {
      return new ArrayNode2(json.items);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options) {
      var items = this.items.map(function(node) {
        return node.toHTML(options);
      });
      return '<span class="math-parenthesis math-square-parenthesis">[</span>' + items.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      function itemsToTex(items, nested) {
        var mixedItems = items.some(isArrayNode) && !items.every(isArrayNode);
        var itemsFormRow = nested || mixedItems;
        var itemSep = itemsFormRow ? "&" : "\\\\";
        var itemsTex = items.map(function(node) {
          if (node.items) {
            return itemsToTex(node.items, !nested);
          } else {
            return node.toTex(options);
          }
        }).join(itemSep);
        return mixedItems || !itemsFormRow || itemsFormRow && !nested ? "\\begin{bmatrix}" + itemsTex + "\\end{bmatrix}" : itemsTex;
      }
      return itemsToTex(this.items, false);
    }
  }
  _defineProperty(ArrayNode2, "name", name$1F);
  return ArrayNode2;
}, {
  isClass: true,
  isNode: true
});
function assignFactory(_ref) {
  var {
    subset: subset2,
    matrix: matrix2
  } = _ref;
  return function assign2(object, index2, value) {
    try {
      if (Array.isArray(object)) {
        var result = matrix2(object).subset(index2, value).valueOf();
        result.forEach((item, index3) => {
          object[index3] = item;
        });
        return object;
      } else if (object && typeof object.subset === "function") {
        return object.subset(index2, value);
      } else if (typeof object === "string") {
        return subset2(object, index2, value);
      } else if (typeof object === "object") {
        if (!index2.isObjectProperty()) {
          throw TypeError("Cannot apply a numeric index as object property");
        }
        setSafeProperty(object, index2.getObjectProperty(), value);
        return object;
      } else {
        throw new TypeError("Cannot apply index: unsupported type of object");
      }
    } catch (err) {
      throw errorTransform(err);
    }
  };
}
var properties = [{
  // assignment
  AssignmentNode: {},
  FunctionAssignmentNode: {}
}, {
  // conditional expression
  ConditionalNode: {
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
    // conditionals don't need parentheses in LaTeX because
    // they are 2 dimensional
  }
}, {
  // logical or
  "OperatorNode:or": {
    op: "or",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical xor
  "OperatorNode:xor": {
    op: "xor",
    associativity: "left",
    associativeWith: []
  }
}, {
  // logical and
  "OperatorNode:and": {
    op: "and",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise or
  "OperatorNode:bitOr": {
    op: "|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise xor
  "OperatorNode:bitXor": {
    op: "^|",
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitwise and
  "OperatorNode:bitAnd": {
    op: "&",
    associativity: "left",
    associativeWith: []
  }
}, {
  // relational operators
  "OperatorNode:equal": {
    op: "==",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:unequal": {
    op: "!=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smaller": {
    op: "<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:larger": {
    op: ">",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:smallerEq": {
    op: "<=",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:largerEq": {
    op: ">=",
    associativity: "left",
    associativeWith: []
  },
  RelationalNode: {
    associativity: "left",
    associativeWith: []
  }
}, {
  // bitshift operators
  "OperatorNode:leftShift": {
    op: "<<",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightArithShift": {
    op: ">>",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:rightLogShift": {
    op: ">>>",
    associativity: "left",
    associativeWith: []
  }
}, {
  // unit conversion
  "OperatorNode:to": {
    op: "to",
    associativity: "left",
    associativeWith: []
  }
}, {
  // range
  RangeNode: {}
}, {
  // addition, subtraction
  "OperatorNode:add": {
    op: "+",
    associativity: "left",
    associativeWith: ["OperatorNode:add", "OperatorNode:subtract"]
  },
  "OperatorNode:subtract": {
    op: "-",
    associativity: "left",
    associativeWith: []
  }
}, {
  // multiply, divide, modulus
  "OperatorNode:multiply": {
    op: "*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  },
  "OperatorNode:divide": {
    op: "/",
    associativity: "left",
    associativeWith: [],
    latexLeftParens: false,
    latexRightParens: false,
    latexParens: false
    // fractions don't require parentheses because
    // they're 2 dimensional, so parens aren't needed
    // in LaTeX
  },
  "OperatorNode:dotMultiply": {
    op: ".*",
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "OperatorNode:dotMultiply", "OperatorNode:doDivide"]
  },
  "OperatorNode:dotDivide": {
    op: "./",
    associativity: "left",
    associativeWith: []
  },
  "OperatorNode:mod": {
    op: "mod",
    associativity: "left",
    associativeWith: []
  }
}, {
  // Repeat multiplication for implicit multiplication
  "OperatorNode:multiply": {
    associativity: "left",
    associativeWith: ["OperatorNode:multiply", "OperatorNode:divide", "Operator:dotMultiply", "Operator:dotDivide"]
  }
}, {
  // unary prefix operators
  "OperatorNode:unaryPlus": {
    op: "+",
    associativity: "right"
  },
  "OperatorNode:unaryMinus": {
    op: "-",
    associativity: "right"
  },
  "OperatorNode:bitNot": {
    op: "~",
    associativity: "right"
  },
  "OperatorNode:not": {
    op: "not",
    associativity: "right"
  }
}, {
  // exponentiation
  "OperatorNode:pow": {
    op: "^",
    associativity: "right",
    associativeWith: [],
    latexRightParens: false
    // the exponent doesn't need parentheses in
    // LaTeX because it's 2 dimensional
    // (it's on top)
  },
  "OperatorNode:dotPow": {
    op: ".^",
    associativity: "right",
    associativeWith: []
  }
}, {
  // factorial
  "OperatorNode:factorial": {
    op: "!",
    associativity: "left"
  }
}, {
  // matrix transpose
  "OperatorNode:ctranspose": {
    op: "'",
    associativity: "left"
  }
}];
function unwrapParen(_node, parenthesis) {
  if (!parenthesis || parenthesis !== "auto")
    return _node;
  var node = _node;
  while (isParenthesisNode(node))
    node = node.content;
  return node;
}
function getPrecedence(_node, parenthesis, implicit, parent) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var precedence = null;
  for (var i2 = 0; i2 < properties.length; i2++) {
    if (identifier in properties[i2]) {
      precedence = i2;
      break;
    }
  }
  if (identifier === "OperatorNode:multiply" && node.implicit && implicit !== "show") {
    var leftArg = unwrapParen(node.args[0], parenthesis);
    if (!(isConstantNode(leftArg) && parent && parent.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(parent.args[0], parenthesis))) && !(leftArg.getIdentifier() === "OperatorNode:divide" && rule2Node(unwrapParen(leftArg.args[0], parenthesis)) && isConstantNode(unwrapParen(leftArg.args[1])))) {
      precedence += 1;
    }
  }
  return precedence;
}
function getAssociativity(_node, parenthesis) {
  var node = _node;
  if (parenthesis !== "keep") {
    node = _node.getContent();
  }
  var identifier = node.getIdentifier();
  var index2 = getPrecedence(node, parenthesis);
  if (index2 === null) {
    return null;
  }
  var property = properties[index2][identifier];
  if (hasOwnProperty(property, "associativity")) {
    if (property.associativity === "left") {
      return "left";
    }
    if (property.associativity === "right") {
      return "right";
    }
    throw Error("'" + identifier + "' has the invalid associativity '" + property.associativity + "'.");
  }
  return null;
}
function isAssociativeWith(nodeA, nodeB, parenthesis) {
  var a = parenthesis !== "keep" ? nodeA.getContent() : nodeA;
  var b = parenthesis !== "keep" ? nodeA.getContent() : nodeB;
  var identifierA = a.getIdentifier();
  var identifierB = b.getIdentifier();
  var index2 = getPrecedence(a, parenthesis);
  if (index2 === null) {
    return null;
  }
  var property = properties[index2][identifierA];
  if (hasOwnProperty(property, "associativeWith") && property.associativeWith instanceof Array) {
    for (var i2 = 0; i2 < property.associativeWith.length; i2++) {
      if (property.associativeWith[i2] === identifierB) {
        return true;
      }
    }
    return false;
  }
  return null;
}
function getOperator(fn) {
  var identifier = "OperatorNode:" + fn;
  for (var group of properties) {
    if (identifier in group) {
      return group[identifier].op;
    }
  }
  return null;
}
var name$1E = "AssignmentNode";
var dependencies$1E = [
  "subset",
  "?matrix",
  // FIXME: should not be needed at all, should be handled by subset
  "Node"
];
var createAssignmentNode = /* @__PURE__ */ factory(name$1E, dependencies$1E, (_ref) => {
  var {
    subset: subset2,
    matrix: matrix2,
    Node: Node2
  } = _ref;
  var access = accessFactory({
    subset: subset2
  });
  var assign2 = assignFactory({
    subset: subset2,
    matrix: matrix2
  });
  function needParenthesis(node, parenthesis, implicit) {
    if (!parenthesis) {
      parenthesis = "keep";
    }
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.value, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }
  class AssignmentNode2 extends Node2 {
    /**
     * @constructor AssignmentNode
     * @extends {Node}
     *
     * Define a symbol, like `a=3.2`, update a property like `a.b=3.2`, or
     * replace a subset of a matrix like `A[2,2]=42`.
     *
     * Syntax:
     *
     *     new AssignmentNode(symbol, value)
     *     new AssignmentNode(object, index, value)
     *
     * Usage:
     *
     *    new AssignmentNode(new SymbolNode('a'), new ConstantNode(2))  // a=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode('b'),
     *                       new ConstantNode(2))   // a.b=2
     *    new AssignmentNode(new SymbolNode('a'),
     *                       new IndexNode(1, 2),
     *                       new ConstantNode(3))  // a[1,2]=3
     *
     * @param {SymbolNode | AccessorNode} object
     *     Object on which to assign a value
     * @param {IndexNode} [index=null]
     *     Index, property name or matrix index. Optional. If not provided
     *     and `object` is a SymbolNode, the property is assigned to the
     *     global scope.
     * @param {Node} value
     *     The value to be assigned
     */
    constructor(object, index2, value) {
      super();
      this.object = object;
      this.index = value ? index2 : null;
      this.value = value || index2;
      if (!isSymbolNode(object) && !isAccessorNode(object)) {
        throw new TypeError('SymbolNode or AccessorNode expected as "object"');
      }
      if (isSymbolNode(object) && object.name === "end") {
        throw new Error('Cannot assign to symbol "end"');
      }
      if (this.index && !isIndexNode(this.index)) {
        throw new TypeError('IndexNode expected as "index"');
      }
      if (!isNode(this.value)) {
        throw new TypeError('Node expected as "value"');
      }
    }
    // class name for typing purposes:
    // readonly property name
    get name() {
      if (this.index) {
        return this.index.isObjectProperty() ? this.index.getObjectProperty() : "";
      } else {
        return this.object.name || "";
      }
    }
    get type() {
      return name$1E;
    }
    get isAssignmentNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalObject = this.object._compile(math2, argNames);
      var evalIndex = this.index ? this.index._compile(math2, argNames) : null;
      var evalValue = this.value._compile(math2, argNames);
      var name2 = this.object.name;
      if (!this.index) {
        if (!isSymbolNode(this.object)) {
          throw new TypeError("SymbolNode expected as object");
        }
        return function evalAssignmentNode(scope, args, context) {
          var value = evalValue(scope, args, context);
          scope.set(name2, value);
          return value;
        };
      } else if (this.index.isObjectProperty()) {
        var prop = this.index.getObjectProperty();
        return function evalAssignmentNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          setSafeProperty(object, prop, value);
          return value;
        };
      } else if (isSymbolNode(this.object)) {
        return function evalAssignmentNode(scope, args, context) {
          var childObject = evalObject(scope, args, context);
          var value = evalValue(scope, args, context);
          var index2 = evalIndex(scope, args, childObject);
          scope.set(name2, assign2(childObject, index2, value));
          return value;
        };
      } else {
        var evalParentObject = this.object.object._compile(math2, argNames);
        if (this.object.index.isObjectProperty()) {
          var parentProp = this.object.index.getObjectProperty();
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var childObject = getSafeProperty(parent, parentProp);
            var index2 = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            setSafeProperty(parent, parentProp, assign2(childObject, index2, value));
            return value;
          };
        } else {
          var evalParentIndex = this.object.index._compile(math2, argNames);
          return function evalAssignmentNode(scope, args, context) {
            var parent = evalParentObject(scope, args, context);
            var parentIndex = evalParentIndex(scope, args, parent);
            var childObject = access(parent, parentIndex);
            var index2 = evalIndex(scope, args, childObject);
            var value = evalValue(scope, args, context);
            assign2(parent, parentIndex, assign2(childObject, index2, value));
            return value;
          };
        }
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.object, "object", this);
      if (this.index) {
        callback(this.index, "index", this);
      }
      callback(this.value, "value", this);
    }
    /**
     * Create a new AssignmentNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {AssignmentNode} Returns a transformed copy of the node
     */
    map(callback) {
      var object = this._ifNode(callback(this.object, "object", this));
      var index2 = this.index ? this._ifNode(callback(this.index, "index", this)) : null;
      var value = this._ifNode(callback(this.value, "value", this));
      return new AssignmentNode2(object, index2, value);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {AssignmentNode}
     */
    clone() {
      return new AssignmentNode2(this.object, this.index, this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string}
     */
    _toString(options) {
      var object = this.object.toString(options);
      var index2 = this.index ? this.index.toString(options) : "";
      var value = this.value.toString(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "(" + value + ")";
      }
      return object + index2 + " = " + value;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1E,
        object: this.object,
        index: this.index,
        value: this.value
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "AssignmentNode", object: ..., index: ..., value: ...}`,
     *     where mathjs is optional
     * @returns {AssignmentNode}
     */
    static fromJSON(json) {
      return new AssignmentNode2(json.object, json.index, json.value);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string}
     */
    _toHTML(options) {
      var object = this.object.toHTML(options);
      var index2 = this.index ? this.index.toHTML(options) : "";
      var value = this.value.toHTML(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = '<span class="math-paranthesis math-round-parenthesis">(</span>' + value + '<span class="math-paranthesis math-round-parenthesis">)</span>';
      }
      return object + index2 + '<span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + value;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string}
     */
    _toTex(options) {
      var object = this.object.toTex(options);
      var index2 = this.index ? this.index.toTex(options) : "";
      var value = this.value.toTex(options);
      if (needParenthesis(this, options && options.parenthesis, options && options.implicit)) {
        value = "\\left(".concat(value, "\\right)");
      }
      return object + index2 + "=" + value;
    }
  }
  _defineProperty(AssignmentNode2, "name", name$1E);
  return AssignmentNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1D = "BlockNode";
var dependencies$1D = ["ResultSet", "Node"];
var createBlockNode = /* @__PURE__ */ factory(name$1D, dependencies$1D, (_ref) => {
  var {
    ResultSet: ResultSet2,
    Node: Node2
  } = _ref;
  class BlockNode2 extends Node2 {
    /**
     * @constructor BlockNode
     * @extends {Node}
     * Holds a set with blocks
     * @param {Array.<{node: Node} | {node: Node, visible: boolean}>} blocks
     *            An array with blocks, where a block is constructed as an
     *            Object with properties block, which is a Node, and visible,
     *            which is a boolean. The property visible is optional and
     *            is true by default
     */
    constructor(blocks) {
      super();
      if (!Array.isArray(blocks))
        throw new Error("Array expected");
      this.blocks = blocks.map(function(block) {
        var node = block && block.node;
        var visible = block && block.visible !== void 0 ? block.visible : true;
        if (!isNode(node))
          throw new TypeError('Property "node" must be a Node');
        if (typeof visible !== "boolean") {
          throw new TypeError('Property "visible" must be a boolean');
        }
        return {
          node,
          visible
        };
      });
    }
    get type() {
      return name$1D;
    }
    get isBlockNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalBlocks = map$1(this.blocks, function(block) {
        return {
          evaluate: block.node._compile(math2, argNames),
          visible: block.visible
        };
      });
      return function evalBlockNodes(scope, args, context) {
        var results = [];
        forEach$1(evalBlocks, function evalBlockNode(block) {
          var result = block.evaluate(scope, args, context);
          if (block.visible) {
            results.push(result);
          }
        });
        return new ResultSet2(results);
      };
    }
    /**
     * Execute a callback for each of the child blocks of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i2 = 0; i2 < this.blocks.length; i2++) {
        callback(this.blocks[i2].node, "blocks[" + i2 + "].node", this);
      }
    }
    /**
     * Create a new BlockNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {BlockNode} Returns a transformed copy of the node
     */
    map(callback) {
      var blocks = [];
      for (var i2 = 0; i2 < this.blocks.length; i2++) {
        var block = this.blocks[i2];
        var node = this._ifNode(callback(block.node, "blocks[" + i2 + "].node", this));
        blocks[i2] = {
          node,
          visible: block.visible
        };
      }
      return new BlockNode2(blocks);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {BlockNode}
     */
    clone() {
      var blocks = this.blocks.map(function(block) {
        return {
          node: block.node,
          visible: block.visible
        };
      });
      return new BlockNode2(blocks);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      return this.blocks.map(function(param) {
        return param.node.toString(options) + (param.visible ? "" : ";");
      }).join("\n");
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1D,
        blocks: this.blocks
      };
    }
    /**
     * Instantiate an BlockNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "BlockNode", blocks: [{node: ..., visible: false}, ...]}`,
     *     where mathjs is optional
     * @returns {BlockNode}
     */
    static fromJSON(json) {
      return new BlockNode2(json.blocks);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options) {
      return this.blocks.map(function(param) {
        return param.node.toHTML(options) + (param.visible ? "" : '<span class="math-separator">;</span>');
      }).join('<span class="math-separator"><br /></span>');
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      return this.blocks.map(function(param) {
        return param.node.toTex(options) + (param.visible ? "" : ";");
      }).join("\\;\\;\n");
    }
  }
  _defineProperty(BlockNode2, "name", name$1D);
  return BlockNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1C = "ConditionalNode";
var dependencies$1C = ["Node"];
var createConditionalNode = /* @__PURE__ */ factory(name$1C, dependencies$1C, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function testCondition(condition) {
    if (typeof condition === "number" || typeof condition === "boolean" || typeof condition === "string") {
      return !!condition;
    }
    if (condition) {
      if (isBigNumber(condition)) {
        return !condition.isZero();
      }
      if (isComplex(condition)) {
        return !!(condition.re || condition.im);
      }
      if (isUnit(condition)) {
        return !!condition.value;
      }
    }
    if (condition === null || condition === void 0) {
      return false;
    }
    throw new TypeError('Unsupported type of condition "' + typeOf$1(condition) + '"');
  }
  class ConditionalNode2 extends Node2 {
    /**
     * A lazy evaluating conditional operator: 'condition ? trueExpr : falseExpr'
     *
     * @param {Node} condition   Condition, must result in a boolean
     * @param {Node} trueExpr    Expression evaluated when condition is true
     * @param {Node} falseExpr   Expression evaluated when condition is true
     *
     * @constructor ConditionalNode
     * @extends {Node}
     */
    constructor(condition, trueExpr, falseExpr) {
      super();
      if (!isNode(condition)) {
        throw new TypeError("Parameter condition must be a Node");
      }
      if (!isNode(trueExpr)) {
        throw new TypeError("Parameter trueExpr must be a Node");
      }
      if (!isNode(falseExpr)) {
        throw new TypeError("Parameter falseExpr must be a Node");
      }
      this.condition = condition;
      this.trueExpr = trueExpr;
      this.falseExpr = falseExpr;
    }
    get type() {
      return name$1C;
    }
    get isConditionalNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalCondition = this.condition._compile(math2, argNames);
      var evalTrueExpr = this.trueExpr._compile(math2, argNames);
      var evalFalseExpr = this.falseExpr._compile(math2, argNames);
      return function evalConditionalNode(scope, args, context) {
        return testCondition(evalCondition(scope, args, context)) ? evalTrueExpr(scope, args, context) : evalFalseExpr(scope, args, context);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.condition, "condition", this);
      callback(this.trueExpr, "trueExpr", this);
      callback(this.falseExpr, "falseExpr", this);
    }
    /**
     * Create a new ConditionalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ConditionalNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new ConditionalNode2(this._ifNode(callback(this.condition, "condition", this)), this._ifNode(callback(this.trueExpr, "trueExpr", this)), this._ifNode(callback(this.falseExpr, "falseExpr", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConditionalNode}
     */
    clone() {
      return new ConditionalNode2(this.condition, this.trueExpr, this.falseExpr);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toString(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = "(" + condition + ")";
      }
      var trueExpr = this.trueExpr.toString(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = "(" + trueExpr + ")";
      }
      var falseExpr = this.falseExpr.toString(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = "(" + falseExpr + ")";
      }
      return condition + " ? " + trueExpr + " : " + falseExpr;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1C,
        condition: this.condition,
        trueExpr: this.trueExpr,
        falseExpr: this.falseExpr
      };
    }
    /**
     * Instantiate an ConditionalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "ConditionalNode",
     *      "condition": ...,
     *      "trueExpr": ...,
     *      "falseExpr": ...}
     *     ```
     *     where mathjs is optional
     * @returns {ConditionalNode}
     */
    static fromJSON(json) {
      return new ConditionalNode2(json.condition, json.trueExpr, json.falseExpr);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var condition = this.condition.toHTML(options);
      var conditionPrecedence = getPrecedence(this.condition, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.condition.type === "OperatorNode" || conditionPrecedence !== null && conditionPrecedence <= precedence) {
        condition = '<span class="math-parenthesis math-round-parenthesis">(</span>' + condition + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var trueExpr = this.trueExpr.toHTML(options);
      var truePrecedence = getPrecedence(this.trueExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.trueExpr.type === "OperatorNode" || truePrecedence !== null && truePrecedence <= precedence) {
        trueExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + trueExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      var falseExpr = this.falseExpr.toHTML(options);
      var falsePrecedence = getPrecedence(this.falseExpr, parenthesis, options && options.implicit);
      if (parenthesis === "all" || this.falseExpr.type === "OperatorNode" || falsePrecedence !== null && falsePrecedence <= precedence) {
        falseExpr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + falseExpr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return condition + '<span class="math-operator math-conditional-operator">?</span>' + trueExpr + '<span class="math-operator math-conditional-operator">:</span>' + falseExpr;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      return "\\begin{cases} {" + this.trueExpr.toTex(options) + "}, &\\quad{\\text{if }\\;" + this.condition.toTex(options) + "}\\\\{" + this.falseExpr.toTex(options) + "}, &\\quad{\\text{otherwise}}\\end{cases}";
    }
  }
  _defineProperty(ConditionalNode2, "name", name$1C);
  return ConditionalNode2;
}, {
  isClass: true,
  isNode: true
});
var _extends = Object.assign || function(target) {
  for (var i2 = 1; i2 < arguments.length; i2++) {
    var source = arguments[i2];
    for (var key in source) {
      if (Object.prototype.hasOwnProperty.call(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
var defaultEscapes = {
  "{": "\\{",
  "}": "\\}",
  "\\": "\\textbackslash{}",
  "#": "\\#",
  $: "\\$",
  "%": "\\%",
  "&": "\\&",
  "^": "\\textasciicircum{}",
  _: "\\_",
  "~": "\\textasciitilde{}"
};
var formatEscapes = {
  "": "\\--",
  "": "\\---",
  " ": "~",
  "	": "\\qquad{}",
  "\r\n": "\\newline{}",
  "\n": "\\newline{}"
};
var defaultEscapeMapFn = function defaultEscapeMapFn2(defaultEscapes2, formatEscapes2) {
  return _extends({}, defaultEscapes2, formatEscapes2);
};
var dist = function(str) {
  var _ref = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref$preserveFormatti = _ref.preserveFormatting, preserveFormatting = _ref$preserveFormatti === void 0 ? false : _ref$preserveFormatti, _ref$escapeMapFn = _ref.escapeMapFn, escapeMapFn = _ref$escapeMapFn === void 0 ? defaultEscapeMapFn : _ref$escapeMapFn;
  var runningStr = String(str);
  var result = "";
  var escapes = escapeMapFn(_extends({}, defaultEscapes), preserveFormatting ? _extends({}, formatEscapes) : {});
  var escapeKeys = Object.keys(escapes);
  var _loop = function _loop2() {
    var specialCharFound = false;
    escapeKeys.forEach(function(key, index2) {
      if (specialCharFound) {
        return;
      }
      if (runningStr.length >= key.length && runningStr.slice(0, key.length) === key) {
        result += escapes[escapeKeys[index2]];
        runningStr = runningStr.slice(key.length, runningStr.length);
        specialCharFound = true;
      }
    });
    if (!specialCharFound) {
      result += runningStr.slice(0, 1);
      runningStr = runningStr.slice(1, runningStr.length);
    }
  };
  while (runningStr) {
    _loop();
  }
  return result;
};
const escapeLatexLib = /* @__PURE__ */ getDefaultExportFromCjs(dist);
var latexSymbols = {
  // GREEK LETTERS
  Alpha: "A",
  alpha: "\\alpha",
  Beta: "B",
  beta: "\\beta",
  Gamma: "\\Gamma",
  gamma: "\\gamma",
  Delta: "\\Delta",
  delta: "\\delta",
  Epsilon: "E",
  epsilon: "\\epsilon",
  varepsilon: "\\varepsilon",
  Zeta: "Z",
  zeta: "\\zeta",
  Eta: "H",
  eta: "\\eta",
  Theta: "\\Theta",
  theta: "\\theta",
  vartheta: "\\vartheta",
  Iota: "I",
  iota: "\\iota",
  Kappa: "K",
  kappa: "\\kappa",
  varkappa: "\\varkappa",
  Lambda: "\\Lambda",
  lambda: "\\lambda",
  Mu: "M",
  mu: "\\mu",
  Nu: "N",
  nu: "\\nu",
  Xi: "\\Xi",
  xi: "\\xi",
  Omicron: "O",
  omicron: "o",
  Pi: "\\Pi",
  pi: "\\pi",
  varpi: "\\varpi",
  Rho: "P",
  rho: "\\rho",
  varrho: "\\varrho",
  Sigma: "\\Sigma",
  sigma: "\\sigma",
  varsigma: "\\varsigma",
  Tau: "T",
  tau: "\\tau",
  Upsilon: "\\Upsilon",
  upsilon: "\\upsilon",
  Phi: "\\Phi",
  phi: "\\phi",
  varphi: "\\varphi",
  Chi: "X",
  chi: "\\chi",
  Psi: "\\Psi",
  psi: "\\psi",
  Omega: "\\Omega",
  omega: "\\omega",
  // logic
  true: "\\mathrm{True}",
  false: "\\mathrm{False}",
  // other
  i: "i",
  // TODO use \i ??
  inf: "\\infty",
  Inf: "\\infty",
  infinity: "\\infty",
  Infinity: "\\infty",
  oo: "\\infty",
  lim: "\\lim",
  undefined: "\\mathbf{?}"
};
var latexOperators = {
  transpose: "^\\top",
  ctranspose: "^H",
  factorial: "!",
  pow: "^",
  dotPow: ".^\\wedge",
  // TODO find ideal solution
  unaryPlus: "+",
  unaryMinus: "-",
  bitNot: "\\~",
  // TODO find ideal solution
  not: "\\neg",
  multiply: "\\cdot",
  divide: "\\frac",
  // TODO how to handle that properly?
  dotMultiply: ".\\cdot",
  // TODO find ideal solution
  dotDivide: ".:",
  // TODO find ideal solution
  mod: "\\mod",
  add: "+",
  subtract: "-",
  to: "\\rightarrow",
  leftShift: "<<",
  rightArithShift: ">>",
  rightLogShift: ">>>",
  equal: "=",
  unequal: "\\neq",
  smaller: "<",
  larger: ">",
  smallerEq: "\\leq",
  largerEq: "\\geq",
  bitAnd: "\\&",
  bitXor: "\\underline{|}",
  bitOr: "|",
  and: "\\wedge",
  xor: "\\veebar",
  or: "\\vee"
};
var latexFunctions = {
  // arithmetic
  abs: {
    1: "\\left|${args[0]}\\right|"
  },
  add: {
    2: "\\left(${args[0]}".concat(latexOperators.add, "${args[1]}\\right)")
  },
  cbrt: {
    1: "\\sqrt[3]{${args[0]}}"
  },
  ceil: {
    1: "\\left\\lceil${args[0]}\\right\\rceil"
  },
  cube: {
    1: "\\left(${args[0]}\\right)^3"
  },
  divide: {
    2: "\\frac{${args[0]}}{${args[1]}}"
  },
  dotDivide: {
    2: "\\left(${args[0]}".concat(latexOperators.dotDivide, "${args[1]}\\right)")
  },
  dotMultiply: {
    2: "\\left(${args[0]}".concat(latexOperators.dotMultiply, "${args[1]}\\right)")
  },
  dotPow: {
    2: "\\left(${args[0]}".concat(latexOperators.dotPow, "${args[1]}\\right)")
  },
  exp: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  expm1: "\\left(e".concat(latexOperators.pow, "{${args[0]}}-1\\right)"),
  fix: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  floor: {
    1: "\\left\\lfloor${args[0]}\\right\\rfloor"
  },
  gcd: "\\gcd\\left(${args}\\right)",
  hypot: "\\hypot\\left(${args}\\right)",
  log: {
    1: "\\ln\\left(${args[0]}\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}\\right)"
  },
  log10: {
    1: "\\log_{10}\\left(${args[0]}\\right)"
  },
  log1p: {
    1: "\\ln\\left(${args[0]}+1\\right)",
    2: "\\log_{${args[1]}}\\left(${args[0]}+1\\right)"
  },
  log2: "\\log_{2}\\left(${args[0]}\\right)",
  mod: {
    2: "\\left(${args[0]}".concat(latexOperators.mod, "${args[1]}\\right)")
  },
  multiply: {
    2: "\\left(${args[0]}".concat(latexOperators.multiply, "${args[1]}\\right)")
  },
  norm: {
    1: "\\left\\|${args[0]}\\right\\|",
    2: void 0
    // use default template
  },
  nthRoot: {
    2: "\\sqrt[${args[1]}]{${args[0]}}"
  },
  nthRoots: {
    2: "\\{y : $y^{args[1]} = {${args[0]}}\\}"
  },
  pow: {
    2: "\\left(${args[0]}\\right)".concat(latexOperators.pow, "{${args[1]}}")
  },
  round: {
    1: "\\left\\lfloor${args[0]}\\right\\rceil",
    2: void 0
    // use default template
  },
  sign: {
    1: "\\mathrm{${name}}\\left(${args[0]}\\right)"
  },
  sqrt: {
    1: "\\sqrt{${args[0]}}"
  },
  square: {
    1: "\\left(${args[0]}\\right)^2"
  },
  subtract: {
    2: "\\left(${args[0]}".concat(latexOperators.subtract, "${args[1]}\\right)")
  },
  unaryMinus: {
    1: "".concat(latexOperators.unaryMinus, "\\left(${args[0]}\\right)")
  },
  unaryPlus: {
    1: "".concat(latexOperators.unaryPlus, "\\left(${args[0]}\\right)")
  },
  // bitwise
  bitAnd: {
    2: "\\left(${args[0]}".concat(latexOperators.bitAnd, "${args[1]}\\right)")
  },
  bitNot: {
    1: latexOperators.bitNot + "\\left(${args[0]}\\right)"
  },
  bitOr: {
    2: "\\left(${args[0]}".concat(latexOperators.bitOr, "${args[1]}\\right)")
  },
  bitXor: {
    2: "\\left(${args[0]}".concat(latexOperators.bitXor, "${args[1]}\\right)")
  },
  leftShift: {
    2: "\\left(${args[0]}".concat(latexOperators.leftShift, "${args[1]}\\right)")
  },
  rightArithShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightArithShift, "${args[1]}\\right)")
  },
  rightLogShift: {
    2: "\\left(${args[0]}".concat(latexOperators.rightLogShift, "${args[1]}\\right)")
  },
  // combinatorics
  bellNumbers: {
    1: "\\mathrm{B}_{${args[0]}}"
  },
  catalan: {
    1: "\\mathrm{C}_{${args[0]}}"
  },
  stirlingS2: {
    2: "\\mathrm{S}\\left(${args}\\right)"
  },
  // complex
  arg: {
    1: "\\arg\\left(${args[0]}\\right)"
  },
  conj: {
    1: "\\left(${args[0]}\\right)^*"
  },
  im: {
    1: "\\Im\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  re: {
    1: "\\Re\\left\\lbrace${args[0]}\\right\\rbrace"
  },
  // logical
  and: {
    2: "\\left(${args[0]}".concat(latexOperators.and, "${args[1]}\\right)")
  },
  not: {
    1: latexOperators.not + "\\left(${args[0]}\\right)"
  },
  or: {
    2: "\\left(${args[0]}".concat(latexOperators.or, "${args[1]}\\right)")
  },
  xor: {
    2: "\\left(${args[0]}".concat(latexOperators.xor, "${args[1]}\\right)")
  },
  // matrix
  cross: {
    2: "\\left(${args[0]}\\right)\\times\\left(${args[1]}\\right)"
  },
  ctranspose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.ctranspose)
  },
  det: {
    1: "\\det\\left(${args[0]}\\right)"
  },
  dot: {
    2: "\\left(${args[0]}\\cdot${args[1]}\\right)"
  },
  expm: {
    1: "\\exp\\left(${args[0]}\\right)"
  },
  inv: {
    1: "\\left(${args[0]}\\right)^{-1}"
  },
  pinv: {
    1: "\\left(${args[0]}\\right)^{+}"
  },
  sqrtm: {
    1: "{${args[0]}}".concat(latexOperators.pow, "{\\frac{1}{2}}")
  },
  trace: {
    1: "\\mathrm{tr}\\left(${args[0]}\\right)"
  },
  transpose: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.transpose)
  },
  // probability
  combinations: {
    2: "\\binom{${args[0]}}{${args[1]}}"
  },
  combinationsWithRep: {
    2: "\\left(\\!\\!{\\binom{${args[0]}}{${args[1]}}}\\!\\!\\right)"
  },
  factorial: {
    1: "\\left(${args[0]}\\right)".concat(latexOperators.factorial)
  },
  gamma: {
    1: "\\Gamma\\left(${args[0]}\\right)"
  },
  lgamma: {
    1: "\\ln\\Gamma\\left(${args[0]}\\right)"
  },
  // relational
  equal: {
    2: "\\left(${args[0]}".concat(latexOperators.equal, "${args[1]}\\right)")
  },
  larger: {
    2: "\\left(${args[0]}".concat(latexOperators.larger, "${args[1]}\\right)")
  },
  largerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.largerEq, "${args[1]}\\right)")
  },
  smaller: {
    2: "\\left(${args[0]}".concat(latexOperators.smaller, "${args[1]}\\right)")
  },
  smallerEq: {
    2: "\\left(${args[0]}".concat(latexOperators.smallerEq, "${args[1]}\\right)")
  },
  unequal: {
    2: "\\left(${args[0]}".concat(latexOperators.unequal, "${args[1]}\\right)")
  },
  // special
  erf: {
    1: "erf\\left(${args[0]}\\right)"
  },
  // statistics
  max: "\\max\\left(${args}\\right)",
  min: "\\min\\left(${args}\\right)",
  variance: "\\mathrm{Var}\\left(${args}\\right)",
  // trigonometry
  acos: {
    1: "\\cos^{-1}\\left(${args[0]}\\right)"
  },
  acosh: {
    1: "\\cosh^{-1}\\left(${args[0]}\\right)"
  },
  acot: {
    1: "\\cot^{-1}\\left(${args[0]}\\right)"
  },
  acoth: {
    1: "\\coth^{-1}\\left(${args[0]}\\right)"
  },
  acsc: {
    1: "\\csc^{-1}\\left(${args[0]}\\right)"
  },
  acsch: {
    1: "\\mathrm{csch}^{-1}\\left(${args[0]}\\right)"
  },
  asec: {
    1: "\\sec^{-1}\\left(${args[0]}\\right)"
  },
  asech: {
    1: "\\mathrm{sech}^{-1}\\left(${args[0]}\\right)"
  },
  asin: {
    1: "\\sin^{-1}\\left(${args[0]}\\right)"
  },
  asinh: {
    1: "\\sinh^{-1}\\left(${args[0]}\\right)"
  },
  atan: {
    1: "\\tan^{-1}\\left(${args[0]}\\right)"
  },
  atan2: {
    2: "\\mathrm{atan2}\\left(${args}\\right)"
  },
  atanh: {
    1: "\\tanh^{-1}\\left(${args[0]}\\right)"
  },
  cos: {
    1: "\\cos\\left(${args[0]}\\right)"
  },
  cosh: {
    1: "\\cosh\\left(${args[0]}\\right)"
  },
  cot: {
    1: "\\cot\\left(${args[0]}\\right)"
  },
  coth: {
    1: "\\coth\\left(${args[0]}\\right)"
  },
  csc: {
    1: "\\csc\\left(${args[0]}\\right)"
  },
  csch: {
    1: "\\mathrm{csch}\\left(${args[0]}\\right)"
  },
  sec: {
    1: "\\sec\\left(${args[0]}\\right)"
  },
  sech: {
    1: "\\mathrm{sech}\\left(${args[0]}\\right)"
  },
  sin: {
    1: "\\sin\\left(${args[0]}\\right)"
  },
  sinh: {
    1: "\\sinh\\left(${args[0]}\\right)"
  },
  tan: {
    1: "\\tan\\left(${args[0]}\\right)"
  },
  tanh: {
    1: "\\tanh\\left(${args[0]}\\right)"
  },
  // unit
  to: {
    2: "\\left(${args[0]}".concat(latexOperators.to, "${args[1]}\\right)")
  },
  // utils
  numeric: function numeric(node, options) {
    return node.args[0].toTex();
  },
  // type
  number: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  },
  string: {
    0: '\\mathtt{""}',
    1: "\\mathrm{string}\\left(${args[0]}\\right)"
  },
  bignumber: {
    0: "0",
    1: "\\left(${args[0]}\\right)"
  },
  complex: {
    0: "0",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)+".concat(latexSymbols.i, "\\cdot\\left(${args[1]}\\right)\\right)")
  },
  matrix: {
    0: "\\begin{bmatrix}\\end{bmatrix}",
    1: "\\left(${args[0]}\\right)",
    2: "\\left(${args[0]}\\right)"
  },
  sparse: {
    0: "\\begin{bsparse}\\end{bsparse}",
    1: "\\left(${args[0]}\\right)"
  },
  unit: {
    1: "\\left(${args[0]}\\right)",
    2: "\\left(\\left(${args[0]}\\right)${args[1]}\\right)"
  }
};
var defaultTemplate = "\\mathrm{${name}}\\left(${args}\\right)";
var latexUnits = {
  deg: "^\\circ"
};
function escapeLatex(string2) {
  return escapeLatexLib(string2, {
    preserveFormatting: true
  });
}
function toSymbol(name2, isUnit2) {
  isUnit2 = typeof isUnit2 === "undefined" ? false : isUnit2;
  if (isUnit2) {
    if (hasOwnProperty(latexUnits, name2)) {
      return latexUnits[name2];
    }
    return "\\mathrm{" + escapeLatex(name2) + "}";
  }
  if (hasOwnProperty(latexSymbols, name2)) {
    return latexSymbols[name2];
  }
  return escapeLatex(name2);
}
var name$1B = "ConstantNode";
var dependencies$1B = ["Node"];
var createConstantNode = /* @__PURE__ */ factory(name$1B, dependencies$1B, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ConstantNode2 extends Node2 {
    /**
     * A ConstantNode holds a constant value like a number or string.
     *
     * Usage:
     *
     *     new ConstantNode(2.3)
     *     new ConstantNode('hello')
     *
     * @param {*} value    Value can be any type (number, BigNumber, string, ...)
     * @constructor ConstantNode
     * @extends {Node}
     */
    constructor(value) {
      super();
      this.value = value;
    }
    get type() {
      return name$1B;
    }
    get isConstantNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var value = this.value;
      return function evalConstantNode() {
        return value;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
    }
    /**
     * Create a new ConstantNode with children produced by the given callback.
     * Trivial because there are no children.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ConstantNode} Returns a clone of the node
     */
    map(callback) {
      return this.clone();
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ConstantNode}
     */
    clone() {
      return new ConstantNode2(this.value);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      return format$1(this.value, options);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options) {
      var value = this._toString(options);
      switch (typeOf$1(this.value)) {
        case "number":
        case "BigNumber":
        case "Fraction":
          return '<span class="math-number">' + value + "</span>";
        case "string":
          return '<span class="math-string">' + value + "</span>";
        case "boolean":
          return '<span class="math-boolean">' + value + "</span>";
        case "null":
          return '<span class="math-null-symbol">' + value + "</span>";
        case "undefined":
          return '<span class="math-undefined">' + value + "</span>";
        default:
          return '<span class="math-symbol">' + value + "</span>";
      }
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1B,
        value: this.value
      };
    }
    /**
     * Instantiate a ConstantNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", value: 2.3}`,
     *                       where mathjs is optional
     * @returns {ConstantNode}
     */
    static fromJSON(json) {
      return new ConstantNode2(json.value);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var value = this._toString(options);
      var type = typeOf$1(this.value);
      switch (type) {
        case "string":
          return "\\mathtt{" + escapeLatex(value) + "}";
        case "number":
        case "BigNumber": {
          var finite = type === "BigNumber" ? this.value.isFinite() : isFinite(this.value);
          if (!finite) {
            return this.value.valueOf() < 0 ? "-\\infty" : "\\infty";
          }
          var index2 = value.toLowerCase().indexOf("e");
          if (index2 !== -1) {
            return value.substring(0, index2) + "\\cdot10^{" + value.substring(index2 + 1) + "}";
          }
          return value;
        }
        case "Fraction":
          return this.value.toLatex();
        default:
          return value;
      }
    }
  }
  _defineProperty(ConstantNode2, "name", name$1B);
  return ConstantNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1A = "FunctionAssignmentNode";
var dependencies$1A = ["typed", "Node"];
var createFunctionAssignmentNode = /* @__PURE__ */ factory(name$1A, dependencies$1A, (_ref) => {
  var {
    typed: typed2,
    Node: Node2
  } = _ref;
  function needParenthesis(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var exprPrecedence = getPrecedence(node.expr, parenthesis, implicit);
    return parenthesis === "all" || exprPrecedence !== null && exprPrecedence <= precedence;
  }
  class FunctionAssignmentNode2 extends Node2 {
    /**
     * @constructor FunctionAssignmentNode
     * @extends {Node}
     * Function assignment
     *
     * @param {string} name           Function name
     * @param {string[] | Array.<{name: string, type: string}>} params
     *                                Array with function parameter names, or an
     *                                array with objects containing the name
     *                                and type of the parameter
     * @param {Node} expr             The function expression
     */
    constructor(name2, params, expr) {
      super();
      if (typeof name2 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      if (!Array.isArray(params)) {
        throw new TypeError('Array containing strings or objects expected for parameter "params"');
      }
      if (!isNode(expr)) {
        throw new TypeError('Node expected for parameter "expr"');
      }
      if (keywords.has(name2)) {
        throw new Error('Illegal function name, "' + name2 + '" is a reserved keyword');
      }
      var paramNames = /* @__PURE__ */ new Set();
      for (var param of params) {
        var _name = typeof param === "string" ? param : param.name;
        if (paramNames.has(_name)) {
          throw new Error('Duplicate parameter name "'.concat(_name, '"'));
        } else {
          paramNames.add(_name);
        }
      }
      this.name = name2;
      this.params = params.map(function(param2) {
        return param2 && param2.name || param2;
      });
      this.types = params.map(function(param2) {
        return param2 && param2.type || "any";
      });
      this.expr = expr;
    }
    get type() {
      return name$1A;
    }
    get isFunctionAssignmentNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var childArgNames = Object.create(argNames);
      forEach$1(this.params, function(param) {
        childArgNames[param] = true;
      });
      var evalExpr = this.expr._compile(math2, childArgNames);
      var name2 = this.name;
      var params = this.params;
      var signature = join(this.types, ",");
      var syntax = name2 + "(" + join(this.params, ", ") + ")";
      return function evalFunctionAssignmentNode(scope, args, context) {
        var signatures = {};
        signatures[signature] = function() {
          var childArgs = Object.create(args);
          for (var i2 = 0; i2 < params.length; i2++) {
            childArgs[params[i2]] = arguments[i2];
          }
          return evalExpr(scope, childArgs, context);
        };
        var fn = typed2(name2, signatures);
        fn.syntax = syntax;
        scope.set(name2, fn);
        return fn;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.expr, "expr", this);
    }
    /**
     * Create a new FunctionAssignmentNode whose children are the results of
     * calling the provided callback function for each child of the original
     * node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionAssignmentNode} Returns a transformed copy of the node
     */
    map(callback) {
      var expr = this._ifNode(callback(this.expr, "expr", this));
      return new FunctionAssignmentNode2(this.name, this.params.slice(0), expr);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionAssignmentNode}
     */
    clone() {
      return new FunctionAssignmentNode2(this.name, this.params.slice(0), this.expr);
    }
    /**
     * get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toString(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "(" + expr + ")";
      }
      return this.name + "(" + this.params.join(", ") + ") = " + expr;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      var types = this.types;
      return {
        mathjs: name$1A,
        name: this.name,
        params: this.params.map(function(param, index2) {
          return {
            name: param,
            type: types[index2]
          };
        }),
        expr: this.expr
      };
    }
    /**
     * Instantiate an FunctionAssignmentNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "FunctionAssignmentNode",
     *      name: ..., params: ..., expr: ...}
     *     ```
     *     where mathjs is optional
     * @returns {FunctionAssignmentNode}
     */
    static fromJSON(json) {
      return new FunctionAssignmentNode2(json.name, json.params, json.expr);
    }
    /**
     * get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var params = [];
      for (var i2 = 0; i2 < this.params.length; i2++) {
        params.push('<span class="math-symbol math-parameter">' + escape(this.params[i2]) + "</span>");
      }
      var expr = this.expr.toHTML(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = '<span class="math-parenthesis math-round-parenthesis">(</span>' + expr + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return '<span class="math-function">' + escape(this.name) + '</span><span class="math-parenthesis math-round-parenthesis">(</span>' + params.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-round-parenthesis">)</span><span class="math-operator math-assignment-operator math-variable-assignment-operator math-binary-operator">=</span>' + expr;
    }
    /**
     * get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var expr = this.expr.toTex(options);
      if (needParenthesis(this, parenthesis, options && options.implicit)) {
        expr = "\\left(".concat(expr, "\\right)");
      }
      return "\\mathrm{" + this.name + "}\\left(" + this.params.map(toSymbol).join(",") + "\\right)=" + expr;
    }
  }
  _defineProperty(FunctionAssignmentNode2, "name", name$1A);
  return FunctionAssignmentNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1z = "IndexNode";
var dependencies$1z = ["Node", "size"];
var createIndexNode = /* @__PURE__ */ factory(name$1z, dependencies$1z, (_ref) => {
  var {
    Node: Node2,
    size: size2
  } = _ref;
  class IndexNode2 extends Node2 {
    /**
     * @constructor IndexNode
     * @extends Node
     *
     * Describes a subset of a matrix or an object property.
     * Cannot be used on its own, needs to be used within an AccessorNode or
     * AssignmentNode.
     *
     * @param {Node[]} dimensions
     * @param {boolean} [dotNotation=false]
     *     Optional property describing whether this index was written using dot
     *     notation like `a.b`, or using bracket notation like `a["b"]`
     *     (which is the default). This property is used for string conversion.
     */
    constructor(dimensions, dotNotation) {
      super();
      this.dimensions = dimensions;
      this.dotNotation = dotNotation || false;
      if (!Array.isArray(dimensions) || !dimensions.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "dimensions"');
      }
      if (this.dotNotation && !this.isObjectProperty()) {
        throw new Error("dotNotation only applicable for object properties");
      }
    }
    get type() {
      return name$1z;
    }
    get isIndexNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalDimensions = map$1(this.dimensions, function(dimension, i2) {
        var needsEnd = dimension.filter((node) => node.isSymbolNode && node.name === "end").length > 0;
        if (needsEnd) {
          var childArgNames = Object.create(argNames);
          childArgNames.end = true;
          var _evalDimension = dimension._compile(math2, childArgNames);
          return function evalDimension(scope, args, context) {
            if (!isMatrix(context) && !isArray(context) && !isString(context)) {
              throw new TypeError('Cannot resolve "end": context must be a Matrix, Array, or string but is ' + typeOf$1(context));
            }
            var s = size2(context).valueOf();
            var childArgs = Object.create(args);
            childArgs.end = s[i2];
            return _evalDimension(scope, childArgs, context);
          };
        } else {
          return dimension._compile(math2, argNames);
        }
      });
      var index2 = getSafeProperty(math2, "index");
      return function evalIndexNode(scope, args, context) {
        var dimensions = map$1(evalDimensions, function(evalDimension) {
          return evalDimension(scope, args, context);
        });
        return index2(...dimensions);
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        callback(this.dimensions[i2], "dimensions[" + i2 + "]", this);
      }
    }
    /**
     * Create a new IndexNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {IndexNode} Returns a transformed copy of the node
     */
    map(callback) {
      var dimensions = [];
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        dimensions[i2] = this._ifNode(callback(this.dimensions[i2], "dimensions[" + i2 + "]", this));
      }
      return new IndexNode2(dimensions, this.dotNotation);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {IndexNode}
     */
    clone() {
      return new IndexNode2(this.dimensions.slice(0), this.dotNotation);
    }
    /**
     * Test whether this IndexNode contains a single property name
     * @return {boolean}
     */
    isObjectProperty() {
      return this.dimensions.length === 1 && isConstantNode(this.dimensions[0]) && typeof this.dimensions[0].value === "string";
    }
    /**
     * Returns the property name if IndexNode contains a property.
     * If not, returns null.
     * @return {string | null}
     */
    getObjectProperty() {
      return this.isObjectProperty() ? this.dimensions[0].value : null;
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      return this.dotNotation ? "." + this.getObjectProperty() : "[" + this.dimensions.join(", ") + "]";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1z,
        dimensions: this.dimensions,
        dotNotation: this.dotNotation
      };
    }
    /**
     * Instantiate an IndexNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "IndexNode", dimensions: [...], dotNotation: false}`,
     *     where mathjs is optional
     * @returns {IndexNode}
     */
    static fromJSON(json) {
      return new IndexNode2(json.dimensions, json.dotNotation);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options) {
      var dimensions = [];
      for (var i2 = 0; i2 < this.dimensions.length; i2++) {
        dimensions[i2] = this.dimensions[i2].toHTML();
      }
      if (this.dotNotation) {
        return '<span class="math-operator math-accessor-operator">.</span><span class="math-symbol math-property">' + escape(this.getObjectProperty()) + "</span>";
      } else {
        return '<span class="math-parenthesis math-square-parenthesis">[</span>' + dimensions.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-square-parenthesis">]</span>';
      }
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var dimensions = this.dimensions.map(function(range2) {
        return range2.toTex(options);
      });
      return this.dotNotation ? "." + this.getObjectProperty() : "_{" + dimensions.join(",") + "}";
    }
  }
  _defineProperty(IndexNode2, "name", name$1z);
  return IndexNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1y = "ObjectNode";
var dependencies$1y = ["Node"];
var createObjectNode = /* @__PURE__ */ factory(name$1y, dependencies$1y, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ObjectNode2 extends Node2 {
    /**
     * @constructor ObjectNode
     * @extends {Node}
     * Holds an object with keys/values
     * @param {Object.<string, Node>} [properties]   object with key/value pairs
     */
    constructor(properties2) {
      super();
      this.properties = properties2 || {};
      if (properties2) {
        if (!(typeof properties2 === "object") || !Object.keys(properties2).every(function(key) {
          return isNode(properties2[key]);
        })) {
          throw new TypeError("Object containing Nodes expected");
        }
      }
    }
    get type() {
      return name$1y;
    }
    get isObjectNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var evalEntries = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          var stringifiedKey = stringify(key);
          var parsedKey = JSON.parse(stringifiedKey);
          var prop = getSafeProperty(this.properties, key);
          evalEntries[parsedKey] = prop._compile(math2, argNames);
        }
      }
      return function evalObjectNode(scope, args, context) {
        var obj = {};
        for (var _key in evalEntries) {
          if (hasOwnProperty(evalEntries, _key)) {
            obj[_key] = evalEntries[_key](scope, args, context);
          }
        }
        return obj;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          callback(this.properties[key], "properties[" + stringify(key) + "]", this);
        }
      }
    }
    /**
     * Create a new ObjectNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {ObjectNode} Returns a transformed copy of the node
     */
    map(callback) {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties2[key] = this._ifNode(callback(this.properties[key], "properties[" + stringify(key) + "]", this));
        }
      }
      return new ObjectNode2(properties2);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ObjectNode}
     */
    clone() {
      var properties2 = {};
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          properties2[key] = this.properties[key];
        }
      }
      return new ObjectNode2(properties2);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push(stringify(key) + ": " + this.properties[key].toString(options));
        }
      }
      return "{" + entries.join(", ") + "}";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1y,
        properties: this.properties
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ObjectNode", "properties": {...}}`,
     *                       where mathjs is optional
     * @returns {ObjectNode}
     */
    static fromJSON(json) {
      return new ObjectNode2(json.properties);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push('<span class="math-symbol math-property">' + escape(key) + '</span><span class="math-operator math-assignment-operator math-property-assignment-operator math-binary-operator">:</span>' + this.properties[key].toHTML(options));
        }
      }
      return '<span class="math-parenthesis math-curly-parenthesis">{</span>' + entries.join('<span class="math-separator">,</span>') + '<span class="math-parenthesis math-curly-parenthesis">}</span>';
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var entries = [];
      for (var key in this.properties) {
        if (hasOwnProperty(this.properties, key)) {
          entries.push("\\mathbf{" + key + ":} & " + this.properties[key].toTex(options) + "\\\\");
        }
      }
      var tex = "\\left\\{\\begin{array}{ll}" + entries.join("\n") + "\\end{array}\\right\\}";
      return tex;
    }
  }
  _defineProperty(ObjectNode2, "name", name$1y);
  return ObjectNode2;
}, {
  isClass: true,
  isNode: true
});
function createSubScope(parentScope, args) {
  return new PartitionedMap(parentScope, new ObjectWrappingMap(args), new Set(Object.keys(args)));
}
var name$1x = "OperatorNode";
var dependencies$1x = ["Node"];
var createOperatorNode = /* @__PURE__ */ factory(name$1x, dependencies$1x, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function startsWithConstant(expr, parenthesis) {
    var curNode = expr;
    if (parenthesis === "auto") {
      while (isParenthesisNode(curNode))
        curNode = curNode.content;
    }
    if (isConstantNode(curNode))
      return true;
    if (isOperatorNode(curNode)) {
      return startsWithConstant(curNode.args[0], parenthesis);
    }
    return false;
  }
  function calculateNecessaryParentheses(root, parenthesis, implicit, args, latex) {
    var precedence = getPrecedence(root, parenthesis, implicit);
    var associativity = getAssociativity(root, parenthesis);
    if (parenthesis === "all" || args.length > 2 && root.getIdentifier() !== "OperatorNode:add" && root.getIdentifier() !== "OperatorNode:multiply") {
      return args.map(function(arg2) {
        switch (arg2.getContent().type) {
          case "ArrayNode":
          case "ConstantNode":
          case "SymbolNode":
          case "ParenthesisNode":
            return false;
          default:
            return true;
        }
      });
    }
    var result;
    switch (args.length) {
      case 0:
        result = [];
        break;
      case 1:
        {
          var operandPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          if (latex && operandPrecedence !== null) {
            var operandIdentifier;
            var rootIdentifier;
            if (parenthesis === "keep") {
              operandIdentifier = args[0].getIdentifier();
              rootIdentifier = root.getIdentifier();
            } else {
              operandIdentifier = args[0].getContent().getIdentifier();
              rootIdentifier = root.getContent().getIdentifier();
            }
            if (properties[precedence][rootIdentifier].latexLeftParens === false) {
              result = [false];
              break;
            }
            if (properties[operandPrecedence][operandIdentifier].latexParens === false) {
              result = [false];
              break;
            }
          }
          if (operandPrecedence === null) {
            result = [false];
            break;
          }
          if (operandPrecedence <= precedence) {
            result = [true];
            break;
          }
          result = [false];
        }
        break;
      case 2:
        {
          var lhsParens;
          var lhsPrecedence = getPrecedence(args[0], parenthesis, implicit, root);
          var assocWithLhs = isAssociativeWith(root, args[0], parenthesis);
          if (lhsPrecedence === null) {
            lhsParens = false;
          } else if (lhsPrecedence === precedence && associativity === "right" && !assocWithLhs) {
            lhsParens = true;
          } else if (lhsPrecedence < precedence) {
            lhsParens = true;
          } else {
            lhsParens = false;
          }
          var rhsParens;
          var rhsPrecedence = getPrecedence(args[1], parenthesis, implicit, root);
          var assocWithRhs = isAssociativeWith(root, args[1], parenthesis);
          if (rhsPrecedence === null) {
            rhsParens = false;
          } else if (rhsPrecedence === precedence && associativity === "left" && !assocWithRhs) {
            rhsParens = true;
          } else if (rhsPrecedence < precedence) {
            rhsParens = true;
          } else {
            rhsParens = false;
          }
          if (latex) {
            var _rootIdentifier;
            var lhsIdentifier;
            var rhsIdentifier;
            if (parenthesis === "keep") {
              _rootIdentifier = root.getIdentifier();
              lhsIdentifier = root.args[0].getIdentifier();
              rhsIdentifier = root.args[1].getIdentifier();
            } else {
              _rootIdentifier = root.getContent().getIdentifier();
              lhsIdentifier = root.args[0].getContent().getIdentifier();
              rhsIdentifier = root.args[1].getContent().getIdentifier();
            }
            if (lhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexLeftParens === false) {
                lhsParens = false;
              }
              if (properties[lhsPrecedence][lhsIdentifier].latexParens === false) {
                lhsParens = false;
              }
            }
            if (rhsPrecedence !== null) {
              if (properties[precedence][_rootIdentifier].latexRightParens === false) {
                rhsParens = false;
              }
              if (properties[rhsPrecedence][rhsIdentifier].latexParens === false) {
                rhsParens = false;
              }
            }
          }
          result = [lhsParens, rhsParens];
        }
        break;
      default:
        if (root.getIdentifier() === "OperatorNode:add" || root.getIdentifier() === "OperatorNode:multiply") {
          result = args.map(function(arg2) {
            var argPrecedence = getPrecedence(arg2, parenthesis, implicit, root);
            var assocWithArg = isAssociativeWith(root, arg2, parenthesis);
            var argAssociativity = getAssociativity(arg2, parenthesis);
            if (argPrecedence === null) {
              return false;
            } else if (precedence === argPrecedence && associativity === argAssociativity && !assocWithArg) {
              return true;
            } else if (argPrecedence < precedence) {
              return true;
            }
            return false;
          });
        }
        break;
    }
    if (args.length >= 2 && root.getIdentifier() === "OperatorNode:multiply" && root.implicit && parenthesis !== "all" && implicit === "hide") {
      for (var i2 = 1; i2 < result.length; ++i2) {
        if (startsWithConstant(args[i2], parenthesis) && !result[i2 - 1] && (parenthesis !== "keep" || !isParenthesisNode(args[i2 - 1]))) {
          result[i2] = true;
        }
      }
    }
    return result;
  }
  class OperatorNode2 extends Node2 {
    /**
     * @constructor OperatorNode
     * @extends {Node}
     * An operator with two arguments, like 2+3
     *
     * @param {string} op           Operator name, for example '+'
     * @param {string} fn           Function name, for example 'add'
     * @param {Node[]} args         Operator arguments
     * @param {boolean} [implicit]  Is this an implicit multiplication?
     * @param {boolean} [isPercentage] Is this an percentage Operation?
     */
    constructor(op, fn, args, implicit, isPercentage) {
      super();
      if (typeof op !== "string") {
        throw new TypeError('string expected for parameter "op"');
      }
      if (typeof fn !== "string") {
        throw new TypeError('string expected for parameter "fn"');
      }
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.implicit = implicit === true;
      this.isPercentage = isPercentage === true;
      this.op = op;
      this.fn = fn;
      this.args = args || [];
    }
    get type() {
      return name$1x;
    }
    get isOperatorNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      if (typeof this.fn !== "string" || !isSafeMethod(math2, this.fn)) {
        if (!math2[this.fn]) {
          throw new Error("Function " + this.fn + ' missing in provided namespace "math"');
        } else {
          throw new Error('No access to function "' + this.fn + '"');
        }
      }
      var fn = getSafeProperty(math2, this.fn);
      var evalArgs = map$1(this.args, function(arg2) {
        return arg2._compile(math2, argNames);
      });
      if (typeof fn === "function" && fn.rawArgs === true) {
        var rawArgs = this.args;
        return function evalOperatorNode(scope, args, context) {
          return fn(rawArgs, math2, createSubScope(scope, args));
        };
      } else if (evalArgs.length === 1) {
        var evalArg0 = evalArgs[0];
        return function evalOperatorNode(scope, args, context) {
          return fn(evalArg0(scope, args, context));
        };
      } else if (evalArgs.length === 2) {
        var _evalArg = evalArgs[0];
        var evalArg1 = evalArgs[1];
        return function evalOperatorNode(scope, args, context) {
          return fn(_evalArg(scope, args, context), evalArg1(scope, args, context));
        };
      } else {
        return function evalOperatorNode(scope, args, context) {
          return fn.apply(null, map$1(evalArgs, function(evalArg) {
            return evalArg(scope, args, context);
          }));
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      for (var i2 = 0; i2 < this.args.length; i2++) {
        callback(this.args[i2], "args[" + i2 + "]", this);
      }
    }
    /**
     * Create a new OperatorNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {OperatorNode} Returns a transformed copy of the node
     */
    map(callback) {
      var args = [];
      for (var i2 = 0; i2 < this.args.length; i2++) {
        args[i2] = this._ifNode(callback(this.args[i2], "args[" + i2 + "]", this));
      }
      return new OperatorNode2(this.op, this.fn, args, this.implicit, this.isPercentage);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {OperatorNode}
     */
    clone() {
      return new OperatorNode2(this.op, this.fn, this.args.slice(0), this.implicit, this.isPercentage);
    }
    /**
     * Check whether this is an unary OperatorNode:
     * has exactly one argument, like `-a`.
     * @return {boolean}
     *     Returns true when an unary operator node, false otherwise.
     */
    isUnary() {
      return this.args.length === 1;
    }
    /**
     * Check whether this is a binary OperatorNode:
     * has exactly two arguments, like `a + b`.
     * @return {boolean}
     *     Returns true when a binary operator node, false otherwise.
     */
    isBinary() {
      return this.args.length === 2;
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toString(options);
        if (parens[0]) {
          operand = "(" + operand + ")";
        }
        var opIsNamed = /[a-zA-Z]+/.test(this.op);
        if (assoc === "right") {
          return this.op + (opIsNamed ? " " : "") + operand;
        } else if (assoc === "left") {
          return operand + (opIsNamed ? " " : "") + this.op;
        }
        return operand + this.op;
      } else if (args.length === 2) {
        var lhs = args[0].toString(options);
        var rhs = args[1].toString(options);
        if (parens[0]) {
          lhs = "(" + lhs + ")";
        }
        if (parens[1]) {
          rhs = "(" + rhs + ")";
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + " " + rhs;
        }
        return lhs + " " + this.op + " " + rhs;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var stringifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toString(options);
          if (parens[index2]) {
            arg2 = "(" + arg2 + ")";
          }
          return arg2;
        });
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return stringifiedArgs.join(" ");
        }
        return stringifiedArgs.join(" " + this.op + " ");
      } else {
        return this.fn + "(" + this.args.join(", ") + ")";
      }
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1x,
        op: this.op,
        fn: this.fn,
        args: this.args,
        implicit: this.implicit,
        isPercentage: this.isPercentage
      };
    }
    /**
     * Instantiate an OperatorNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     ```
     *     {"mathjs": "OperatorNode",
     *      "op": "+", "fn": "add", "args": [...],
     *      "implicit": false,
     *      "isPercentage":false}
     *     ```
     *     where mathjs is optional
     * @returns {OperatorNode}
     */
    static fromJSON(json) {
      return new OperatorNode2(json.op, json.fn, json.args, json.implicit, json.isPercentage);
    }
    /**
     * Get HTML representation.
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, false);
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toHTML(options);
        if (parens[0]) {
          operand = '<span class="math-parenthesis math-round-parenthesis">(</span>' + operand + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (assoc === "right") {
          return '<span class="math-operator math-unary-operator math-lefthand-unary-operator">' + escape(this.op) + "</span>" + operand;
        } else {
          return operand + '<span class="math-operator math-unary-operator math-righthand-unary-operator">' + escape(this.op) + "</span>";
        }
      } else if (args.length === 2) {
        var lhs = args[0].toHTML(options);
        var rhs = args[1].toHTML(options);
        if (parens[0]) {
          lhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + lhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (parens[1]) {
          rhs = '<span class="math-parenthesis math-round-parenthesis">(</span>' + rhs + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
          return lhs + '<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>' + rhs;
        }
        return lhs + '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>" + rhs;
      } else {
        var stringifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toHTML(options);
          if (parens[index2]) {
            arg2 = '<span class="math-parenthesis math-round-parenthesis">(</span>' + arg2 + '<span class="math-parenthesis math-round-parenthesis">)</span>';
          }
          return arg2;
        });
        if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
          if (this.implicit && this.getIdentifier() === "OperatorNode:multiply" && implicit === "hide") {
            return stringifiedArgs.join('<span class="math-operator math-binary-operator math-implicit-binary-operator"></span>');
          }
          return stringifiedArgs.join('<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(this.op) + "</span>");
        } else {
          return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + stringifiedArgs.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
        }
      }
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var implicit = options && options.implicit ? options.implicit : "hide";
      var args = this.args;
      var parens = calculateNecessaryParentheses(this, parenthesis, implicit, args, true);
      var op = latexOperators[this.fn];
      op = typeof op === "undefined" ? this.op : op;
      if (args.length === 1) {
        var assoc = getAssociativity(this, parenthesis);
        var operand = args[0].toTex(options);
        if (parens[0]) {
          operand = "\\left(".concat(operand, "\\right)");
        }
        if (assoc === "right") {
          return op + operand;
        } else if (assoc === "left") {
          return operand + op;
        }
        return operand + op;
      } else if (args.length === 2) {
        var lhs = args[0];
        var lhsTex = lhs.toTex(options);
        if (parens[0]) {
          lhsTex = "\\left(".concat(lhsTex, "\\right)");
        }
        var rhs = args[1];
        var rhsTex = rhs.toTex(options);
        if (parens[1]) {
          rhsTex = "\\left(".concat(rhsTex, "\\right)");
        }
        var lhsIdentifier;
        if (parenthesis === "keep") {
          lhsIdentifier = lhs.getIdentifier();
        } else {
          lhsIdentifier = lhs.getContent().getIdentifier();
        }
        switch (this.getIdentifier()) {
          case "OperatorNode:divide":
            return op + "{" + lhsTex + "}{" + rhsTex + "}";
          case "OperatorNode:pow":
            lhsTex = "{" + lhsTex + "}";
            rhsTex = "{" + rhsTex + "}";
            switch (lhsIdentifier) {
              case "ConditionalNode":
              case "OperatorNode:divide":
                lhsTex = "\\left(".concat(lhsTex, "\\right)");
            }
            break;
          case "OperatorNode:multiply":
            if (this.implicit && implicit === "hide") {
              return lhsTex + "~" + rhsTex;
            }
        }
        return lhsTex + op + rhsTex;
      } else if (args.length > 2 && (this.getIdentifier() === "OperatorNode:add" || this.getIdentifier() === "OperatorNode:multiply")) {
        var texifiedArgs = args.map(function(arg2, index2) {
          arg2 = arg2.toTex(options);
          if (parens[index2]) {
            arg2 = "\\left(".concat(arg2, "\\right)");
          }
          return arg2;
        });
        if (this.getIdentifier() === "OperatorNode:multiply" && this.implicit && implicit === "hide") {
          return texifiedArgs.join("~");
        }
        return texifiedArgs.join(op);
      } else {
        return "\\mathrm{" + this.fn + "}\\left(" + args.map(function(arg2) {
          return arg2.toTex(options);
        }).join(",") + "\\right)";
      }
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.fn;
    }
  }
  _defineProperty(OperatorNode2, "name", name$1x);
  return OperatorNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1w = "ParenthesisNode";
var dependencies$1w = ["Node"];
var createParenthesisNode = /* @__PURE__ */ factory(name$1w, dependencies$1w, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  class ParenthesisNode2 extends Node2 {
    /**
     * @constructor ParenthesisNode
     * @extends {Node}
     * A parenthesis node describes manual parenthesis from the user input
     * @param {Node} content
     * @extends {Node}
     */
    constructor(content) {
      super();
      if (!isNode(content)) {
        throw new TypeError('Node expected for parameter "content"');
      }
      this.content = content;
    }
    get type() {
      return name$1w;
    }
    get isParenthesisNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      return this.content._compile(math2, argNames);
    }
    /**
     * Get the content of the current Node.
     * @return {Node} content
     * @override
     **/
    getContent() {
      return this.content.getContent();
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.content, "content", this);
    }
    /**
     * Create a new ParenthesisNode whose child is the result of calling
     * the provided callback function on the child of this node.
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {ParenthesisNode} Returns a clone of the node
     */
    map(callback) {
      var content = callback(this.content, "content", this);
      return new ParenthesisNode2(content);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {ParenthesisNode}
     */
    clone() {
      return new ParenthesisNode2(this.content);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "(" + this.content.toString(options) + ")";
      }
      return this.content.toString(options);
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1w,
        content: this.content
      };
    }
    /**
     * Instantiate an ParenthesisNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "ParenthesisNode", "content": ...}`,
     *                       where mathjs is optional
     * @returns {ParenthesisNode}
     */
    static fromJSON(json) {
      return new ParenthesisNode2(json.content);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return '<span class="math-parenthesis math-round-parenthesis">(</span>' + this.content.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      return this.content.toHTML(options);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(options) {
      if (!options || options && !options.parenthesis || options && options.parenthesis === "keep") {
        return "\\left(".concat(this.content.toTex(options), "\\right)");
      }
      return this.content.toTex(options);
    }
  }
  _defineProperty(ParenthesisNode2, "name", name$1w);
  return ParenthesisNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1v = "RangeNode";
var dependencies$1v = ["Node"];
var createRangeNode = /* @__PURE__ */ factory(name$1v, dependencies$1v, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  function calculateNecessaryParentheses(node, parenthesis, implicit) {
    var precedence = getPrecedence(node, parenthesis, implicit);
    var parens = {};
    var startPrecedence = getPrecedence(node.start, parenthesis, implicit);
    parens.start = startPrecedence !== null && startPrecedence <= precedence || parenthesis === "all";
    if (node.step) {
      var stepPrecedence = getPrecedence(node.step, parenthesis, implicit);
      parens.step = stepPrecedence !== null && stepPrecedence <= precedence || parenthesis === "all";
    }
    var endPrecedence = getPrecedence(node.end, parenthesis, implicit);
    parens.end = endPrecedence !== null && endPrecedence <= precedence || parenthesis === "all";
    return parens;
  }
  class RangeNode2 extends Node2 {
    /**
     * @constructor RangeNode
     * @extends {Node}
     * create a range
     * @param {Node} start  included lower-bound
     * @param {Node} end    included upper-bound
     * @param {Node} [step] optional step
     */
    constructor(start, end, step) {
      super();
      if (!isNode(start))
        throw new TypeError("Node expected");
      if (!isNode(end))
        throw new TypeError("Node expected");
      if (step && !isNode(step))
        throw new TypeError("Node expected");
      if (arguments.length > 3)
        throw new Error("Too many arguments");
      this.start = start;
      this.end = end;
      this.step = step || null;
    }
    get type() {
      return name$1v;
    }
    get isRangeNode() {
      return true;
    }
    /**
     * Check whether the RangeNode needs the `end` symbol to be defined.
     * This end is the size of the Matrix in current dimension.
     * @return {boolean}
     */
    needsEnd() {
      var endSymbols = this.filter(function(node) {
        return isSymbolNode(node) && node.name === "end";
      });
      return endSymbols.length > 0;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var range2 = math2.range;
      var evalStart = this.start._compile(math2, argNames);
      var evalEnd = this.end._compile(math2, argNames);
      if (this.step) {
        var evalStep = this.step._compile(math2, argNames);
        return function evalRangeNode(scope, args, context) {
          return range2(evalStart(scope, args, context), evalEnd(scope, args, context), evalStep(scope, args, context));
        };
      } else {
        return function evalRangeNode(scope, args, context) {
          return range2(evalStart(scope, args, context), evalEnd(scope, args, context));
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.start, "start", this);
      callback(this.end, "end", this);
      if (this.step) {
        callback(this.step, "step", this);
      }
    }
    /**
     * Create a new RangeNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RangeNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new RangeNode2(this._ifNode(callback(this.start, "start", this)), this._ifNode(callback(this.end, "end", this)), this.step && this._ifNode(callback(this.step, "step", this)));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RangeNode}
     */
    clone() {
      return new RangeNode2(this.start, this.end, this.step && this.step);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start = this.start.toString(options);
      if (parens.start) {
        start = "(" + start + ")";
      }
      str = start;
      if (this.step) {
        var step = this.step.toString(options);
        if (parens.step) {
          step = "(" + step + ")";
        }
        str += ":" + step;
      }
      var end = this.end.toString(options);
      if (parens.end) {
        end = "(" + end + ")";
      }
      str += ":" + end;
      return str;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1v,
        start: this.start,
        end: this.end,
        step: this.step
      };
    }
    /**
     * Instantiate an RangeNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RangeNode", "start": ..., "end": ..., "step": ...}`,
     *     where mathjs is optional
     * @returns {RangeNode}
     */
    static fromJSON(json) {
      return new RangeNode2(json.start, json.end, json.step);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str;
      var start = this.start.toHTML(options);
      if (parens.start) {
        start = '<span class="math-parenthesis math-round-parenthesis">(</span>' + start + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str = start;
      if (this.step) {
        var step = this.step.toHTML(options);
        if (parens.step) {
          step = '<span class="math-parenthesis math-round-parenthesis">(</span>' + step + '<span class="math-parenthesis math-round-parenthesis">)</span>';
        }
        str += '<span class="math-operator math-range-operator">:</span>' + step;
      }
      var end = this.end.toHTML(options);
      if (parens.end) {
        end = '<span class="math-parenthesis math-round-parenthesis">(</span>' + end + '<span class="math-parenthesis math-round-parenthesis">)</span>';
      }
      str += '<span class="math-operator math-range-operator">:</span>' + end;
      return str;
    }
    /**
     * Get LaTeX representation
     * @params {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var parens = calculateNecessaryParentheses(this, parenthesis, options && options.implicit);
      var str = this.start.toTex(options);
      if (parens.start) {
        str = "\\left(".concat(str, "\\right)");
      }
      if (this.step) {
        var step = this.step.toTex(options);
        if (parens.step) {
          step = "\\left(".concat(step, "\\right)");
        }
        str += ":" + step;
      }
      var end = this.end.toTex(options);
      if (parens.end) {
        end = "\\left(".concat(end, "\\right)");
      }
      str += ":" + end;
      return str;
    }
  }
  _defineProperty(RangeNode2, "name", name$1v);
  return RangeNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1u = "RelationalNode";
var dependencies$1u = ["Node"];
var createRelationalNode = /* @__PURE__ */ factory(name$1u, dependencies$1u, (_ref) => {
  var {
    Node: Node2
  } = _ref;
  var operatorMap = {
    equal: "==",
    unequal: "!=",
    smaller: "<",
    larger: ">",
    smallerEq: "<=",
    largerEq: ">="
  };
  class RelationalNode2 extends Node2 {
    /**
     * A node representing a chained conditional expression, such as 'x > y > z'
     *
     * @param {String[]} conditionals
     *     An array of conditional operators used to compare the parameters
     * @param {Node[]} params
     *     The parameters that will be compared
     *
     * @constructor RelationalNode
     * @extends {Node}
     */
    constructor(conditionals, params) {
      super();
      if (!Array.isArray(conditionals)) {
        throw new TypeError("Parameter conditionals must be an array");
      }
      if (!Array.isArray(params)) {
        throw new TypeError("Parameter params must be an array");
      }
      if (conditionals.length !== params.length - 1) {
        throw new TypeError("Parameter params must contain exactly one more element than parameter conditionals");
      }
      this.conditionals = conditionals;
      this.params = params;
    }
    get type() {
      return name$1u;
    }
    get isRelationalNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math2, argNames) {
      var self2 = this;
      var compiled = this.params.map((p) => p._compile(math2, argNames));
      return function evalRelationalNode(scope, args, context) {
        var evalLhs;
        var evalRhs = compiled[0](scope, args, context);
        for (var i2 = 0; i2 < self2.conditionals.length; i2++) {
          evalLhs = evalRhs;
          evalRhs = compiled[i2 + 1](scope, args, context);
          var condFn = getSafeProperty(math2, self2.conditionals[i2]);
          if (!condFn(evalLhs, evalRhs)) {
            return false;
          }
        }
        return true;
      };
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      this.params.forEach((n, i2) => callback(n, "params[" + i2 + "]", this), this);
    }
    /**
     * Create a new RelationalNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {RelationalNode} Returns a transformed copy of the node
     */
    map(callback) {
      return new RelationalNode2(this.conditionals.slice(), this.params.map((n, i2) => this._ifNode(callback(n, "params[" + i2 + "]", this)), this));
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {RelationalNode}
     */
    clone() {
      return new RelationalNode2(this.conditionals, this.params);
    }
    /**
     * Get string representation.
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index2) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "(" + p.toString(options) + ")" : p.toString(options);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += " " + operatorMap[this.conditionals[i2]];
        ret += " " + paramStrings[i2 + 1];
      }
      return ret;
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1u,
        conditionals: this.conditionals,
        params: this.params
      };
    }
    /**
     * Instantiate a RelationalNode from its JSON representation
     * @param {Object} json
     *     An object structured like
     *     `{"mathjs": "RelationalNode", "conditionals": ..., "params": ...}`,
     *     where mathjs is optional
     * @returns {RelationalNode}
     */
    static fromJSON(json) {
      return new RelationalNode2(json.conditionals, json.params);
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index2) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? '<span class="math-parenthesis math-round-parenthesis">(</span>' + p.toHTML(options) + '<span class="math-parenthesis math-round-parenthesis">)</span>' : p.toHTML(options);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += '<span class="math-operator math-binary-operator math-explicit-binary-operator">' + escape(operatorMap[this.conditionals[i2]]) + "</span>" + paramStrings[i2 + 1];
      }
      return ret;
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var parenthesis = options && options.parenthesis ? options.parenthesis : "keep";
      var precedence = getPrecedence(this, parenthesis, options && options.implicit);
      var paramStrings = this.params.map(function(p, index2) {
        var paramPrecedence = getPrecedence(p, parenthesis, options && options.implicit);
        return parenthesis === "all" || paramPrecedence !== null && paramPrecedence <= precedence ? "\\left(" + p.toTex(options) + "\right)" : p.toTex(options);
      });
      var ret = paramStrings[0];
      for (var i2 = 0; i2 < this.conditionals.length; i2++) {
        ret += latexOperators[this.conditionals[i2]] + paramStrings[i2 + 1];
      }
      return ret;
    }
  }
  _defineProperty(RelationalNode2, "name", name$1u);
  return RelationalNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1t = "SymbolNode";
var dependencies$1t = ["math", "?Unit", "Node"];
var createSymbolNode = /* @__PURE__ */ factory(name$1t, dependencies$1t, (_ref) => {
  var {
    math: math2,
    Unit: Unit2,
    Node: Node2
  } = _ref;
  function isValuelessUnit(name2) {
    return Unit2 ? Unit2.isValuelessUnit(name2) : false;
  }
  class SymbolNode2 extends Node2 {
    /**
     * @constructor SymbolNode
     * @extends {Node}
     * A symbol node can hold and resolve a symbol
     * @param {string} name
     * @extends {Node}
     */
    constructor(name2) {
      super();
      if (typeof name2 !== "string") {
        throw new TypeError('String expected for parameter "name"');
      }
      this.name = name2;
    }
    get type() {
      return "SymbolNode";
    }
    get isSymbolNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math3, argNames) {
      var name2 = this.name;
      if (argNames[name2] === true) {
        return function(scope, args, context) {
          return getSafeProperty(args, name2);
        };
      } else if (name2 in math3) {
        return function(scope, args, context) {
          return scope.has(name2) ? scope.get(name2) : getSafeProperty(math3, name2);
        };
      } else {
        var isUnit2 = isValuelessUnit(name2);
        return function(scope, args, context) {
          return scope.has(name2) ? scope.get(name2) : isUnit2 ? new Unit2(null, name2) : SymbolNode2.onUndefinedSymbol(name2);
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
    }
    /**
     * Create a new SymbolNode with children produced by the given callback.
     * Trivial since a SymbolNode has no children
     * @param {function(child: Node, path: string, parent: Node) : Node} callback
     * @returns {SymbolNode} Returns a clone of the node
     */
    map(callback) {
      return this.clone();
    }
    /**
     * Throws an error 'Undefined symbol {name}'
     * @param {string} name
     */
    static onUndefinedSymbol(name2) {
      throw new Error("Undefined symbol " + name2);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {SymbolNode}
     */
    clone() {
      return new SymbolNode2(this.name);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toString(options) {
      return this.name;
    }
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toHTML(options) {
      var name2 = escape(this.name);
      if (name2 === "true" || name2 === "false") {
        return '<span class="math-symbol math-boolean">' + name2 + "</span>";
      } else if (name2 === "i") {
        return '<span class="math-symbol math-imaginary-symbol">' + name2 + "</span>";
      } else if (name2 === "Infinity") {
        return '<span class="math-symbol math-infinity-symbol">' + name2 + "</span>";
      } else if (name2 === "NaN") {
        return '<span class="math-symbol math-nan-symbol">' + name2 + "</span>";
      } else if (name2 === "null") {
        return '<span class="math-symbol math-null-symbol">' + name2 + "</span>";
      } else if (name2 === "undefined") {
        return '<span class="math-symbol math-undefined-symbol">' + name2 + "</span>";
      }
      return '<span class="math-symbol">' + name2 + "</span>";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: "SymbolNode",
        name: this.name
      };
    }
    /**
     * Instantiate a SymbolNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "SymbolNode", name: "x"}`,
     *                       where mathjs is optional
     * @returns {SymbolNode}
     */
    static fromJSON(json) {
      return new SymbolNode2(json.name);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     * @override
     */
    _toTex(options) {
      var isUnit2 = false;
      if (typeof math2[this.name] === "undefined" && isValuelessUnit(this.name)) {
        isUnit2 = true;
      }
      var symbol = toSymbol(this.name, isUnit2);
      if (symbol[0] === "\\") {
        return symbol;
      }
      return " " + symbol;
    }
  }
  return SymbolNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1s = "FunctionNode";
var dependencies$1s = ["math", "Node", "SymbolNode"];
var createFunctionNode = /* @__PURE__ */ factory(name$1s, dependencies$1s, (_ref) => {
  var _FunctionNode;
  var {
    math: math2,
    Node: Node2,
    SymbolNode: SymbolNode2
  } = _ref;
  var strin = (entity) => format$1(entity, {
    truncate: 78
  });
  function expandTemplate(template, node, options) {
    var latex = "";
    var regex = /\$(?:\{([a-z_][a-z_0-9]*)(?:\[([0-9]+)\])?\}|\$)/gi;
    var inputPos = 0;
    var match;
    while ((match = regex.exec(template)) !== null) {
      latex += template.substring(inputPos, match.index);
      inputPos = match.index;
      if (match[0] === "$$") {
        latex += "$";
        inputPos++;
      } else {
        inputPos += match[0].length;
        var property = node[match[1]];
        if (!property) {
          throw new ReferenceError("Template: Property " + match[1] + " does not exist.");
        }
        if (match[2] === void 0) {
          switch (typeof property) {
            case "string":
              latex += property;
              break;
            case "object":
              if (isNode(property)) {
                latex += property.toTex(options);
              } else if (Array.isArray(property)) {
                latex += property.map(function(arg2, index2) {
                  if (isNode(arg2)) {
                    return arg2.toTex(options);
                  }
                  throw new TypeError("Template: " + match[1] + "[" + index2 + "] is not a Node.");
                }).join(",");
              } else {
                throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
              }
              break;
            default:
              throw new TypeError("Template: " + match[1] + " has to be a Node, String or array of Nodes");
          }
        } else {
          if (isNode(property[match[2]] && property[match[2]])) {
            latex += property[match[2]].toTex(options);
          } else {
            throw new TypeError("Template: " + match[1] + "[" + match[2] + "] is not a Node.");
          }
        }
      }
    }
    latex += template.slice(inputPos);
    return latex;
  }
  class FunctionNode2 extends Node2 {
    /**
     * @constructor FunctionNode
     * @extends {./Node}
     * invoke a list with arguments on a node
     * @param {./Node | string} fn
     *     Item resolving to a function on which to invoke
     *     the arguments, typically a SymboNode or AccessorNode
     * @param {./Node[]} args
     */
    constructor(fn, args) {
      super();
      if (typeof fn === "string") {
        fn = new SymbolNode2(fn);
      }
      if (!isNode(fn))
        throw new TypeError('Node expected as parameter "fn"');
      if (!Array.isArray(args) || !args.every(isNode)) {
        throw new TypeError('Array containing Nodes expected for parameter "args"');
      }
      this.fn = fn;
      this.args = args || [];
    }
    // readonly property name
    get name() {
      return this.fn.name || "";
    }
    get type() {
      return name$1s;
    }
    get isFunctionNode() {
      return true;
    }
    /**
     * Compile a node into a JavaScript function.
     * This basically pre-calculates as much as possible and only leaves open
     * calculations which depend on a dynamic scope with variables.
     * @param {Object} math     Math.js namespace with functions and constants.
     * @param {Object} argNames An object with argument names as key and `true`
     *                          as value. Used in the SymbolNode to optimize
     *                          for arguments from user assigned functions
     *                          (see FunctionAssignmentNode) or special symbols
     *                          like `end` (see IndexNode).
     * @return {function} Returns a function which can be called like:
     *                        evalNode(scope: Object, args: Object, context: *)
     */
    _compile(math3, argNames) {
      var evalArgs = this.args.map((arg2) => arg2._compile(math3, argNames));
      if (isSymbolNode(this.fn)) {
        var _name = this.fn.name;
        if (!argNames[_name]) {
          var fn = _name in math3 ? getSafeProperty(math3, _name) : void 0;
          var isRaw = typeof fn === "function" && fn.rawArgs === true;
          var resolveFn = (scope) => {
            var value;
            if (scope.has(_name)) {
              value = scope.get(_name);
            } else if (_name in math3) {
              value = getSafeProperty(math3, _name);
            } else {
              return FunctionNode2.onUndefinedFunction(_name);
            }
            if (typeof value === "function") {
              return value;
            }
            throw new TypeError("'".concat(_name, "' is not a function; its value is:\n  ").concat(strin(value)));
          };
          if (isRaw) {
            var rawArgs = this.args;
            return function evalFunctionNode(scope, args, context) {
              var fn2 = resolveFn(scope);
              return fn2(rawArgs, math3, createSubScope(scope, args));
            };
          } else {
            switch (evalArgs.length) {
              case 0:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  return fn2();
                };
              case 1:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  return fn2(evalArg0(scope, args, context));
                };
              case 2:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var evalArg0 = evalArgs[0];
                  var evalArg1 = evalArgs[1];
                  return fn2(evalArg0(scope, args, context), evalArg1(scope, args, context));
                };
              default:
                return function evalFunctionNode(scope, args, context) {
                  var fn2 = resolveFn(scope);
                  var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
                  return fn2(...values);
                };
            }
          }
        } else {
          var _rawArgs = this.args;
          return function evalFunctionNode(scope, args, context) {
            var fn2 = getSafeProperty(args, _name);
            if (typeof fn2 !== "function") {
              throw new TypeError("Argument '".concat(_name, "' was not a function; received: ").concat(strin(fn2)));
            }
            if (fn2.rawArgs) {
              return fn2(_rawArgs, math3, createSubScope(scope, args));
            } else {
              var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
              return fn2.apply(fn2, values);
            }
          };
        }
      } else if (isAccessorNode(this.fn) && isIndexNode(this.fn.index) && this.fn.index.isObjectProperty()) {
        var evalObject = this.fn.object._compile(math3, argNames);
        var prop = this.fn.index.getObjectProperty();
        var _rawArgs2 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var object = evalObject(scope, args, context);
          var fn2 = getSafeMethod(object, prop);
          if (fn2 !== null && fn2 !== void 0 && fn2.rawArgs) {
            return fn2(_rawArgs2, math3, createSubScope(scope, args));
          } else {
            var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(object, values);
          }
        };
      } else {
        var fnExpr = this.fn.toString();
        var evalFn = this.fn._compile(math3, argNames);
        var _rawArgs3 = this.args;
        return function evalFunctionNode(scope, args, context) {
          var fn2 = evalFn(scope, args, context);
          if (typeof fn2 !== "function") {
            throw new TypeError("Expression '".concat(fnExpr, "' did not evaluate to a function; value is:") + "\n  ".concat(strin(fn2)));
          }
          if (fn2.rawArgs) {
            return fn2(_rawArgs3, math3, createSubScope(scope, args));
          } else {
            var values = evalArgs.map((evalArg) => evalArg(scope, args, context));
            return fn2.apply(fn2, values);
          }
        };
      }
    }
    /**
     * Execute a callback for each of the child nodes of this node
     * @param {function(child: Node, path: string, parent: Node)} callback
     */
    forEach(callback) {
      callback(this.fn, "fn", this);
      for (var i2 = 0; i2 < this.args.length; i2++) {
        callback(this.args[i2], "args[" + i2 + "]", this);
      }
    }
    /**
     * Create a new FunctionNode whose children are the results of calling
     * the provided callback function for each child of the original node.
     * @param {function(child: Node, path: string, parent: Node): Node} callback
     * @returns {FunctionNode} Returns a transformed copy of the node
     */
    map(callback) {
      var fn = this._ifNode(callback(this.fn, "fn", this));
      var args = [];
      for (var i2 = 0; i2 < this.args.length; i2++) {
        args[i2] = this._ifNode(callback(this.args[i2], "args[" + i2 + "]", this));
      }
      return new FunctionNode2(fn, args);
    }
    /**
     * Create a clone of this node, a shallow copy
     * @return {FunctionNode}
     */
    clone() {
      return new FunctionNode2(this.fn, this.args.slice(0));
    }
    /**
     * Throws an error 'Undefined function {name}'
     * @param {string} name
     */
    /**
     * Get string representation. (wrapper function)
     * This overrides parts of Node's toString function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toString
     * function.
     *
     * @param {Object} options
     * @return {string} str
     * @override
     */
    toString(options) {
      var customString;
      var name2 = this.fn.toString(options);
      if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, name2)) {
        customString = options.handler[name2](this, options);
      }
      if (typeof customString !== "undefined") {
        return customString;
      }
      return super.toString(options);
    }
    /**
     * Get string representation
     * @param {Object} options
     * @return {string} str
     */
    _toString(options) {
      var args = this.args.map(function(arg2) {
        return arg2.toString(options);
      });
      var fn = isFunctionAssignmentNode(this.fn) ? "(" + this.fn.toString(options) + ")" : this.fn.toString(options);
      return fn + "(" + args.join(", ") + ")";
    }
    /**
     * Get a JSON representation of the node
     * @returns {Object}
     */
    toJSON() {
      return {
        mathjs: name$1s,
        fn: this.fn,
        args: this.args
      };
    }
    /**
     * Instantiate an AssignmentNode from its JSON representation
     * @param {Object} json  An object structured like
     *                       `{"mathjs": "FunctionNode", fn: ..., args: ...}`,
     *                       where mathjs is optional
     * @returns {FunctionNode}
     */
    /**
     * Get HTML representation
     * @param {Object} options
     * @return {string} str
     */
    _toHTML(options) {
      var args = this.args.map(function(arg2) {
        return arg2.toHTML(options);
      });
      return '<span class="math-function">' + escape(this.fn) + '</span><span class="math-paranthesis math-round-parenthesis">(</span>' + args.join('<span class="math-separator">,</span>') + '<span class="math-paranthesis math-round-parenthesis">)</span>';
    }
    /**
     * Get LaTeX representation. (wrapper function)
     * This overrides parts of Node's toTex function.
     * If callback is an object containing callbacks, it
     * calls the correct callback for the current node,
     * otherwise it falls back to calling Node's toTex
     * function.
     *
     * @param {Object} options
     * @return {string}
     */
    toTex(options) {
      var customTex;
      if (options && typeof options.handler === "object" && hasOwnProperty(options.handler, this.name)) {
        customTex = options.handler[this.name](this, options);
      }
      if (typeof customTex !== "undefined") {
        return customTex;
      }
      return super.toTex(options);
    }
    /**
     * Get LaTeX representation
     * @param {Object} options
     * @return {string} str
     */
    _toTex(options) {
      var args = this.args.map(function(arg2) {
        return arg2.toTex(options);
      });
      var latexConverter;
      if (latexFunctions[this.name]) {
        latexConverter = latexFunctions[this.name];
      }
      if (math2[this.name] && (typeof math2[this.name].toTex === "function" || typeof math2[this.name].toTex === "object" || typeof math2[this.name].toTex === "string")) {
        latexConverter = math2[this.name].toTex;
      }
      var customToTex;
      switch (typeof latexConverter) {
        case "function":
          customToTex = latexConverter(this, options);
          break;
        case "string":
          customToTex = expandTemplate(latexConverter, this, options);
          break;
        case "object":
          switch (typeof latexConverter[args.length]) {
            case "function":
              customToTex = latexConverter[args.length](this, options);
              break;
            case "string":
              customToTex = expandTemplate(latexConverter[args.length], this, options);
              break;
          }
      }
      if (typeof customToTex !== "undefined") {
        return customToTex;
      }
      return expandTemplate(defaultTemplate, this, options);
    }
    /**
     * Get identifier.
     * @return {string}
     */
    getIdentifier() {
      return this.type + ":" + this.name;
    }
  }
  _FunctionNode = FunctionNode2;
  _defineProperty(FunctionNode2, "name", name$1s);
  _defineProperty(FunctionNode2, "onUndefinedFunction", function(name2) {
    throw new Error("Undefined function " + name2);
  });
  _defineProperty(FunctionNode2, "fromJSON", function(json) {
    return new _FunctionNode(json.fn, json.args);
  });
  return FunctionNode2;
}, {
  isClass: true,
  isNode: true
});
var name$1r = "parse";
var dependencies$1r = ["typed", "numeric", "config", "AccessorNode", "ArrayNode", "AssignmentNode", "BlockNode", "ConditionalNode", "ConstantNode", "FunctionAssignmentNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "RangeNode", "RelationalNode", "SymbolNode"];
var createParse = /* @__PURE__ */ factory(name$1r, dependencies$1r, (_ref) => {
  var {
    typed: typed2,
    numeric: numeric3,
    config: config3,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    AssignmentNode: AssignmentNode2,
    BlockNode: BlockNode2,
    ConditionalNode: ConditionalNode2,
    ConstantNode: ConstantNode2,
    FunctionAssignmentNode: FunctionAssignmentNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    RangeNode: RangeNode2,
    RelationalNode: RelationalNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var parse2 = typed2(name$1r, {
    string: function string2(expression) {
      return parseStart(expression, {});
    },
    "Array | Matrix": function ArrayMatrix(expressions) {
      return parseMultiple(expressions, {});
    },
    "string, Object": function stringObject(expression, options) {
      var extraNodes = options.nodes !== void 0 ? options.nodes : {};
      return parseStart(expression, extraNodes);
    },
    "Array | Matrix, Object": parseMultiple
  });
  function parseMultiple(expressions) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var extraNodes = options.nodes !== void 0 ? options.nodes : {};
    return deepMap(expressions, function(elem) {
      if (typeof elem !== "string")
        throw new TypeError("String expected");
      return parseStart(elem, extraNodes);
    });
  }
  var TOKENTYPE = {
    NULL: 0,
    DELIMITER: 1,
    NUMBER: 2,
    SYMBOL: 3,
    UNKNOWN: 4
  };
  var DELIMITERS = {
    ",": true,
    "(": true,
    ")": true,
    "[": true,
    "]": true,
    "{": true,
    "}": true,
    '"': true,
    "'": true,
    ";": true,
    "+": true,
    "-": true,
    "*": true,
    ".*": true,
    "/": true,
    "./": true,
    "%": true,
    "^": true,
    ".^": true,
    "~": true,
    "!": true,
    "&": true,
    "|": true,
    "^|": true,
    "=": true,
    ":": true,
    "?": true,
    "==": true,
    "!=": true,
    "<": true,
    ">": true,
    "<=": true,
    ">=": true,
    "<<": true,
    ">>": true,
    ">>>": true
  };
  var NAMED_DELIMITERS = {
    mod: true,
    to: true,
    in: true,
    and: true,
    xor: true,
    or: true,
    not: true
  };
  var CONSTANTS = {
    true: true,
    false: false,
    null: null,
    undefined: void 0
  };
  var NUMERIC_CONSTANTS = ["NaN", "Infinity"];
  var ESCAPE_CHARACTERS = {
    '"': '"',
    "'": "'",
    "\\": "\\",
    "/": "/",
    b: "\b",
    f: "\f",
    n: "\n",
    r: "\r",
    t: "	"
    // note that \u is handled separately in parseStringToken()
  };
  function initialState() {
    return {
      extraNodes: {},
      // current extra nodes, must be careful not to mutate
      expression: "",
      // current expression
      comment: "",
      // last parsed comment
      index: 0,
      // current index in expr
      token: "",
      // current token
      tokenType: TOKENTYPE.NULL,
      // type of the token
      nestingLevel: 0,
      // level of nesting inside parameters, used to ignore newline characters
      conditionalLevel: null
      // when a conditional is being parsed, the level of the conditional is stored here
    };
  }
  function currentString(state, length) {
    return state.expression.substr(state.index, length);
  }
  function currentCharacter(state) {
    return currentString(state, 1);
  }
  function next(state) {
    state.index++;
  }
  function prevCharacter(state) {
    return state.expression.charAt(state.index - 1);
  }
  function nextCharacter(state) {
    return state.expression.charAt(state.index + 1);
  }
  function getToken(state) {
    state.tokenType = TOKENTYPE.NULL;
    state.token = "";
    state.comment = "";
    while (true) {
      if (currentCharacter(state) === "#") {
        while (currentCharacter(state) !== "\n" && currentCharacter(state) !== "") {
          state.comment += currentCharacter(state);
          next(state);
        }
      }
      if (parse2.isWhitespace(currentCharacter(state), state.nestingLevel)) {
        next(state);
      } else {
        break;
      }
    }
    if (currentCharacter(state) === "") {
      state.tokenType = TOKENTYPE.DELIMITER;
      return;
    }
    if (currentCharacter(state) === "\n" && !state.nestingLevel) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = currentCharacter(state);
      next(state);
      return;
    }
    var c1 = currentCharacter(state);
    var c2 = currentString(state, 2);
    var c3 = currentString(state, 3);
    if (c3.length === 3 && DELIMITERS[c3]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c3;
      next(state);
      next(state);
      next(state);
      return;
    }
    if (c2.length === 2 && DELIMITERS[c2]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c2;
      next(state);
      next(state);
      return;
    }
    if (DELIMITERS[c1]) {
      state.tokenType = TOKENTYPE.DELIMITER;
      state.token = c1;
      next(state);
      return;
    }
    if (parse2.isDigitDot(c1)) {
      state.tokenType = TOKENTYPE.NUMBER;
      var _c = currentString(state, 2);
      if (_c === "0b" || _c === "0o" || _c === "0x") {
        state.token += currentCharacter(state);
        next(state);
        state.token += currentCharacter(state);
        next(state);
        while (parse2.isHexDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (currentCharacter(state) === ".") {
          state.token += ".";
          next(state);
          while (parse2.isHexDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        } else if (currentCharacter(state) === "i") {
          state.token += "i";
          next(state);
          while (parse2.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
        }
        return;
      }
      if (currentCharacter(state) === ".") {
        state.token += currentCharacter(state);
        next(state);
        if (!parse2.isDigit(currentCharacter(state))) {
          state.tokenType = TOKENTYPE.DELIMITER;
          return;
        }
      } else {
        while (parse2.isDigit(currentCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
        if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
          state.token += currentCharacter(state);
          next(state);
        }
      }
      while (parse2.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (currentCharacter(state) === "E" || currentCharacter(state) === "e") {
        if (parse2.isDigit(nextCharacter(state)) || nextCharacter(state) === "-" || nextCharacter(state) === "+") {
          state.token += currentCharacter(state);
          next(state);
          if (currentCharacter(state) === "+" || currentCharacter(state) === "-") {
            state.token += currentCharacter(state);
            next(state);
          }
          if (!parse2.isDigit(currentCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
          while (parse2.isDigit(currentCharacter(state))) {
            state.token += currentCharacter(state);
            next(state);
          }
          if (parse2.isDecimalMark(currentCharacter(state), nextCharacter(state))) {
            throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
          }
        } else if (nextCharacter(state) === ".") {
          next(state);
          throw createSyntaxError(state, 'Digit expected, got "' + currentCharacter(state) + '"');
        }
      }
      return;
    }
    if (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state))) {
      while (parse2.isAlpha(currentCharacter(state), prevCharacter(state), nextCharacter(state)) || parse2.isDigit(currentCharacter(state))) {
        state.token += currentCharacter(state);
        next(state);
      }
      if (hasOwnProperty(NAMED_DELIMITERS, state.token)) {
        state.tokenType = TOKENTYPE.DELIMITER;
      } else {
        state.tokenType = TOKENTYPE.SYMBOL;
      }
      return;
    }
    state.tokenType = TOKENTYPE.UNKNOWN;
    while (currentCharacter(state) !== "") {
      state.token += currentCharacter(state);
      next(state);
    }
    throw createSyntaxError(state, 'Syntax error in part "' + state.token + '"');
  }
  function getTokenSkipNewline(state) {
    do {
      getToken(state);
    } while (state.token === "\n");
  }
  function openParams(state) {
    state.nestingLevel++;
  }
  function closeParams(state) {
    state.nestingLevel--;
  }
  parse2.isAlpha = function isAlpha(c, cPrev, cNext) {
    return parse2.isValidLatinOrGreek(c) || parse2.isValidMathSymbol(c, cNext) || parse2.isValidMathSymbol(cPrev, c);
  };
  parse2.isValidLatinOrGreek = function isValidLatinOrGreek(c) {
    return /^[a-zA-Z_$\u00C0-\u02AF\u0370-\u03FF\u2100-\u214F]$/.test(c);
  };
  parse2.isValidMathSymbol = function isValidMathSymbol(high, low) {
    return /^[\uD835]$/.test(high) && /^[\uDC00-\uDFFF]$/.test(low) && /^[^\uDC55\uDC9D\uDCA0\uDCA1\uDCA3\uDCA4\uDCA7\uDCA8\uDCAD\uDCBA\uDCBC\uDCC4\uDD06\uDD0B\uDD0C\uDD15\uDD1D\uDD3A\uDD3F\uDD45\uDD47-\uDD49\uDD51\uDEA6\uDEA7\uDFCC\uDFCD]$/.test(low);
  };
  parse2.isWhitespace = function isWhitespace(c, nestingLevel) {
    return c === " " || c === "	" || c === "\n" && nestingLevel > 0;
  };
  parse2.isDecimalMark = function isDecimalMark(c, cNext) {
    return c === "." && cNext !== "/" && cNext !== "*" && cNext !== "^";
  };
  parse2.isDigitDot = function isDigitDot(c) {
    return c >= "0" && c <= "9" || c === ".";
  };
  parse2.isDigit = function isDigit(c) {
    return c >= "0" && c <= "9";
  };
  parse2.isHexDigit = function isHexDigit(c) {
    return c >= "0" && c <= "9" || c >= "a" && c <= "f" || c >= "A" && c <= "F";
  };
  function parseStart(expression, extraNodes) {
    var state = initialState();
    _extends$1(state, {
      expression,
      extraNodes
    });
    getToken(state);
    var node = parseBlock(state);
    if (state.token !== "") {
      if (state.tokenType === TOKENTYPE.DELIMITER) {
        throw createError(state, "Unexpected operator " + state.token);
      } else {
        throw createSyntaxError(state, 'Unexpected part "' + state.token + '"');
      }
    }
    return node;
  }
  function parseBlock(state) {
    var node;
    var blocks = [];
    var visible;
    if (state.token !== "" && state.token !== "\n" && state.token !== ";") {
      node = parseAssignment(state);
      if (state.comment) {
        node.comment = state.comment;
      }
    }
    while (state.token === "\n" || state.token === ";") {
      if (blocks.length === 0 && node) {
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
      getToken(state);
      if (state.token !== "\n" && state.token !== ";" && state.token !== "") {
        node = parseAssignment(state);
        if (state.comment) {
          node.comment = state.comment;
        }
        visible = state.token !== ";";
        blocks.push({
          node,
          visible
        });
      }
    }
    if (blocks.length > 0) {
      return new BlockNode2(blocks);
    } else {
      if (!node) {
        node = new ConstantNode2(void 0);
        if (state.comment) {
          node.comment = state.comment;
        }
      }
      return node;
    }
  }
  function parseAssignment(state) {
    var name2, args, value, valid;
    var node = parseConditional(state);
    if (state.token === "=") {
      if (isSymbolNode(node)) {
        name2 = node.name;
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode2(new SymbolNode2(name2), value);
      } else if (isAccessorNode(node)) {
        getTokenSkipNewline(state);
        value = parseAssignment(state);
        return new AssignmentNode2(node.object, node.index, value);
      } else if (isFunctionNode(node) && isSymbolNode(node.fn)) {
        valid = true;
        args = [];
        name2 = node.name;
        node.args.forEach(function(arg2, index2) {
          if (isSymbolNode(arg2)) {
            args[index2] = arg2.name;
          } else {
            valid = false;
          }
        });
        if (valid) {
          getTokenSkipNewline(state);
          value = parseAssignment(state);
          return new FunctionAssignmentNode2(name2, args, value);
        }
      }
      throw createSyntaxError(state, "Invalid left hand side of assignment operator =");
    }
    return node;
  }
  function parseConditional(state) {
    var node = parseLogicalOr(state);
    while (state.token === "?") {
      var prev = state.conditionalLevel;
      state.conditionalLevel = state.nestingLevel;
      getTokenSkipNewline(state);
      var condition = node;
      var trueExpr = parseAssignment(state);
      if (state.token !== ":")
        throw createSyntaxError(state, "False part of conditional expression expected");
      state.conditionalLevel = null;
      getTokenSkipNewline(state);
      var falseExpr = parseAssignment(state);
      node = new ConditionalNode2(condition, trueExpr, falseExpr);
      state.conditionalLevel = prev;
    }
    return node;
  }
  function parseLogicalOr(state) {
    var node = parseLogicalXor(state);
    while (state.token === "or") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("or", "or", [node, parseLogicalXor(state)]);
    }
    return node;
  }
  function parseLogicalXor(state) {
    var node = parseLogicalAnd(state);
    while (state.token === "xor") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("xor", "xor", [node, parseLogicalAnd(state)]);
    }
    return node;
  }
  function parseLogicalAnd(state) {
    var node = parseBitwiseOr(state);
    while (state.token === "and") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("and", "and", [node, parseBitwiseOr(state)]);
    }
    return node;
  }
  function parseBitwiseOr(state) {
    var node = parseBitwiseXor(state);
    while (state.token === "|") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("|", "bitOr", [node, parseBitwiseXor(state)]);
    }
    return node;
  }
  function parseBitwiseXor(state) {
    var node = parseBitwiseAnd(state);
    while (state.token === "^|") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("^|", "bitXor", [node, parseBitwiseAnd(state)]);
    }
    return node;
  }
  function parseBitwiseAnd(state) {
    var node = parseRelational(state);
    while (state.token === "&") {
      getTokenSkipNewline(state);
      node = new OperatorNode2("&", "bitAnd", [node, parseRelational(state)]);
    }
    return node;
  }
  function parseRelational(state) {
    var params = [parseShift(state)];
    var conditionals = [];
    var operators = {
      "==": "equal",
      "!=": "unequal",
      "<": "smaller",
      ">": "larger",
      "<=": "smallerEq",
      ">=": "largerEq"
    };
    while (hasOwnProperty(operators, state.token)) {
      var cond = {
        name: state.token,
        fn: operators[state.token]
      };
      conditionals.push(cond);
      getTokenSkipNewline(state);
      params.push(parseShift(state));
    }
    if (params.length === 1) {
      return params[0];
    } else if (params.length === 2) {
      return new OperatorNode2(conditionals[0].name, conditionals[0].fn, params);
    } else {
      return new RelationalNode2(conditionals.map((c) => c.fn), params);
    }
  }
  function parseShift(state) {
    var node, name2, fn, params;
    node = parseConversion(state);
    var operators = {
      "<<": "leftShift",
      ">>": "rightArithShift",
      ">>>": "rightLogShift"
    };
    while (hasOwnProperty(operators, state.token)) {
      name2 = state.token;
      fn = operators[name2];
      getTokenSkipNewline(state);
      params = [node, parseConversion(state)];
      node = new OperatorNode2(name2, fn, params);
    }
    return node;
  }
  function parseConversion(state) {
    var node, name2, fn, params;
    node = parseRange(state);
    var operators = {
      to: "to",
      in: "to"
      // alias of 'to'
    };
    while (hasOwnProperty(operators, state.token)) {
      name2 = state.token;
      fn = operators[name2];
      getTokenSkipNewline(state);
      if (name2 === "in" && state.token === "") {
        node = new OperatorNode2("*", "multiply", [node, new SymbolNode2("in")], true);
      } else {
        params = [node, parseRange(state)];
        node = new OperatorNode2(name2, fn, params);
      }
    }
    return node;
  }
  function parseRange(state) {
    var node;
    var params = [];
    if (state.token === ":") {
      node = new ConstantNode2(1);
    } else {
      node = parseAddSubtract(state);
    }
    if (state.token === ":" && state.conditionalLevel !== state.nestingLevel) {
      params.push(node);
      while (state.token === ":" && params.length < 3) {
        getTokenSkipNewline(state);
        if (state.token === ")" || state.token === "]" || state.token === "," || state.token === "") {
          params.push(new SymbolNode2("end"));
        } else {
          params.push(parseAddSubtract(state));
        }
      }
      if (params.length === 3) {
        node = new RangeNode2(params[0], params[2], params[1]);
      } else {
        node = new RangeNode2(params[0], params[1]);
      }
    }
    return node;
  }
  function parseAddSubtract(state) {
    var node, name2, fn, params;
    node = parseMultiplyDivide(state);
    var operators = {
      "+": "add",
      "-": "subtract"
    };
    while (hasOwnProperty(operators, state.token)) {
      name2 = state.token;
      fn = operators[name2];
      getTokenSkipNewline(state);
      var rightNode = parseMultiplyDivide(state);
      if (rightNode.isPercentage) {
        params = [node, new OperatorNode2("*", "multiply", [node, rightNode])];
      } else {
        params = [node, rightNode];
      }
      node = new OperatorNode2(name2, fn, params);
    }
    return node;
  }
  function parseMultiplyDivide(state) {
    var node, last, name2, fn;
    node = parseImplicitMultiplication(state);
    last = node;
    var operators = {
      "*": "multiply",
      ".*": "dotMultiply",
      "/": "divide",
      "./": "dotDivide"
    };
    while (true) {
      if (hasOwnProperty(operators, state.token)) {
        name2 = state.token;
        fn = operators[name2];
        getTokenSkipNewline(state);
        last = parseImplicitMultiplication(state);
        node = new OperatorNode2(name2, fn, [node, last]);
      } else {
        break;
      }
    }
    return node;
  }
  function parseImplicitMultiplication(state) {
    var node, last;
    node = parseRule2(state);
    last = node;
    while (true) {
      if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "in" && isConstantNode(node) || state.tokenType === TOKENTYPE.NUMBER && !isConstantNode(last) && (!isOperatorNode(last) || last.op === "!") || state.token === "(") {
        last = parseRule2(state);
        node = new OperatorNode2(
          "*",
          "multiply",
          [node, last],
          true
          /* implicit */
        );
      } else {
        break;
      }
    }
    return node;
  }
  function parseRule2(state) {
    var node = parsePercentage(state);
    var last = node;
    var tokenStates = [];
    while (true) {
      if (state.token === "/" && rule2Node(last)) {
        tokenStates.push(_extends$1({}, state));
        getTokenSkipNewline(state);
        if (state.tokenType === TOKENTYPE.NUMBER) {
          tokenStates.push(_extends$1({}, state));
          getTokenSkipNewline(state);
          if (state.tokenType === TOKENTYPE.SYMBOL || state.token === "(") {
            _extends$1(state, tokenStates.pop());
            tokenStates.pop();
            last = parsePercentage(state);
            node = new OperatorNode2("/", "divide", [node, last]);
          } else {
            tokenStates.pop();
            _extends$1(state, tokenStates.pop());
            break;
          }
        } else {
          _extends$1(state, tokenStates.pop());
          break;
        }
      } else {
        break;
      }
    }
    return node;
  }
  function parsePercentage(state) {
    var node, name2, fn, params;
    node = parseUnary(state);
    var operators = {
      "%": "mod",
      mod: "mod"
    };
    while (hasOwnProperty(operators, state.token)) {
      name2 = state.token;
      fn = operators[name2];
      getTokenSkipNewline(state);
      if (name2 === "%" && state.tokenType === TOKENTYPE.DELIMITER && state.token !== "(") {
        node = new OperatorNode2("/", "divide", [node, new ConstantNode2(100)], false, true);
      } else {
        params = [node, parseUnary(state)];
        node = new OperatorNode2(name2, fn, params);
      }
    }
    return node;
  }
  function parseUnary(state) {
    var name2, params, fn;
    var operators = {
      "-": "unaryMinus",
      "+": "unaryPlus",
      "~": "bitNot",
      not: "not"
    };
    if (hasOwnProperty(operators, state.token)) {
      fn = operators[state.token];
      name2 = state.token;
      getTokenSkipNewline(state);
      params = [parseUnary(state)];
      return new OperatorNode2(name2, fn, params);
    }
    return parsePow(state);
  }
  function parsePow(state) {
    var node, name2, fn, params;
    node = parseLeftHandOperators(state);
    if (state.token === "^" || state.token === ".^") {
      name2 = state.token;
      fn = name2 === "^" ? "pow" : "dotPow";
      getTokenSkipNewline(state);
      params = [node, parseUnary(state)];
      node = new OperatorNode2(name2, fn, params);
    }
    return node;
  }
  function parseLeftHandOperators(state) {
    var node, name2, fn, params;
    node = parseCustomNodes(state);
    var operators = {
      "!": "factorial",
      "'": "ctranspose"
    };
    while (hasOwnProperty(operators, state.token)) {
      name2 = state.token;
      fn = operators[name2];
      getToken(state);
      params = [node];
      node = new OperatorNode2(name2, fn, params);
      node = parseAccessors(state, node);
    }
    return node;
  }
  function parseCustomNodes(state) {
    var params = [];
    if (state.tokenType === TOKENTYPE.SYMBOL && hasOwnProperty(state.extraNodes, state.token)) {
      var CustomNode = state.extraNodes[state.token];
      getToken(state);
      if (state.token === "(") {
        params = [];
        openParams(state);
        getToken(state);
        if (state.token !== ")") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== ")") {
          throw createSyntaxError(state, "Parenthesis ) expected");
        }
        closeParams(state);
        getToken(state);
      }
      return new CustomNode(params);
    }
    return parseSymbol(state);
  }
  function parseSymbol(state) {
    var node, name2;
    if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
      name2 = state.token;
      getToken(state);
      if (hasOwnProperty(CONSTANTS, name2)) {
        node = new ConstantNode2(CONSTANTS[name2]);
      } else if (NUMERIC_CONSTANTS.indexOf(name2) !== -1) {
        node = new ConstantNode2(numeric3(name2, "number"));
      } else {
        node = new SymbolNode2(name2);
      }
      node = parseAccessors(state, node);
      return node;
    }
    return parseString(state);
  }
  function parseAccessors(state, node, types) {
    var params;
    while ((state.token === "(" || state.token === "[" || state.token === ".") && (!types || types.indexOf(state.token) !== -1)) {
      params = [];
      if (state.token === "(") {
        if (isSymbolNode(node) || isAccessorNode(node)) {
          openParams(state);
          getToken(state);
          if (state.token !== ")") {
            params.push(parseAssignment(state));
            while (state.token === ",") {
              getToken(state);
              params.push(parseAssignment(state));
            }
          }
          if (state.token !== ")") {
            throw createSyntaxError(state, "Parenthesis ) expected");
          }
          closeParams(state);
          getToken(state);
          node = new FunctionNode2(node, params);
        } else {
          return node;
        }
      } else if (state.token === "[") {
        openParams(state);
        getToken(state);
        if (state.token !== "]") {
          params.push(parseAssignment(state));
          while (state.token === ",") {
            getToken(state);
            params.push(parseAssignment(state));
          }
        }
        if (state.token !== "]") {
          throw createSyntaxError(state, "Parenthesis ] expected");
        }
        closeParams(state);
        getToken(state);
        node = new AccessorNode2(node, new IndexNode2(params));
      } else {
        getToken(state);
        var isPropertyName = state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS;
        if (!isPropertyName) {
          throw createSyntaxError(state, "Property name expected after dot");
        }
        params.push(new ConstantNode2(state.token));
        getToken(state);
        var dotNotation = true;
        node = new AccessorNode2(node, new IndexNode2(params, dotNotation));
      }
    }
    return node;
  }
  function parseString(state) {
    var node, str;
    if (state.token === '"' || state.token === "'") {
      str = parseStringToken(state, state.token);
      node = new ConstantNode2(str);
      node = parseAccessors(state, node);
      return node;
    }
    return parseMatrix(state);
  }
  function parseStringToken(state, quote) {
    var str = "";
    while (currentCharacter(state) !== "" && currentCharacter(state) !== quote) {
      if (currentCharacter(state) === "\\") {
        next(state);
        var char = currentCharacter(state);
        var escapeChar = ESCAPE_CHARACTERS[char];
        if (escapeChar !== void 0) {
          str += escapeChar;
          state.index += 1;
        } else if (char === "u") {
          var unicode = state.expression.slice(state.index + 1, state.index + 5);
          if (/^[0-9A-Fa-f]{4}$/.test(unicode)) {
            str += String.fromCharCode(parseInt(unicode, 16));
            state.index += 5;
          } else {
            throw createSyntaxError(state, "Invalid unicode character \\u".concat(unicode));
          }
        } else {
          throw createSyntaxError(state, "Bad escape character \\".concat(char));
        }
      } else {
        str += currentCharacter(state);
        next(state);
      }
    }
    getToken(state);
    if (state.token !== quote) {
      throw createSyntaxError(state, "End of string ".concat(quote, " expected"));
    }
    getToken(state);
    return str;
  }
  function parseMatrix(state) {
    var array, params, rows, cols;
    if (state.token === "[") {
      openParams(state);
      getToken(state);
      if (state.token !== "]") {
        var row2 = parseRow(state);
        if (state.token === ";") {
          rows = 1;
          params = [row2];
          while (state.token === ";") {
            getToken(state);
            if (state.token !== "]") {
              params[rows] = parseRow(state);
              rows++;
            }
          }
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          cols = params[0].items.length;
          for (var r = 1; r < rows; r++) {
            if (params[r].items.length !== cols) {
              throw createError(state, "Column dimensions mismatch (" + params[r].items.length + " !== " + cols + ")");
            }
          }
          array = new ArrayNode2(params);
        } else {
          if (state.token !== "]") {
            throw createSyntaxError(state, "End of matrix ] expected");
          }
          closeParams(state);
          getToken(state);
          array = row2;
        }
      } else {
        closeParams(state);
        getToken(state);
        array = new ArrayNode2([]);
      }
      return parseAccessors(state, array);
    }
    return parseObject(state);
  }
  function parseRow(state) {
    var params = [parseAssignment(state)];
    var len = 1;
    while (state.token === ",") {
      getToken(state);
      if (state.token !== "]" && state.token !== ";") {
        params[len] = parseAssignment(state);
        len++;
      }
    }
    return new ArrayNode2(params);
  }
  function parseObject(state) {
    if (state.token === "{") {
      openParams(state);
      var key;
      var properties2 = {};
      do {
        getToken(state);
        if (state.token !== "}") {
          if (state.token === '"' || state.token === "'") {
            key = parseStringToken(state, state.token);
          } else if (state.tokenType === TOKENTYPE.SYMBOL || state.tokenType === TOKENTYPE.DELIMITER && state.token in NAMED_DELIMITERS) {
            key = state.token;
            getToken(state);
          } else {
            throw createSyntaxError(state, "Symbol or string expected as object key");
          }
          if (state.token !== ":") {
            throw createSyntaxError(state, "Colon : expected after object key");
          }
          getToken(state);
          properties2[key] = parseAssignment(state);
        }
      } while (state.token === ",");
      if (state.token !== "}") {
        throw createSyntaxError(state, "Comma , or bracket } expected after object value");
      }
      closeParams(state);
      getToken(state);
      var node = new ObjectNode2(properties2);
      node = parseAccessors(state, node);
      return node;
    }
    return parseNumber(state);
  }
  function parseNumber(state) {
    var numberStr;
    if (state.tokenType === TOKENTYPE.NUMBER) {
      numberStr = state.token;
      getToken(state);
      return new ConstantNode2(numeric3(numberStr, config3.number));
    }
    return parseParentheses(state);
  }
  function parseParentheses(state) {
    var node;
    if (state.token === "(") {
      openParams(state);
      getToken(state);
      node = parseAssignment(state);
      if (state.token !== ")") {
        throw createSyntaxError(state, "Parenthesis ) expected");
      }
      closeParams(state);
      getToken(state);
      node = new ParenthesisNode2(node);
      node = parseAccessors(state, node);
      return node;
    }
    return parseEnd(state);
  }
  function parseEnd(state) {
    if (state.token === "") {
      throw createSyntaxError(state, "Unexpected end of expression");
    } else {
      throw createSyntaxError(state, "Value expected");
    }
  }
  function col(state) {
    return state.index - state.token.length + 1;
  }
  function createSyntaxError(state, message) {
    var c = col(state);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  function createError(state, message) {
    var c = col(state);
    var error = new SyntaxError(message + " (char " + c + ")");
    error.char = c;
    return error;
  }
  typed2.addConversion({
    from: "string",
    to: "Node",
    convert: parse2
  });
  return parse2;
});
var name$1q = "compile";
var dependencies$1q = ["typed", "parse"];
var createCompile = /* @__PURE__ */ factory(name$1q, dependencies$1q, (_ref) => {
  var {
    typed: typed2,
    parse: parse2
  } = _ref;
  return typed2(name$1q, {
    string: function string2(expr) {
      return parse2(expr).compile();
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      return deepMap(expr, function(entry) {
        return parse2(entry).compile();
      });
    }
  });
});
var name$1p = "evaluate";
var dependencies$1p = ["typed", "parse"];
var createEvaluate = /* @__PURE__ */ factory(name$1p, dependencies$1p, (_ref) => {
  var {
    typed: typed2,
    parse: parse2
  } = _ref;
  return typed2(name$1p, {
    string: function string2(expr) {
      var scope = createEmptyMap();
      return parse2(expr).compile().evaluate(scope);
    },
    "string, Map | Object": function stringMapObject(expr, scope) {
      return parse2(expr).compile().evaluate(scope);
    },
    "Array | Matrix": function ArrayMatrix(expr) {
      var scope = createEmptyMap();
      return deepMap(expr, function(entry) {
        return parse2(entry).compile().evaluate(scope);
      });
    },
    "Array | Matrix, Map | Object": function ArrayMatrixMapObject(expr, scope) {
      return deepMap(expr, function(entry) {
        return parse2(entry).compile().evaluate(scope);
      });
    }
  });
});
var name$1o = "Parser";
var dependencies$1o = ["evaluate"];
var createParserClass = /* @__PURE__ */ factory(name$1o, dependencies$1o, (_ref) => {
  var {
    evaluate: evaluate2
  } = _ref;
  function Parser2() {
    if (!(this instanceof Parser2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    Object.defineProperty(this, "scope", {
      value: createEmptyMap(),
      writable: false
    });
  }
  Parser2.prototype.type = "Parser";
  Parser2.prototype.isParser = true;
  Parser2.prototype.evaluate = function(expr) {
    return evaluate2(expr, this.scope);
  };
  Parser2.prototype.get = function(name2) {
    if (this.scope.has(name2)) {
      return this.scope.get(name2);
    }
  };
  Parser2.prototype.getAll = function() {
    return toObject(this.scope);
  };
  Parser2.prototype.getAllAsMap = function() {
    return this.scope;
  };
  Parser2.prototype.set = function(name2, value) {
    this.scope.set(name2, value);
    return value;
  };
  Parser2.prototype.remove = function(name2) {
    this.scope.delete(name2);
  };
  Parser2.prototype.clear = function() {
    this.scope.clear();
  };
  return Parser2;
}, {
  isClass: true
});
var name$1n = "parser";
var dependencies$1n = ["typed", "Parser"];
var createParser = /* @__PURE__ */ factory(name$1n, dependencies$1n, (_ref) => {
  var {
    typed: typed2,
    Parser: Parser2
  } = _ref;
  return typed2(name$1n, {
    "": function _() {
      return new Parser2();
    }
  });
});
var name$1m = "lup";
var dependencies$1m = ["typed", "matrix", "abs", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "larger", "equalScalar", "unaryMinus", "DenseMatrix", "SparseMatrix", "Spa"];
var createLup = /* @__PURE__ */ factory(name$1m, dependencies$1m, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    abs: abs2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    larger: larger2,
    equalScalar: equalScalar2,
    unaryMinus: unaryMinus2,
    DenseMatrix: DenseMatrix2,
    SparseMatrix: SparseMatrix2,
    Spa: Spa2
  } = _ref;
  return typed2(name$1m, {
    DenseMatrix: function DenseMatrix3(m) {
      return _denseLUP(m);
    },
    SparseMatrix: function SparseMatrix3(m) {
      return _sparseLUP(m);
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseLUP(m);
      return {
        L: r.L.valueOf(),
        U: r.U.valueOf(),
        p: r.p
      };
    }
  });
  function _denseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var data = clone$3(m._data);
    var ldata = [];
    var lsize = [rows, n];
    var udata = [];
    var usize = [n, columns];
    var i2, j, k;
    var p = [];
    for (i2 = 0; i2 < rows; i2++) {
      p[i2] = i2;
    }
    for (j = 0; j < columns; j++) {
      if (j > 0) {
        for (i2 = 0; i2 < rows; i2++) {
          var min2 = Math.min(i2, j);
          var s = 0;
          for (k = 0; k < min2; k++) {
            s = addScalar2(s, multiplyScalar2(data[i2][k], data[k][j]));
          }
          data[i2][j] = subtractScalar2(data[i2][j], s);
        }
      }
      var pi2 = j;
      var pabsv = 0;
      var vjj = 0;
      for (i2 = j; i2 < rows; i2++) {
        var v = data[i2][j];
        var absv = abs2(v);
        if (larger2(absv, pabsv)) {
          pi2 = i2;
          pabsv = absv;
          vjj = v;
        }
      }
      if (j !== pi2) {
        p[j] = [p[pi2], p[pi2] = p[j]][0];
        DenseMatrix2._swapRows(j, pi2, data);
      }
      if (j < rows) {
        for (i2 = j + 1; i2 < rows; i2++) {
          var vij = data[i2][j];
          if (!equalScalar2(vij, 0)) {
            data[i2][j] = divideScalar2(data[i2][j], vjj);
          }
        }
      }
    }
    for (j = 0; j < columns; j++) {
      for (i2 = 0; i2 < rows; i2++) {
        if (j === 0) {
          if (i2 < columns) {
            udata[i2] = [];
          }
          ldata[i2] = [];
        }
        if (i2 < j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 0;
          }
          continue;
        }
        if (i2 === j) {
          if (i2 < columns) {
            udata[i2][j] = data[i2][j];
          }
          if (j < rows) {
            ldata[i2][j] = 1;
          }
          continue;
        }
        if (i2 < columns) {
          udata[i2][j] = 0;
        }
        if (j < rows) {
          ldata[i2][j] = data[i2][j];
        }
      }
    }
    var l = new DenseMatrix2({
      data: ldata,
      size: lsize
    });
    var u = new DenseMatrix2({
      data: udata,
      size: usize
    });
    var pv = [];
    for (i2 = 0, n = p.length; i2 < n; i2++) {
      pv[p[i2]] = i2;
    }
    return {
      L: l,
      U: u,
      p: pv,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
  function _sparseLUP(m) {
    var rows = m._size[0];
    var columns = m._size[1];
    var n = Math.min(rows, columns);
    var values = m._values;
    var index2 = m._index;
    var ptr = m._ptr;
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var lsize = [rows, n];
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var usize = [n, columns];
    var i2, j, k;
    var pvCo = [];
    var pvOc = [];
    for (i2 = 0; i2 < rows; i2++) {
      pvCo[i2] = i2;
      pvOc[i2] = i2;
    }
    var swapIndeces = function swapIndeces2(x, y) {
      var kx = pvOc[x];
      var ky = pvOc[y];
      pvCo[kx] = y;
      pvCo[ky] = x;
      pvOc[x] = ky;
      pvOc[y] = kx;
    };
    var _loop = function _loop2() {
      var spa = new Spa2();
      if (j < rows) {
        lptr.push(lvalues.length);
        lvalues.push(1);
        lindex.push(j);
      }
      uptr.push(uvalues.length);
      var k0 = ptr[j];
      var k1 = ptr[j + 1];
      for (k = k0; k < k1; k++) {
        i2 = index2[k];
        spa.set(pvCo[i2], values[k]);
      }
      if (j > 0) {
        spa.forEach(0, j - 1, function(k2, vkj) {
          SparseMatrix2._forEachRow(k2, lvalues, lindex, lptr, function(i3, vik) {
            if (i3 > k2) {
              spa.accumulate(i3, unaryMinus2(multiplyScalar2(vik, vkj)));
            }
          });
        });
      }
      var pi2 = j;
      var vjj = spa.get(j);
      var pabsv = abs2(vjj);
      spa.forEach(j + 1, rows - 1, function(x, v) {
        var absv = abs2(v);
        if (larger2(absv, pabsv)) {
          pi2 = x;
          pabsv = absv;
          vjj = v;
        }
      });
      if (j !== pi2) {
        SparseMatrix2._swapRows(j, pi2, lsize[1], lvalues, lindex, lptr);
        SparseMatrix2._swapRows(j, pi2, usize[1], uvalues, uindex, uptr);
        spa.swap(j, pi2);
        swapIndeces(j, pi2);
      }
      spa.forEach(0, rows - 1, function(x, v) {
        if (x <= j) {
          uvalues.push(v);
          uindex.push(x);
        } else {
          v = divideScalar2(v, vjj);
          if (!equalScalar2(v, 0)) {
            lvalues.push(v);
            lindex.push(x);
          }
        }
      });
    };
    for (j = 0; j < columns; j++) {
      _loop();
    }
    uptr.push(uvalues.length);
    lptr.push(lvalues.length);
    return {
      L: new SparseMatrix2({
        values: lvalues,
        index: lindex,
        ptr: lptr,
        size: lsize
      }),
      U: new SparseMatrix2({
        values: uvalues,
        index: uindex,
        ptr: uptr,
        size: usize
      }),
      p: pvCo,
      toString: function toString() {
        return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\nP: " + this.p;
      }
    };
  }
});
var name$1l = "qr";
var dependencies$1l = ["typed", "matrix", "zeros", "identity", "isZero", "equal", "sign", "sqrt", "conj", "unaryMinus", "addScalar", "divideScalar", "multiplyScalar", "subtractScalar", "complex"];
var createQr = /* @__PURE__ */ factory(name$1l, dependencies$1l, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    identity: identity2,
    isZero: isZero2,
    equal: equal2,
    sign: sign2,
    sqrt: sqrt2,
    conj: conj2,
    unaryMinus: unaryMinus2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    subtractScalar: subtractScalar2,
    complex: complex2
  } = _ref;
  return _extends$1(typed2(name$1l, {
    DenseMatrix: function DenseMatrix2(m) {
      return _denseQR(m);
    },
    SparseMatrix: function SparseMatrix2(m) {
      return _sparseQR();
    },
    Array: function Array2(a) {
      var m = matrix2(a);
      var r = _denseQR(m);
      return {
        Q: r.Q.valueOf(),
        R: r.R.valueOf()
      };
    }
  }), {
    _denseQRimpl
  });
  function _denseQRimpl(m) {
    var rows = m._size[0];
    var cols = m._size[1];
    var Q2 = identity2([rows], "dense");
    var Qdata = Q2._data;
    var R = m.clone();
    var Rdata = R._data;
    var i2, j, k;
    var w = zeros2([rows], "");
    for (k = 0; k < Math.min(cols, rows); ++k) {
      var pivot = Rdata[k][k];
      var sgn = unaryMinus2(equal2(pivot, 0) ? 1 : sign2(pivot));
      var conjSgn = conj2(sgn);
      var alphaSquared = 0;
      for (i2 = k; i2 < rows; i2++) {
        alphaSquared = addScalar2(alphaSquared, multiplyScalar2(Rdata[i2][k], conj2(Rdata[i2][k])));
      }
      var alpha = multiplyScalar2(sgn, sqrt2(alphaSquared));
      if (!isZero2(alpha)) {
        var u1 = subtractScalar2(pivot, alpha);
        w[k] = 1;
        for (i2 = k + 1; i2 < rows; i2++) {
          w[i2] = divideScalar2(Rdata[i2][k], u1);
        }
        var tau2 = unaryMinus2(conj2(divideScalar2(u1, alpha)));
        var s = void 0;
        for (j = k; j < cols; j++) {
          s = 0;
          for (i2 = k; i2 < rows; i2++) {
            s = addScalar2(s, multiplyScalar2(conj2(w[i2]), Rdata[i2][j]));
          }
          s = multiplyScalar2(s, tau2);
          for (i2 = k; i2 < rows; i2++) {
            Rdata[i2][j] = multiplyScalar2(subtractScalar2(Rdata[i2][j], multiplyScalar2(w[i2], s)), conjSgn);
          }
        }
        for (i2 = 0; i2 < rows; i2++) {
          s = 0;
          for (j = k; j < rows; j++) {
            s = addScalar2(s, multiplyScalar2(Qdata[i2][j], w[j]));
          }
          s = multiplyScalar2(s, tau2);
          for (j = k; j < rows; ++j) {
            Qdata[i2][j] = divideScalar2(subtractScalar2(Qdata[i2][j], multiplyScalar2(s, conj2(w[j]))), conjSgn);
          }
        }
      }
    }
    return {
      Q: Q2,
      R,
      toString: function toString() {
        return "Q: " + this.Q.toString() + "\nR: " + this.R.toString();
      }
    };
  }
  function _denseQR(m) {
    var ret = _denseQRimpl(m);
    var Rdata = ret.R._data;
    if (m._data.length > 0) {
      var zero = Rdata[0][0].type === "Complex" ? complex2(0) : 0;
      for (var i2 = 0; i2 < Rdata.length; ++i2) {
        for (var j = 0; j < i2 && j < (Rdata[0] || []).length; ++j) {
          Rdata[i2][j] = zero;
        }
      }
    }
    return ret;
  }
  function _sparseQR(m) {
    throw new Error("qr not implemented for sparse matrices yet");
  }
});
function csPermute(a, pinv2, q, values) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var adt = a._datatype;
  var m = asize[0];
  var n = asize[1];
  var cvalues = values && a._values ? [] : null;
  var cindex = [];
  var cptr = [];
  var nz = 0;
  for (var k = 0; k < n; k++) {
    cptr[k] = nz;
    var j = q ? q[k] : k;
    for (var t0 = aptr[j], t1 = aptr[j + 1], t = t0; t < t1; t++) {
      var r = pinv2 ? pinv2[aindex[t]] : aindex[t];
      cindex[nz] = r;
      if (cvalues) {
        cvalues[nz] = avalues[t];
      }
      nz++;
    }
  }
  cptr[n] = nz;
  return a.createSparseMatrix({
    values: cvalues,
    index: cindex,
    ptr: cptr,
    size: [m, n],
    datatype: adt
  });
}
function csTdfs(j, k, w, head, next, post, stack) {
  var top = 0;
  w[stack] = j;
  while (top >= 0) {
    var p = w[stack + top];
    var i2 = w[head + p];
    if (i2 === -1) {
      top--;
      post[k++] = p;
    } else {
      w[head + p] = w[next + i2];
      ++top;
      w[stack + top] = i2;
    }
  }
  return k;
}
function csPost(parent, n) {
  if (!parent) {
    return null;
  }
  var k = 0;
  var j;
  var post = [];
  var w = [];
  var head = 0;
  var next = n;
  var stack = 2 * n;
  for (j = 0; j < n; j++) {
    w[head + j] = -1;
  }
  for (j = n - 1; j >= 0; j--) {
    if (parent[j] === -1) {
      continue;
    }
    w[next + j] = w[head + parent[j]];
    w[head + parent[j]] = j;
  }
  for (j = 0; j < n; j++) {
    if (parent[j] !== -1) {
      continue;
    }
    k = csTdfs(j, k, w, head, next, post, stack);
  }
  return post;
}
function csEtree(a, ata) {
  if (!a) {
    return null;
  }
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var m = asize[0];
  var n = asize[1];
  var parent = [];
  var w = [];
  var ancestor = 0;
  var prev = n;
  var i2, inext;
  if (ata) {
    for (i2 = 0; i2 < m; i2++) {
      w[prev + i2] = -1;
    }
  }
  for (var k = 0; k < n; k++) {
    parent[k] = -1;
    w[ancestor + k] = -1;
    for (var p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
      var r = aindex[p];
      i2 = ata ? w[prev + r] : r;
      for (; i2 !== -1 && i2 < k; i2 = inext) {
        inext = w[ancestor + i2];
        w[ancestor + i2] = k;
        if (inext === -1) {
          parent[i2] = k;
        }
      }
      if (ata) {
        w[prev + r] = k;
      }
    }
  }
  return parent;
}
function csFkeep(a, callback, other) {
  var avalues = a._values;
  var aindex = a._index;
  var aptr = a._ptr;
  var asize = a._size;
  var n = asize[1];
  var nz = 0;
  for (var j = 0; j < n; j++) {
    var p = aptr[j];
    aptr[j] = nz;
    for (; p < aptr[j + 1]; p++) {
      if (callback(aindex[p], j, avalues ? avalues[p] : 1, other)) {
        aindex[nz] = aindex[p];
        if (avalues) {
          avalues[nz] = avalues[p];
        }
        nz++;
      }
    }
  }
  aptr[n] = nz;
  aindex.splice(nz, aindex.length - nz);
  if (avalues) {
    avalues.splice(nz, avalues.length - nz);
  }
  return nz;
}
function csFlip(i2) {
  return -i2 - 2;
}
var name$1k = "csAmd";
var dependencies$1k = ["add", "multiply", "transpose"];
var createCsAmd = /* @__PURE__ */ factory(name$1k, dependencies$1k, (_ref) => {
  var {
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return function csAmd(order, a) {
    if (!a || order <= 0 || order > 3) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var lemax = 0;
    var dense = Math.max(16, 10 * Math.sqrt(n));
    dense = Math.min(n - 2, dense);
    var cm = _createTargetMatrix(order, a, m, n, dense);
    csFkeep(cm, _diag, null);
    var cindex = cm._index;
    var cptr = cm._ptr;
    var cnz = cptr[n];
    var P2 = [];
    var W = [];
    var len = 0;
    var nv = n + 1;
    var next = 2 * (n + 1);
    var head = 3 * (n + 1);
    var elen = 4 * (n + 1);
    var degree = 5 * (n + 1);
    var w = 6 * (n + 1);
    var hhead = 7 * (n + 1);
    var last = P2;
    var mark = _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree);
    var nel = _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next);
    var mindeg = 0;
    var i2, j, k, k1, k2, e2, pj, ln2, nvi, pk, eln, p1, p2, pn, h, d;
    while (nel < n) {
      for (k = -1; mindeg < n && (k = W[head + mindeg]) === -1; mindeg++)
        ;
      if (W[next + k] !== -1) {
        last[W[next + k]] = -1;
      }
      W[head + mindeg] = W[next + k];
      var elenk = W[elen + k];
      var nvk = W[nv + k];
      nel += nvk;
      var dk = 0;
      W[nv + k] = -nvk;
      var p = cptr[k];
      var pk1 = elenk === 0 ? p : cnz;
      var pk2 = pk1;
      for (k1 = 1; k1 <= elenk + 1; k1++) {
        if (k1 > elenk) {
          e2 = k;
          pj = p;
          ln2 = W[len + k] - elenk;
        } else {
          e2 = cindex[p++];
          pj = cptr[e2];
          ln2 = W[len + e2];
        }
        for (k2 = 1; k2 <= ln2; k2++) {
          i2 = cindex[pj++];
          if ((nvi = W[nv + i2]) <= 0) {
            continue;
          }
          dk += nvi;
          W[nv + i2] = -nvi;
          cindex[pk2++] = i2;
          if (W[next + i2] !== -1) {
            last[W[next + i2]] = last[i2];
          }
          if (last[i2] !== -1) {
            W[next + last[i2]] = W[next + i2];
          } else {
            W[head + W[degree + i2]] = W[next + i2];
          }
        }
        if (e2 !== k) {
          cptr[e2] = csFlip(k);
          W[w + e2] = 0;
        }
      }
      if (elenk !== 0) {
        cnz = pk2;
      }
      W[degree + k] = dk;
      cptr[k] = pk1;
      W[len + k] = pk2 - pk1;
      W[elen + k] = -2;
      mark = _wclear(mark, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((eln = W[elen + i2]) <= 0) {
          continue;
        }
        nvi = -W[nv + i2];
        var wnvi = mark - nvi;
        for (p = cptr[i2], p1 = cptr[i2] + eln - 1; p <= p1; p++) {
          e2 = cindex[p];
          if (W[w + e2] >= mark) {
            W[w + e2] -= nvi;
          } else if (W[w + e2] !== 0) {
            W[w + e2] = W[degree + e2] + wnvi;
          }
        }
      }
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        p1 = cptr[i2];
        p2 = p1 + W[elen + i2] - 1;
        pn = p1;
        for (h = 0, d = 0, p = p1; p <= p2; p++) {
          e2 = cindex[p];
          if (W[w + e2] !== 0) {
            var dext = W[w + e2] - mark;
            if (dext > 0) {
              d += dext;
              cindex[pn++] = e2;
              h += e2;
            } else {
              cptr[e2] = csFlip(k);
              W[w + e2] = 0;
            }
          }
        }
        W[elen + i2] = pn - p1 + 1;
        var p3 = pn;
        var p4 = p1 + W[len + i2];
        for (p = p2 + 1; p < p4; p++) {
          j = cindex[p];
          var nvj = W[nv + j];
          if (nvj <= 0) {
            continue;
          }
          d += nvj;
          cindex[pn++] = j;
          h += j;
        }
        if (d === 0) {
          cptr[i2] = csFlip(k);
          nvi = -W[nv + i2];
          dk -= nvi;
          nvk += nvi;
          nel += nvi;
          W[nv + i2] = 0;
          W[elen + i2] = -1;
        } else {
          W[degree + i2] = Math.min(W[degree + i2], d);
          cindex[pn] = cindex[p3];
          cindex[p3] = cindex[p1];
          cindex[p1] = k;
          W[len + i2] = pn - p1 + 1;
          h = (h < 0 ? -h : h) % n;
          W[next + i2] = W[hhead + h];
          W[hhead + h] = i2;
          last[i2] = h;
        }
      }
      W[degree + k] = dk;
      lemax = Math.max(lemax, dk);
      mark = _wclear(mark + lemax, lemax, W, w, n);
      for (pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if (W[nv + i2] >= 0) {
          continue;
        }
        h = last[i2];
        i2 = W[hhead + h];
        W[hhead + h] = -1;
        for (; i2 !== -1 && W[next + i2] !== -1; i2 = W[next + i2], mark++) {
          ln2 = W[len + i2];
          eln = W[elen + i2];
          for (p = cptr[i2] + 1; p <= cptr[i2] + ln2 - 1; p++) {
            W[w + cindex[p]] = mark;
          }
          var jlast = i2;
          for (j = W[next + i2]; j !== -1; ) {
            var ok2 = W[len + j] === ln2 && W[elen + j] === eln;
            for (p = cptr[j] + 1; ok2 && p <= cptr[j] + ln2 - 1; p++) {
              if (W[w + cindex[p]] !== mark) {
                ok2 = 0;
              }
            }
            if (ok2) {
              cptr[j] = csFlip(i2);
              W[nv + i2] += W[nv + j];
              W[nv + j] = 0;
              W[elen + j] = -1;
              j = W[next + j];
              W[next + jlast] = j;
            } else {
              jlast = j;
              j = W[next + j];
            }
          }
        }
      }
      for (p = pk1, pk = pk1; pk < pk2; pk++) {
        i2 = cindex[pk];
        if ((nvi = -W[nv + i2]) <= 0) {
          continue;
        }
        W[nv + i2] = nvi;
        d = W[degree + i2] + dk - nvi;
        d = Math.min(d, n - nel - nvi);
        if (W[head + d] !== -1) {
          last[W[head + d]] = i2;
        }
        W[next + i2] = W[head + d];
        last[i2] = -1;
        W[head + d] = i2;
        mindeg = Math.min(mindeg, d);
        W[degree + i2] = d;
        cindex[p++] = i2;
      }
      W[nv + k] = nvk;
      if ((W[len + k] = p - pk1) === 0) {
        cptr[k] = -1;
        W[w + k] = 0;
      }
      if (elenk !== 0) {
        cnz = p;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      cptr[i2] = csFlip(cptr[i2]);
    }
    for (j = 0; j <= n; j++) {
      W[head + j] = -1;
    }
    for (j = n; j >= 0; j--) {
      if (W[nv + j] > 0) {
        continue;
      }
      W[next + j] = W[head + cptr[j]];
      W[head + cptr[j]] = j;
    }
    for (e2 = n; e2 >= 0; e2--) {
      if (W[nv + e2] <= 0) {
        continue;
      }
      if (cptr[e2] !== -1) {
        W[next + e2] = W[head + cptr[e2]];
        W[head + cptr[e2]] = e2;
      }
    }
    for (k = 0, i2 = 0; i2 <= n; i2++) {
      if (cptr[i2] === -1) {
        k = csTdfs(i2, k, W, head, next, P2, w);
      }
    }
    P2.splice(P2.length - 1, 1);
    return P2;
  };
  function _createTargetMatrix(order, a, m, n, dense) {
    var at = transpose2(a);
    if (order === 1 && n === m) {
      return add2(a, at);
    }
    if (order === 2) {
      var tindex = at._index;
      var tptr = at._ptr;
      var p2 = 0;
      for (var j = 0; j < m; j++) {
        var p = tptr[j];
        tptr[j] = p2;
        if (tptr[j + 1] - p > dense) {
          continue;
        }
        for (var p1 = tptr[j + 1]; p < p1; p++) {
          tindex[p2++] = tindex[p];
        }
      }
      tptr[m] = p2;
      a = transpose2(at);
      return multiply2(at, a);
    }
    return multiply2(at, a);
  }
  function _initializeQuotientGraph(n, cptr, W, len, head, last, next, hhead, nv, w, elen, degree) {
    for (var k = 0; k < n; k++) {
      W[len + k] = cptr[k + 1] - cptr[k];
    }
    W[len + n] = 0;
    for (var i2 = 0; i2 <= n; i2++) {
      W[head + i2] = -1;
      last[i2] = -1;
      W[next + i2] = -1;
      W[hhead + i2] = -1;
      W[nv + i2] = 1;
      W[w + i2] = 1;
      W[elen + i2] = 0;
      W[degree + i2] = W[len + i2];
    }
    var mark = _wclear(0, 0, W, w, n);
    W[elen + n] = -2;
    cptr[n] = -1;
    W[w + n] = 0;
    return mark;
  }
  function _initializeDegreeLists(n, cptr, W, degree, elen, w, dense, nv, head, last, next) {
    var nel = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var d = W[degree + i2];
      if (d === 0) {
        W[elen + i2] = -2;
        nel++;
        cptr[i2] = -1;
        W[w + i2] = 0;
      } else if (d > dense) {
        W[nv + i2] = 0;
        W[elen + i2] = -1;
        nel++;
        cptr[i2] = csFlip(n);
        W[nv + n]++;
      } else {
        var h = W[head + d];
        if (h !== -1) {
          last[h] = i2;
        }
        W[next + i2] = W[head + d];
        W[head + d] = i2;
      }
    }
    return nel;
  }
  function _wclear(mark, lemax, W, w, n) {
    if (mark < 2 || mark + lemax < 0) {
      for (var k = 0; k < n; k++) {
        if (W[w + k] !== 0) {
          W[w + k] = 1;
        }
      }
      mark = 2;
    }
    return mark;
  }
  function _diag(i2, j) {
    return i2 !== j;
  }
});
function csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor) {
  var s, sparent;
  var jleaf = 0;
  var q;
  if (i2 <= j || w[first + j] <= w[maxfirst + i2]) {
    return -1;
  }
  w[maxfirst + i2] = w[first + j];
  var jprev = w[prevleaf + i2];
  w[prevleaf + i2] = j;
  if (jprev === -1) {
    jleaf = 1;
    q = i2;
  } else {
    jleaf = 2;
    for (q = jprev; q !== w[ancestor + q]; q = w[ancestor + q])
      ;
    for (s = jprev; s !== q; s = sparent) {
      sparent = w[ancestor + s];
      w[ancestor + s] = q;
    }
  }
  return {
    jleaf,
    q
  };
}
var name$1j = "csCounts";
var dependencies$1j = ["transpose"];
var createCsCounts = /* @__PURE__ */ factory(name$1j, dependencies$1j, (_ref) => {
  var {
    transpose: transpose2
  } = _ref;
  return function(a, parent, post, ata) {
    if (!a || !parent || !post) {
      return null;
    }
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    var i2, j, k, J, p, p0, p1;
    var s = 4 * n + (ata ? n + m + 1 : 0);
    var w = [];
    var ancestor = 0;
    var maxfirst = n;
    var prevleaf = 2 * n;
    var first = 3 * n;
    var head = 4 * n;
    var next = 5 * n + 1;
    for (k = 0; k < s; k++) {
      w[k] = -1;
    }
    var colcount = [];
    var at = transpose2(a);
    var tindex = at._index;
    var tptr = at._ptr;
    for (k = 0; k < n; k++) {
      j = post[k];
      colcount[j] = w[first + j] === -1 ? 1 : 0;
      for (; j !== -1 && w[first + j] === -1; j = parent[j]) {
        w[first + j] = k;
      }
    }
    if (ata) {
      for (k = 0; k < n; k++) {
        w[post[k]] = k;
      }
      for (i2 = 0; i2 < m; i2++) {
        for (k = n, p0 = tptr[i2], p1 = tptr[i2 + 1], p = p0; p < p1; p++) {
          k = Math.min(k, w[tindex[p]]);
        }
        w[next + i2] = w[head + k];
        w[head + k] = i2;
      }
    }
    for (i2 = 0; i2 < n; i2++) {
      w[ancestor + i2] = i2;
    }
    for (k = 0; k < n; k++) {
      j = post[k];
      if (parent[j] !== -1) {
        colcount[parent[j]]--;
      }
      for (J = ata ? w[head + k] : j; J !== -1; J = ata ? w[next + J] : -1) {
        for (p = tptr[J]; p < tptr[J + 1]; p++) {
          i2 = tindex[p];
          var r = csLeaf(i2, j, w, first, maxfirst, prevleaf, ancestor);
          if (r.jleaf >= 1) {
            colcount[j]++;
          }
          if (r.jleaf === 2) {
            colcount[r.q]--;
          }
        }
      }
      if (parent[j] !== -1) {
        w[ancestor + j] = parent[j];
      }
    }
    for (j = 0; j < n; j++) {
      if (parent[j] !== -1) {
        colcount[parent[j]] += colcount[j];
      }
    }
    return colcount;
  };
});
var name$1i = "csSqr";
var dependencies$1i = ["add", "multiply", "transpose"];
var createCsSqr = /* @__PURE__ */ factory(name$1i, dependencies$1i, (_ref) => {
  var {
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  var csAmd = createCsAmd({
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  });
  var csCounts = createCsCounts({
    transpose: transpose2
  });
  return function csSqr(order, a, qr2) {
    var aptr = a._ptr;
    var asize = a._size;
    var n = asize[1];
    var k;
    var s = {};
    s.q = csAmd(order, a);
    if (order && !s.q) {
      return null;
    }
    if (qr2) {
      var c = order ? csPermute(a, null, s.q, 0) : a;
      s.parent = csEtree(c, 1);
      var post = csPost(s.parent, n);
      s.cp = csCounts(c, s.parent, post, 1);
      if (c && s.parent && s.cp && _vcount(c, s)) {
        for (s.unz = 0, k = 0; k < n; k++) {
          s.unz += s.cp[k];
        }
      }
    } else {
      s.unz = 4 * aptr[n] + n;
      s.lnz = s.unz;
    }
    return s;
  };
  function _vcount(a, s) {
    var aptr = a._ptr;
    var aindex = a._index;
    var asize = a._size;
    var m = asize[0];
    var n = asize[1];
    s.pinv = [];
    s.leftmost = [];
    var parent = s.parent;
    var pinv2 = s.pinv;
    var leftmost = s.leftmost;
    var w = [];
    var next = 0;
    var head = m;
    var tail = m + n;
    var nque = m + 2 * n;
    var i2, k, p, p0, p1;
    for (k = 0; k < n; k++) {
      w[head + k] = -1;
      w[tail + k] = -1;
      w[nque + k] = 0;
    }
    for (i2 = 0; i2 < m; i2++) {
      leftmost[i2] = -1;
    }
    for (k = n - 1; k >= 0; k--) {
      for (p0 = aptr[k], p1 = aptr[k + 1], p = p0; p < p1; p++) {
        leftmost[aindex[p]] = k;
      }
    }
    for (i2 = m - 1; i2 >= 0; i2--) {
      pinv2[i2] = -1;
      k = leftmost[i2];
      if (k === -1) {
        continue;
      }
      if (w[nque + k]++ === 0) {
        w[tail + k] = i2;
      }
      w[next + i2] = w[head + k];
      w[head + k] = i2;
    }
    s.lnz = 0;
    s.m2 = m;
    for (k = 0; k < n; k++) {
      i2 = w[head + k];
      s.lnz++;
      if (i2 < 0) {
        i2 = s.m2++;
      }
      pinv2[i2] = k;
      if (--nque[k] <= 0) {
        continue;
      }
      s.lnz += w[nque + k];
      var pa = parent[k];
      if (pa !== -1) {
        if (w[nque + pa] === 0) {
          w[tail + pa] = w[tail + k];
        }
        w[next + w[tail + k]] = w[head + pa];
        w[head + pa] = w[next + i2];
        w[nque + pa] += w[nque + k];
      }
    }
    for (i2 = 0; i2 < m; i2++) {
      if (pinv2[i2] < 0) {
        pinv2[i2] = k++;
      }
    }
    return true;
  }
});
function csMarked(w, j) {
  return w[j] < 0;
}
function csMark(w, j) {
  w[j] = csFlip(w[j]);
}
function csUnflip(i2) {
  return i2 < 0 ? csFlip(i2) : i2;
}
function csDfs(j, g, top, xi, pinv2) {
  var index2 = g._index;
  var ptr = g._ptr;
  var size2 = g._size;
  var n = size2[1];
  var i2, p, p2;
  var head = 0;
  xi[0] = j;
  while (head >= 0) {
    j = xi[head];
    var jnew = pinv2 ? pinv2[j] : j;
    if (!csMarked(ptr, j)) {
      csMark(ptr, j);
      xi[n + head] = jnew < 0 ? 0 : csUnflip(ptr[jnew]);
    }
    var done = 1;
    for (p = xi[n + head], p2 = jnew < 0 ? 0 : csUnflip(ptr[jnew + 1]); p < p2; p++) {
      i2 = index2[p];
      if (csMarked(ptr, i2)) {
        continue;
      }
      xi[n + head] = p;
      xi[++head] = i2;
      done = 0;
      break;
    }
    if (done) {
      head--;
      xi[--top] = j;
    }
  }
  return top;
}
function csReach(g, b, k, xi, pinv2) {
  var gptr = g._ptr;
  var gsize = g._size;
  var bindex = b._index;
  var bptr = b._ptr;
  var n = gsize[1];
  var p, p0, p1;
  var top = n;
  for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
    var i2 = bindex[p];
    if (!csMarked(gptr, i2)) {
      top = csDfs(i2, g, top, xi, pinv2);
    }
  }
  for (p = top; p < n; p++) {
    csMark(gptr, xi[p]);
  }
  return top;
}
var name$1h = "csSpsolve";
var dependencies$1h = ["divideScalar", "multiply", "subtract"];
var createCsSpsolve = /* @__PURE__ */ factory(name$1h, dependencies$1h, (_ref) => {
  var {
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  } = _ref;
  return function csSpsolve(g, b, k, xi, x, pinv2, lo) {
    var gvalues = g._values;
    var gindex = g._index;
    var gptr = g._ptr;
    var gsize = g._size;
    var n = gsize[1];
    var bvalues = b._values;
    var bindex = b._index;
    var bptr = b._ptr;
    var p, p0, p1, q;
    var top = csReach(g, b, k, xi, pinv2);
    for (p = top; p < n; p++) {
      x[xi[p]] = 0;
    }
    for (p0 = bptr[k], p1 = bptr[k + 1], p = p0; p < p1; p++) {
      x[bindex[p]] = bvalues[p];
    }
    for (var px = top; px < n; px++) {
      var j = xi[px];
      var J = pinv2 ? pinv2[j] : j;
      if (J < 0) {
        continue;
      }
      p0 = gptr[J];
      p1 = gptr[J + 1];
      x[j] = divideScalar2(x[j], gvalues[lo ? p0 : p1 - 1]);
      p = lo ? p0 + 1 : p0;
      q = lo ? p1 : p1 - 1;
      for (; p < q; p++) {
        var i2 = gindex[p];
        x[i2] = subtract2(x[i2], multiply2(gvalues[p], x[j]));
      }
    }
    return top;
  };
});
var name$1g = "csLu";
var dependencies$1g = ["abs", "divideScalar", "multiply", "subtract", "larger", "largerEq", "SparseMatrix"];
var createCsLu = /* @__PURE__ */ factory(name$1g, dependencies$1g, (_ref) => {
  var {
    abs: abs2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSpsolve = createCsSpsolve({
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2
  });
  return function csLu(m, s, tol) {
    if (!m) {
      return null;
    }
    var size2 = m._size;
    var n = size2[1];
    var q;
    var lnz = 100;
    var unz = 100;
    if (s) {
      q = s.q;
      lnz = s.lnz || lnz;
      unz = s.unz || unz;
    }
    var lvalues = [];
    var lindex = [];
    var lptr = [];
    var L = new SparseMatrix2({
      values: lvalues,
      index: lindex,
      ptr: lptr,
      size: [n, n]
    });
    var uvalues = [];
    var uindex = [];
    var uptr = [];
    var U = new SparseMatrix2({
      values: uvalues,
      index: uindex,
      ptr: uptr,
      size: [n, n]
    });
    var pinv2 = [];
    var i2, p;
    var x = [];
    var xi = [];
    for (i2 = 0; i2 < n; i2++) {
      x[i2] = 0;
      pinv2[i2] = -1;
      lptr[i2 + 1] = 0;
    }
    lnz = 0;
    unz = 0;
    for (var k = 0; k < n; k++) {
      lptr[k] = lnz;
      uptr[k] = unz;
      var col = q ? q[k] : k;
      var top = csSpsolve(L, m, col, xi, x, pinv2, 1);
      var ipiv = -1;
      var a = -1;
      for (p = top; p < n; p++) {
        i2 = xi[p];
        if (pinv2[i2] < 0) {
          var xabs = abs2(x[i2]);
          if (larger2(xabs, a)) {
            a = xabs;
            ipiv = i2;
          }
        } else {
          uindex[unz] = pinv2[i2];
          uvalues[unz++] = x[i2];
        }
      }
      if (ipiv === -1 || a <= 0) {
        return null;
      }
      if (pinv2[col] < 0 && largerEq2(abs2(x[col]), multiply2(a, tol))) {
        ipiv = col;
      }
      var pivot = x[ipiv];
      uindex[unz] = k;
      uvalues[unz++] = pivot;
      pinv2[ipiv] = k;
      lindex[lnz] = ipiv;
      lvalues[lnz++] = 1;
      for (p = top; p < n; p++) {
        i2 = xi[p];
        if (pinv2[i2] < 0) {
          lindex[lnz] = i2;
          lvalues[lnz++] = divideScalar2(x[i2], pivot);
        }
        x[i2] = 0;
      }
    }
    lptr[n] = lnz;
    uptr[n] = unz;
    for (p = 0; p < lnz; p++) {
      lindex[p] = pinv2[lindex[p]];
    }
    lvalues.splice(lnz, lvalues.length - lnz);
    lindex.splice(lnz, lindex.length - lnz);
    uvalues.splice(unz, uvalues.length - unz);
    uindex.splice(unz, uindex.length - unz);
    return {
      L,
      U,
      pinv: pinv2
    };
  };
});
var name$1f = "slu";
var dependencies$1f = ["typed", "abs", "add", "multiply", "transpose", "divideScalar", "subtract", "larger", "largerEq", "SparseMatrix"];
var createSlu = /* @__PURE__ */ factory(name$1f, dependencies$1f, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply: multiply2,
    transpose: transpose2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  } = _ref;
  var csSqr = createCsSqr({
    add: add2,
    multiply: multiply2,
    transpose: transpose2
  });
  var csLu = createCsLu({
    abs: abs2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    subtract: subtract2,
    larger: larger2,
    largerEq: largerEq2,
    SparseMatrix: SparseMatrix2
  });
  return typed2(name$1f, {
    "SparseMatrix, number, number": function SparseMatrixNumberNumber(a, order, threshold) {
      if (!isInteger$1(order) || order < 0 || order > 3) {
        throw new Error("Symbolic Ordering and Analysis order must be an integer number in the interval [0, 3]");
      }
      if (threshold < 0 || threshold > 1) {
        throw new Error("Partial pivoting threshold must be a number from 0 to 1");
      }
      var s = csSqr(order, a, false);
      var f = csLu(a, s, threshold);
      return {
        L: f.L,
        U: f.U,
        p: f.pinv,
        q: s.q,
        toString: function toString() {
          return "L: " + this.L.toString() + "\nU: " + this.U.toString() + "\np: " + this.p.toString() + (this.q ? "\nq: " + this.q.toString() : "") + "\n";
        }
      };
    }
  });
});
function csIpvec(p, b) {
  var k;
  var n = b.length;
  var x = [];
  if (p) {
    for (k = 0; k < n; k++) {
      x[p[k]] = b[k];
    }
  } else {
    for (k = 0; k < n; k++) {
      x[k] = b[k];
    }
  }
  return x;
}
var name$1e = "lusolve";
var dependencies$1e = ["typed", "matrix", "lup", "slu", "usolve", "lsolve", "DenseMatrix"];
var createLusolve = /* @__PURE__ */ factory(name$1e, dependencies$1e, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    lup: lup2,
    slu: slu2,
    usolve: usolve2,
    lsolve: lsolve2,
    DenseMatrix: DenseMatrix2
  } = _ref;
  var solveValidation = createSolveValidation({
    DenseMatrix: DenseMatrix2
  });
  return typed2(name$1e, {
    "Array, Array | Matrix": function ArrayArrayMatrix(a, b) {
      a = matrix2(a);
      var d = lup2(a);
      var x = _lusolve(d.L, d.U, d.p, null, b);
      return x.valueOf();
    },
    "DenseMatrix, Array | Matrix": function DenseMatrixArrayMatrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix": function SparseMatrixArrayMatrix(a, b) {
      var d = lup2(a);
      return _lusolve(d.L, d.U, d.p, null, b);
    },
    "SparseMatrix, Array | Matrix, number, number": function SparseMatrixArrayMatrixNumberNumber(a, b, order, threshold) {
      var d = slu2(a, order, threshold);
      return _lusolve(d.L, d.U, d.p, d.q, b);
    },
    "Object, Array | Matrix": function ObjectArrayMatrix(d, b) {
      return _lusolve(d.L, d.U, d.p, d.q, b);
    }
  });
  function _toMatrix(a) {
    if (isMatrix(a)) {
      return a;
    }
    if (isArray(a)) {
      return matrix2(a);
    }
    throw new TypeError("Invalid Matrix LU decomposition");
  }
  function _lusolve(l, u, p, q, b) {
    l = _toMatrix(l);
    u = _toMatrix(u);
    if (p) {
      b = solveValidation(l, b, true);
      b._data = csIpvec(p, b._data);
    }
    var y = lsolve2(l, b);
    var x = usolve2(u, y);
    if (q) {
      x._data = csIpvec(q, x._data);
    }
    return x;
  }
});
var name$1d = "polynomialRoot";
var dependencies$1d = ["typed", "isZero", "equalScalar", "add", "subtract", "multiply", "divide", "sqrt", "unaryMinus", "cbrt", "typeOf", "im", "re"];
var createPolynomialRoot = /* @__PURE__ */ factory(name$1d, dependencies$1d, (_ref) => {
  var {
    typed: typed2,
    isZero: isZero2,
    equalScalar: equalScalar2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    sqrt: sqrt2,
    unaryMinus: unaryMinus2,
    cbrt: cbrt3,
    typeOf: typeOf2,
    im: im2,
    re: re2
  } = _ref;
  return typed2(name$1d, {
    "number|Complex, ...number|Complex": (constant, restCoeffs) => {
      var coeffs = [constant, ...restCoeffs];
      while (coeffs.length > 0 && isZero2(coeffs[coeffs.length - 1])) {
        coeffs.pop();
      }
      if (coeffs.length < 2) {
        throw new RangeError("Polynomial [".concat(constant, ", ").concat(restCoeffs, "] must have a non-zero non-constant coefficient"));
      }
      switch (coeffs.length) {
        case 2:
          return [unaryMinus2(divide2(coeffs[0], coeffs[1]))];
        case 3: {
          var [c, b, a] = coeffs;
          var denom = multiply2(2, a);
          var d1 = multiply2(b, b);
          var d2 = multiply2(4, a, c);
          if (equalScalar2(d1, d2))
            return [divide2(unaryMinus2(b), denom)];
          var discriminant = sqrt2(subtract2(d1, d2));
          return [divide2(subtract2(discriminant, b), denom), divide2(subtract2(unaryMinus2(discriminant), b), denom)];
        }
        case 4: {
          var [d, _c, _b, _a] = coeffs;
          var _denom = unaryMinus2(multiply2(3, _a));
          var D0_1 = multiply2(_b, _b);
          var D0_2 = multiply2(3, _a, _c);
          var D1_1 = add2(multiply2(2, _b, _b, _b), multiply2(27, _a, _a, d));
          var D1_2 = multiply2(9, _a, _b, _c);
          if (equalScalar2(D0_1, D0_2) && equalScalar2(D1_1, D1_2)) {
            return [divide2(_b, _denom)];
          }
          var Delta0 = subtract2(D0_1, D0_2);
          var Delta1 = subtract2(D1_1, D1_2);
          var discriminant1 = add2(multiply2(18, _a, _b, _c, d), multiply2(_b, _b, _c, _c));
          var discriminant2 = add2(multiply2(4, _b, _b, _b, d), multiply2(4, _a, _c, _c, _c), multiply2(27, _a, _a, d, d));
          if (equalScalar2(discriminant1, discriminant2)) {
            return [
              divide2(subtract2(multiply2(4, _a, _b, _c), add2(multiply2(9, _a, _a, d), multiply2(_b, _b, _b))), multiply2(_a, Delta0)),
              // simple root
              divide2(subtract2(multiply2(9, _a, d), multiply2(_b, _c)), multiply2(2, Delta0))
              // double root
            ];
          }
          var Ccubed;
          if (equalScalar2(D0_1, D0_2)) {
            Ccubed = Delta1;
          } else {
            Ccubed = divide2(add2(Delta1, sqrt2(subtract2(multiply2(Delta1, Delta1), multiply2(4, Delta0, Delta0, Delta0)))), 2);
          }
          var allRoots = true;
          var rawRoots = cbrt3(Ccubed, allRoots).toArray().map((C) => divide2(add2(_b, C, divide2(Delta0, C)), _denom));
          return rawRoots.map((r) => {
            if (typeOf2(r) === "Complex" && equalScalar2(re2(r), re2(r) + im2(r))) {
              return re2(r);
            }
            return r;
          });
        }
        default:
          throw new RangeError("only implemented for cubic or lower-order polynomials, not ".concat(coeffs));
      }
    }
  });
});
var name$1c = "Help";
var dependencies$1c = ["evaluate"];
var createHelpClass = /* @__PURE__ */ factory(name$1c, dependencies$1c, (_ref) => {
  var {
    evaluate: evaluate2
  } = _ref;
  function Help2(doc) {
    if (!(this instanceof Help2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (!doc)
      throw new Error('Argument "doc" missing');
    this.doc = doc;
  }
  Help2.prototype.type = "Help";
  Help2.prototype.isHelp = true;
  Help2.prototype.toString = function() {
    var doc = this.doc || {};
    var desc = "\n";
    if (doc.name) {
      desc += "Name: " + doc.name + "\n\n";
    }
    if (doc.category) {
      desc += "Category: " + doc.category + "\n\n";
    }
    if (doc.description) {
      desc += "Description:\n    " + doc.description + "\n\n";
    }
    if (doc.syntax) {
      desc += "Syntax:\n    " + doc.syntax.join("\n    ") + "\n\n";
    }
    if (doc.examples) {
      desc += "Examples:\n";
      var configChanged = false;
      var originalConfig = evaluate2("config()");
      var scope = {
        config: (newConfig) => {
          configChanged = true;
          return evaluate2("config(newConfig)", {
            newConfig
          });
        }
      };
      for (var i2 = 0; i2 < doc.examples.length; i2++) {
        var expr = doc.examples[i2];
        desc += "    " + expr + "\n";
        var res = void 0;
        try {
          res = evaluate2(expr, scope);
        } catch (e2) {
          res = e2;
        }
        if (res !== void 0 && !isHelp(res)) {
          desc += "        " + format$1(res, {
            precision: 14
          }) + "\n";
        }
      }
      desc += "\n";
      if (configChanged) {
        evaluate2("config(originalConfig)", {
          originalConfig
        });
      }
    }
    if (doc.mayThrow && doc.mayThrow.length) {
      desc += "Throws: " + doc.mayThrow.join(", ") + "\n\n";
    }
    if (doc.seealso && doc.seealso.length) {
      desc += "See also: " + doc.seealso.join(", ") + "\n";
    }
    return desc;
  };
  Help2.prototype.toJSON = function() {
    var obj = clone$3(this.doc);
    obj.mathjs = "Help";
    return obj;
  };
  Help2.fromJSON = function(json) {
    var doc = {};
    Object.keys(json).filter((prop) => prop !== "mathjs").forEach((prop) => {
      doc[prop] = json[prop];
    });
    return new Help2(doc);
  };
  Help2.prototype.valueOf = Help2.prototype.toString;
  return Help2;
}, {
  isClass: true
});
var name$1b = "Chain";
var dependencies$1b = ["?on", "math", "typed"];
var createChainClass = /* @__PURE__ */ factory(name$1b, dependencies$1b, (_ref) => {
  var {
    on,
    math: math2,
    typed: typed2
  } = _ref;
  function Chain2(value) {
    if (!(this instanceof Chain2)) {
      throw new SyntaxError("Constructor must be called with the new operator");
    }
    if (isChain(value)) {
      this.value = value.value;
    } else {
      this.value = value;
    }
  }
  Chain2.prototype.type = "Chain";
  Chain2.prototype.isChain = true;
  Chain2.prototype.done = function() {
    return this.value;
  };
  Chain2.prototype.valueOf = function() {
    return this.value;
  };
  Chain2.prototype.toString = function() {
    return format$1(this.value);
  };
  Chain2.prototype.toJSON = function() {
    return {
      mathjs: "Chain",
      value: this.value
    };
  };
  Chain2.fromJSON = function(json) {
    return new Chain2(json.value);
  };
  function createProxy(name2, fn) {
    if (typeof fn === "function") {
      Chain2.prototype[name2] = chainify(fn);
    }
  }
  function createLazyProxy(name2, resolver) {
    lazy(Chain2.prototype, name2, function outerResolver() {
      var fn = resolver();
      if (typeof fn === "function") {
        return chainify(fn);
      }
      return void 0;
    });
  }
  function chainify(fn) {
    return function() {
      if (arguments.length === 0) {
        return new Chain2(fn(this.value));
      }
      var args = [this.value];
      for (var i2 = 0; i2 < arguments.length; i2++) {
        args[i2 + 1] = arguments[i2];
      }
      if (typed2.isTypedFunction(fn)) {
        var sigObject = typed2.resolve(fn, args);
        if (sigObject.params.length === 1) {
          throw new Error("chain function " + fn.name + " cannot match rest parameter between chain value and additional arguments.");
        }
        return new Chain2(sigObject.implementation.apply(fn, args));
      }
      return new Chain2(fn.apply(fn, args));
    };
  }
  Chain2.createProxy = function(arg0, arg1) {
    if (typeof arg0 === "string") {
      createProxy(arg0, arg1);
    } else {
      var _loop = function _loop2(_name2) {
        if (hasOwnProperty(arg0, _name2) && excludedNames[_name2] === void 0) {
          createLazyProxy(_name2, () => arg0[_name2]);
        }
      };
      for (var _name in arg0) {
        _loop(_name);
      }
    }
  };
  var excludedNames = {
    expression: true,
    docs: true,
    type: true,
    classes: true,
    json: true,
    error: true,
    isChain: true
    // conflicts with the property isChain of a Chain instance
  };
  Chain2.createProxy(math2);
  if (on) {
    on("import", function(name2, resolver, path) {
      if (!path) {
        createLazyProxy(name2, resolver);
      }
    });
  }
  return Chain2;
}, {
  isClass: true
});
var eDocs = {
  name: "e",
  category: "Constants",
  syntax: ["e"],
  description: "Euler's number, the base of the natural logarithm. Approximately equal to 2.71828",
  examples: ["e", "e ^ 2", "exp(2)", "log(e)"],
  seealso: ["exp"]
};
var falseDocs = {
  name: "false",
  category: "Constants",
  syntax: ["false"],
  description: "Boolean value false",
  examples: ["false"],
  seealso: ["true"]
};
var iDocs = {
  name: "i",
  category: "Constants",
  syntax: ["i"],
  description: "Imaginary unit, defined as i*i=-1. A complex number is described as a + b*i, where a is the real part, and b is the imaginary part.",
  examples: ["i", "i * i", "sqrt(-1)"],
  seealso: []
};
var InfinityDocs = {
  name: "Infinity",
  category: "Constants",
  syntax: ["Infinity"],
  description: "Infinity, a number which is larger than the maximum number that can be handled by a floating point number.",
  examples: ["Infinity", "1 / 0"],
  seealso: []
};
var LN10Docs = {
  name: "LN10",
  category: "Constants",
  syntax: ["LN10"],
  description: "Returns the natural logarithm of 10, approximately equal to 2.302",
  examples: ["LN10", "log(10)"],
  seealso: []
};
var LN2Docs = {
  name: "LN2",
  category: "Constants",
  syntax: ["LN2"],
  description: "Returns the natural logarithm of 2, approximately equal to 0.693",
  examples: ["LN2", "log(2)"],
  seealso: []
};
var LOG10EDocs = {
  name: "LOG10E",
  category: "Constants",
  syntax: ["LOG10E"],
  description: "Returns the base-10 logarithm of E, approximately equal to 0.434",
  examples: ["LOG10E", "log(e, 10)"],
  seealso: []
};
var LOG2EDocs = {
  name: "LOG2E",
  category: "Constants",
  syntax: ["LOG2E"],
  description: "Returns the base-2 logarithm of E, approximately equal to 1.442",
  examples: ["LOG2E", "log(e, 2)"],
  seealso: []
};
var NaNDocs = {
  name: "NaN",
  category: "Constants",
  syntax: ["NaN"],
  description: "Not a number",
  examples: ["NaN", "0 / 0"],
  seealso: []
};
var nullDocs = {
  name: "null",
  category: "Constants",
  syntax: ["null"],
  description: "Value null",
  examples: ["null"],
  seealso: ["true", "false"]
};
var phiDocs = {
  name: "phi",
  category: "Constants",
  syntax: ["phi"],
  description: "Phi is the golden ratio. Two quantities are in the golden ratio if their ratio is the same as the ratio of their sum to the larger of the two quantities. Phi is defined as `(1 + sqrt(5)) / 2` and is approximately 1.618034...",
  examples: ["phi"],
  seealso: []
};
var piDocs = {
  name: "pi",
  category: "Constants",
  syntax: ["pi"],
  description: "The number pi is a mathematical constant that is the ratio of a circle's circumference to its diameter, and is approximately equal to 3.14159",
  examples: ["pi", "sin(pi/2)"],
  seealso: ["tau"]
};
var SQRT12Docs = {
  name: "SQRT1_2",
  category: "Constants",
  syntax: ["SQRT1_2"],
  description: "Returns the square root of 1/2, approximately equal to 0.707",
  examples: ["SQRT1_2", "sqrt(1/2)"],
  seealso: []
};
var SQRT2Docs = {
  name: "SQRT2",
  category: "Constants",
  syntax: ["SQRT2"],
  description: "Returns the square root of 2, approximately equal to 1.414",
  examples: ["SQRT2", "sqrt(2)"],
  seealso: []
};
var tauDocs = {
  name: "tau",
  category: "Constants",
  syntax: ["tau"],
  description: "Tau is the ratio constant of a circle's circumference to radius, equal to 2 * pi, approximately 6.2832.",
  examples: ["tau", "2 * pi"],
  seealso: ["pi"]
};
var trueDocs = {
  name: "true",
  category: "Constants",
  syntax: ["true"],
  description: "Boolean value true",
  examples: ["true"],
  seealso: ["false"]
};
var versionDocs = {
  name: "version",
  category: "Constants",
  syntax: ["version"],
  description: "A string with the version number of math.js",
  examples: ["version"],
  seealso: []
};
var bignumberDocs = {
  name: "bignumber",
  category: "Construction",
  syntax: ["bignumber(x)"],
  description: "Create a big number from a number or string.",
  examples: ["0.1 + 0.2", "bignumber(0.1) + bignumber(0.2)", 'bignumber("7.2")', 'bignumber("7.2e500")', "bignumber([0.1, 0.2, 0.3])"],
  seealso: ["boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};
var booleanDocs = {
  name: "boolean",
  category: "Construction",
  syntax: ["x", "boolean(x)"],
  description: "Convert a string or number into a boolean.",
  examples: ["boolean(0)", "boolean(1)", "boolean(3)", 'boolean("true")', 'boolean("false")', "boolean([1, 0, 1, 1])"],
  seealso: ["bignumber", "complex", "index", "matrix", "number", "string", "unit"]
};
var complexDocs = {
  name: "complex",
  category: "Construction",
  syntax: ["complex()", "complex(re, im)", "complex(string)"],
  description: "Create a complex number.",
  examples: ["complex()", "complex(2, 3)", 'complex("7 - 2i")'],
  seealso: ["bignumber", "boolean", "index", "matrix", "number", "string", "unit"]
};
var createUnitDocs = {
  name: "createUnit",
  category: "Construction",
  syntax: ["createUnit(definitions)", "createUnit(name, definition)"],
  description: "Create a user-defined unit and register it with the Unit type.",
  examples: ['createUnit("foo")', 'createUnit("knot", {definition: "0.514444444 m/s", aliases: ["knots", "kt", "kts"]})', 'createUnit("mph", "1 mile/hour")'],
  seealso: ["unit", "splitUnit"]
};
var fractionDocs = {
  name: "fraction",
  category: "Construction",
  syntax: ["fraction(num)", "fraction(matrix)", "fraction(num,den)", "fraction({n: num, d: den})"],
  description: "Create a fraction from a number or from integer numerator and denominator.",
  examples: ["fraction(0.125)", "fraction(1, 3) + fraction(2, 5)", "fraction({n: 333, d: 53})", "fraction([sqrt(9), sqrt(10), sqrt(11)])"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "string", "unit"]
};
var indexDocs = {
  name: "index",
  category: "Construction",
  syntax: ["[start]", "[start:end]", "[start:step:end]", "[start1, start 2, ...]", "[start1:end1, start2:end2, ...]", "[start1:step1:end1, start2:step2:end2, ...]"],
  description: "Create an index to get or replace a subset of a matrix",
  examples: ["A = [1, 2, 3; 4, 5, 6]", "A[1, :]", "A[1, 2] = 50", "A[1:2, 1:2] = 1", "B = [1, 2, 3]", "B[B>1 and B<3]"],
  seealso: ["bignumber", "boolean", "complex", "matrix,", "number", "range", "string", "unit"]
};
var matrixDocs = {
  name: "matrix",
  category: "Construction",
  syntax: ["[]", "[a1, b1, ...; a2, b2, ...]", "matrix()", 'matrix("dense")', "matrix([...])"],
  description: "Create a matrix.",
  examples: ["[]", "[1, 2, 3]", "[1, 2, 3; 4, 5, 6]", "matrix()", "matrix([3, 4])", 'matrix([3, 4; 5, 6], "sparse")', 'matrix([3, 4; 5, 6], "sparse", "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "sparse"]
};
var numberDocs = {
  name: "number",
  category: "Construction",
  syntax: ["x", "number(x)", "number(unit, valuelessUnit)"],
  description: "Create a number or convert a string or boolean into a number.",
  examples: ["2", "2e3", "4.05", "number(2)", 'number("7.2")', "number(true)", "number([true, false, true, true])", 'number(unit("52cm"), "m")'],
  seealso: ["bignumber", "boolean", "complex", "fraction", "index", "matrix", "string", "unit"]
};
var sparseDocs = {
  name: "sparse",
  category: "Construction",
  syntax: ["sparse()", "sparse([a1, b1, ...; a1, b2, ...])", 'sparse([a1, b1, ...; a1, b2, ...], "number")'],
  description: "Create a sparse matrix.",
  examples: ["sparse()", "sparse([3, 4; 5, 6])", 'sparse([3, 0; 5, 0], "number")'],
  seealso: ["bignumber", "boolean", "complex", "index", "number", "string", "unit", "matrix"]
};
var splitUnitDocs = {
  name: "splitUnit",
  category: "Construction",
  syntax: ["splitUnit(unit: Unit, parts: Unit[])"],
  description: "Split a unit in an array of units whose sum is equal to the original unit.",
  examples: ['splitUnit(1 m, ["feet", "inch"])'],
  seealso: ["unit", "createUnit"]
};
var stringDocs = {
  name: "string",
  category: "Construction",
  syntax: ['"text"', "string(x)"],
  description: "Create a string or convert a value to a string",
  examples: ['"Hello World!"', "string(4.2)", "string(3 + 2i)"],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "unit"]
};
var unitDocs = {
  name: "unit",
  category: "Construction",
  syntax: ["value unit", "unit(value, unit)", "unit(string)"],
  description: "Create a unit.",
  examples: ["5.5 mm", "3 inch", 'unit(7.1, "kilogram")', 'unit("23 deg")'],
  seealso: ["bignumber", "boolean", "complex", "index", "matrix", "number", "string"]
};
var configDocs = {
  name: "config",
  category: "Core",
  syntax: ["config()", "config(options)"],
  description: "Get configuration or change configuration.",
  examples: ["config()", "1/3 + 1/4", 'config({number: "Fraction"})', "1/3 + 1/4"],
  seealso: []
};
var importDocs = {
  name: "import",
  category: "Core",
  syntax: ["import(functions)", "import(functions, options)"],
  description: "Import functions or constants from an object.",
  examples: ["import({myFn: f(x)=x^2, myConstant: 32 })", "myFn(2)", "myConstant"],
  seealso: []
};
var typedDocs = {
  name: "typed",
  category: "Core",
  syntax: ["typed(signatures)", "typed(name, signatures)"],
  description: "Create a typed function.",
  examples: ['double = typed({ "number": f(x)=x+x, "string": f(x)=concat(x,x) })', "double(2)", 'double("hello")'],
  seealso: []
};
var derivativeDocs = {
  name: "derivative",
  category: "Algebra",
  syntax: ["derivative(expr, variable)", "derivative(expr, variable, {simplify: boolean})"],
  description: "Takes the derivative of an expression expressed in parser Nodes. The derivative will be taken over the supplied variable in the second parameter. If there are multiple variables in the expression, it will return a partial derivative.",
  examples: ['derivative("2x^3", "x")', 'derivative("2x^3", "x", {simplify: false})', 'derivative("2x^2 + 3x + 4", "x")', 'derivative("sin(2x)", "x")', 'f = parse("x^2 + x")', 'x = parse("x")', "df = derivative(f, x)", "df.evaluate({x: 3})"],
  seealso: ["simplify", "parse", "evaluate"]
};
var leafCountDocs = {
  name: "leafCount",
  category: "Algebra",
  syntax: ["leafCount(expr)"],
  description: "Computes the number of leaves in the parse tree of the given expression",
  examples: ['leafCount("e^(i*pi)-1")', 'leafCount(parse("{a: 22/7, b: 10^(1/2)}"))'],
  seealso: ["simplify"]
};
var lsolveDocs = {
  name: "lsolve",
  category: "Algebra",
  syntax: ["x=lsolve(L, b)"],
  description: "Finds one solution of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolveAll", "lup", "lusolve", "usolve", "matrix", "sparse"]
};
var lsolveAllDocs = {
  name: "lsolveAll",
  category: "Algebra",
  syntax: ["x=lsolveAll(L, b)"],
  description: "Finds all solutions of the linear system L * x = b where L is an [n x n] lower triangular matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lsolve(a, b)"],
  seealso: ["lsolve", "lup", "lusolve", "usolve", "matrix", "sparse"]
};
var lupDocs = {
  name: "lup",
  category: "Algebra",
  syntax: ["lup(m)"],
  description: "Calculate the Matrix LU decomposition with partial pivoting. Matrix A is decomposed in three matrices (L, U, P) where P * A = L * U",
  examples: ["lup([[2, 1], [1, 4]])", "lup(matrix([[2, 1], [1, 4]]))", "lup(sparse([[2, 1], [1, 4]]))"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "slu", "qr"]
};
var lusolveDocs = {
  name: "lusolve",
  category: "Algebra",
  syntax: ["x=lusolve(A, b)", "x=lusolve(lu, b)"],
  description: "Solves the linear system A * x = b where A is an [n x n] matrix and b is a [n] column vector.",
  examples: ["a = [-2, 3; 2, 1]", "b = [11, 9]", "x = lusolve(a, b)"],
  seealso: ["lup", "slu", "lsolve", "usolve", "matrix", "sparse"]
};
var polynomialRootDocs = {
  name: "polynomialRoot",
  category: "Algebra",
  syntax: ["x=polynomialRoot(-6, 3)", "x=polynomialRoot(4, -4, 1)", "x=polynomialRoot(-8, 12, -6, 1)"],
  description: "Finds the roots of a univariate polynomial given by its coefficients starting from constant, linear, and so on, increasing in degree.",
  examples: ["a = polynomialRoot(-6, 11, -6, 1)"],
  seealso: ["cbrt", "sqrt"]
};
var qrDocs = {
  name: "qr",
  category: "Algebra",
  syntax: ["qr(A)"],
  description: "Calculates the Matrix QR decomposition. Matrix `A` is decomposed in two matrices (`Q`, `R`) where `Q` is an orthogonal matrix and `R` is an upper triangular matrix.",
  examples: ["qr([[1, -1,  4], [1,  4, -2], [1,  4,  2], [1,  -1, 0]])"],
  seealso: ["lup", "slu", "matrix"]
};
var rationalizeDocs = {
  name: "rationalize",
  category: "Algebra",
  syntax: ["rationalize(expr)", "rationalize(expr, scope)", "rationalize(expr, scope, detailed)"],
  description: "Transform a rationalizable expression in a rational fraction. If rational fraction is one variable polynomial then converts the numerator and denominator in canonical form, with decreasing exponents, returning the coefficients of numerator.",
  examples: ['rationalize("2x/y - y/(x+1)")', 'rationalize("2x/y - y/(x+1)", true)'],
  seealso: ["simplify"]
};
var resolveDocs = {
  name: "resolve",
  category: "Algebra",
  syntax: ["resolve(node, scope)"],
  description: "Recursively substitute variables in an expression tree.",
  examples: ['resolve(parse("1 + x"), { x: 7 })', 'resolve(parse("size(text)"), { text: "Hello World" })', 'resolve(parse("x + y"), { x: parse("3z") })', 'resolve(parse("3x"), { x: parse("y+z"), z: parse("w^y") })'],
  seealso: ["simplify", "evaluate"],
  mayThrow: ["ReferenceError"]
};
var simplifyDocs = {
  name: "simplify",
  category: "Algebra",
  syntax: ["simplify(expr)", "simplify(expr, rules)"],
  description: "Simplify an expression tree.",
  examples: ['simplify("3 + 2 / 4")', 'simplify("2x + x")', 'f = parse("x * (x + 2 + x)")', "simplified = simplify(f)", "simplified.evaluate({x: 2})"],
  seealso: ["simplifyCore", "derivative", "evaluate", "parse", "rationalize", "resolve"]
};
var simplifyConstantDocs = {
  name: "simplifyConstant",
  category: "Algebra",
  syntax: ["simplifyConstant(expr)", "simplifyConstant(expr, options)"],
  description: "Replace constant subexpressions of node with their values.",
  examples: ['simplifyConstant("(3-3)*x")', 'simplifyConstant(parse("z-cos(tau/8)"))'],
  seealso: ["simplify", "simplifyCore", "evaluate"]
};
var simplifyCoreDocs = {
  name: "simplifyCore",
  category: "Algebra",
  syntax: ["simplifyCore(node)"],
  description: "Perform simple one-pass simplifications on an expression tree.",
  examples: ['simplifyCore(parse("0*x"))', 'simplifyCore(parse("(x+0)*2"))'],
  seealso: ["simplify", "simplifyConstant", "evaluate"]
};
var sluDocs = {
  name: "slu",
  category: "Algebra",
  syntax: ["slu(A, order, threshold)"],
  description: "Calculate the Matrix LU decomposition with full pivoting. Matrix A is decomposed in two matrices (L, U) and two permutation vectors (pinv, q) where P * A * Q = L * U",
  examples: ["slu(sparse([4.5, 0, 3.2, 0; 3.1, 2.9, 0, 0.9; 0, 1.7, 3, 0; 3.5, 0.4, 0, 1]), 1, 0.001)"],
  seealso: ["lusolve", "lsolve", "usolve", "matrix", "sparse", "lup", "qr"]
};
var symbolicEqualDocs = {
  name: "symbolicEqual",
  category: "Algebra",
  syntax: ["symbolicEqual(expr1, expr2)", "symbolicEqual(expr1, expr2, options)"],
  description: "Returns true if the difference of the expressions simplifies to 0",
  examples: ['symbolicEqual("x*y","y*x")', 'symbolicEqual("abs(x^2)", "x^2")', 'symbolicEqual("abs(x)", "x", {context: {abs: {trivial: true}}})'],
  seealso: ["simplify", "evaluate"]
};
var usolveDocs = {
  name: "usolve",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds one solution of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolveAll", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};
var usolveAllDocs = {
  name: "usolveAll",
  category: "Algebra",
  syntax: ["x=usolve(U, b)"],
  description: "Finds all solutions of the linear system U * x = b where U is an [n x n] upper triangular matrix and b is a [n] column vector.",
  examples: ["x=usolve(sparse([1, 1, 1, 1; 0, 1, 1, 1; 0, 0, 1, 1; 0, 0, 0, 1]), [1; 2; 3; 4])"],
  seealso: ["usolve", "lup", "lusolve", "lsolve", "matrix", "sparse"]
};
var absDocs = {
  name: "abs",
  category: "Arithmetic",
  syntax: ["abs(x)"],
  description: "Compute the absolute value.",
  examples: ["abs(3.5)", "abs(-4.2)"],
  seealso: ["sign"]
};
var addDocs = {
  name: "add",
  category: "Operators",
  syntax: ["x + y", "add(x, y)"],
  description: "Add two values.",
  examples: ["a = 2.1 + 3.6", "a - 3.6", "3 + 2i", "3 cm + 2 inch", '"2.3" + "4"'],
  seealso: ["subtract"]
};
var cbrtDocs = {
  name: "cbrt",
  category: "Arithmetic",
  syntax: ["cbrt(x)", "cbrt(x, allRoots)"],
  description: "Compute the cubic root value. If x = y * y * y, then y is the cubic root of x. When `x` is a number or complex number, an optional second argument `allRoots` can be provided to return all three cubic roots. If not provided, the principal root is returned",
  examples: ["cbrt(64)", "cube(4)", "cbrt(-8)", "cbrt(2 + 3i)", "cbrt(8i)", "cbrt(8i, true)", "cbrt(27 m^3)"],
  seealso: ["square", "sqrt", "cube", "multiply"]
};
var ceilDocs = {
  name: "ceil",
  category: "Arithmetic",
  syntax: ["ceil(x)"],
  description: "Round a value towards plus infinity. If x is complex, both real and imaginary part are rounded towards plus infinity.",
  examples: ["ceil(3.2)", "ceil(3.8)", "ceil(-4.2)"],
  seealso: ["floor", "fix", "round"]
};
var cubeDocs = {
  name: "cube",
  category: "Arithmetic",
  syntax: ["cube(x)"],
  description: "Compute the cube of a value. The cube of x is x * x * x.",
  examples: ["cube(2)", "2^3", "2 * 2 * 2"],
  seealso: ["multiply", "square", "pow"]
};
var divideDocs = {
  name: "divide",
  category: "Operators",
  syntax: ["x / y", "divide(x, y)"],
  description: "Divide two values.",
  examples: ["a = 2 / 3", "a * 3", "4.5 / 2", "3 + 4 / 2", "(3 + 4) / 2", "18 km / 4.5"],
  seealso: ["multiply"]
};
var dotDivideDocs = {
  name: "dotDivide",
  category: "Operators",
  syntax: ["x ./ y", "dotDivide(x, y)"],
  description: "Divide two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a ./ b"],
  seealso: ["multiply", "dotMultiply", "divide"]
};
var dotMultiplyDocs = {
  name: "dotMultiply",
  category: "Operators",
  syntax: ["x .* y", "dotMultiply(x, y)"],
  description: "Multiply two values element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "b = [2, 1, 1; 3, 2, 5]", "a .* b"],
  seealso: ["multiply", "divide", "dotDivide"]
};
var dotPowDocs = {
  name: "dotPow",
  category: "Operators",
  syntax: ["x .^ y", "dotPow(x, y)"],
  description: "Calculates the power of x to y element wise.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a .^ 2"],
  seealso: ["pow"]
};
var expDocs = {
  name: "exp",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Calculate the exponent of a value.",
  examples: ["exp(1.3)", "e ^ 1.3", "log(exp(1.3))", "x = 2.4", "(exp(i*x) == cos(x) + i*sin(x))   # Euler's formula"],
  seealso: ["expm", "expm1", "pow", "log"]
};
var expmDocs = {
  name: "expm",
  category: "Arithmetic",
  syntax: ["exp(x)"],
  description: "Compute the matrix exponential, expm(A) = e^A. The matrix must be square. Not to be confused with exp(a), which performs element-wise exponentiation.",
  examples: ["expm([[0,2],[0,0]])"],
  seealso: ["exp"]
};
var expm1Docs = {
  name: "expm1",
  category: "Arithmetic",
  syntax: ["expm1(x)"],
  description: "Calculate the value of subtracting 1 from the exponential value.",
  examples: ["expm1(2)", "pow(e, 2) - 1", "log(expm1(2) + 1)"],
  seealso: ["exp", "pow", "log"]
};
var fixDocs = {
  name: "fix",
  category: "Arithmetic",
  syntax: ["fix(x)"],
  description: "Round a value towards zero. If x is complex, both real and imaginary part are rounded towards zero.",
  examples: ["fix(3.2)", "fix(3.8)", "fix(-4.2)", "fix(-4.8)"],
  seealso: ["ceil", "floor", "round"]
};
var floorDocs = {
  name: "floor",
  category: "Arithmetic",
  syntax: ["floor(x)"],
  description: "Round a value towards minus infinity.If x is complex, both real and imaginary part are rounded towards minus infinity.",
  examples: ["floor(3.2)", "floor(3.8)", "floor(-4.2)"],
  seealso: ["ceil", "fix", "round"]
};
var gcdDocs = {
  name: "gcd",
  category: "Arithmetic",
  syntax: ["gcd(a, b)", "gcd(a, b, c, ...)"],
  description: "Compute the greatest common divisor.",
  examples: ["gcd(8, 12)", "gcd(-4, 6)", "gcd(25, 15, -10)"],
  seealso: ["lcm", "xgcd"]
};
var hypotDocs = {
  name: "hypot",
  category: "Arithmetic",
  syntax: ["hypot(a, b, c, ...)", "hypot([a, b, c, ...])"],
  description: "Calculate the hypotenusa of a list with values. ",
  examples: ["hypot(3, 4)", "sqrt(3^2 + 4^2)", "hypot(-2)", "hypot([3, 4, 5])"],
  seealso: ["abs", "norm"]
};
var invmodDocs = {
  name: "invmod",
  category: "Arithmetic",
  syntax: ["invmod(a, b)"],
  description: "Calculate the (modular) multiplicative inverse of a modulo b. Solution to the equation ax  1 (mod b)",
  examples: ["invmod(8, 12)", "invmod(7, 13)", "invmod(15151, 15122)"],
  seealso: ["gcd", "xgcd"]
};
var lcmDocs = {
  name: "lcm",
  category: "Arithmetic",
  syntax: ["lcm(x, y)"],
  description: "Compute the least common multiple.",
  examples: ["lcm(4, 6)", "lcm(6, 21)", "lcm(6, 21, 5)"],
  seealso: ["gcd"]
};
var logDocs = {
  name: "log",
  category: "Arithmetic",
  syntax: ["log(x)", "log(x, base)"],
  description: "Compute the logarithm of a value. If no base is provided, the natural logarithm of x is calculated. If base if provided, the logarithm is calculated for the specified base. log(x, base) is defined as log(x) / log(base).",
  examples: ["log(3.5)", "a = log(2.4)", "exp(a)", "10 ^ 4", "log(10000, 10)", "log(10000) / log(10)", "b = log(1024, 2)", "2 ^ b"],
  seealso: ["exp", "log1p", "log2", "log10"]
};
var log10Docs = {
  name: "log10",
  category: "Arithmetic",
  syntax: ["log10(x)"],
  description: "Compute the 10-base logarithm of a value.",
  examples: ["log10(0.00001)", "log10(10000)", "10 ^ 4", "log(10000) / log(10)", "log(10000, 10)"],
  seealso: ["exp", "log"]
};
var log1pDocs = {
  name: "log1p",
  category: "Arithmetic",
  syntax: ["log1p(x)", "log1p(x, base)"],
  description: "Calculate the logarithm of a `value+1`",
  examples: ["log1p(2.5)", "exp(log1p(1.4))", "pow(10, 4)", "log1p(9999, 10)", "log1p(9999) / log(10)"],
  seealso: ["exp", "log", "log2", "log10"]
};
var log2Docs = {
  name: "log2",
  category: "Arithmetic",
  syntax: ["log2(x)"],
  description: "Calculate the 2-base of a value. This is the same as calculating `log(x, 2)`.",
  examples: ["log2(0.03125)", "log2(16)", "log2(16) / log2(2)", "pow(2, 4)"],
  seealso: ["exp", "log1p", "log", "log10"]
};
var modDocs = {
  name: "mod",
  category: "Operators",
  syntax: ["x % y", "x mod y", "mod(x, y)"],
  description: "Calculates the modulus, the remainder of an integer division.",
  examples: ["7 % 3", "11 % 2", "10 mod 4", "isOdd(x) = x % 2", "isOdd(2)", "isOdd(3)"],
  seealso: ["divide"]
};
var multiplyDocs = {
  name: "multiply",
  category: "Operators",
  syntax: ["x * y", "multiply(x, y)"],
  description: "multiply two values.",
  examples: ["a = 2.1 * 3.4", "a / 3.4", "2 * 3 + 4", "2 * (3 + 4)", "3 * 2.1 km"],
  seealso: ["divide"]
};
var normDocs = {
  name: "norm",
  category: "Arithmetic",
  syntax: ["norm(x)", "norm(x, p)"],
  description: "Calculate the norm of a number, vector or matrix.",
  examples: ["abs(-3.5)", "norm(-3.5)", "norm(3 - 4i)", "norm([1, 2, -3], Infinity)", "norm([1, 2, -3], -Infinity)", "norm([3, 4], 2)", "norm([[1, 2], [3, 4]], 1)", 'norm([[1, 2], [3, 4]], "inf")', 'norm([[1, 2], [3, 4]], "fro")']
};
var nthRootDocs = {
  name: "nthRoot",
  category: "Arithmetic",
  syntax: ["nthRoot(a)", "nthRoot(a, root)"],
  description: 'Calculate the nth root of a value. The principal nth root of a positive real number A, is the positive real solution of the equation "x^root = A".',
  examples: ["4 ^ 3", "nthRoot(64, 3)", "nthRoot(9, 2)", "sqrt(9)"],
  seealso: ["nthRoots", "pow", "sqrt"]
};
var nthRootsDocs = {
  name: "nthRoots",
  category: "Arithmetic",
  syntax: ["nthRoots(A)", "nthRoots(A, root)"],
  description: 'Calculate the nth roots of a value. An nth root of a positive real number A, is a positive real solution of the equation "x^root = A". This function returns an array of complex values.',
  examples: ["nthRoots(1)", "nthRoots(1, 3)"],
  seealso: ["sqrt", "pow", "nthRoot"]
};
var powDocs = {
  name: "pow",
  category: "Operators",
  syntax: ["x ^ y", "pow(x, y)"],
  description: "Calculates the power of x to y, x^y.",
  examples: ["2^3", "2*2*2", "1 + e ^ (pi * i)", "pow([[1, 2], [4, 3]], 2)", "pow([[1, 2], [4, 3]], -1)"],
  seealso: ["multiply", "nthRoot", "nthRoots", "sqrt"]
};
var roundDocs = {
  name: "round",
  category: "Arithmetic",
  syntax: ["round(x)", "round(x, n)", "round(unit, valuelessUnit)", "round(unit, n, valuelessUnit)"],
  description: "round a value towards the nearest integer.If x is complex, both real and imaginary part are rounded towards the nearest integer. When n is specified, the value is rounded to n decimals.",
  examples: ["round(3.2)", "round(3.8)", "round(-4.2)", "round(-4.8)", "round(pi, 3)", "round(123.45678, 2)", "round(3.241cm, 2, cm)", "round([3.2, 3.8, -4.7])"],
  seealso: ["ceil", "floor", "fix"]
};
var signDocs = {
  name: "sign",
  category: "Arithmetic",
  syntax: ["sign(x)"],
  description: "Compute the sign of a value. The sign of a value x is 1 when x>1, -1 when x<0, and 0 when x=0.",
  examples: ["sign(3.5)", "sign(-4.2)", "sign(0)"],
  seealso: ["abs"]
};
var sqrtDocs = {
  name: "sqrt",
  category: "Arithmetic",
  syntax: ["sqrt(x)"],
  description: "Compute the square root value. If x = y * y, then y is the square root of x.",
  examples: ["sqrt(25)", "5 * 5", "sqrt(-1)"],
  seealso: ["square", "sqrtm", "multiply", "nthRoot", "nthRoots", "pow"]
};
var sqrtmDocs = {
  name: "sqrtm",
  category: "Arithmetic",
  syntax: ["sqrtm(x)"],
  description: "Calculate the principal square root of a square matrix. The principal square root matrix `X` of another matrix `A` is such that `X * X = A`.",
  examples: ["sqrtm([[33, 24], [48, 57]])"],
  seealso: ["sqrt", "abs", "square", "multiply"]
};
var sylvesterDocs = {
  name: "sylvester",
  category: "Algebra",
  syntax: ["sylvester(A,B,C)"],
  description: "Solves the real-valued Sylvester equation AX+XB=C for X",
  examples: ["sylvester([[-1, -2], [1, 1]], [[-2, 1], [-1, 2]], [[-3, 2], [3, 0]])", "A = [[-1, -2], [1, 1]]; B = [[2, -1], [1, -2]]; C = [[-3, 2], [3, 0]]", "sylvester(A, B, C)"],
  seealso: ["schur", "lyap"]
};
var schurDocs = {
  name: "schur",
  category: "Algebra",
  syntax: ["schur(A)"],
  description: "Performs a real Schur decomposition of the real matrix A = UTU'",
  examples: ["schur([[1, 0], [-4, 3]])", "A = [[1, 0], [-4, 3]]", "schur(A)"],
  seealso: ["lyap", "sylvester"]
};
var lyapDocs = {
  name: "lyap",
  category: "Algebra",
  syntax: ["lyap(A,Q)"],
  description: "Solves the Continuous-time Lyapunov equation AP+PA'+Q=0 for P",
  examples: ["lyap([[-2, 0], [1, -4]], [[3, 1], [1, 3]])", "A = [[-2, 0], [1, -4]]", "Q = [[3, 1], [1, 3]]", "lyap(A,Q)"],
  seealso: ["schur", "sylvester"]
};
var squareDocs = {
  name: "square",
  category: "Arithmetic",
  syntax: ["square(x)"],
  description: "Compute the square of a value. The square of x is x * x.",
  examples: ["square(3)", "sqrt(9)", "3^2", "3 * 3"],
  seealso: ["multiply", "pow", "sqrt", "cube"]
};
var subtractDocs = {
  name: "subtract",
  category: "Operators",
  syntax: ["x - y", "subtract(x, y)"],
  description: "subtract two values.",
  examples: ["a = 5.3 - 2", "a + 2", "2/3 - 1/6", "2 * 3 - 3", "2.1 km - 500m"],
  seealso: ["add"]
};
var unaryMinusDocs = {
  name: "unaryMinus",
  category: "Operators",
  syntax: ["-x", "unaryMinus(x)"],
  description: "Inverse the sign of a value. Converts booleans and strings to numbers.",
  examples: ["-4.5", "-(-5.6)", '-"22"'],
  seealso: ["add", "subtract", "unaryPlus"]
};
var unaryPlusDocs = {
  name: "unaryPlus",
  category: "Operators",
  syntax: ["+x", "unaryPlus(x)"],
  description: "Converts booleans and strings to numbers.",
  examples: ["+true", '+"2"'],
  seealso: ["add", "subtract", "unaryMinus"]
};
var xgcdDocs = {
  name: "xgcd",
  category: "Arithmetic",
  syntax: ["xgcd(a, b)"],
  description: "Calculate the extended greatest common divisor for two values. The result is an array [d, x, y] with 3 entries, where d is the greatest common divisor, and d = x * a + y * b.",
  examples: ["xgcd(8, 12)", "gcd(8, 12)", "xgcd(36163, 21199)"],
  seealso: ["gcd", "lcm"]
};
var bitAndDocs = {
  name: "bitAnd",
  category: "Bitwise",
  syntax: ["x & y", "bitAnd(x, y)"],
  description: "Bitwise AND operation. Performs the logical AND operation on each pair of the corresponding bits of the two given values by multiplying them. If both bits in the compared position are 1, the bit in the resulting binary representation is 1, otherwise, the result is 0",
  examples: ["5 & 3", "bitAnd(53, 131)", "[1, 12, 31] & 42"],
  seealso: ["bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};
var bitNotDocs = {
  name: "bitNot",
  category: "Bitwise",
  syntax: ["~x", "bitNot(x)"],
  description: "Bitwise NOT operation. Performs a logical negation on each bit of the given value. Bits that are 0 become 1, and those that are 1 become 0.",
  examples: ["~1", "~2", "bitNot([2, -3, 4])"],
  seealso: ["bitAnd", "bitOr", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};
var bitOrDocs = {
  name: "bitOr",
  category: "Bitwise",
  syntax: ["x | y", "bitOr(x, y)"],
  description: "Bitwise OR operation. Performs the logical inclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if the first bit is 1 or the second bit is 1 or both bits are 1, otherwise, the result is 0.",
  examples: ["5 | 3", "bitOr([1, 2, 3], 4)"],
  seealso: ["bitAnd", "bitNot", "bitXor", "leftShift", "rightArithShift", "rightLogShift"]
};
var bitXorDocs = {
  name: "bitXor",
  category: "Bitwise",
  syntax: ["bitXor(x, y)"],
  description: "Bitwise XOR operation, exclusive OR. Performs the logical exclusive OR operation on each pair of corresponding bits of the two given values. The result in each position is 1 if only the first bit is 1 or only the second bit is 1, but will be 0 if both are 0 or both are 1.",
  examples: ["bitOr(1, 2)", "bitXor([2, 3, 4], 4)"],
  seealso: ["bitAnd", "bitNot", "bitOr", "leftShift", "rightArithShift", "rightLogShift"]
};
var leftShiftDocs = {
  name: "leftShift",
  category: "Bitwise",
  syntax: ["x << y", "leftShift(x, y)"],
  description: "Bitwise left logical shift of a value x by y number of bits.",
  examples: ["4 << 1", "8 >> 1"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "rightArithShift", "rightLogShift"]
};
var rightArithShiftDocs = {
  name: "rightArithShift",
  category: "Bitwise",
  syntax: ["x >> y", "rightArithShift(x, y)"],
  description: "Bitwise right arithmetic shift of a value x by y number of bits.",
  examples: ["8 >> 1", "4 << 1", "-12 >> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightLogShift"]
};
var rightLogShiftDocs = {
  name: "rightLogShift",
  category: "Bitwise",
  syntax: ["x >>> y", "rightLogShift(x, y)"],
  description: "Bitwise right logical shift of a value x by y number of bits.",
  examples: ["8 >>> 1", "4 << 1", "-12 >>> 2"],
  seealso: ["bitAnd", "bitNot", "bitOr", "bitXor", "leftShift", "rightArithShift"]
};
var bellNumbersDocs = {
  name: "bellNumbers",
  category: "Combinatorics",
  syntax: ["bellNumbers(n)"],
  description: "The Bell Numbers count the number of partitions of a set. A partition is a pairwise disjoint subset of S whose union is S. `bellNumbers` only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["bellNumbers(3)", "bellNumbers(8)"],
  seealso: ["stirlingS2"]
};
var catalanDocs = {
  name: "catalan",
  category: "Combinatorics",
  syntax: ["catalan(n)"],
  description: "The Catalan Numbers enumerate combinatorial structures of many different types. catalan only takes integer arguments. The following condition must be enforced: n >= 0.",
  examples: ["catalan(3)", "catalan(8)"],
  seealso: ["bellNumbers"]
};
var compositionDocs = {
  name: "composition",
  category: "Combinatorics",
  syntax: ["composition(n, k)"],
  description: "The composition counts of n into k parts. composition only takes integer arguments. The following condition must be enforced: k <= n.",
  examples: ["composition(5, 3)"],
  seealso: ["combinations"]
};
var stirlingS2Docs = {
  name: "stirlingS2",
  category: "Combinatorics",
  syntax: ["stirlingS2(n, k)"],
  description: "he Stirling numbers of the second kind, counts the number of ways to partition a set of n labelled objects into k nonempty unlabelled subsets. `stirlingS2` only takes integer arguments. The following condition must be enforced: k <= n. If n = k or k = 1, then s(n,k) = 1.",
  examples: ["stirlingS2(5, 3)"],
  seealso: ["bellNumbers"]
};
var argDocs = {
  name: "arg",
  category: "Complex",
  syntax: ["arg(x)"],
  description: "Compute the argument of a complex value. If x = a+bi, the argument is computed as atan2(b, a).",
  examples: ["arg(2 + 2i)", "atan2(3, 2)", "arg(2 + 3i)"],
  seealso: ["re", "im", "conj", "abs"]
};
var conjDocs = {
  name: "conj",
  category: "Complex",
  syntax: ["conj(x)"],
  description: "Compute the complex conjugate of a complex value. If x = a+bi, the complex conjugate is a-bi.",
  examples: ["conj(2 + 3i)", "conj(2 - 3i)", "conj(-5.2i)"],
  seealso: ["re", "im", "abs", "arg"]
};
var imDocs = {
  name: "im",
  category: "Complex",
  syntax: ["im(x)"],
  description: "Get the imaginary part of a complex number.",
  examples: ["im(2 + 3i)", "re(2 + 3i)", "im(-5.2i)", "im(2.4)"],
  seealso: ["re", "conj", "abs", "arg"]
};
var reDocs = {
  name: "re",
  category: "Complex",
  syntax: ["re(x)"],
  description: "Get the real part of a complex number.",
  examples: ["re(2 + 3i)", "im(2 + 3i)", "re(-5.2i)", "re(2.4)"],
  seealso: ["im", "conj", "abs", "arg"]
};
var evaluateDocs = {
  name: "evaluate",
  category: "Expression",
  syntax: ["evaluate(expression)", "evaluate(expression, scope)", "evaluate([expr1, expr2, expr3, ...])", "evaluate([expr1, expr2, expr3, ...], scope)"],
  description: "Evaluate an expression or an array with expressions.",
  examples: ['evaluate("2 + 3")', 'evaluate("sqrt(16)")', 'evaluate("2 inch to cm")', 'evaluate("sin(x * pi)", { "x": 1/2 })', 'evaluate(["width=2", "height=4","width*height"])'],
  seealso: []
};
var helpDocs = {
  name: "help",
  category: "Expression",
  syntax: ["help(object)", "help(string)"],
  description: "Display documentation on a function or data type.",
  examples: ["help(sqrt)", 'help("complex")'],
  seealso: []
};
var distanceDocs = {
  name: "distance",
  category: "Geometry",
  syntax: ["distance([x1, y1], [x2, y2])", "distance([[x1, y1], [x2, y2]])"],
  description: "Calculates the Euclidean distance between two points.",
  examples: ["distance([0,0], [4,4])", "distance([[0,0], [4,4]])"],
  seealso: []
};
var intersectDocs = {
  name: "intersect",
  category: "Geometry",
  syntax: ["intersect(expr1, expr2, expr3, expr4)", "intersect(expr1, expr2, expr3)"],
  description: "Computes the intersection point of lines and/or planes.",
  examples: ["intersect([0, 0], [10, 10], [10, 0], [0, 10])", "intersect([1, 0, 1],  [4, -2, 2], [1, 1, 1, 6])"],
  seealso: []
};
var andDocs = {
  name: "and",
  category: "Logical",
  syntax: ["x and y", "and(x, y)"],
  description: "Logical and. Test whether two values are both defined with a nonzero/nonempty value.",
  examples: ["true and false", "true and true", "2 and 4"],
  seealso: ["not", "or", "xor"]
};
var notDocs = {
  name: "not",
  category: "Logical",
  syntax: ["not x", "not(x)"],
  description: "Logical not. Flips the boolean value of given argument.",
  examples: ["not true", "not false", "not 2", "not 0"],
  seealso: ["and", "or", "xor"]
};
var orDocs = {
  name: "or",
  category: "Logical",
  syntax: ["x or y", "or(x, y)"],
  description: "Logical or. Test if at least one value is defined with a nonzero/nonempty value.",
  examples: ["true or false", "false or false", "0 or 4"],
  seealso: ["not", "and", "xor"]
};
var xorDocs = {
  name: "xor",
  category: "Logical",
  syntax: ["x xor y", "xor(x, y)"],
  description: "Logical exclusive or, xor. Test whether one and only one value is defined with a nonzero/nonempty value.",
  examples: ["true xor false", "false xor false", "true xor true", "0 xor 4"],
  seealso: ["not", "and", "or"]
};
var columnDocs = {
  name: "column",
  category: "Matrix",
  syntax: ["column(x, index)"],
  description: "Return a column from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "column(A, 1)", "column(A, 2)"],
  seealso: ["row", "matrixFromColumns"]
};
var concatDocs = {
  name: "concat",
  category: "Matrix",
  syntax: ["concat(A, B, C, ...)", "concat(A, B, C, ..., dim)"],
  description: "Concatenate matrices. By default, the matrices are concatenated by the last dimension. The dimension on which to concatenate can be provided as last argument.",
  examples: ["A = [1, 2; 5, 6]", "B = [3, 4; 7, 8]", "concat(A, B)", "concat(A, B, 1)", "concat(A, B, 2)"],
  seealso: ["det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var countDocs = {
  name: "count",
  category: "Matrix",
  syntax: ["count(x)"],
  description: "Count the number of elements of a matrix, array or string.",
  examples: ["a = [1, 2; 3, 4; 5, 6]", "count(a)", "size(a)", 'count("hello world")'],
  seealso: ["size"]
};
var crossDocs = {
  name: "cross",
  category: "Matrix",
  syntax: ["cross(A, B)"],
  description: "Calculate the cross product for two vectors in three dimensional space.",
  examples: ["cross([1, 1, 0],  [0, 1, 1])", "cross([3, -3, 1], [4, 9, 2])", "cross([2, 3, 4],  [5, 6, 7])"],
  seealso: ["multiply", "dot"]
};
var ctransposeDocs = {
  name: "ctranspose",
  category: "Matrix",
  syntax: ["x'", "ctranspose(x)"],
  description: "Complex Conjugate and Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "ctranspose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};
var detDocs = {
  name: "det",
  category: "Matrix",
  syntax: ["det(x)"],
  description: "Calculate the determinant of a matrix",
  examples: ["det([1, 2; 3, 4])", "det([-2, 2, 3; -1, 1, 3; 2, 0, -1])"],
  seealso: ["concat", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var diagDocs = {
  name: "diag",
  category: "Matrix",
  syntax: ["diag(x)", "diag(x, k)"],
  description: "Create a diagonal matrix or retrieve the diagonal of a matrix. When x is a vector, a matrix with the vector values on the diagonal will be returned. When x is a matrix, a vector with the diagonal values of the matrix is returned. When k is provided, the k-th diagonal will be filled in or retrieved, if k is positive, the values are placed on the super diagonal. When k is negative, the values are placed on the sub diagonal.",
  examples: ["diag(1:3)", "diag(1:3, 1)", "a = [1, 2, 3; 4, 5, 6; 7, 8, 9]", "diag(a)"],
  seealso: ["concat", "det", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var diffDocs = {
  name: "diff",
  category: "Matrix",
  syntax: ["diff(arr)", "diff(arr, dim)"],
  description: ["Create a new matrix or array with the difference of the passed matrix or array.", "Dim parameter is optional and used to indicant the dimension of the array/matrix to apply the difference", "If no dimension parameter is passed it is assumed as dimension 0", "Dimension is zero-based in javascript and one-based in the parser", "Arrays must be 'rectangular' meaning arrays like [1, 2]", "If something is passed as a matrix it will be returned as a matrix but other than that all matrices are converted to arrays"],
  examples: ["A = [1, 2, 4, 7, 0]", "diff(A)", "diff(A, 1)", "B = [[1, 2], [3, 4]]", "diff(B)", "diff(B, 1)", "diff(B, 2)", "diff(B, bignumber(2))", "diff([[1, 2], matrix([3, 4])], 2)"],
  seealso: ["subtract", "partitionSelect"]
};
var dotDocs = {
  name: "dot",
  category: "Matrix",
  syntax: ["dot(A, B)", "A * B"],
  description: "Calculate the dot product of two vectors. The dot product of A = [a1, a2, a3, ..., an] and B = [b1, b2, b3, ..., bn] is defined as dot(A, B) = a1 * b1 + a2 * b2 + a3 * b3 + ... + an * bn",
  examples: ["dot([2, 4, 1], [2, 2, 3])", "[2, 4, 1] * [2, 2, 3]"],
  seealso: ["multiply", "cross"]
};
var eigsDocs = {
  name: "eigs",
  category: "Matrix",
  syntax: ["eigs(x)"],
  description: "Calculate the eigenvalues and optionally eigenvectors of a square matrix",
  examples: ["eigs([[5, 2.3], [2.3, 1]])", "eigs([[1, 2, 3], [4, 5, 6], [7, 8, 9]], { precision: 1e-6, eigenvectors: false })"],
  seealso: ["inv"]
};
var filterDocs = {
  name: "filter",
  category: "Matrix",
  syntax: ["filter(x, test)"],
  description: "Filter items in a matrix.",
  examples: ["isPositive(x) = x > 0", "filter([6, -2, -1, 4, 3], isPositive)", "filter([6, -2, 0, 1, 0], x != 0)"],
  seealso: ["sort", "map", "forEach"]
};
var flattenDocs = {
  name: "flatten",
  category: "Matrix",
  syntax: ["flatten(x)"],
  description: "Flatten a multi dimensional matrix into a single dimensional matrix.",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "size(a)", "b = flatten(a)", "size(b)"],
  seealso: ["concat", "resize", "size", "squeeze"]
};
var forEachDocs = {
  name: "forEach",
  category: "Matrix",
  syntax: ["forEach(x, callback)"],
  description: "Iterates over all elements of a matrix/array, and executes the given callback function.",
  examples: ["numberOfPets = {}", "addPet(n) = numberOfPets[n] = (numberOfPets[n] ? numberOfPets[n]:0 ) + 1;", 'forEach(["Dog","Cat","Cat"], addPet)', "numberOfPets"],
  seealso: ["map", "sort", "filter"]
};
var getMatrixDataTypeDocs = {
  name: "getMatrixDataType",
  category: "Matrix",
  syntax: ["getMatrixDataType(x)"],
  description: 'Find the data type of all elements in a matrix or array, for example "number" if all items are a number and "Complex" if all values are complex numbers. If a matrix contains more than one data type, it will return "mixed".',
  examples: ["getMatrixDataType([1, 2, 3])", "getMatrixDataType([[5 cm], [2 inch]])", 'getMatrixDataType([1, "text"])', "getMatrixDataType([1, bignumber(4)])"],
  seealso: ["matrix", "sparse", "typeOf"]
};
var identityDocs = {
  name: "identity",
  category: "Matrix",
  syntax: ["identity(n)", "identity(m, n)", "identity([m, n])"],
  description: "Returns the identity matrix with size m-by-n. The matrix has ones on the diagonal and zeros elsewhere.",
  examples: ["identity(3)", "identity(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "identity(size(a))"],
  seealso: ["concat", "det", "diag", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var invDocs = {
  name: "inv",
  category: "Matrix",
  syntax: ["inv(x)"],
  description: "Calculate the inverse of a matrix",
  examples: ["inv([1, 2; 3, 4])", "inv(4)", "1 / 4"],
  seealso: ["concat", "det", "diag", "identity", "ones", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var pinvDocs = {
  name: "pinv",
  category: "Matrix",
  syntax: ["pinv(x)"],
  description: "Calculate the MoorePenrose inverse of a matrix",
  examples: ["pinv([1, 2; 3, 4])", "pinv([[1, 0], [0, 1], [0, 1]])", "pinv(4)"],
  seealso: ["inv"]
};
var kronDocs = {
  name: "kron",
  category: "Matrix",
  syntax: ["kron(x, y)"],
  description: "Calculates the kronecker product of 2 matrices or vectors.",
  examples: ["kron([[1, 0], [0, 1]], [[1, 2], [3, 4]])", "kron([1,1], [2,3,4])"],
  seealso: ["multiply", "dot", "cross"]
};
var mapDocs = {
  name: "map",
  category: "Matrix",
  syntax: ["map(x, callback)"],
  description: "Create a new matrix or array with the results of the callback function executed on each entry of the matrix/array.",
  examples: ["map([1, 2, 3], square)"],
  seealso: ["filter", "forEach"]
};
var matrixFromColumnsDocs = {
  name: "matrixFromColumns",
  category: "Matrix",
  syntax: ["matrixFromColumns(...arr)", "matrixFromColumns(row1, row2)", "matrixFromColumns(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual columns.",
  examples: ["matrixFromColumns([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromRows", "matrixFromFunction", "zeros"]
};
var matrixFromFunctionDocs = {
  name: "matrixFromFunction",
  category: "Matrix",
  syntax: ["matrixFromFunction(size, fn)", "matrixFromFunction(size, fn, format)", "matrixFromFunction(size, fn, format, datatype)", "matrixFromFunction(size, format, fn)", "matrixFromFunction(size, format, datatype, fn)"],
  description: "Create a matrix by evaluating a generating function at each index.",
  examples: ["f(I) = I[1] - I[2]", "matrixFromFunction([3,3], f)", "g(I) = I[1] - I[2] == 1 ? 4 : 0", 'matrixFromFunction([100, 100], "sparse", g)', "matrixFromFunction([5], random)"],
  seealso: ["matrix", "matrixFromRows", "matrixFromColumns", "zeros"]
};
var matrixFromRowsDocs = {
  name: "matrixFromRows",
  category: "Matrix",
  syntax: ["matrixFromRows(...arr)", "matrixFromRows(row1, row2)", "matrixFromRows(row1, row2, row3)"],
  description: "Create a dense matrix from vectors as individual rows.",
  examples: ["matrixFromRows([1, 2, 3], [[4],[5],[6]])"],
  seealso: ["matrix", "matrixFromColumns", "matrixFromFunction", "zeros"]
};
var onesDocs = {
  name: "ones",
  category: "Matrix",
  syntax: ["ones(m)", "ones(m, n)", "ones(m, n, p, ...)", "ones([m])", "ones([m, n])", "ones([m, n, p, ...])"],
  description: "Create a matrix containing ones.",
  examples: ["ones(3)", "ones(3, 5)", "ones([2,3]) * 4.5", "a = [1, 2, 3; 4, 5, 6]", "ones(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "range", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var partitionSelectDocs = {
  name: "partitionSelect",
  category: "Matrix",
  syntax: ["partitionSelect(x, k)", "partitionSelect(x, k, compare)"],
  description: "Partition-based selection of an array or 1D matrix. Will find the kth smallest value, and mutates the input array. Uses Quickselect.",
  examples: ["partitionSelect([5, 10, 1], 2)", 'partitionSelect(["C", "B", "A", "D"], 1, compareText)', "arr = [5, 2, 1]", "partitionSelect(arr, 0) # returns 1, arr is now: [1, 2, 5]", "arr", "partitionSelect(arr, 1, 'desc') # returns 2, arr is now: [5, 2, 1]", "arr"],
  seealso: ["sort"]
};
var rangeDocs = {
  name: "range",
  category: "Type",
  syntax: ["start:end", "start:step:end", "range(start, end)", "range(start, end, step)", "range(string)"],
  description: "Create a range. Lower bound of the range is included, upper bound is excluded.",
  examples: ["1:5", "3:-1:-3", "range(3, 7)", "range(0, 12, 2)", 'range("4:10")', "range(1m, 1m, 3m)", "a = [1, 2, 3, 4; 5, 6, 7, 8]", "a[1:2, 1:2]"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "size", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var reshapeDocs = {
  name: "reshape",
  category: "Matrix",
  syntax: ["reshape(x, sizes)"],
  description: "Reshape a multi dimensional array to fit the specified dimensions.",
  examples: ["reshape([1, 2, 3, 4, 5, 6], [2, 3])", "reshape([[1, 2], [3, 4]], [1, 4])", "reshape([[1, 2], [3, 4]], [4])", "reshape([1, 2, 3, 4], [-1, 2])"],
  seealso: ["size", "squeeze", "resize"]
};
var resizeDocs = {
  name: "resize",
  category: "Matrix",
  syntax: ["resize(x, size)", "resize(x, size, defaultValue)"],
  description: "Resize a matrix.",
  examples: ["resize([1,2,3,4,5], [3])", "resize([1,2,3], [5])", "resize([1,2,3], [5], -1)", "resize(2, [2, 3])", 'resize("hello", [8], "!")'],
  seealso: ["size", "subset", "squeeze", "reshape"]
};
var rotateDocs = {
  name: "rotate",
  category: "Matrix",
  syntax: ["rotate(w, theta)", "rotate(w, theta, v)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotate([1, 0], pi / 2)", 'rotate(matrix([1, 0]), unit("35deg"))', 'rotate([1, 0, 0], unit("90deg"), [0, 0, 1])', 'rotate(matrix([1, 0, 0]), unit("90deg"), matrix([0, 0, 1]))'],
  seealso: ["matrix", "rotationMatrix"]
};
var rotationMatrixDocs = {
  name: "rotationMatrix",
  category: "Matrix",
  syntax: ["rotationMatrix(theta)", "rotationMatrix(theta, v)", "rotationMatrix(theta, v, format)"],
  description: "Returns a 2-D rotation matrix (2x2) for a given angle (in radians). Returns a 2-D rotation matrix (3x3) of a given angle (in radians) around given axis.",
  examples: ["rotationMatrix(pi / 2)", 'rotationMatrix(unit("45deg"), [0, 0, 1])', 'rotationMatrix(1, matrix([0, 0, 1]), "sparse")'],
  seealso: ["cos", "sin"]
};
var rowDocs = {
  name: "row",
  category: "Matrix",
  syntax: ["row(x, index)"],
  description: "Return a row from a matrix or array.",
  examples: ["A = [[1, 2], [3, 4]]", "row(A, 1)", "row(A, 2)"],
  seealso: ["column", "matrixFromRows"]
};
var sizeDocs = {
  name: "size",
  category: "Matrix",
  syntax: ["size(x)"],
  description: "Calculate the size of a matrix.",
  examples: ["size(2.3)", 'size("hello world")', "a = [1, 2; 3, 4; 5, 6]", "size(a)", "size(1:6)"],
  seealso: ["concat", "count", "det", "diag", "identity", "inv", "ones", "range", "squeeze", "subset", "trace", "transpose", "zeros"]
};
var sortDocs = {
  name: "sort",
  category: "Matrix",
  syntax: ["sort(x)", "sort(x, compare)"],
  description: 'Sort the items in a matrix. Compare can be a string "asc", "desc", "natural", or a custom sort function.',
  examples: ["sort([5, 10, 1])", 'sort(["C", "B", "A", "D"], "natural")', "sortByLength(a, b) = size(a)[1] - size(b)[1]", 'sort(["Langdon", "Tom", "Sara"], sortByLength)', 'sort(["10", "1", "2"], "natural")'],
  seealso: ["map", "filter", "forEach"]
};
var squeezeDocs = {
  name: "squeeze",
  category: "Matrix",
  syntax: ["squeeze(x)"],
  description: "Remove inner and outer singleton dimensions from a matrix.",
  examples: ["a = zeros(3,2,1)", "size(squeeze(a))", "b = zeros(1,1,3)", "size(squeeze(b))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "subset", "trace", "transpose", "zeros"]
};
var subsetDocs = {
  name: "subset",
  category: "Matrix",
  syntax: ["value(index)", "value(index) = replacement", "subset(value, [index])", "subset(value, [index], replacement)"],
  description: "Get or set a subset of the entries of a matrix or characters of a string. Indexes are one-based. There should be one index specification for each dimension of the target. Each specification can be a single index, a list of indices, or a range in colon notation `l:u`. In a range, both the lower bound l and upper bound u are included; and if a bound is omitted it defaults to the most extreme valid value. The cartesian product of the indices specified in each dimension determines the target of the operation.",
  examples: ["d = [1, 2; 3, 4]", "e = []", "e[1, 1:2] = [5, 6]", "e[2, :] = [7, 8]", "f = d * e", "f[2, 1]", "f[:, 1]", "f[[1,2], [1,3]] = [9, 10; 11, 12]", "f"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "trace", "transpose", "zeros"]
};
var traceDocs = {
  name: "trace",
  category: "Matrix",
  syntax: ["trace(A)"],
  description: "Calculate the trace of a matrix: the sum of the elements on the main diagonal of a square matrix.",
  examples: ["A = [1, 2, 3; -1, 2, 3; 2, 0, 3]", "trace(A)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "transpose", "zeros"]
};
var transposeDocs = {
  name: "transpose",
  category: "Matrix",
  syntax: ["x'", "transpose(x)"],
  description: "Transpose a matrix",
  examples: ["a = [1, 2, 3; 4, 5, 6]", "a'", "transpose(a)"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "zeros"]
};
var zerosDocs = {
  name: "zeros",
  category: "Matrix",
  syntax: ["zeros(m)", "zeros(m, n)", "zeros(m, n, p, ...)", "zeros([m])", "zeros([m, n])", "zeros([m, n, p, ...])"],
  description: "Create a matrix containing zeros.",
  examples: ["zeros(3)", "zeros(3, 5)", "a = [1, 2, 3; 4, 5, 6]", "zeros(size(a))"],
  seealso: ["concat", "det", "diag", "identity", "inv", "ones", "range", "size", "squeeze", "subset", "trace", "transpose"]
};
var fftDocs = {
  name: "fft",
  category: "Matrix",
  syntax: ["fft(x)"],
  description: "Calculate N-dimensional fourier transform",
  examples: ["fft([[1, 0], [1, 0]])"],
  seealso: ["ifft"]
};
var ifftDocs = {
  name: "ifft",
  category: "Matrix",
  syntax: ["ifft(x)"],
  description: "Calculate N-dimensional inverse fourier transform",
  examples: ["ifft([[2, 2], [0, 0]])"],
  seealso: ["fft"]
};
var combinationsDocs = {
  name: "combinations",
  category: "Probability",
  syntax: ["combinations(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time",
  examples: ["combinations(7, 5)"],
  seealso: ["combinationsWithRep", "permutations", "factorial"]
};
var combinationsWithRepDocs = {
  name: "combinationsWithRep",
  category: "Probability",
  syntax: ["combinationsWithRep(n, k)"],
  description: "Compute the number of combinations of n items taken k at a time with replacements.",
  examples: ["combinationsWithRep(7, 5)"],
  seealso: ["combinations", "permutations", "factorial"]
};
var factorialDocs = {
  name: "factorial",
  category: "Probability",
  syntax: ["n!", "factorial(n)"],
  description: "Compute the factorial of a value",
  examples: ["5!", "5 * 4 * 3 * 2 * 1", "3!"],
  seealso: ["combinations", "combinationsWithRep", "permutations", "gamma"]
};
var gammaDocs = {
  name: "gamma",
  category: "Probability",
  syntax: ["gamma(n)"],
  description: "Compute the gamma function. For small values, the Lanczos approximation is used, and for large values the extended Stirling approximation.",
  examples: ["gamma(4)", "3!", "gamma(1/2)", "sqrt(pi)"],
  seealso: ["factorial"]
};
var lgammaDocs = {
  name: "lgamma",
  category: "Probability",
  syntax: ["lgamma(n)"],
  description: "Logarithm of the gamma function for real, positive numbers and complex numbers, using Lanczos approximation for numbers and Stirling series for complex numbers.",
  examples: ["lgamma(4)", "lgamma(1/2)", "lgamma(i)", "lgamma(complex(1.1, 2))"],
  seealso: ["gamma"]
};
var kldivergenceDocs = {
  name: "kldivergence",
  category: "Probability",
  syntax: ["kldivergence(x, y)"],
  description: "Calculate the Kullback-Leibler (KL) divergence  between two distributions.",
  examples: ["kldivergence([0.7,0.5,0.4], [0.2,0.9,0.5])"],
  seealso: []
};
var multinomialDocs = {
  name: "multinomial",
  category: "Probability",
  syntax: ["multinomial(A)"],
  description: "Multinomial Coefficients compute the number of ways of picking a1, a2, ..., ai unordered outcomes from `n` possibilities. multinomial takes one array of integers as an argument. The following condition must be enforced: every ai > 0.",
  examples: ["multinomial([1, 2, 1])"],
  seealso: ["combinations", "factorial"]
};
var permutationsDocs = {
  name: "permutations",
  category: "Probability",
  syntax: ["permutations(n)", "permutations(n, k)"],
  description: "Compute the number of permutations of n items taken k at a time",
  examples: ["permutations(5)", "permutations(5, 3)"],
  seealso: ["combinations", "combinationsWithRep", "factorial"]
};
var pickRandomDocs = {
  name: "pickRandom",
  category: "Probability",
  syntax: ["pickRandom(array)", "pickRandom(array, number)", "pickRandom(array, weights)", "pickRandom(array, number, weights)", "pickRandom(array, weights, number)"],
  description: "Pick a random entry from a given array.",
  examples: ["pickRandom(0:10)", "pickRandom([1, 3, 1, 6])", "pickRandom([1, 3, 1, 6], 2)", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], 2, [2, 3, 2, 1])", "pickRandom([1, 3, 1, 6], [2, 3, 2, 1], 2)"],
  seealso: ["random", "randomInt"]
};
var randomDocs = {
  name: "random",
  category: "Probability",
  syntax: ["random()", "random(max)", "random(min, max)", "random(size)", "random(size, max)", "random(size, min, max)"],
  description: "Return a random number.",
  examples: ["random()", "random(10, 20)", "random([2, 3])"],
  seealso: ["pickRandom", "randomInt"]
};
var randomIntDocs = {
  name: "randomInt",
  category: "Probability",
  syntax: ["randomInt(max)", "randomInt(min, max)", "randomInt(size)", "randomInt(size, max)", "randomInt(size, min, max)"],
  description: "Return a random integer number",
  examples: ["randomInt(10, 20)", "randomInt([2, 3], 10)"],
  seealso: ["pickRandom", "random"]
};
var compareDocs = {
  name: "compare",
  category: "Relational",
  syntax: ["compare(x, y)"],
  description: "Compare two values. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compare(2, 3)", "compare(3, 2)", "compare(2, 2)", "compare(5cm, 40mm)", "compare(2, [1, 2, 3])"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compareNatural", "compareText"]
};
var compareNaturalDocs = {
  name: "compareNatural",
  category: "Relational",
  syntax: ["compareNatural(x, y)"],
  description: "Compare two values of any type in a deterministic, natural way. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ["compareNatural(2, 3)", "compareNatural(3, 2)", "compareNatural(2, 2)", "compareNatural(5cm, 40mm)", 'compareNatural("2", "10")', "compareNatural(2 + 3i, 2 + 4i)", "compareNatural([1, 2, 4], [1, 2, 3])", "compareNatural([1, 5], [1, 2, 3])", "compareNatural([1, 2], [1, 2])", "compareNatural({a: 2}, {a: 4})"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare", "compareText"]
};
var compareTextDocs = {
  name: "compareText",
  category: "Relational",
  syntax: ["compareText(x, y)"],
  description: "Compare two strings lexically. Comparison is case sensitive. Returns 1 when x > y, -1 when x < y, and 0 when x == y.",
  examples: ['compareText("B", "A")', 'compareText("A", "B")', 'compareText("A", "A")', 'compareText("2", "10")', 'compare("2", "10")', "compare(2, 10)", 'compareNatural("2", "10")', 'compareText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural"]
};
var deepEqualDocs = {
  name: "deepEqual",
  category: "Relational",
  syntax: ["deepEqual(x, y)"],
  description: "Check equality of two matrices element wise. Returns true if the size of both matrices is equal and when and each of the elements are equal.",
  examples: ["deepEqual([1,3,4], [1,3,4])", "deepEqual([1,3,4], [1,3])"],
  seealso: ["equal", "unequal", "smaller", "larger", "smallerEq", "largerEq", "compare"]
};
var equalDocs = {
  name: "equal",
  category: "Relational",
  syntax: ["x == y", "equal(x, y)"],
  description: "Check equality of two values. Returns true if the values are equal, and false if not.",
  examples: ["2+2 == 3", "2+2 == 4", "a = 3.2", "b = 6-2.8", "a == b", "50cm == 0.5m"],
  seealso: ["unequal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual", "equalText"]
};
var equalTextDocs = {
  name: "equalText",
  category: "Relational",
  syntax: ["equalText(x, y)"],
  description: "Check equality of two strings. Comparison is case sensitive. Returns true if the values are equal, and false if not.",
  examples: ['equalText("Hello", "Hello")', 'equalText("a", "A")', 'equal("2e3", "2000")', 'equalText("2e3", "2000")', 'equalText("B", ["A", "B", "C"])'],
  seealso: ["compare", "compareNatural", "compareText", "equal"]
};
var largerDocs = {
  name: "larger",
  category: "Relational",
  syntax: ["x > y", "larger(x, y)"],
  description: "Check if value x is larger than y. Returns true if x is larger than y, and false if not.",
  examples: ["2 > 3", "5 > 2*2", "a = 3.3", "b = 6-2.8", "(a > b)", "(b < a)", "5 cm > 2 inch"],
  seealso: ["equal", "unequal", "smaller", "smallerEq", "largerEq", "compare"]
};
var largerEqDocs = {
  name: "largerEq",
  category: "Relational",
  syntax: ["x >= y", "largerEq(x, y)"],
  description: "Check if value x is larger or equal to y. Returns true if x is larger or equal to y, and false if not.",
  examples: ["2 >= 1+1", "2 > 1+1", "a = 3.2", "b = 6-2.8", "(a >= b)"],
  seealso: ["equal", "unequal", "smallerEq", "smaller", "compare"]
};
var smallerDocs = {
  name: "smaller",
  category: "Relational",
  syntax: ["x < y", "smaller(x, y)"],
  description: "Check if value x is smaller than value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 < 3", "5 < 2*2", "a = 3.3", "b = 6-2.8", "(a < b)", "5 cm < 2 inch"],
  seealso: ["equal", "unequal", "larger", "smallerEq", "largerEq", "compare"]
};
var smallerEqDocs = {
  name: "smallerEq",
  category: "Relational",
  syntax: ["x <= y", "smallerEq(x, y)"],
  description: "Check if value x is smaller or equal to value y. Returns true if x is smaller than y, and false if not.",
  examples: ["2 <= 1+1", "2 < 1+1", "a = 3.2", "b = 6-2.8", "(a <= b)"],
  seealso: ["equal", "unequal", "larger", "smaller", "largerEq", "compare"]
};
var unequalDocs = {
  name: "unequal",
  category: "Relational",
  syntax: ["x != y", "unequal(x, y)"],
  description: "Check unequality of two values. Returns true if the values are unequal, and false if they are equal.",
  examples: ["2+2 != 3", "2+2 != 4", "a = 3.2", "b = 6-2.8", "a != b", "50cm != 0.5m", "5 cm != 2 inch"],
  seealso: ["equal", "smaller", "larger", "smallerEq", "largerEq", "compare", "deepEqual"]
};
var setCartesianDocs = {
  name: "setCartesian",
  category: "Set",
  syntax: ["setCartesian(set1, set2)"],
  description: "Create the cartesian product of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays and the values will be sorted in ascending order before the operation.",
  examples: ["setCartesian([1, 2], [3, 4])"],
  seealso: ["setUnion", "setIntersect", "setDifference", "setPowerset"]
};
var setDifferenceDocs = {
  name: "setDifference",
  category: "Set",
  syntax: ["setDifference(set1, set2)"],
  description: "Create the difference of two (multi)sets: every element of set1, that is not the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setSymDifference"]
};
var setDistinctDocs = {
  name: "setDistinct",
  category: "Set",
  syntax: ["setDistinct(set)"],
  description: "Collect the distinct elements of a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setDistinct([1, 1, 1, 2, 2, 3])"],
  seealso: ["setMultiplicity"]
};
var setIntersectDocs = {
  name: "setIntersect",
  category: "Set",
  syntax: ["setIntersect(set1, set2)"],
  description: "Create the intersection of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIntersect([1, 2, 3, 4], [3, 4, 5, 6])", "setIntersect([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setDifference"]
};
var setIsSubsetDocs = {
  name: "setIsSubset",
  category: "Set",
  syntax: ["setIsSubset(set1, set2)"],
  description: "Check whether a (multi)set is a subset of another (multi)set: every element of set1 is the element of set2. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setIsSubset([1, 2], [3, 4, 5, 6])", "setIsSubset([3, 4], [3, 4, 5, 6])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};
var setMultiplicityDocs = {
  name: "setMultiplicity",
  category: "Set",
  syntax: ["setMultiplicity(element, set)"],
  description: "Count the multiplicity of an element in a multiset. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setMultiplicity(1, [1, 2, 2, 4])", "setMultiplicity(2, [1, 2, 2, 4])"],
  seealso: ["setDistinct", "setSize"]
};
var setPowersetDocs = {
  name: "setPowerset",
  category: "Set",
  syntax: ["setPowerset(set)"],
  description: "Create the powerset of a (multi)set: the powerset contains very possible subsets of a (multi)set. A multi-dimension array will be converted to a single-dimension array before the operation.",
  examples: ["setPowerset([1, 2, 3])"],
  seealso: ["setCartesian"]
};
var setSizeDocs = {
  name: "setSize",
  category: "Set",
  syntax: ["setSize(set)", "setSize(set, unique)"],
  description: 'Count the number of elements of a (multi)set. When the second parameter "unique" is true, count only the unique values. A multi-dimension array will be converted to a single-dimension array before the operation.',
  examples: ["setSize([1, 2, 2, 4])", "setSize([1, 2, 2, 4], true)"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};
var setSymDifferenceDocs = {
  name: "setSymDifference",
  category: "Set",
  syntax: ["setSymDifference(set1, set2)"],
  description: "Create the symmetric difference of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setSymDifference([1, 2, 3, 4], [3, 4, 5, 6])", "setSymDifference([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setUnion", "setIntersect", "setDifference"]
};
var setUnionDocs = {
  name: "setUnion",
  category: "Set",
  syntax: ["setUnion(set1, set2)"],
  description: "Create the union of two (multi)sets. Multi-dimension arrays will be converted to single-dimension arrays before the operation.",
  examples: ["setUnion([1, 2, 3, 4], [3, 4, 5, 6])", "setUnion([[1, 2], [3, 4]], [[3, 4], [5, 6]])"],
  seealso: ["setIntersect", "setDifference"]
};
var zpk2tfDocs = {
  name: "zpk2tf",
  category: "Signal",
  syntax: ["zpk2tf(z, p, k)"],
  description: "Compute the transfer function of a zero-pole-gain model.",
  examples: ["zpk2tf([1, 2], [-1, -2], 1)", "zpk2tf([1, 2], [-1, -2])", "zpk2tf([1 - 3i, 2 + 2i], [-1, -2])"],
  seealso: []
};
var freqzDocs = {
  name: "freqz",
  category: "Signal",
  syntax: ["freqz(b, a)", "freqz(b, a, w)"],
  description: "Calculates the frequency response of a filter given its numerator and denominator coefficients.",
  examples: ["freqz([1, 2], [1, 2, 3])", "freqz([1, 2], [1, 2, 3], [0, 1])", "freqz([1, 2], [1, 2, 3], 512)"],
  seealso: []
};
var erfDocs = {
  name: "erf",
  category: "Special",
  syntax: ["erf(x)"],
  description: "Compute the erf function of a value using a rational Chebyshev approximations for different intervals of x",
  examples: ["erf(0.2)", "erf(-0.5)", "erf(4)"],
  seealso: []
};
var zetaDocs = {
  name: "zeta",
  category: "Special",
  syntax: ["zeta(s)"],
  description: "Compute the Riemann Zeta Function using an infinite series and Riemanns Functional Equation for the entire complex plane",
  examples: ["zeta(0.2)", "zeta(-0.5)", "zeta(4)"],
  seealso: []
};
var madDocs = {
  name: "mad",
  category: "Statistics",
  syntax: ["mad(a, b, c, ...)", "mad(A)"],
  description: "Compute the median absolute deviation of a matrix or a list with values. The median absolute deviation is defined as the median of the absolute deviations from the median.",
  examples: ["mad(10, 20, 30)", "mad([1, 2, 3])"],
  seealso: ["mean", "median", "std", "abs"]
};
var maxDocs = {
  name: "max",
  category: "Statistics",
  syntax: ["max(a, b, c, ...)", "max(A)", "max(A, dimension)"],
  description: "Compute the maximum value of a list of values.",
  examples: ["max(2, 3, 4, 1)", "max([2, 3, 4, 1])", "max([2, 5; 4, 3])", "max([2, 5; 4, 3], 1)", "max([2, 5; 4, 3], 2)", "max(2.7, 7.1, -4.5, 2.0, 4.1)", "min(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["mean", "median", "min", "prod", "std", "sum", "variance"]
};
var meanDocs = {
  name: "mean",
  category: "Statistics",
  syntax: ["mean(a, b, c, ...)", "mean(A)", "mean(A, dimension)"],
  description: "Compute the arithmetic mean of a list of values.",
  examples: ["mean(2, 3, 4, 1)", "mean([2, 3, 4, 1])", "mean([2, 5; 4, 3])", "mean([2, 5; 4, 3], 1)", "mean([2, 5; 4, 3], 2)", "mean([1.0, 2.7, 3.2, 4.0])"],
  seealso: ["max", "median", "min", "prod", "std", "sum", "variance"]
};
var medianDocs = {
  name: "median",
  category: "Statistics",
  syntax: ["median(a, b, c, ...)", "median(A)"],
  description: "Compute the median of all values. The values are sorted and the middle value is returned. In case of an even number of values, the average of the two middle values is returned.",
  examples: ["median(5, 2, 7)", "median([3, -1, 5, 7])"],
  seealso: ["max", "mean", "min", "prod", "std", "sum", "variance", "quantileSeq"]
};
var minDocs = {
  name: "min",
  category: "Statistics",
  syntax: ["min(a, b, c, ...)", "min(A)", "min(A, dimension)"],
  description: "Compute the minimum value of a list of values.",
  examples: ["min(2, 3, 4, 1)", "min([2, 3, 4, 1])", "min([2, 5; 4, 3])", "min([2, 5; 4, 3], 1)", "min([2, 5; 4, 3], 2)", "min(2.7, 7.1, -4.5, 2.0, 4.1)", "max(2.7, 7.1, -4.5, 2.0, 4.1)"],
  seealso: ["max", "mean", "median", "prod", "std", "sum", "variance"]
};
var modeDocs = {
  name: "mode",
  category: "Statistics",
  syntax: ["mode(a, b, c, ...)", "mode(A)", "mode(A, a, b, B, c, ...)"],
  description: "Computes the mode of all values as an array. In case mode being more than one, multiple values are returned in an array.",
  examples: ["mode(2, 1, 4, 3, 1)", "mode([1, 2.7, 3.2, 4, 2.7])", "mode(1, 4, 6, 1, 6)"],
  seealso: ["max", "mean", "min", "median", "prod", "std", "sum", "variance"]
};
var prodDocs = {
  name: "prod",
  category: "Statistics",
  syntax: ["prod(a, b, c, ...)", "prod(A)"],
  description: "Compute the product of all values.",
  examples: ["prod(2, 3, 4)", "prod([2, 3, 4])", "prod([2, 5; 4, 3])"],
  seealso: ["max", "mean", "min", "median", "min", "std", "sum", "variance"]
};
var quantileSeqDocs = {
  name: "quantileSeq",
  category: "Statistics",
  syntax: ["quantileSeq(A, prob[, sorted])", "quantileSeq(A, [prob1, prob2, ...][, sorted])", "quantileSeq(A, N[, sorted])"],
  description: "Compute the prob order quantile of a matrix or a list with values. The sequence is sorted and the middle value is returned. Supported types of sequence values are: Number, BigNumber, Unit Supported types of probablity are: Number, BigNumber. \n\nIn case of a (multi dimensional) array or matrix, the prob order quantile of all elements will be calculated.",
  examples: ["quantileSeq([3, -1, 5, 7], 0.5)", "quantileSeq([3, -1, 5, 7], [1/3, 2/3])", "quantileSeq([3, -1, 5, 7], 2)", "quantileSeq([-1, 3, 5, 7], 0.5, true)"],
  seealso: ["mean", "median", "min", "max", "prod", "std", "sum", "variance"]
};
var stdDocs = {
  name: "std",
  category: "Statistics",
  syntax: ["std(a, b, c, ...)", "std(A)", "std(A, dimension)", "std(A, normalization)", "std(A, dimension, normalization)"],
  description: 'Compute the standard deviation of all values, defined as std(A) = sqrt(variance(A)). Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["std(2, 4, 6)", "std([2, 4, 6, 8])", 'std([2, 4, 6, 8], "uncorrected")', 'std([2, 4, 6, 8], "biased")', "std([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "prod", "sum", "variance"]
};
var cumSumDocs = {
  name: "cumsum",
  category: "Statistics",
  syntax: ["cumsum(a, b, c, ...)", "cumsum(A)"],
  description: "Compute the cumulative sum of all values.",
  examples: ["cumsum(2, 3, 4, 1)", "cumsum([2, 3, 4, 1])", "cumsum([1, 2; 3, 4])", "cumsum([1, 2; 3, 4], 1)", "cumsum([1, 2; 3, 4], 2)"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};
var sumDocs = {
  name: "sum",
  category: "Statistics",
  syntax: ["sum(a, b, c, ...)", "sum(A)", "sum(A, dimension)"],
  description: "Compute the sum of all values.",
  examples: ["sum(2, 3, 4, 1)", "sum([2, 3, 4, 1])", "sum([2, 5; 4, 3])"],
  seealso: ["max", "mean", "median", "min", "prod", "std", "sum", "variance"]
};
var varianceDocs = {
  name: "variance",
  category: "Statistics",
  syntax: ["variance(a, b, c, ...)", "variance(A)", "variance(A, dimension)", "variance(A, normalization)", "variance(A, dimension, normalization)"],
  description: 'Compute the variance of all values. Optional parameter normalization can be "unbiased" (default), "uncorrected", or "biased".',
  examples: ["variance(2, 4, 6)", "variance([2, 4, 6, 8])", 'variance([2, 4, 6, 8], "uncorrected")', 'variance([2, 4, 6, 8], "biased")', "variance([1, 2, 3; 4, 5, 6])"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};
var corrDocs = {
  name: "corr",
  category: "Statistics",
  syntax: ["corr(A,B)"],
  description: "Compute the correlation coefficient of a two list with values, For matrices, the matrix correlation coefficient is calculated.",
  examples: ["corr([2, 4, 6, 8],[1, 2, 3, 6])", "corr(matrix([[1, 2.2, 3, 4.8, 5], [1, 2, 3, 4, 5]]), matrix([[4, 5.3, 6.6, 7, 8], [1, 2, 3, 4, 5]]))"],
  seealso: ["max", "mean", "min", "median", "min", "prod", "std", "sum"]
};
var acosDocs = {
  name: "acos",
  category: "Trigonometry",
  syntax: ["acos(x)"],
  description: "Compute the inverse cosine of a value in radians.",
  examples: ["acos(0.5)", "acos(cos(2.3))"],
  seealso: ["cos", "atan", "asin"]
};
var acoshDocs = {
  name: "acosh",
  category: "Trigonometry",
  syntax: ["acosh(x)"],
  description: "Calculate the hyperbolic arccos of a value, defined as `acosh(x) = ln(sqrt(x^2 - 1) + x)`.",
  examples: ["acosh(1.5)"],
  seealso: ["cosh", "asinh", "atanh"]
};
var acotDocs = {
  name: "acot",
  category: "Trigonometry",
  syntax: ["acot(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acot(0.5)", "acot(cot(0.5))", "acot(2)"],
  seealso: ["cot", "atan"]
};
var acothDocs = {
  name: "acoth",
  category: "Trigonometry",
  syntax: ["acoth(x)"],
  description: "Calculate the hyperbolic arccotangent of a value, defined as `acoth(x) = (ln((x+1)/x) + ln(x/(x-1))) / 2`.",
  examples: ["acoth(2)", "acoth(0.5)"],
  seealso: ["acsch", "asech"]
};
var acscDocs = {
  name: "acsc",
  category: "Trigonometry",
  syntax: ["acsc(x)"],
  description: "Calculate the inverse cotangent of a value.",
  examples: ["acsc(2)", "acsc(csc(0.5))", "acsc(0.5)"],
  seealso: ["csc", "asin", "asec"]
};
var acschDocs = {
  name: "acsch",
  category: "Trigonometry",
  syntax: ["acsch(x)"],
  description: "Calculate the hyperbolic arccosecant of a value, defined as `acsch(x) = ln(1/x + sqrt(1/x^2 + 1))`.",
  examples: ["acsch(0.5)"],
  seealso: ["asech", "acoth"]
};
var asecDocs = {
  name: "asec",
  category: "Trigonometry",
  syntax: ["asec(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asec(0.5)", "asec(sec(0.5))", "asec(2)"],
  seealso: ["acos", "acot", "acsc"]
};
var asechDocs = {
  name: "asech",
  category: "Trigonometry",
  syntax: ["asech(x)"],
  description: "Calculate the inverse secant of a value.",
  examples: ["asech(0.5)"],
  seealso: ["acsch", "acoth"]
};
var asinDocs = {
  name: "asin",
  category: "Trigonometry",
  syntax: ["asin(x)"],
  description: "Compute the inverse sine of a value in radians.",
  examples: ["asin(0.5)", "asin(sin(0.5))"],
  seealso: ["sin", "acos", "atan"]
};
var asinhDocs = {
  name: "asinh",
  category: "Trigonometry",
  syntax: ["asinh(x)"],
  description: "Calculate the hyperbolic arcsine of a value, defined as `asinh(x) = ln(x + sqrt(x^2 + 1))`.",
  examples: ["asinh(0.5)"],
  seealso: ["acosh", "atanh"]
};
var atanDocs = {
  name: "atan",
  category: "Trigonometry",
  syntax: ["atan(x)"],
  description: "Compute the inverse tangent of a value in radians.",
  examples: ["atan(0.5)", "atan(tan(0.5))"],
  seealso: ["tan", "acos", "asin"]
};
var atan2Docs = {
  name: "atan2",
  category: "Trigonometry",
  syntax: ["atan2(y, x)"],
  description: "Computes the principal value of the arc tangent of y/x in radians.",
  examples: ["atan2(2, 2) / pi", "angle = 60 deg in rad", "x = cos(angle)", "y = sin(angle)", "atan2(y, x)"],
  seealso: ["sin", "cos", "tan"]
};
var atanhDocs = {
  name: "atanh",
  category: "Trigonometry",
  syntax: ["atanh(x)"],
  description: "Calculate the hyperbolic arctangent of a value, defined as `atanh(x) = ln((1 + x)/(1 - x)) / 2`.",
  examples: ["atanh(0.5)"],
  seealso: ["acosh", "asinh"]
};
var cosDocs = {
  name: "cos",
  category: "Trigonometry",
  syntax: ["cos(x)"],
  description: "Compute the cosine of x in radians.",
  examples: ["cos(2)", "cos(pi / 4) ^ 2", "cos(180 deg)", "cos(60 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["acos", "sin", "tan"]
};
var coshDocs = {
  name: "cosh",
  category: "Trigonometry",
  syntax: ["cosh(x)"],
  description: "Compute the hyperbolic cosine of x in radians.",
  examples: ["cosh(0.5)"],
  seealso: ["sinh", "tanh", "coth"]
};
var cotDocs = {
  name: "cot",
  category: "Trigonometry",
  syntax: ["cot(x)"],
  description: "Compute the cotangent of x in radians. Defined as 1/tan(x)",
  examples: ["cot(2)", "1 / tan(2)"],
  seealso: ["sec", "csc", "tan"]
};
var cothDocs = {
  name: "coth",
  category: "Trigonometry",
  syntax: ["coth(x)"],
  description: "Compute the hyperbolic cotangent of x in radians.",
  examples: ["coth(2)", "1 / tanh(2)"],
  seealso: ["sech", "csch", "tanh"]
};
var cscDocs = {
  name: "csc",
  category: "Trigonometry",
  syntax: ["csc(x)"],
  description: "Compute the cosecant of x in radians. Defined as 1/sin(x)",
  examples: ["csc(2)", "1 / sin(2)"],
  seealso: ["sec", "cot", "sin"]
};
var cschDocs = {
  name: "csch",
  category: "Trigonometry",
  syntax: ["csch(x)"],
  description: "Compute the hyperbolic cosecant of x in radians. Defined as 1/sinh(x)",
  examples: ["csch(2)", "1 / sinh(2)"],
  seealso: ["sech", "coth", "sinh"]
};
var secDocs = {
  name: "sec",
  category: "Trigonometry",
  syntax: ["sec(x)"],
  description: "Compute the secant of x in radians. Defined as 1/cos(x)",
  examples: ["sec(2)", "1 / cos(2)"],
  seealso: ["cot", "csc", "cos"]
};
var sechDocs = {
  name: "sech",
  category: "Trigonometry",
  syntax: ["sech(x)"],
  description: "Compute the hyperbolic secant of x in radians. Defined as 1/cosh(x)",
  examples: ["sech(2)", "1 / cosh(2)"],
  seealso: ["coth", "csch", "cosh"]
};
var sinDocs = {
  name: "sin",
  category: "Trigonometry",
  syntax: ["sin(x)"],
  description: "Compute the sine of x in radians.",
  examples: ["sin(2)", "sin(pi / 4) ^ 2", "sin(90 deg)", "sin(30 deg)", "sin(0.2)^2 + cos(0.2)^2"],
  seealso: ["asin", "cos", "tan"]
};
var sinhDocs = {
  name: "sinh",
  category: "Trigonometry",
  syntax: ["sinh(x)"],
  description: "Compute the hyperbolic sine of x in radians.",
  examples: ["sinh(0.5)"],
  seealso: ["cosh", "tanh"]
};
var tanDocs = {
  name: "tan",
  category: "Trigonometry",
  syntax: ["tan(x)"],
  description: "Compute the tangent of x in radians.",
  examples: ["tan(0.5)", "sin(0.5) / cos(0.5)", "tan(pi / 4)", "tan(45 deg)"],
  seealso: ["atan", "sin", "cos"]
};
var tanhDocs = {
  name: "tanh",
  category: "Trigonometry",
  syntax: ["tanh(x)"],
  description: "Compute the hyperbolic tangent of x in radians.",
  examples: ["tanh(0.5)", "sinh(0.5) / cosh(0.5)"],
  seealso: ["sinh", "cosh"]
};
var toDocs = {
  name: "to",
  category: "Units",
  syntax: ["x to unit", "to(x, unit)"],
  description: "Change the unit of a value.",
  examples: ["5 inch to cm", "3.2kg to g", "16 bytes in bits"],
  seealso: []
};
var binDocs = {
  name: "bin",
  category: "Utils",
  syntax: ["bin(value)"],
  description: "Format a number as binary",
  examples: ["bin(2)"],
  seealso: ["oct", "hex"]
};
var cloneDocs = {
  name: "clone",
  category: "Utils",
  syntax: ["clone(x)"],
  description: "Clone a variable. Creates a copy of primitive variables,and a deep copy of matrices",
  examples: ["clone(3.5)", "clone(2 - 4i)", "clone(45 deg)", "clone([1, 2; 3, 4])", 'clone("hello world")'],
  seealso: []
};
var formatDocs = {
  name: "format",
  category: "Utils",
  syntax: ["format(value)", "format(value, precision)"],
  description: "Format a value of any type as string.",
  examples: ["format(2.3)", "format(3 - 4i)", "format([])", "format(pi, 3)"],
  seealso: ["print"]
};
var hasNumericValueDocs = {
  name: "hasNumericValue",
  category: "Utils",
  syntax: ["hasNumericValue(x)"],
  description: "Test whether a value is an numeric value. In case of a string, true is returned if the string contains a numeric value.",
  examples: ["hasNumericValue(2)", 'hasNumericValue("2")', 'isNumeric("2")', "hasNumericValue(0)", "hasNumericValue(bignumber(500))", "hasNumericValue(fraction(0.125))", "hasNumericValue(2 + 3i)", 'hasNumericValue([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "isNumeric"]
};
var hexDocs = {
  name: "hex",
  category: "Utils",
  syntax: ["hex(value)"],
  description: "Format a number as hexadecimal",
  examples: ["hex(240)"],
  seealso: ["bin", "oct"]
};
var isIntegerDocs = {
  name: "isInteger",
  category: "Utils",
  syntax: ["isInteger(x)"],
  description: "Test whether a value is an integer number.",
  examples: ["isInteger(2)", "isInteger(3.5)", "isInteger([3, 0.5, -2])"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};
var isNaNDocs = {
  name: "isNaN",
  category: "Utils",
  syntax: ["isNaN(x)"],
  description: "Test whether a value is NaN (not a number)",
  examples: ["isNaN(2)", "isNaN(0 / 0)", "isNaN(NaN)", "isNaN(Infinity)"],
  seealso: ["isNegative", "isNumeric", "isPositive", "isZero"]
};
var isNegativeDocs = {
  name: "isNegative",
  category: "Utils",
  syntax: ["isNegative(x)"],
  description: "Test whether a value is negative: smaller than zero.",
  examples: ["isNegative(2)", "isNegative(0)", "isNegative(-4)", "isNegative([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isPositive", "isZero"]
};
var isNumericDocs = {
  name: "isNumeric",
  category: "Utils",
  syntax: ["isNumeric(x)"],
  description: "Test whether a value is a numeric value. Returns true when the input is a number, BigNumber, Fraction, or boolean.",
  examples: ["isNumeric(2)", 'isNumeric("2")', 'hasNumericValue("2")', "isNumeric(0)", "isNumeric(bignumber(500))", "isNumeric(fraction(0.125))", "isNumeric(2 + 3i)", 'isNumeric([2.3, "foo", false])'],
  seealso: ["isInteger", "isZero", "isNegative", "isPositive", "isNaN", "hasNumericValue"]
};
var isPositiveDocs = {
  name: "isPositive",
  category: "Utils",
  syntax: ["isPositive(x)"],
  description: "Test whether a value is positive: larger than zero.",
  examples: ["isPositive(2)", "isPositive(0)", "isPositive(-4)", "isPositive([3, 0.5, -2])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};
var isPrimeDocs = {
  name: "isPrime",
  category: "Utils",
  syntax: ["isPrime(x)"],
  description: "Test whether a value is prime: has no divisors other than itself and one.",
  examples: ["isPrime(3)", "isPrime(-2)", "isPrime([2, 17, 100])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isZero"]
};
var isZeroDocs = {
  name: "isZero",
  category: "Utils",
  syntax: ["isZero(x)"],
  description: "Test whether a value is zero.",
  examples: ["isZero(2)", "isZero(0)", "isZero(-4)", "isZero([3, 0, -2, 0])"],
  seealso: ["isInteger", "isNumeric", "isNegative", "isPositive"]
};
var numericDocs = {
  name: "numeric",
  category: "Utils",
  syntax: ["numeric(x)"],
  description: "Convert a numeric input to a specific numeric type: number, BigNumber, or Fraction.",
  examples: ['numeric("4")', 'numeric("4", "number")', 'numeric("4", "BigNumber")', 'numeric("4", "Fraction")', 'numeric(4, "Fraction")', 'numeric(fraction(2, 5), "number")'],
  seealso: ["number", "fraction", "bignumber", "string", "format"]
};
var octDocs = {
  name: "oct",
  category: "Utils",
  syntax: ["oct(value)"],
  description: "Format a number as octal",
  examples: ["oct(56)"],
  seealso: ["bin", "hex"]
};
var printDocs = {
  name: "print",
  category: "Utils",
  syntax: ["print(template, values)", "print(template, values, precision)"],
  description: "Interpolate values into a string template.",
  examples: ['print("Lucy is $age years old", {age: 5})', 'print("The value of pi is $pi", {pi: pi}, 3)', 'print("Hello, $user.name!", {user: {name: "John"}})', 'print("Values: $1, $2, $3", [6, 9, 4])'],
  seealso: ["format"]
};
var typeOfDocs = {
  name: "typeOf",
  category: "Utils",
  syntax: ["typeOf(x)"],
  description: "Get the type of a variable.",
  examples: ["typeOf(3.5)", "typeOf(2 - 4i)", "typeOf(45 deg)", 'typeOf("hello world")'],
  seealso: ["getMatrixDataType"]
};
var solveODEDocs = {
  name: "solveODE",
  category: "Numeric",
  syntax: ["solveODE(func, tspan, y0)", "solveODE(func, tspan, y0, options)"],
  description: "Numerical Integration of Ordinary Differential Equations.",
  examples: ["f(t,y) = y", "tspan = [0, 4]", "solveODE(f, tspan, 1)", "solveODE(f, tspan, [1, 2])", 'solveODE(f, tspan, 1, { method:"RK23", maxStep:0.1 })'],
  seealso: ["derivative", "simplifyCore"]
};
var embeddedDocs = {
  // construction functions
  bignumber: bignumberDocs,
  boolean: booleanDocs,
  complex: complexDocs,
  createUnit: createUnitDocs,
  fraction: fractionDocs,
  index: indexDocs,
  matrix: matrixDocs,
  number: numberDocs,
  sparse: sparseDocs,
  splitUnit: splitUnitDocs,
  string: stringDocs,
  unit: unitDocs,
  // constants
  e: eDocs,
  E: eDocs,
  false: falseDocs,
  i: iDocs,
  Infinity: InfinityDocs,
  LN2: LN2Docs,
  LN10: LN10Docs,
  LOG2E: LOG2EDocs,
  LOG10E: LOG10EDocs,
  NaN: NaNDocs,
  null: nullDocs,
  pi: piDocs,
  PI: piDocs,
  phi: phiDocs,
  SQRT1_2: SQRT12Docs,
  SQRT2: SQRT2Docs,
  tau: tauDocs,
  true: trueDocs,
  version: versionDocs,
  // physical constants
  // TODO: more detailed docs for physical constants
  speedOfLight: {
    description: "Speed of light in vacuum",
    examples: ["speedOfLight"]
  },
  gravitationConstant: {
    description: "Newtonian constant of gravitation",
    examples: ["gravitationConstant"]
  },
  planckConstant: {
    description: "Planck constant",
    examples: ["planckConstant"]
  },
  reducedPlanckConstant: {
    description: "Reduced Planck constant",
    examples: ["reducedPlanckConstant"]
  },
  magneticConstant: {
    description: "Magnetic constant (vacuum permeability)",
    examples: ["magneticConstant"]
  },
  electricConstant: {
    description: "Electric constant (vacuum permeability)",
    examples: ["electricConstant"]
  },
  vacuumImpedance: {
    description: "Characteristic impedance of vacuum",
    examples: ["vacuumImpedance"]
  },
  coulomb: {
    description: "Coulomb's constant",
    examples: ["coulomb"]
  },
  elementaryCharge: {
    description: "Elementary charge",
    examples: ["elementaryCharge"]
  },
  bohrMagneton: {
    description: "Borh magneton",
    examples: ["bohrMagneton"]
  },
  conductanceQuantum: {
    description: "Conductance quantum",
    examples: ["conductanceQuantum"]
  },
  inverseConductanceQuantum: {
    description: "Inverse conductance quantum",
    examples: ["inverseConductanceQuantum"]
  },
  // josephson: {description: 'Josephson constant', examples: ['josephson']},
  magneticFluxQuantum: {
    description: "Magnetic flux quantum",
    examples: ["magneticFluxQuantum"]
  },
  nuclearMagneton: {
    description: "Nuclear magneton",
    examples: ["nuclearMagneton"]
  },
  klitzing: {
    description: "Von Klitzing constant",
    examples: ["klitzing"]
  },
  bohrRadius: {
    description: "Borh radius",
    examples: ["bohrRadius"]
  },
  classicalElectronRadius: {
    description: "Classical electron radius",
    examples: ["classicalElectronRadius"]
  },
  electronMass: {
    description: "Electron mass",
    examples: ["electronMass"]
  },
  fermiCoupling: {
    description: "Fermi coupling constant",
    examples: ["fermiCoupling"]
  },
  fineStructure: {
    description: "Fine-structure constant",
    examples: ["fineStructure"]
  },
  hartreeEnergy: {
    description: "Hartree energy",
    examples: ["hartreeEnergy"]
  },
  protonMass: {
    description: "Proton mass",
    examples: ["protonMass"]
  },
  deuteronMass: {
    description: "Deuteron Mass",
    examples: ["deuteronMass"]
  },
  neutronMass: {
    description: "Neutron mass",
    examples: ["neutronMass"]
  },
  quantumOfCirculation: {
    description: "Quantum of circulation",
    examples: ["quantumOfCirculation"]
  },
  rydberg: {
    description: "Rydberg constant",
    examples: ["rydberg"]
  },
  thomsonCrossSection: {
    description: "Thomson cross section",
    examples: ["thomsonCrossSection"]
  },
  weakMixingAngle: {
    description: "Weak mixing angle",
    examples: ["weakMixingAngle"]
  },
  efimovFactor: {
    description: "Efimov factor",
    examples: ["efimovFactor"]
  },
  atomicMass: {
    description: "Atomic mass constant",
    examples: ["atomicMass"]
  },
  avogadro: {
    description: "Avogadro's number",
    examples: ["avogadro"]
  },
  boltzmann: {
    description: "Boltzmann constant",
    examples: ["boltzmann"]
  },
  faraday: {
    description: "Faraday constant",
    examples: ["faraday"]
  },
  firstRadiation: {
    description: "First radiation constant",
    examples: ["firstRadiation"]
  },
  loschmidt: {
    description: "Loschmidt constant at T=273.15 K and p=101.325 kPa",
    examples: ["loschmidt"]
  },
  gasConstant: {
    description: "Gas constant",
    examples: ["gasConstant"]
  },
  molarPlanckConstant: {
    description: "Molar Planck constant",
    examples: ["molarPlanckConstant"]
  },
  molarVolume: {
    description: "Molar volume of an ideal gas at T=273.15 K and p=101.325 kPa",
    examples: ["molarVolume"]
  },
  sackurTetrode: {
    description: "Sackur-Tetrode constant at T=1 K and p=101.325 kPa",
    examples: ["sackurTetrode"]
  },
  secondRadiation: {
    description: "Second radiation constant",
    examples: ["secondRadiation"]
  },
  stefanBoltzmann: {
    description: "Stefan-Boltzmann constant",
    examples: ["stefanBoltzmann"]
  },
  wienDisplacement: {
    description: "Wien displacement law constant",
    examples: ["wienDisplacement"]
  },
  // spectralRadiance: {description: 'First radiation constant for spectral radiance', examples: ['spectralRadiance']},
  molarMass: {
    description: "Molar mass constant",
    examples: ["molarMass"]
  },
  molarMassC12: {
    description: "Molar mass constant of carbon-12",
    examples: ["molarMassC12"]
  },
  gravity: {
    description: "Standard acceleration of gravity (standard acceleration of free-fall on Earth)",
    examples: ["gravity"]
  },
  planckLength: {
    description: "Planck length",
    examples: ["planckLength"]
  },
  planckMass: {
    description: "Planck mass",
    examples: ["planckMass"]
  },
  planckTime: {
    description: "Planck time",
    examples: ["planckTime"]
  },
  planckCharge: {
    description: "Planck charge",
    examples: ["planckCharge"]
  },
  planckTemperature: {
    description: "Planck temperature",
    examples: ["planckTemperature"]
  },
  // functions - algebra
  derivative: derivativeDocs,
  lsolve: lsolveDocs,
  lsolveAll: lsolveAllDocs,
  lup: lupDocs,
  lusolve: lusolveDocs,
  leafCount: leafCountDocs,
  polynomialRoot: polynomialRootDocs,
  resolve: resolveDocs,
  simplify: simplifyDocs,
  simplifyConstant: simplifyConstantDocs,
  simplifyCore: simplifyCoreDocs,
  symbolicEqual: symbolicEqualDocs,
  rationalize: rationalizeDocs,
  slu: sluDocs,
  usolve: usolveDocs,
  usolveAll: usolveAllDocs,
  qr: qrDocs,
  // functions - arithmetic
  abs: absDocs,
  add: addDocs,
  cbrt: cbrtDocs,
  ceil: ceilDocs,
  cube: cubeDocs,
  divide: divideDocs,
  dotDivide: dotDivideDocs,
  dotMultiply: dotMultiplyDocs,
  dotPow: dotPowDocs,
  exp: expDocs,
  expm: expmDocs,
  expm1: expm1Docs,
  fix: fixDocs,
  floor: floorDocs,
  gcd: gcdDocs,
  hypot: hypotDocs,
  lcm: lcmDocs,
  log: logDocs,
  log2: log2Docs,
  log1p: log1pDocs,
  log10: log10Docs,
  mod: modDocs,
  multiply: multiplyDocs,
  norm: normDocs,
  nthRoot: nthRootDocs,
  nthRoots: nthRootsDocs,
  pow: powDocs,
  round: roundDocs,
  sign: signDocs,
  sqrt: sqrtDocs,
  sqrtm: sqrtmDocs,
  square: squareDocs,
  subtract: subtractDocs,
  unaryMinus: unaryMinusDocs,
  unaryPlus: unaryPlusDocs,
  xgcd: xgcdDocs,
  invmod: invmodDocs,
  // functions - bitwise
  bitAnd: bitAndDocs,
  bitNot: bitNotDocs,
  bitOr: bitOrDocs,
  bitXor: bitXorDocs,
  leftShift: leftShiftDocs,
  rightArithShift: rightArithShiftDocs,
  rightLogShift: rightLogShiftDocs,
  // functions - combinatorics
  bellNumbers: bellNumbersDocs,
  catalan: catalanDocs,
  composition: compositionDocs,
  stirlingS2: stirlingS2Docs,
  // functions - core
  config: configDocs,
  import: importDocs,
  typed: typedDocs,
  // functions - complex
  arg: argDocs,
  conj: conjDocs,
  re: reDocs,
  im: imDocs,
  // functions - expression
  evaluate: evaluateDocs,
  help: helpDocs,
  // functions - geometry
  distance: distanceDocs,
  intersect: intersectDocs,
  // functions - logical
  and: andDocs,
  not: notDocs,
  or: orDocs,
  xor: xorDocs,
  // functions - matrix
  concat: concatDocs,
  count: countDocs,
  cross: crossDocs,
  column: columnDocs,
  ctranspose: ctransposeDocs,
  det: detDocs,
  diag: diagDocs,
  diff: diffDocs,
  dot: dotDocs,
  getMatrixDataType: getMatrixDataTypeDocs,
  identity: identityDocs,
  filter: filterDocs,
  flatten: flattenDocs,
  forEach: forEachDocs,
  inv: invDocs,
  pinv: pinvDocs,
  eigs: eigsDocs,
  kron: kronDocs,
  matrixFromFunction: matrixFromFunctionDocs,
  matrixFromRows: matrixFromRowsDocs,
  matrixFromColumns: matrixFromColumnsDocs,
  map: mapDocs,
  ones: onesDocs,
  partitionSelect: partitionSelectDocs,
  range: rangeDocs,
  resize: resizeDocs,
  reshape: reshapeDocs,
  rotate: rotateDocs,
  rotationMatrix: rotationMatrixDocs,
  row: rowDocs,
  size: sizeDocs,
  sort: sortDocs,
  squeeze: squeezeDocs,
  subset: subsetDocs,
  trace: traceDocs,
  transpose: transposeDocs,
  zeros: zerosDocs,
  fft: fftDocs,
  ifft: ifftDocs,
  sylvester: sylvesterDocs,
  schur: schurDocs,
  lyap: lyapDocs,
  // functions - numeric
  solveODE: solveODEDocs,
  // functions - probability
  combinations: combinationsDocs,
  combinationsWithRep: combinationsWithRepDocs,
  // distribution: distributionDocs,
  factorial: factorialDocs,
  gamma: gammaDocs,
  kldivergence: kldivergenceDocs,
  lgamma: lgammaDocs,
  multinomial: multinomialDocs,
  permutations: permutationsDocs,
  pickRandom: pickRandomDocs,
  random: randomDocs,
  randomInt: randomIntDocs,
  // functions - relational
  compare: compareDocs,
  compareNatural: compareNaturalDocs,
  compareText: compareTextDocs,
  deepEqual: deepEqualDocs,
  equal: equalDocs,
  equalText: equalTextDocs,
  larger: largerDocs,
  largerEq: largerEqDocs,
  smaller: smallerDocs,
  smallerEq: smallerEqDocs,
  unequal: unequalDocs,
  // functions - set
  setCartesian: setCartesianDocs,
  setDifference: setDifferenceDocs,
  setDistinct: setDistinctDocs,
  setIntersect: setIntersectDocs,
  setIsSubset: setIsSubsetDocs,
  setMultiplicity: setMultiplicityDocs,
  setPowerset: setPowersetDocs,
  setSize: setSizeDocs,
  setSymDifference: setSymDifferenceDocs,
  setUnion: setUnionDocs,
  // functions - signal
  zpk2tf: zpk2tfDocs,
  freqz: freqzDocs,
  // functions - special
  erf: erfDocs,
  zeta: zetaDocs,
  // functions - statistics
  cumsum: cumSumDocs,
  mad: madDocs,
  max: maxDocs,
  mean: meanDocs,
  median: medianDocs,
  min: minDocs,
  mode: modeDocs,
  prod: prodDocs,
  quantileSeq: quantileSeqDocs,
  std: stdDocs,
  sum: sumDocs,
  variance: varianceDocs,
  corr: corrDocs,
  // functions - trigonometry
  acos: acosDocs,
  acosh: acoshDocs,
  acot: acotDocs,
  acoth: acothDocs,
  acsc: acscDocs,
  acsch: acschDocs,
  asec: asecDocs,
  asech: asechDocs,
  asin: asinDocs,
  asinh: asinhDocs,
  atan: atanDocs,
  atanh: atanhDocs,
  atan2: atan2Docs,
  cos: cosDocs,
  cosh: coshDocs,
  cot: cotDocs,
  coth: cothDocs,
  csc: cscDocs,
  csch: cschDocs,
  sec: secDocs,
  sech: sechDocs,
  sin: sinDocs,
  sinh: sinhDocs,
  tan: tanDocs,
  tanh: tanhDocs,
  // functions - units
  to: toDocs,
  // functions - utils
  clone: cloneDocs,
  format: formatDocs,
  bin: binDocs,
  oct: octDocs,
  hex: hexDocs,
  isNaN: isNaNDocs,
  isInteger: isIntegerDocs,
  isNegative: isNegativeDocs,
  isNumeric: isNumericDocs,
  hasNumericValue: hasNumericValueDocs,
  isPositive: isPositiveDocs,
  isPrime: isPrimeDocs,
  isZero: isZeroDocs,
  print: printDocs,
  typeOf: typeOfDocs,
  numeric: numericDocs
};
var name$1a = "help";
var dependencies$1a = ["typed", "mathWithTransform", "Help"];
var createHelp = /* @__PURE__ */ factory(name$1a, dependencies$1a, (_ref) => {
  var {
    typed: typed2,
    mathWithTransform: mathWithTransform2,
    Help: Help2
  } = _ref;
  return typed2(name$1a, {
    any: function any(search) {
      var prop;
      var searchName = search;
      if (typeof search !== "string") {
        for (prop in mathWithTransform2) {
          if (hasOwnProperty(mathWithTransform2, prop) && search === mathWithTransform2[prop]) {
            searchName = prop;
            break;
          }
        }
      }
      var doc = getSafeProperty(embeddedDocs, searchName);
      if (!doc) {
        var searchText = typeof searchName === "function" ? searchName.name : searchName;
        throw new Error('No documentation found on "' + searchText + '"');
      }
      return new Help2(doc);
    }
  });
});
var name$19 = "chain";
var dependencies$19 = ["typed", "Chain"];
var createChain = /* @__PURE__ */ factory(name$19, dependencies$19, (_ref) => {
  var {
    typed: typed2,
    Chain: Chain2
  } = _ref;
  return typed2(name$19, {
    "": function _() {
      return new Chain2();
    },
    any: function any(value) {
      return new Chain2(value);
    }
  });
});
var name$18 = "det";
var dependencies$18 = ["typed", "matrix", "subtractScalar", "multiply", "divideScalar", "isZero", "unaryMinus"];
var createDet = /* @__PURE__ */ factory(name$18, dependencies$18, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtractScalar: subtractScalar2,
    multiply: multiply2,
    divideScalar: divideScalar2,
    isZero: isZero2,
    unaryMinus: unaryMinus2
  } = _ref;
  return typed2(name$18, {
    any: function any(x) {
      return clone$3(x);
    },
    "Array | Matrix": function det2(x) {
      var size2;
      if (isMatrix(x)) {
        size2 = x.size();
      } else if (Array.isArray(x)) {
        x = matrix2(x);
        size2 = x.size();
      } else {
        size2 = [];
      }
      switch (size2.length) {
        case 0:
          return clone$3(x);
        case 1:
          if (size2[0] === 1) {
            return clone$3(x.valueOf()[0]);
          }
          if (size2[0] === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            return _det(x.clone().valueOf(), rows);
          }
          if (cols === 0) {
            return 1;
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
      }
    }
  });
  function _det(matrix3, rows, cols) {
    if (rows === 1) {
      return clone$3(matrix3[0][0]);
    } else if (rows === 2) {
      return subtractScalar2(multiply2(matrix3[0][0], matrix3[1][1]), multiply2(matrix3[1][0], matrix3[0][1]));
    } else {
      var negated = false;
      var rowIndices = new Array(rows).fill(0).map((_, i3) => i3);
      for (var k = 0; k < rows; k++) {
        var k_ = rowIndices[k];
        if (isZero2(matrix3[k_][k])) {
          var _k = void 0;
          for (_k = k + 1; _k < rows; _k++) {
            if (!isZero2(matrix3[rowIndices[_k]][k])) {
              k_ = rowIndices[_k];
              rowIndices[_k] = rowIndices[k];
              rowIndices[k] = k_;
              negated = !negated;
              break;
            }
          }
          if (_k === rows)
            return matrix3[k_][k];
        }
        var piv = matrix3[k_][k];
        var piv_ = k === 0 ? 1 : matrix3[rowIndices[k - 1]][k - 1];
        for (var i2 = k + 1; i2 < rows; i2++) {
          var i_ = rowIndices[i2];
          for (var j = k + 1; j < rows; j++) {
            matrix3[i_][j] = divideScalar2(subtractScalar2(multiply2(matrix3[i_][j], piv), multiply2(matrix3[i_][k], matrix3[k_][j])), piv_);
          }
        }
      }
      var det2 = matrix3[rowIndices[rows - 1]][rows - 1];
      return negated ? unaryMinus2(det2) : det2;
    }
  }
});
var name$17 = "inv";
var dependencies$17 = ["typed", "matrix", "divideScalar", "addScalar", "multiply", "unaryMinus", "det", "identity", "abs"];
var createInv = /* @__PURE__ */ factory(name$17, dependencies$17, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divideScalar: divideScalar2,
    addScalar: addScalar2,
    multiply: multiply2,
    unaryMinus: unaryMinus2,
    det: det2,
    identity: identity2,
    abs: abs2
  } = _ref;
  return typed2(name$17, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (size2[0] === 1) {
            if (isMatrix(x)) {
              return matrix2([divideScalar2(1, x.valueOf()[0])]);
            } else {
              return [divideScalar2(1, x[0])];
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        case 2: {
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            if (isMatrix(x)) {
              return matrix2(_inv(x.valueOf(), rows, cols), x.storage());
            } else {
              return _inv(x, rows, cols);
            }
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
      }
    },
    any: function any(x) {
      return divideScalar2(1, x);
    }
  });
  function _inv(mat, rows, cols) {
    var r, s, f, value, temp;
    if (rows === 1) {
      value = mat[0][0];
      if (value === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(1, value)]];
    } else if (rows === 2) {
      var d = det2(mat);
      if (d === 0) {
        throw Error("Cannot calculate inverse, determinant is zero");
      }
      return [[divideScalar2(mat[1][1], d), divideScalar2(unaryMinus2(mat[0][1]), d)], [divideScalar2(unaryMinus2(mat[1][0]), d), divideScalar2(mat[0][0], d)]];
    } else {
      var A = mat.concat();
      for (r = 0; r < rows; r++) {
        A[r] = A[r].concat();
      }
      var B = identity2(rows).valueOf();
      for (var c = 0; c < cols; c++) {
        var ABig = abs2(A[c][c]);
        var rBig = c;
        r = c + 1;
        while (r < rows) {
          if (abs2(A[r][c]) > ABig) {
            ABig = abs2(A[r][c]);
            rBig = r;
          }
          r++;
        }
        if (ABig === 0) {
          throw Error("Cannot calculate inverse, determinant is zero");
        }
        r = rBig;
        if (r !== c) {
          temp = A[c];
          A[c] = A[r];
          A[r] = temp;
          temp = B[c];
          B[c] = B[r];
          B[r] = temp;
        }
        var Ac = A[c];
        var Bc = B[c];
        for (r = 0; r < rows; r++) {
          var Ar = A[r];
          var Br = B[r];
          if (r !== c) {
            if (Ar[c] !== 0) {
              f = divideScalar2(unaryMinus2(Ar[c]), Ac[c]);
              for (s = c; s < cols; s++) {
                Ar[s] = addScalar2(Ar[s], multiply2(f, Ac[s]));
              }
              for (s = 0; s < cols; s++) {
                Br[s] = addScalar2(Br[s], multiply2(f, Bc[s]));
              }
            }
          } else {
            f = Ac[c];
            for (s = c; s < cols; s++) {
              Ar[s] = divideScalar2(Ar[s], f);
            }
            for (s = 0; s < cols; s++) {
              Br[s] = divideScalar2(Br[s], f);
            }
          }
        }
      }
      return B;
    }
  }
});
var name$16 = "pinv";
var dependencies$16 = ["typed", "matrix", "inv", "deepEqual", "equal", "dotDivide", "dot", "ctranspose", "divideScalar", "multiply", "add", "Complex"];
var createPinv = /* @__PURE__ */ factory(name$16, dependencies$16, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    inv: inv2,
    deepEqual: deepEqual2,
    equal: equal2,
    dotDivide: dotDivide2,
    dot: dot2,
    ctranspose: ctranspose2,
    divideScalar: divideScalar2,
    multiply: multiply2,
    add: add2,
    Complex: Complex2
  } = _ref;
  return typed2(name$16, {
    "Array | Matrix": function ArrayMatrix(x) {
      var size2 = isMatrix(x) ? x.size() : arraySize(x);
      switch (size2.length) {
        case 1:
          if (_isZeros(x))
            return ctranspose2(x);
          if (size2[0] === 1) {
            return inv2(x);
          } else {
            return dotDivide2(ctranspose2(x), dot2(x, x));
          }
        case 2: {
          if (_isZeros(x))
            return ctranspose2(x);
          var rows = size2[0];
          var cols = size2[1];
          if (rows === cols) {
            try {
              return inv2(x);
            } catch (err) {
              if (err instanceof Error && err.message.match(/Cannot calculate inverse, determinant is zero/))
                ;
              else {
                throw err;
              }
            }
          }
          if (isMatrix(x)) {
            return matrix2(_pinv(x.valueOf(), rows, cols), x.storage());
          } else {
            return _pinv(x, rows, cols);
          }
        }
        default:
          throw new RangeError("Matrix must be two dimensional (size: " + format$1(size2) + ")");
      }
    },
    any: function any(x) {
      if (equal2(x, 0))
        return clone$3(x);
      return divideScalar2(1, x);
    }
  });
  function _pinv(mat, rows, cols) {
    var {
      C,
      F
    } = _rankFact(mat, rows, cols);
    var Cpinv = multiply2(inv2(multiply2(ctranspose2(C), C)), ctranspose2(C));
    var Fpinv = multiply2(ctranspose2(F), inv2(multiply2(F, ctranspose2(F))));
    return multiply2(Fpinv, Cpinv);
  }
  function _rref(mat, rows, cols) {
    var M = clone$3(mat);
    var lead = 0;
    for (var r = 0; r < rows; r++) {
      if (cols <= lead) {
        return M;
      }
      var i2 = r;
      while (_isZero(M[i2][lead])) {
        i2++;
        if (rows === i2) {
          i2 = r;
          lead++;
          if (cols === lead) {
            return M;
          }
        }
      }
      [M[i2], M[r]] = [M[r], M[i2]];
      var val = M[r][lead];
      for (var j = 0; j < cols; j++) {
        M[r][j] = dotDivide2(M[r][j], val);
      }
      for (var _i = 0; _i < rows; _i++) {
        if (_i === r)
          continue;
        val = M[_i][lead];
        for (var _j = 0; _j < cols; _j++) {
          M[_i][_j] = add2(M[_i][_j], multiply2(-1, multiply2(val, M[r][_j])));
        }
      }
      lead++;
    }
    return M;
  }
  function _rankFact(mat, rows, cols) {
    var rref = _rref(mat, rows, cols);
    var C = mat.map((_, i2) => _.filter((_2, j) => j < rows && !_isZero(dot2(rref[j], rref[j]))));
    var F = rref.filter((_, i2) => !_isZero(dot2(rref[i2], rref[i2])));
    return {
      C,
      F
    };
  }
  function _isZero(x) {
    return equal2(add2(x, Complex2(1, 1)), add2(0, Complex2(1, 1)));
  }
  function _isZeros(arr) {
    return deepEqual2(add2(arr, Complex2(1, 1)), add2(multiply2(arr, 0), Complex2(1, 1)));
  }
});
function createComplexEigs(_ref) {
  var {
    addScalar: addScalar2,
    subtract: subtract2,
    flatten: flatten2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    size: size2,
    reshape: reshape2,
    inv: inv2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  function complexEigs(arr, N, prec, type) {
    var findVectors = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true;
    var R = balance(arr, N, prec, type, findVectors);
    reduceToHessenberg(arr, N, prec, type, findVectors, R);
    var {
      values,
      C
    } = iterateUntilTriangular(arr, N, prec, type, findVectors);
    if (findVectors) {
      var eigenvectors = findEigenvectors(arr, N, C, R, values, prec, type);
      return {
        values,
        eigenvectors
      };
    }
    return {
      values
    };
  }
  function balance(arr, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var realzero = big ? bignumber2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var realone = big ? bignumber2(1) : 1;
    var radix = big ? bignumber2(10) : 2;
    var radixSq = multiplyScalar2(radix, radix);
    var Rdiag;
    if (findVectors) {
      Rdiag = Array(N).fill(one);
    }
    var last = false;
    while (!last) {
      last = true;
      for (var i2 = 0; i2 < N; i2++) {
        var colNorm = realzero;
        var rowNorm = realzero;
        for (var j = 0; j < N; j++) {
          if (i2 === j)
            continue;
          colNorm = addScalar2(colNorm, abs2(arr[j][i2]));
          rowNorm = addScalar2(rowNorm, abs2(arr[i2][j]));
        }
        if (!equal2(colNorm, 0) && !equal2(rowNorm, 0)) {
          var f = realone;
          var c = colNorm;
          var rowDivRadix = divideScalar2(rowNorm, radix);
          var rowMulRadix = multiplyScalar2(rowNorm, radix);
          while (smaller2(c, rowDivRadix)) {
            c = multiplyScalar2(c, radixSq);
            f = multiplyScalar2(f, radix);
          }
          while (larger2(c, rowMulRadix)) {
            c = divideScalar2(c, radixSq);
            f = divideScalar2(f, radix);
          }
          var condition = smaller2(divideScalar2(addScalar2(c, rowNorm), f), multiplyScalar2(addScalar2(colNorm, rowNorm), 0.95));
          if (condition) {
            last = false;
            var g = divideScalar2(1, f);
            for (var _j = 0; _j < N; _j++) {
              if (i2 === _j) {
                continue;
              }
              arr[i2][_j] = multiplyScalar2(arr[i2][_j], g);
              arr[_j][i2] = multiplyScalar2(arr[_j][i2], f);
            }
            if (findVectors) {
              Rdiag[i2] = multiplyScalar2(Rdiag[i2], g);
            }
          }
        }
      }
    }
    return findVectors ? diag2(Rdiag) : null;
  }
  function reduceToHessenberg(arr, N, prec, type, findVectors, R) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    if (big) {
      prec = bignumber2(prec);
    }
    for (var i2 = 0; i2 < N - 2; i2++) {
      var maxIndex = 0;
      var max2 = zero;
      for (var j = i2 + 1; j < N; j++) {
        var el = arr[j][i2];
        if (smaller2(abs2(max2), abs2(el))) {
          max2 = el;
          maxIndex = j;
        }
      }
      if (smaller2(abs2(max2), prec)) {
        continue;
      }
      if (maxIndex !== i2 + 1) {
        var tmp1 = arr[maxIndex];
        arr[maxIndex] = arr[i2 + 1];
        arr[i2 + 1] = tmp1;
        for (var _j2 = 0; _j2 < N; _j2++) {
          var tmp2 = arr[_j2][maxIndex];
          arr[_j2][maxIndex] = arr[_j2][i2 + 1];
          arr[_j2][i2 + 1] = tmp2;
        }
        if (findVectors) {
          var tmp3 = R[maxIndex];
          R[maxIndex] = R[i2 + 1];
          R[i2 + 1] = tmp3;
        }
      }
      for (var _j3 = i2 + 2; _j3 < N; _j3++) {
        var n = divideScalar2(arr[_j3][i2], max2);
        if (n === 0) {
          continue;
        }
        for (var k = 0; k < N; k++) {
          arr[_j3][k] = subtract2(arr[_j3][k], multiplyScalar2(n, arr[i2 + 1][k]));
        }
        for (var _k = 0; _k < N; _k++) {
          arr[_k][i2 + 1] = addScalar2(arr[_k][i2 + 1], multiplyScalar2(n, arr[_k][_j3]));
        }
        if (findVectors) {
          for (var _k2 = 0; _k2 < N; _k2++) {
            R[_j3][_k2] = subtract2(R[_j3][_k2], multiplyScalar2(n, R[i2 + 1][_k2]));
          }
        }
      }
    }
    return R;
  }
  function iterateUntilTriangular(A, N, prec, type, findVectors) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (big) {
      prec = bignumber2(prec);
    }
    var arr = clone$3(A);
    var lambdas = [];
    var n = N;
    var Sdiag = [];
    var Qtotal = findVectors ? diag2(Array(N).fill(one)) : void 0;
    var Qpartial = findVectors ? diag2(Array(n).fill(one)) : void 0;
    var lastConvergenceBefore = 0;
    while (lastConvergenceBefore <= 100) {
      lastConvergenceBefore += 1;
      var k = arr[n - 1][n - 1];
      for (var i2 = 0; i2 < n; i2++) {
        arr[i2][i2] = subtract2(arr[i2][i2], k);
      }
      var {
        Q: Q2,
        R
      } = qr2(arr);
      arr = multiply2(R, Q2);
      for (var _i = 0; _i < n; _i++) {
        arr[_i][_i] = addScalar2(arr[_i][_i], k);
      }
      if (findVectors) {
        Qpartial = multiply2(Qpartial, Q2);
      }
      if (n === 1 || smaller2(abs2(arr[n - 1][n - 2]), prec)) {
        lastConvergenceBefore = 0;
        lambdas.push(arr[n - 1][n - 1]);
        if (findVectors) {
          Sdiag.unshift([[1]]);
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 1) {
            Qpartial = diag2(Array(n - 1).fill(one));
          }
        }
        n -= 1;
        arr.pop();
        for (var _i2 = 0; _i2 < n; _i2++) {
          arr[_i2].pop();
        }
      } else if (n === 2 || smaller2(abs2(arr[n - 2][n - 3]), prec)) {
        lastConvergenceBefore = 0;
        var ll = eigenvalues2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1]);
        lambdas.push(...ll);
        if (findVectors) {
          Sdiag.unshift(jordanBase2x2(arr[n - 2][n - 2], arr[n - 2][n - 1], arr[n - 1][n - 2], arr[n - 1][n - 1], ll[0], ll[1], prec, type));
          inflateMatrix(Qpartial, N);
          Qtotal = multiply2(Qtotal, Qpartial);
          if (n > 2) {
            Qpartial = diag2(Array(n - 2).fill(one));
          }
        }
        n -= 2;
        arr.pop();
        arr.pop();
        for (var _i3 = 0; _i3 < n; _i3++) {
          arr[_i3].pop();
          arr[_i3].pop();
        }
      }
      if (n === 0) {
        break;
      }
    }
    lambdas.sort((a, b) => +subtract2(abs2(a), abs2(b)));
    if (lastConvergenceBefore > 100) {
      var err = Error("The eigenvalues failed to converge. Only found these eigenvalues: " + lambdas.join(", "));
      err.values = lambdas;
      err.vectors = [];
      throw err;
    }
    var C = findVectors ? multiply2(Qtotal, blockDiag(Sdiag, N)) : void 0;
    return {
      values: lambdas,
      C
    };
  }
  function findEigenvectors(A, N, C, R, values, prec, type) {
    var Cinv = inv2(C);
    var U = multiply2(Cinv, A, C);
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    var uniqueValues = [];
    var multiplicities = [];
    for (var lambda of values) {
      var i2 = indexOf(uniqueValues, lambda, equal2);
      if (i2 === -1) {
        uniqueValues.push(lambda);
        multiplicities.push(1);
      } else {
        multiplicities[i2] += 1;
      }
    }
    var vectors = [];
    var len = uniqueValues.length;
    var b = Array(N).fill(zero);
    var E = diag2(Array(N).fill(one));
    var _loop = function _loop2() {
      var lambda2 = uniqueValues[_i4];
      var S = subtract2(U, multiply2(lambda2, E));
      var solutions = usolveAll2(S, b);
      solutions.shift();
      while (solutions.length < multiplicities[_i4]) {
        var approxVec = inverseIterate(S, N, solutions, prec, type);
        if (approxVec === null) {
          break;
        }
        solutions.push(approxVec);
      }
      var correction = multiply2(inv2(R), C);
      solutions = solutions.map((v) => multiply2(correction, v));
      vectors.push(...solutions.map((v) => ({
        value: lambda2,
        vector: flatten2(v)
      })));
    };
    for (var _i4 = 0; _i4 < len; _i4++) {
      _loop();
    }
    return vectors;
  }
  function eigenvalues2x2(a, b, c, d) {
    var trA = addScalar2(a, d);
    var detA = subtract2(multiplyScalar2(a, d), multiplyScalar2(b, c));
    var x = multiplyScalar2(trA, 0.5);
    var y = multiplyScalar2(sqrt2(subtract2(multiplyScalar2(trA, trA), multiplyScalar2(4, detA))), 0.5);
    return [addScalar2(x, y), subtract2(x, y)];
  }
  function jordanBase2x2(a, b, c, d, l1, l2, prec, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var zero = big ? bignumber2(0) : cplx ? complex2(0) : 0;
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    if (smaller2(abs2(c), prec)) {
      return [[one, zero], [zero, one]];
    }
    if (larger2(abs2(subtract2(l1, l2)), prec)) {
      return [[subtract2(l1, d), subtract2(l2, d)], [c, c]];
    }
    var na = subtract2(a, l1);
    var nd = subtract2(d, l1);
    if (smaller2(abs2(b), prec) && smaller2(abs2(nd), prec)) {
      return [[na, one], [c, zero]];
    } else {
      return [[b, zero], [nd, one]];
    }
  }
  function inflateMatrix(arr, N) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      arr[i2].push(...Array(N - arr[i2].length).fill(0));
    }
    for (var _i5 = arr.length; _i5 < N; _i5++) {
      arr.push(Array(N).fill(0));
      arr[_i5][_i5] = 1;
    }
    return arr;
  }
  function blockDiag(arr, N) {
    var M = [];
    for (var i2 = 0; i2 < N; i2++) {
      M[i2] = Array(N).fill(0);
    }
    var I = 0;
    for (var sub2 of arr) {
      var n = sub2.length;
      for (var _i6 = 0; _i6 < n; _i6++) {
        for (var j = 0; j < n; j++) {
          M[I + _i6][I + j] = sub2[_i6][j];
        }
      }
      I += n;
    }
    return M;
  }
  function indexOf(arr, el, fn) {
    for (var i2 = 0; i2 < arr.length; i2++) {
      if (fn(arr[i2], el)) {
        return i2;
      }
    }
    return -1;
  }
  function inverseIterate(A, N, orthog, prec, type) {
    var largeNum = type === "BigNumber" ? bignumber2(1e3) : 1e3;
    var b;
    var i2 = 0;
    for (; i2 < 5; ++i2) {
      b = randomOrthogonalVector(N, orthog, type);
      try {
        b = usolve2(A, b);
      } catch (_unused) {
        continue;
      }
      if (larger2(norm2(b), largeNum)) {
        break;
      }
    }
    if (i2 >= 5) {
      return null;
    }
    i2 = 0;
    while (true) {
      var c = usolve2(A, b);
      if (smaller2(norm2(orthogonalComplement(b, [c])), prec)) {
        break;
      }
      if (++i2 >= 10) {
        return null;
      }
      b = normalize(c);
    }
    return b;
  }
  function randomOrthogonalVector(N, orthog, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var v = Array(N).fill(0).map((_) => 2 * Math.random() - 1);
    if (big) {
      v = v.map((n) => bignumber2(n));
    }
    if (cplx) {
      v = v.map((n) => complex2(n));
    }
    v = orthogonalComplement(v, orthog);
    return normalize(v, type);
  }
  function orthogonalComplement(v, orthog) {
    var vectorShape = size2(v);
    for (var w of orthog) {
      w = reshape2(w, vectorShape);
      v = subtract2(v, multiply2(divideScalar2(dot2(w, v), dot2(w, w)), w));
    }
    return v;
  }
  function norm2(v) {
    return abs2(sqrt2(dot2(v, v)));
  }
  function normalize(v, type) {
    var big = type === "BigNumber";
    var cplx = type === "Complex";
    var one = big ? bignumber2(1) : cplx ? complex2(1) : 1;
    return multiply2(divideScalar2(one, norm2(v)), v);
  }
  return complexEigs;
}
function createRealSymmetric(_ref) {
  var {
    config: config3,
    addScalar: addScalar2,
    subtract: subtract2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2
  } = _ref;
  function main2(arr, N) {
    var prec = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : config3.epsilon;
    var type = arguments.length > 3 ? arguments[3] : void 0;
    var computeVectors = arguments.length > 4 ? arguments[4] : void 0;
    if (type === "number") {
      return diag2(arr, prec, computeVectors);
    }
    if (type === "BigNumber") {
      return diagBig(arr, prec, computeVectors);
    }
    throw TypeError("Unsupported data type: " + type);
  }
  function diag2(x, precision, computeVectors) {
    var N = x.length;
    var e0 = Math.abs(precision / N);
    var psi;
    var Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (var i2 = 0; i2 < N; i2++) {
        Sij[i2] = Array(N).fill(0);
        Sij[i2][i2] = 1;
      }
    }
    var Vab = getAij(x);
    while (Math.abs(Vab[1]) >= Math.abs(e0)) {
      var _i = Vab[0][0];
      var j = Vab[0][1];
      psi = getTheta(x[_i][_i], x[j][j], x[_i][j]);
      x = x1(x, psi, _i, j);
      if (computeVectors)
        Sij = Sij1(Sij, psi, _i, j);
      Vab = getAij(x);
    }
    var Ei = Array(N).fill(0);
    for (var _i2 = 0; _i2 < N; _i2++) {
      Ei[_i2] = x[_i2][_i2];
    }
    return sorting(clone$3(Ei), Sij, computeVectors);
  }
  function diagBig(x, precision, computeVectors) {
    var N = x.length;
    var e0 = abs2(precision / N);
    var psi;
    var Sij;
    if (computeVectors) {
      Sij = new Array(N);
      for (var i2 = 0; i2 < N; i2++) {
        Sij[i2] = Array(N).fill(0);
        Sij[i2][i2] = 1;
      }
    }
    var Vab = getAijBig(x);
    while (abs2(Vab[1]) >= abs2(e0)) {
      var _i3 = Vab[0][0];
      var j = Vab[0][1];
      psi = getThetaBig(x[_i3][_i3], x[j][j], x[_i3][j]);
      x = x1Big(x, psi, _i3, j);
      if (computeVectors)
        Sij = Sij1Big(Sij, psi, _i3, j);
      Vab = getAijBig(x);
    }
    var Ei = Array(N).fill(0);
    for (var _i4 = 0; _i4 < N; _i4++) {
      Ei[_i4] = x[_i4][_i4];
    }
    return sorting(clone$3(Ei), Sij, computeVectors);
  }
  function getTheta(aii, ajj, aij) {
    var denom = ajj - aii;
    if (Math.abs(denom) <= config3.epsilon) {
      return Math.PI / 4;
    } else {
      return 0.5 * Math.atan(2 * aij / (ajj - aii));
    }
  }
  function getThetaBig(aii, ajj, aij) {
    var denom = subtract2(ajj, aii);
    if (abs2(denom) <= config3.epsilon) {
      return bignumber2(-1).acos().div(4);
    } else {
      return multiplyScalar2(0.5, atan3(multiply2(2, aij, inv2(denom))));
    }
  }
  function Sij1(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var Ski = Array(N).fill(0);
    var Skj = Array(N).fill(0);
    for (var k = 0; k < N; k++) {
      Ski[k] = c * Sij[k][i2] - s * Sij[k][j];
      Skj[k] = s * Sij[k][i2] + c * Sij[k][j];
    }
    for (var _k = 0; _k < N; _k++) {
      Sij[_k][i2] = Ski[_k];
      Sij[_k][j] = Skj[_k];
    }
    return Sij;
  }
  function Sij1Big(Sij, theta, i2, j) {
    var N = Sij.length;
    var c = cos2(theta);
    var s = sin2(theta);
    var Ski = Array(N).fill(bignumber2(0));
    var Skj = Array(N).fill(bignumber2(0));
    for (var k = 0; k < N; k++) {
      Ski[k] = subtract2(multiplyScalar2(c, Sij[k][i2]), multiplyScalar2(s, Sij[k][j]));
      Skj[k] = addScalar2(multiplyScalar2(s, Sij[k][i2]), multiplyScalar2(c, Sij[k][j]));
    }
    for (var _k2 = 0; _k2 < N; _k2++) {
      Sij[_k2][i2] = Ski[_k2];
      Sij[_k2][j] = Skj[_k2];
    }
    return Sij;
  }
  function x1Big(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = bignumber2(cos2(theta));
    var s = bignumber2(sin2(theta));
    var c2 = multiplyScalar2(c, c);
    var s2 = multiplyScalar2(s, s);
    var Aki = Array(N).fill(bignumber2(0));
    var Akj = Array(N).fill(bignumber2(0));
    var csHij = multiply2(bignumber2(2), c, s, Hij[i2][j]);
    var Aii = addScalar2(subtract2(multiplyScalar2(c2, Hij[i2][i2]), csHij), multiplyScalar2(s2, Hij[j][j]));
    var Ajj = add2(multiplyScalar2(s2, Hij[i2][i2]), csHij, multiplyScalar2(c2, Hij[j][j]));
    for (var k = 0; k < N; k++) {
      Aki[k] = subtract2(multiplyScalar2(c, Hij[i2][k]), multiplyScalar2(s, Hij[j][k]));
      Akj[k] = addScalar2(multiplyScalar2(s, Hij[i2][k]), multiplyScalar2(c, Hij[j][k]));
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = bignumber2(0);
    Hij[j][i2] = bignumber2(0);
    for (var _k3 = 0; _k3 < N; _k3++) {
      if (_k3 !== i2 && _k3 !== j) {
        Hij[i2][_k3] = Aki[_k3];
        Hij[_k3][i2] = Aki[_k3];
        Hij[j][_k3] = Akj[_k3];
        Hij[_k3][j] = Akj[_k3];
      }
    }
    return Hij;
  }
  function x1(Hij, theta, i2, j) {
    var N = Hij.length;
    var c = Math.cos(theta);
    var s = Math.sin(theta);
    var c2 = c * c;
    var s2 = s * s;
    var Aki = Array(N).fill(0);
    var Akj = Array(N).fill(0);
    var Aii = c2 * Hij[i2][i2] - 2 * c * s * Hij[i2][j] + s2 * Hij[j][j];
    var Ajj = s2 * Hij[i2][i2] + 2 * c * s * Hij[i2][j] + c2 * Hij[j][j];
    for (var k = 0; k < N; k++) {
      Aki[k] = c * Hij[i2][k] - s * Hij[j][k];
      Akj[k] = s * Hij[i2][k] + c * Hij[j][k];
    }
    Hij[i2][i2] = Aii;
    Hij[j][j] = Ajj;
    Hij[i2][j] = 0;
    Hij[j][i2] = 0;
    for (var _k4 = 0; _k4 < N; _k4++) {
      if (_k4 !== i2 && _k4 !== j) {
        Hij[i2][_k4] = Aki[_k4];
        Hij[_k4][i2] = Aki[_k4];
        Hij[j][_k4] = Akj[_k4];
        Hij[_k4][j] = Akj[_k4];
      }
    }
    return Hij;
  }
  function getAij(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (Math.abs(maxMij) < Math.abs(Mij[i2][j])) {
          maxMij = Math.abs(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function getAijBig(Mij) {
    var N = Mij.length;
    var maxMij = 0;
    var maxIJ = [0, 1];
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2 + 1; j < N; j++) {
        if (abs2(maxMij) < abs2(Mij[i2][j])) {
          maxMij = abs2(Mij[i2][j]);
          maxIJ = [i2, j];
        }
      }
    }
    return [maxIJ, maxMij];
  }
  function sorting(E, S, computeVectors) {
    var N = E.length;
    var values = Array(N);
    var vecs;
    if (computeVectors) {
      vecs = Array(N);
      for (var k = 0; k < N; k++) {
        vecs[k] = Array(N);
      }
    }
    for (var i2 = 0; i2 < N; i2++) {
      var minID = 0;
      var minE = E[0];
      for (var j = 0; j < E.length; j++) {
        if (abs2(E[j]) < abs2(minE)) {
          minID = j;
          minE = E[minID];
        }
      }
      values[i2] = E.splice(minID, 1)[0];
      if (computeVectors) {
        for (var _k5 = 0; _k5 < N; _k5++) {
          vecs[i2][_k5] = S[_k5][minID];
          S[_k5].splice(minID, 1);
        }
      }
    }
    if (!computeVectors)
      return {
        values
      };
    var eigenvectors = vecs.map((vector, i3) => ({
      value: values[i3],
      vector
    }));
    return {
      values,
      eigenvectors
    };
  }
  return main2;
}
var name$15 = "eigs";
var dependencies$15 = ["config", "typed", "matrix", "addScalar", "equal", "subtract", "abs", "atan", "cos", "sin", "multiplyScalar", "divideScalar", "inv", "bignumber", "multiply", "add", "larger", "column", "flatten", "number", "complex", "sqrt", "diag", "size", "reshape", "qr", "usolve", "usolveAll", "im", "re", "smaller", "matrixFromColumns", "dot"];
var createEigs = /* @__PURE__ */ factory(name$15, dependencies$15, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    matrix: matrix2,
    addScalar: addScalar2,
    subtract: subtract2,
    equal: equal2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    inv: inv2,
    bignumber: bignumber2,
    multiply: multiply2,
    add: add2,
    larger: larger2,
    column: column2,
    flatten: flatten2,
    number: number2,
    complex: complex2,
    sqrt: sqrt2,
    diag: diag2,
    size: size2,
    reshape: reshape2,
    qr: qr2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    im: im2,
    re: re2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  } = _ref;
  var doRealSymmetric = createRealSymmetric({
    config: config3,
    addScalar: addScalar2,
    subtract: subtract2,
    column: column2,
    flatten: flatten2,
    equal: equal2,
    abs: abs2,
    atan: atan3,
    cos: cos2,
    sin: sin2,
    multiplyScalar: multiplyScalar2,
    inv: inv2,
    bignumber: bignumber2,
    complex: complex2,
    multiply: multiply2,
    add: add2
  });
  var doComplexEigs = createComplexEigs({
    config: config3,
    addScalar: addScalar2,
    subtract: subtract2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    flatten: flatten2,
    divideScalar: divideScalar2,
    sqrt: sqrt2,
    abs: abs2,
    bignumber: bignumber2,
    diag: diag2,
    size: size2,
    reshape: reshape2,
    qr: qr2,
    inv: inv2,
    usolve: usolve2,
    usolveAll: usolveAll2,
    equal: equal2,
    complex: complex2,
    larger: larger2,
    smaller: smaller2,
    matrixFromColumns: matrixFromColumns2,
    dot: dot2
  });
  return typed2("eigs", {
    // The conversion to matrix in the first two implementations,
    // just to convert back to an array right away in
    // computeValuesAndVectors, is unfortunate, and should perhaps be
    // streamlined. It is done because the Matrix object carries some
    // type information about its entries, and so constructing the matrix
    // is a roundabout way of doing type detection.
    Array: function Array2(x) {
      return doEigs(matrix2(x));
    },
    "Array, number|BigNumber": function ArrayNumberBigNumber(x, prec) {
      return doEigs(matrix2(x), {
        precision: prec
      });
    },
    "Array, Object"(x, opts) {
      return doEigs(matrix2(x), opts);
    },
    Matrix: function Matrix2(mat) {
      return doEigs(mat, {
        matricize: true
      });
    },
    "Matrix, number|BigNumber": function MatrixNumberBigNumber(mat, prec) {
      return doEigs(mat, {
        precision: prec,
        matricize: true
      });
    },
    "Matrix, Object": function MatrixObject(mat, opts) {
      var useOpts = {
        matricize: true
      };
      _extends$1(useOpts, opts);
      return doEigs(mat, useOpts);
    }
  });
  function doEigs(mat) {
    var _opts$precision;
    var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var computeVectors = "eigenvectors" in opts ? opts.eigenvectors : true;
    var prec = (_opts$precision = opts.precision) !== null && _opts$precision !== void 0 ? _opts$precision : config3.epsilon;
    var result = computeValuesAndVectors(mat, prec, computeVectors);
    if (opts.matricize) {
      result.values = matrix2(result.values);
      if (computeVectors) {
        result.eigenvectors = result.eigenvectors.map((_ref2) => {
          var {
            value,
            vector
          } = _ref2;
          return {
            value,
            vector: matrix2(vector)
          };
        });
      }
    }
    if (computeVectors) {
      Object.defineProperty(result, "vectors", {
        enumerable: false,
        // to make sure that the eigenvectors can still be
        // converted to string.
        get: () => {
          throw new Error("eigs(M).vectors replaced with eigs(M).eigenvectors");
        }
      });
    }
    return result;
  }
  function computeValuesAndVectors(mat, prec, computeVectors) {
    var arr = mat.toArray();
    var asize = mat.size();
    if (asize.length !== 2 || asize[0] !== asize[1]) {
      throw new RangeError("Matrix must be square (size: ".concat(format$1(asize), ")"));
    }
    var N = asize[0];
    if (isReal(arr, N, prec)) {
      coerceReal(arr, N);
      if (isSymmetric(arr, N, prec)) {
        var _type = coerceTypes(mat, arr, N);
        return doRealSymmetric(arr, N, prec, _type, computeVectors);
      }
    }
    var type = coerceTypes(mat, arr, N);
    return doComplexEigs(arr, N, prec, type, computeVectors);
  }
  function isSymmetric(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = i2; j < N; j++) {
        if (larger2(bignumber2(abs2(subtract2(arr[i2][j], arr[j][i2]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function isReal(arr, N, prec) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        if (larger2(bignumber2(abs2(im2(arr[i2][j]))), prec)) {
          return false;
        }
      }
    }
    return true;
  }
  function coerceReal(arr, N) {
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        arr[i2][j] = re2(arr[i2][j]);
      }
    }
  }
  function coerceTypes(mat, arr, N) {
    var type = mat.datatype();
    if (type === "number" || type === "BigNumber" || type === "Complex") {
      return type;
    }
    var hasNumber = false;
    var hasBig = false;
    var hasComplex = false;
    for (var i2 = 0; i2 < N; i2++) {
      for (var j = 0; j < N; j++) {
        var el = arr[i2][j];
        if (isNumber(el) || isFraction(el)) {
          hasNumber = true;
        } else if (isBigNumber(el)) {
          hasBig = true;
        } else if (isComplex(el)) {
          hasComplex = true;
        } else {
          throw TypeError("Unsupported type in Matrix: " + typeOf$1(el));
        }
      }
    }
    if (hasBig && hasComplex) {
      console.warn("Complex BigNumbers not supported, this operation will lose precission.");
    }
    if (hasComplex) {
      for (var _i = 0; _i < N; _i++) {
        for (var _j = 0; _j < N; _j++) {
          arr[_i][_j] = complex2(arr[_i][_j]);
        }
      }
      return "Complex";
    }
    if (hasBig) {
      for (var _i2 = 0; _i2 < N; _i2++) {
        for (var _j2 = 0; _j2 < N; _j2++) {
          arr[_i2][_j2] = bignumber2(arr[_i2][_j2]);
        }
      }
      return "BigNumber";
    }
    if (hasNumber) {
      for (var _i3 = 0; _i3 < N; _i3++) {
        for (var _j3 = 0; _j3 < N; _j3++) {
          arr[_i3][_j3] = number2(arr[_i3][_j3]);
        }
      }
      return "number";
    } else {
      throw TypeError("Matrix contains unsupported types only.");
    }
  }
});
var name$14 = "expm";
var dependencies$14 = ["typed", "abs", "add", "identity", "inv", "multiply"];
var createExpm = /* @__PURE__ */ factory(name$14, dependencies$14, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    identity: identity2,
    inv: inv2,
    multiply: multiply2
  } = _ref;
  return typed2(name$14, {
    Matrix: function Matrix2(A) {
      var size2 = A.size();
      if (size2.length !== 2 || size2[0] !== size2[1]) {
        throw new RangeError("Matrix must be square (size: " + format$1(size2) + ")");
      }
      var n = size2[0];
      var eps = 1e-15;
      var infNorm = infinityNorm(A);
      var params = findParams(infNorm, eps);
      var q = params.q;
      var j = params.j;
      var Apos = multiply2(A, Math.pow(2, -j));
      var N = identity2(n);
      var D = identity2(n);
      var factor = 1;
      var AposToI = Apos;
      var alternate = -1;
      for (var i2 = 1; i2 <= q; i2++) {
        if (i2 > 1) {
          AposToI = multiply2(AposToI, Apos);
          alternate = -alternate;
        }
        factor = factor * (q - i2 + 1) / ((2 * q - i2 + 1) * i2);
        N = add2(N, multiply2(factor, AposToI));
        D = add2(D, multiply2(factor * alternate, AposToI));
      }
      var R = multiply2(inv2(D), N);
      for (var _i = 0; _i < j; _i++) {
        R = multiply2(R, R);
      }
      return isSparseMatrix(A) ? A.createSparseMatrix(R) : R;
    }
  });
  function infinityNorm(A) {
    var n = A.size()[0];
    var infNorm = 0;
    for (var i2 = 0; i2 < n; i2++) {
      var rowSum = 0;
      for (var j = 0; j < n; j++) {
        rowSum += abs2(A.get([i2, j]));
      }
      infNorm = Math.max(rowSum, infNorm);
    }
    return infNorm;
  }
  function findParams(infNorm, eps) {
    var maxSearchSize = 30;
    for (var k = 0; k < maxSearchSize; k++) {
      for (var q = 0; q <= k; q++) {
        var j = k - q;
        if (errorEstimate(infNorm, q, j) < eps) {
          return {
            q,
            j
          };
        }
      }
    }
    throw new Error("Could not find acceptable parameters to compute the matrix exponential (try increasing maxSearchSize in expm.js)");
  }
  function errorEstimate(infNorm, q, j) {
    var qfac = 1;
    for (var i2 = 2; i2 <= q; i2++) {
      qfac *= i2;
    }
    var twoqfac = qfac;
    for (var _i2 = q + 1; _i2 <= 2 * q; _i2++) {
      twoqfac *= _i2;
    }
    var twoqp1fac = twoqfac * (2 * q + 1);
    return 8 * Math.pow(infNorm / Math.pow(2, j), 2 * q) * qfac * qfac / (twoqfac * twoqp1fac);
  }
});
var name$13 = "sqrtm";
var dependencies$13 = ["typed", "abs", "add", "multiply", "map", "sqrt", "subtract", "inv", "size", "max", "identity"];
var createSqrtm = /* @__PURE__ */ factory(name$13, dependencies$13, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    add: add2,
    multiply: multiply2,
    map: map2,
    sqrt: sqrt2,
    subtract: subtract2,
    inv: inv2,
    size: size2,
    max: max2,
    identity: identity2
  } = _ref;
  var _maxIterations = 1e3;
  var _tolerance = 1e-6;
  function _denmanBeavers(A) {
    var error;
    var iterations = 0;
    var Y = A;
    var Z = identity2(size2(A));
    do {
      var Yk = Y;
      Y = multiply2(0.5, add2(Yk, inv2(Z)));
      Z = multiply2(0.5, add2(Z, inv2(Yk)));
      error = max2(abs2(subtract2(Y, Yk)));
      if (error > _tolerance && ++iterations > _maxIterations) {
        throw new Error("computing square root of matrix: iterative method could not converge");
      }
    } while (error > _tolerance);
    return Y;
  }
  return typed2(name$13, {
    "Array | Matrix": function ArrayMatrix(A) {
      var size3 = isMatrix(A) ? A.size() : arraySize(A);
      switch (size3.length) {
        case 1:
          if (size3[0] === 1) {
            return map2(A, sqrt2);
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size3) + ")");
          }
        case 2: {
          var rows = size3[0];
          var cols = size3[1];
          if (rows === cols) {
            return _denmanBeavers(A);
          } else {
            throw new RangeError("Matrix must be square (size: " + format$1(size3) + ")");
          }
        }
        default:
          throw new RangeError("Matrix must be at most two dimensional (size: " + format$1(size3) + ")");
      }
    }
  });
});
var name$12 = "sylvester";
var dependencies$12 = ["typed", "schur", "matrixFromColumns", "matrix", "multiply", "range", "concat", "transpose", "index", "subset", "add", "subtract", "identity", "lusolve", "abs"];
var createSylvester = /* @__PURE__ */ factory(name$12, dependencies$12, (_ref) => {
  var {
    typed: typed2,
    schur: schur2,
    matrixFromColumns: matrixFromColumns2,
    matrix: matrix2,
    multiply: multiply2,
    range: range2,
    concat: concat2,
    transpose: transpose2,
    index: index2,
    subset: subset2,
    add: add2,
    subtract: subtract2,
    identity: identity2,
    lusolve: lusolve2,
    abs: abs2
  } = _ref;
  return typed2(name$12, {
    "Matrix, Matrix, Matrix": _sylvester,
    "Array, Matrix, Matrix": function ArrayMatrixMatrix(A, B, C) {
      return _sylvester(matrix2(A), B, C);
    },
    "Array, Array, Matrix": function ArrayArrayMatrix(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), C);
    },
    "Array, Matrix, Array": function ArrayMatrixArray(A, B, C) {
      return _sylvester(matrix2(A), B, matrix2(C));
    },
    "Matrix, Array, Matrix": function MatrixArrayMatrix(A, B, C) {
      return _sylvester(A, matrix2(B), C);
    },
    "Matrix, Array, Array": function MatrixArrayArray(A, B, C) {
      return _sylvester(A, matrix2(B), matrix2(C));
    },
    "Matrix, Matrix, Array": function MatrixMatrixArray(A, B, C) {
      return _sylvester(A, B, matrix2(C));
    },
    "Array, Array, Array": function ArrayArrayArray(A, B, C) {
      return _sylvester(matrix2(A), matrix2(B), matrix2(C)).toArray();
    }
  });
  function _sylvester(A, B, C) {
    var n = B.size()[0];
    var m = A.size()[0];
    var sA = schur2(A);
    var F = sA.T;
    var U = sA.U;
    var sB = schur2(multiply2(-1, B));
    var G = sB.T;
    var V = sB.U;
    var D = multiply2(multiply2(transpose2(U), C), V);
    var all = range2(0, m);
    var y = [];
    var hc = (a, b) => concat2(a, b, 1);
    var vc = (a, b) => concat2(a, b, 0);
    for (var k = 0; k < n; k++) {
      if (k < n - 1 && abs2(subset2(G, index2(k + 1, k))) > 1e-5) {
        var RHS = vc(subset2(D, index2(all, k)), subset2(D, index2(all, k + 1)));
        for (var j = 0; j < k; j++) {
          RHS = add2(RHS, vc(multiply2(y[j], subset2(G, index2(j, k))), multiply2(y[j], subset2(G, index2(j, k + 1)))));
        }
        var gkk = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k, k))));
        var gmk = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k + 1, k))));
        var gkm = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k, k + 1))));
        var gmm = multiply2(identity2(m), multiply2(-1, subset2(G, index2(k + 1, k + 1))));
        var LHS = vc(hc(add2(F, gkk), gmk), hc(gkm, add2(F, gmm)));
        var yAux = lusolve2(LHS, RHS);
        y[k] = yAux.subset(index2(range2(0, m), 0));
        y[k + 1] = yAux.subset(index2(range2(m, 2 * m), 0));
        k++;
      } else {
        var _RHS = subset2(D, index2(all, k));
        for (var _j = 0; _j < k; _j++) {
          _RHS = add2(_RHS, multiply2(y[_j], subset2(G, index2(_j, k))));
        }
        var _gkk = subset2(G, index2(k, k));
        var _LHS = subtract2(F, multiply2(_gkk, identity2(m)));
        y[k] = lusolve2(_LHS, _RHS);
      }
    }
    var Y = matrix2(matrixFromColumns2(...y));
    var X = multiply2(U, multiply2(Y, transpose2(V)));
    return X;
  }
});
var name$11 = "schur";
var dependencies$11 = ["typed", "matrix", "identity", "multiply", "qr", "norm", "subtract"];
var createSchur = /* @__PURE__ */ factory(name$11, dependencies$11, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    identity: identity2,
    multiply: multiply2,
    qr: qr2,
    norm: norm2,
    subtract: subtract2
  } = _ref;
  return typed2(name$11, {
    Array: function Array2(X) {
      var r = _schur(matrix2(X));
      return {
        U: r.U.valueOf(),
        T: r.T.valueOf()
      };
    },
    Matrix: function Matrix2(X) {
      return _schur(X);
    }
  });
  function _schur(X) {
    var n = X.size()[0];
    var A = X;
    var U = identity2(n);
    var k = 0;
    var A0;
    do {
      A0 = A;
      var QR = qr2(A);
      var Q2 = QR.Q;
      var R = QR.R;
      A = multiply2(R, Q2);
      U = multiply2(U, Q2);
      if (k++ > 100) {
        break;
      }
    } while (norm2(subtract2(A, A0)) > 1e-4);
    return {
      U,
      T: A
    };
  }
});
var name$10 = "lyap";
var dependencies$10 = ["typed", "matrix", "sylvester", "multiply", "transpose"];
var createLyap = /* @__PURE__ */ factory(name$10, dependencies$10, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    sylvester: sylvester2,
    multiply: multiply2,
    transpose: transpose2
  } = _ref;
  return typed2(name$10, {
    "Matrix, Matrix": function MatrixMatrix(A, Q2) {
      return sylvester2(A, transpose2(A), multiply2(-1, Q2));
    },
    "Array, Matrix": function ArrayMatrix(A, Q2) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), multiply2(-1, Q2));
    },
    "Matrix, Array": function MatrixArray(A, Q2) {
      return sylvester2(A, transpose2(matrix2(A)), matrix2(multiply2(-1, Q2)));
    },
    "Array, Array": function ArrayArray(A, Q2) {
      return sylvester2(matrix2(A), transpose2(matrix2(A)), matrix2(multiply2(-1, Q2))).toArray();
    }
  });
});
var name$$ = "divide";
var dependencies$$ = ["typed", "matrix", "multiply", "equalScalar", "divideScalar", "inv"];
var createDivide = /* @__PURE__ */ factory(name$$, dependencies$$, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    multiply: multiply2,
    equalScalar: equalScalar2,
    divideScalar: divideScalar2,
    inv: inv2
  } = _ref;
  var matAlgo11xS0s = createMatAlgo11xS0s({
    typed: typed2,
    equalScalar: equalScalar2
  });
  var matAlgo14xDs = createMatAlgo14xDs({
    typed: typed2
  });
  return typed2("divide", extend({
    // we extend the signatures of divideScalar with signatures dealing with matrices
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    },
    "DenseMatrix, any": function DenseMatrixAny(x, y) {
      return matAlgo14xDs(x, y, divideScalar2, false);
    },
    "SparseMatrix, any": function SparseMatrixAny(x, y) {
      return matAlgo11xS0s(x, y, divideScalar2, false);
    },
    "Array, any": function ArrayAny(x, y) {
      return matAlgo14xDs(matrix2(x), y, divideScalar2, false).valueOf();
    },
    "any, Array | Matrix": function anyArrayMatrix(x, y) {
      return multiply2(x, inv2(y));
    }
  }, divideScalar2.signatures));
});
var name$_ = "distance";
var dependencies$_ = ["typed", "addScalar", "subtractScalar", "divideScalar", "multiplyScalar", "deepEqual", "sqrt", "abs"];
var createDistance = /* @__PURE__ */ factory(name$_, dependencies$_, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    subtractScalar: subtractScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    deepEqual: deepEqual2,
    sqrt: sqrt2,
    abs: abs2
  } = _ref;
  return typed2(name$_, {
    "Array, Array, Array": function ArrayArrayArray(x, y, z) {
      if (x.length === 2 && y.length === 2 && z.length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_2d(y)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
        }
        if (!_2d(z)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
        }
        if (deepEqual2(y, z)) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        var xCoeff = subtractScalar2(z[1], y[1]);
        var yCoeff = subtractScalar2(y[0], z[0]);
        var constant = subtractScalar2(multiplyScalar2(z[0], y[1]), multiplyScalar2(y[0], z[1]));
        return _distancePointLine2D(x[0], x[1], xCoeff, yCoeff, constant);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object, Object": function ObjectObjectObject(x, y, z) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 2 && Object.keys(z).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of lineOnePtX and lineOnePtY should be numbers or BigNumbers");
        }
        if (!_2d(z)) {
          throw new TypeError("Values of lineTwoPtX and lineTwoPtY should be numbers or BigNumbers");
        }
        if (deepEqual2(_objectToArray(y), _objectToArray(z))) {
          throw new TypeError("LinePoint1 should not be same with LinePoint2");
        }
        if ("pointX" in x && "pointY" in x && "lineOnePtX" in y && "lineOnePtY" in y && "lineTwoPtX" in z && "lineTwoPtY" in z) {
          var xCoeff = subtractScalar2(z.lineTwoPtY, y.lineOnePtY);
          var yCoeff = subtractScalar2(y.lineOnePtX, z.lineTwoPtX);
          var constant = subtractScalar2(multiplyScalar2(z.lineTwoPtX, y.lineOnePtY), multiplyScalar2(y.lineOnePtX, z.lineTwoPtY));
          return _distancePointLine2D(x.pointX, x.pointY, xCoeff, yCoeff, constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Array, Array": function ArrayArray(x, y) {
      if (x.length === 2 && y.length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
        }
        if (!_3d(y)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine2D(x[0], x[1], y[0], y[1], y[2]);
      } else if (x.length === 3 && y.length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Array with 6 numbers or BigNumbers expected for second argument");
        }
        return _distancePointLine3D(x[0], x[1], x[2], y[0], y[1], y[2], y[3], y[4], y[5]);
      } else if (x.length === y.length && x.length > 0) {
        if (!_containsOnlyNumbers(x)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        if (!_containsOnlyNumbers(y)) {
          throw new TypeError("All values of an array should be numbers or BigNumbers");
        }
        return _euclideanDistance(x, y);
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    "Object, Object": function ObjectObject(x, y) {
      if (Object.keys(x).length === 2 && Object.keys(y).length === 3) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointX and pointY should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of xCoeffLine, yCoeffLine and constant should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "xCoeffLine" in y && "yCoeffLine" in y && "constant" in y) {
          return _distancePointLine2D(x.pointX, x.pointY, y.xCoeffLine, y.yCoeffLine, y.constant);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 6) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointX, pointY and pointZ should be numbers or BigNumbers");
        }
        if (!_parametricLine(y)) {
          throw new TypeError("Values of x0, y0, z0, a, b and c should be numbers or BigNumbers");
        }
        if ("pointX" in x && "pointY" in x && "x0" in y && "y0" in y && "z0" in y && "a" in y && "b" in y && "c" in y) {
          return _distancePointLine3D(x.pointX, x.pointY, x.pointZ, y.x0, y.y0, y.z0, y.a, y.b, y.c);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 2 && Object.keys(y).length === 2) {
        if (!_2d(x)) {
          throw new TypeError("Values of pointOneX and pointOneY should be numbers or BigNumbers");
        }
        if (!_2d(y)) {
          throw new TypeError("Values of pointTwoX and pointTwoY should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointTwoX" in y && "pointTwoY" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY], [y.pointTwoX, y.pointTwoY]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else if (Object.keys(x).length === 3 && Object.keys(y).length === 3) {
        if (!_3d(x)) {
          throw new TypeError("Values of pointOneX, pointOneY and pointOneZ should be numbers or BigNumbers");
        }
        if (!_3d(y)) {
          throw new TypeError("Values of pointTwoX, pointTwoY and pointTwoZ should be numbers or BigNumbers");
        }
        if ("pointOneX" in x && "pointOneY" in x && "pointOneZ" in x && "pointTwoX" in y && "pointTwoY" in y && "pointTwoZ" in y) {
          return _euclideanDistance([x.pointOneX, x.pointOneY, x.pointOneZ], [y.pointTwoX, y.pointTwoY, y.pointTwoZ]);
        } else {
          throw new TypeError("Key names do not match");
        }
      } else {
        throw new TypeError("Invalid Arguments: Try again");
      }
    },
    Array: function Array2(arr) {
      if (!_pairwise(arr)) {
        throw new TypeError("Incorrect array format entered for pairwise distance calculation");
      }
      return _distancePairwise(arr);
    }
  });
  function _isNumber(a) {
    return typeof a === "number" || isBigNumber(a);
  }
  function _2d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]);
  }
  function _3d(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]);
  }
  function _containsOnlyNumbers(a) {
    if (!Array.isArray(a)) {
      a = _objectToArray(a);
    }
    return a.every(_isNumber);
  }
  function _parametricLine(a) {
    if (a.constructor !== Array) {
      a = _objectToArray(a);
    }
    return _isNumber(a[0]) && _isNumber(a[1]) && _isNumber(a[2]) && _isNumber(a[3]) && _isNumber(a[4]) && _isNumber(a[5]);
  }
  function _objectToArray(o) {
    var keys = Object.keys(o);
    var a = [];
    for (var i2 = 0; i2 < keys.length; i2++) {
      a.push(o[keys[i2]]);
    }
    return a;
  }
  function _pairwise(a) {
    if (a[0].length === 2 && _isNumber(a[0][0]) && _isNumber(a[0][1])) {
      if (a.some((aI) => aI.length !== 2 || !_isNumber(aI[0]) || !_isNumber(aI[1]))) {
        return false;
      }
    } else if (a[0].length === 3 && _isNumber(a[0][0]) && _isNumber(a[0][1]) && _isNumber(a[0][2])) {
      if (a.some((aI) => aI.length !== 3 || !_isNumber(aI[0]) || !_isNumber(aI[1]) || !_isNumber(aI[2]))) {
        return false;
      }
    } else {
      return false;
    }
    return true;
  }
  function _distancePointLine2D(x, y, a, b, c) {
    var num = abs2(addScalar2(addScalar2(multiplyScalar2(a, x), multiplyScalar2(b, y)), c));
    var den = sqrt2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)));
    return divideScalar2(num, den);
  }
  function _distancePointLine3D(x, y, z, x0, y0, z0, a, b, c) {
    var num = [subtractScalar2(multiplyScalar2(subtractScalar2(y0, y), c), multiplyScalar2(subtractScalar2(z0, z), b)), subtractScalar2(multiplyScalar2(subtractScalar2(z0, z), a), multiplyScalar2(subtractScalar2(x0, x), c)), subtractScalar2(multiplyScalar2(subtractScalar2(x0, x), b), multiplyScalar2(subtractScalar2(y0, y), a))];
    num = sqrt2(addScalar2(addScalar2(multiplyScalar2(num[0], num[0]), multiplyScalar2(num[1], num[1])), multiplyScalar2(num[2], num[2])));
    var den = sqrt2(addScalar2(addScalar2(multiplyScalar2(a, a), multiplyScalar2(b, b)), multiplyScalar2(c, c)));
    return divideScalar2(num, den);
  }
  function _euclideanDistance(x, y) {
    var vectorSize = x.length;
    var result = 0;
    var diff2 = 0;
    for (var i2 = 0; i2 < vectorSize; i2++) {
      diff2 = subtractScalar2(x[i2], y[i2]);
      result = addScalar2(multiplyScalar2(diff2, diff2), result);
    }
    return sqrt2(result);
  }
  function _distancePairwise(a) {
    var result = [];
    var pointA = [];
    var pointB = [];
    for (var i2 = 0; i2 < a.length - 1; i2++) {
      for (var j = i2 + 1; j < a.length; j++) {
        if (a[0].length === 2) {
          pointA = [a[i2][0], a[i2][1]];
          pointB = [a[j][0], a[j][1]];
        } else if (a[0].length === 3) {
          pointA = [a[i2][0], a[i2][1], a[i2][2]];
          pointB = [a[j][0], a[j][1], a[j][2]];
        }
        result.push(_euclideanDistance(pointA, pointB));
      }
    }
    return result;
  }
});
var name$Z = "intersect";
var dependencies$Z = ["typed", "config", "abs", "add", "addScalar", "matrix", "multiply", "multiplyScalar", "divideScalar", "subtract", "smaller", "equalScalar", "flatten", "isZero", "isNumeric"];
var createIntersect = /* @__PURE__ */ factory(name$Z, dependencies$Z, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    abs: abs2,
    add: add2,
    addScalar: addScalar2,
    matrix: matrix2,
    multiply: multiply2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    subtract: subtract2,
    smaller: smaller2,
    equalScalar: equalScalar2,
    flatten: flatten2,
    isZero: isZero2,
    isNumeric: isNumeric2
  } = _ref;
  return typed2("intersect", {
    "Array, Array, Array": _AAA,
    "Array, Array, Array, Array": _AAAA,
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(x, y, plane) {
      var arr = _AAA(x.valueOf(), y.valueOf(), plane.valueOf());
      return arr === null ? null : matrix2(arr);
    },
    "Matrix, Matrix, Matrix, Matrix": function MatrixMatrixMatrixMatrix(w, x, y, z) {
      var arr = _AAAA(w.valueOf(), x.valueOf(), y.valueOf(), z.valueOf());
      return arr === null ? null : matrix2(arr);
    }
  });
  function _AAA(x, y, plane) {
    x = _coerceArr(x);
    y = _coerceArr(y);
    plane = _coerceArr(plane);
    if (!_3d(x)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
    }
    if (!_3d(y)) {
      throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
    }
    if (!_4d(plane)) {
      throw new TypeError("Array with 4 numbers expected as third argument");
    }
    return _intersectLinePlane(x[0], x[1], x[2], y[0], y[1], y[2], plane[0], plane[1], plane[2], plane[3]);
  }
  function _AAAA(w, x, y, z) {
    w = _coerceArr(w);
    x = _coerceArr(x);
    y = _coerceArr(y);
    z = _coerceArr(z);
    if (w.length === 2) {
      if (!_2d(w)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for first argument");
      }
      if (!_2d(x)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for second argument");
      }
      if (!_2d(y)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for third argument");
      }
      if (!_2d(z)) {
        throw new TypeError("Array with 2 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect2d(w, x, y, z);
    } else if (w.length === 3) {
      if (!_3d(w)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for first argument");
      }
      if (!_3d(x)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for second argument");
      }
      if (!_3d(y)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for third argument");
      }
      if (!_3d(z)) {
        throw new TypeError("Array with 3 numbers or BigNumbers expected for fourth argument");
      }
      return _intersect3d(w[0], w[1], w[2], x[0], x[1], x[2], y[0], y[1], y[2], z[0], z[1], z[2]);
    } else {
      throw new TypeError("Arrays with two or thee dimensional points expected");
    }
  }
  function _coerceArr(arr) {
    if (arr.length === 1)
      return arr[0];
    if (arr.length > 1 && Array.isArray(arr[0])) {
      if (arr.every((el) => Array.isArray(el) && el.length === 1))
        return flatten2(arr);
    }
    return arr;
  }
  function _2d(x) {
    return x.length === 2 && isNumeric2(x[0]) && isNumeric2(x[1]);
  }
  function _3d(x) {
    return x.length === 3 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]);
  }
  function _4d(x) {
    return x.length === 4 && isNumeric2(x[0]) && isNumeric2(x[1]) && isNumeric2(x[2]) && isNumeric2(x[3]);
  }
  function _intersect2d(p1a, p1b, p2a, p2b) {
    var o1 = p1a;
    var o2 = p2a;
    var d1 = subtract2(o1, p1b);
    var d2 = subtract2(o2, p2b);
    var det2 = subtract2(multiplyScalar2(d1[0], d2[1]), multiplyScalar2(d2[0], d1[1]));
    if (isZero2(det2))
      return null;
    if (smaller2(abs2(det2), config3.epsilon)) {
      return null;
    }
    var d20o11 = multiplyScalar2(d2[0], o1[1]);
    var d21o10 = multiplyScalar2(d2[1], o1[0]);
    var d20o21 = multiplyScalar2(d2[0], o2[1]);
    var d21o20 = multiplyScalar2(d2[1], o2[0]);
    var t = divideScalar2(addScalar2(subtract2(subtract2(d20o11, d21o10), d20o21), d21o20), det2);
    return add2(multiply2(d1, t), o1);
  }
  function _intersect3dHelper(a, b, c, d, e2, f, g, h, i2, j, k, l) {
    var add1 = multiplyScalar2(subtract2(a, b), subtract2(c, d));
    var add22 = multiplyScalar2(subtract2(e2, f), subtract2(g, h));
    var add3 = multiplyScalar2(subtract2(i2, j), subtract2(k, l));
    return addScalar2(addScalar2(add1, add22), add3);
  }
  function _intersect3d(x1, y1, z1, x2, y2, z2, x3, y3, z3, x4, y4, z4) {
    var d1343 = _intersect3dHelper(x1, x3, x4, x3, y1, y3, y4, y3, z1, z3, z4, z3);
    var d4321 = _intersect3dHelper(x4, x3, x2, x1, y4, y3, y2, y1, z4, z3, z2, z1);
    var d1321 = _intersect3dHelper(x1, x3, x2, x1, y1, y3, y2, y1, z1, z3, z2, z1);
    var d4343 = _intersect3dHelper(x4, x3, x4, x3, y4, y3, y4, y3, z4, z3, z4, z3);
    var d2121 = _intersect3dHelper(x2, x1, x2, x1, y2, y1, y2, y1, z2, z1, z2, z1);
    var numerator = subtract2(multiplyScalar2(d1343, d4321), multiplyScalar2(d1321, d4343));
    var denominator = subtract2(multiplyScalar2(d2121, d4343), multiplyScalar2(d4321, d4321));
    if (isZero2(denominator))
      return null;
    var ta = divideScalar2(numerator, denominator);
    var tb = divideScalar2(addScalar2(d1343, multiplyScalar2(ta, d4321)), d4343);
    var pax = addScalar2(x1, multiplyScalar2(ta, subtract2(x2, x1)));
    var pay = addScalar2(y1, multiplyScalar2(ta, subtract2(y2, y1)));
    var paz = addScalar2(z1, multiplyScalar2(ta, subtract2(z2, z1)));
    var pbx = addScalar2(x3, multiplyScalar2(tb, subtract2(x4, x3)));
    var pby = addScalar2(y3, multiplyScalar2(tb, subtract2(y4, y3)));
    var pbz = addScalar2(z3, multiplyScalar2(tb, subtract2(z4, z3)));
    if (equalScalar2(pax, pbx) && equalScalar2(pay, pby) && equalScalar2(paz, pbz)) {
      return [pax, pay, paz];
    } else {
      return null;
    }
  }
  function _intersectLinePlane(x1, y1, z1, x2, y2, z2, x, y, z, c) {
    var x1x = multiplyScalar2(x1, x);
    var x2x = multiplyScalar2(x2, x);
    var y1y = multiplyScalar2(y1, y);
    var y2y = multiplyScalar2(y2, y);
    var z1z = multiplyScalar2(z1, z);
    var z2z = multiplyScalar2(z2, z);
    var numerator = subtract2(subtract2(subtract2(c, x1x), y1y), z1z);
    var denominator = subtract2(subtract2(subtract2(addScalar2(addScalar2(x2x, y2y), z2z), x1x), y1y), z1z);
    var t = divideScalar2(numerator, denominator);
    var px = addScalar2(x1, multiplyScalar2(t, subtract2(x2, x1)));
    var py = addScalar2(y1, multiplyScalar2(t, subtract2(y2, y1)));
    var pz = addScalar2(z1, multiplyScalar2(t, subtract2(z2, z1)));
    return [px, py, pz];
  }
});
var name$Y = "sum";
var dependencies$Y = ["typed", "config", "add", "numeric"];
var createSum = /* @__PURE__ */ factory(name$Y, dependencies$Y, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    add: add2,
    numeric: numeric3
  } = _ref;
  return typed2(name$Y, {
    // sum([a, b, c, d, ...])
    "Array | Matrix": _sum,
    // sum([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": _nsumDim,
    // sum(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function sum");
      }
      return _sum(args);
    }
  });
  function _sum(array) {
    var sum2;
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === void 0 ? value : add2(sum2, value);
      } catch (err) {
        throw improveErrorMessage(err, "sum", value);
      }
    });
    if (sum2 === void 0) {
      sum2 = numeric3(0, config3.number);
    }
    if (typeof sum2 === "string") {
      sum2 = numeric3(sum2, config3.number);
    }
    return sum2;
  }
  function _nsumDim(array, dim) {
    try {
      var sum2 = reduce(array, dim, add2);
      return sum2;
    } catch (err) {
      throw improveErrorMessage(err, "sum");
    }
  }
});
var name$X = "cumsum";
var dependencies$X = ["typed", "add", "unaryPlus"];
var createCumSum = /* @__PURE__ */ factory(name$X, dependencies$X, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    unaryPlus: unaryPlus2
  } = _ref;
  return typed2(name$X, {
    // sum([a, b, c, d, ...])
    Array: _cumsum,
    Matrix: function Matrix2(matrix2) {
      return matrix2.create(_cumsum(matrix2.valueOf()));
    },
    // sum([a, b, c, d, ...], dim)
    "Array, number | BigNumber": _ncumSumDim,
    "Matrix, number | BigNumber": function MatrixNumberBigNumber(matrix2, dim) {
      return matrix2.create(_ncumSumDim(matrix2.valueOf(), dim));
    },
    // cumsum(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("All values expected to be scalar in function cumsum");
      }
      return _cumsum(args);
    }
  });
  function _cumsum(array) {
    try {
      return _cumsummap(array);
    } catch (err) {
      throw improveErrorMessage(err, name$X);
    }
  }
  function _cumsummap(array) {
    if (array.length === 0) {
      return [];
    }
    var sums = [unaryPlus2(array[0])];
    for (var i2 = 1; i2 < array.length; ++i2) {
      sums.push(add2(sums[i2 - 1], array[i2]));
    }
    return sums;
  }
  function _ncumSumDim(array, dim) {
    var size2 = arraySize(array);
    if (dim < 0 || dim >= size2.length) {
      throw new IndexError(dim, size2.length);
    }
    try {
      return _cumsumDimensional(array, dim);
    } catch (err) {
      throw improveErrorMessage(err, name$X);
    }
  }
  function _cumsumDimensional(mat, dim) {
    var i2, ret, tran;
    if (dim <= 0) {
      var initialValue = mat[0][0];
      if (!Array.isArray(initialValue)) {
        return _cumsummap(mat);
      } else {
        tran = _switch$1(mat);
        ret = [];
        for (i2 = 0; i2 < tran.length; i2++) {
          ret[i2] = _cumsumDimensional(tran[i2], dim - 1);
        }
        return ret;
      }
    } else {
      ret = [];
      for (i2 = 0; i2 < mat.length; i2++) {
        ret[i2] = _cumsumDimensional(mat[i2], dim - 1);
      }
      return ret;
    }
  }
});
var name$W = "mean";
var dependencies$W = ["typed", "add", "divide"];
var createMean = /* @__PURE__ */ factory(name$W, dependencies$W, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2
  } = _ref;
  return typed2(name$W, {
    // mean([a, b, c, d, ...])
    "Array | Matrix": _mean,
    // mean([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": _nmeanDim,
    // mean(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function mean");
      }
      return _mean(args);
    }
  });
  function _nmeanDim(array, dim) {
    try {
      var sum2 = reduce(array, dim, add2);
      var s = Array.isArray(array) ? arraySize(array) : array.size();
      return divide2(sum2, s[dim]);
    } catch (err) {
      throw improveErrorMessage(err, "mean");
    }
  }
  function _mean(array) {
    var sum2;
    var num = 0;
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === void 0 ? value : add2(sum2, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "mean", value);
      }
    });
    if (num === 0) {
      throw new Error("Cannot calculate the mean of an empty array");
    }
    return divide2(sum2, num);
  }
});
var name$V = "median";
var dependencies$V = ["typed", "add", "divide", "compare", "partitionSelect"];
var createMedian = /* @__PURE__ */ factory(name$V, dependencies$V, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2,
    compare: compare2,
    partitionSelect: partitionSelect2
  } = _ref;
  function _median(array) {
    try {
      array = flatten$1(array.valueOf());
      var num = array.length;
      if (num === 0) {
        throw new Error("Cannot calculate median of an empty array");
      }
      if (num % 2 === 0) {
        var mid = num / 2 - 1;
        var right = partitionSelect2(array, mid + 1);
        var left = array[mid];
        for (var i2 = 0; i2 < mid; ++i2) {
          if (compare2(array[i2], left) > 0) {
            left = array[i2];
          }
        }
        return middle2(left, right);
      } else {
        var m = partitionSelect2(array, (num - 1) / 2);
        return middle(m);
      }
    } catch (err) {
      throw improveErrorMessage(err, "median");
    }
  }
  var middle = typed2({
    "number | BigNumber | Complex | Unit": function numberBigNumberComplexUnit(value) {
      return value;
    }
  });
  var middle2 = typed2({
    "number | BigNumber | Complex | Unit, number | BigNumber | Complex | Unit": function numberBigNumberComplexUnitNumberBigNumberComplexUnit(left, right) {
      return divide2(add2(left, right), 2);
    }
  });
  return typed2(name$V, {
    // median([a, b, c, d, ...])
    "Array | Matrix": _median,
    // median([a, b, c, d, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      throw new Error("median(A, dim) is not yet supported");
    },
    // median(a, b, c, d, ...)
    "...": function _(args) {
      if (containsCollections(args)) {
        throw new TypeError("Scalar values expected in function median");
      }
      return _median(args);
    }
  });
});
var name$U = "mad";
var dependencies$U = ["typed", "abs", "map", "median", "subtract"];
var createMad = /* @__PURE__ */ factory(name$U, dependencies$U, (_ref) => {
  var {
    typed: typed2,
    abs: abs2,
    map: map2,
    median: median2,
    subtract: subtract2
  } = _ref;
  return typed2(name$U, {
    // mad([a, b, c, d, ...])
    "Array | Matrix": _mad,
    // mad(a, b, c, d, ...)
    "...": function _(args) {
      return _mad(args);
    }
  });
  function _mad(array) {
    array = flatten$1(array.valueOf());
    if (array.length === 0) {
      throw new Error("Cannot calculate median absolute deviation (mad) of an empty array");
    }
    try {
      var med = median2(array);
      return median2(map2(array, function(value) {
        return abs2(subtract2(value, med));
      }));
    } catch (err) {
      if (err instanceof TypeError && err.message.indexOf("median") !== -1) {
        throw new TypeError(err.message.replace("median", "mad"));
      } else {
        throw improveErrorMessage(err, "mad");
      }
    }
  }
});
var DEFAULT_NORMALIZATION = "unbiased";
var name$T = "variance";
var dependencies$T = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVariance = /* @__PURE__ */ factory(name$T, dependencies$T, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    apply: apply2,
    isNaN: isNaN2
  } = _ref;
  return typed2(name$T, {
    // variance([a, b, c, d, ...])
    "Array | Matrix": function ArrayMatrix(array) {
      return _var(array, DEFAULT_NORMALIZATION);
    },
    // variance([a, b, c, d, ...], normalization)
    "Array | Matrix, string": _var,
    // variance([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": function ArrayMatrixNumberBigNumber(array, dim) {
      return _varDim(array, dim, DEFAULT_NORMALIZATION);
    },
    // variance([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": _varDim,
    // variance(a, b, c, d, ...)
    "...": function _(args) {
      return _var(args, DEFAULT_NORMALIZATION);
    }
  });
  function _var(array, normalization) {
    var sum2;
    var num = 0;
    if (array.length === 0) {
      throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
    }
    deepForEach(array, function(value) {
      try {
        sum2 = sum2 === void 0 ? value : add2(sum2, value);
        num++;
      } catch (err) {
        throw improveErrorMessage(err, "variance", value);
      }
    });
    if (num === 0)
      throw new Error("Cannot calculate variance of an empty array");
    var mean2 = divide2(sum2, num);
    sum2 = void 0;
    deepForEach(array, function(value) {
      var diff2 = subtract2(value, mean2);
      sum2 = sum2 === void 0 ? multiply2(diff2, diff2) : add2(sum2, multiply2(diff2, diff2));
    });
    if (isNaN2(sum2)) {
      return sum2;
    }
    switch (normalization) {
      case "uncorrected":
        return divide2(sum2, num);
      case "biased":
        return divide2(sum2, num + 1);
      case "unbiased": {
        var zero = isBigNumber(sum2) ? sum2.mul(0) : 0;
        return num === 1 ? zero : divide2(sum2, num - 1);
      }
      default:
        throw new Error('Unknown normalization "' + normalization + '". Choose "unbiased" (default), "uncorrected", or "biased".');
    }
  }
  function _varDim(array, dim, normalization) {
    try {
      if (array.length === 0) {
        throw new SyntaxError("Function variance requires one or more parameters (0 provided)");
      }
      return apply2(array, dim, (x) => _var(x, normalization));
    } catch (err) {
      throw improveErrorMessage(err, "variance");
    }
  }
});
var name$S = "quantileSeq";
var dependencies$S = ["typed", "?bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
var createQuantileSeq = /* @__PURE__ */ factory(name$S, dependencies$S, (_ref) => {
  var {
    typed: typed2,
    bignumber: bignumber2,
    add: add2,
    subtract: subtract2,
    divide: divide2,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2,
    isInteger: isInteger2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2
  } = _ref;
  var apply2 = createApply({
    typed: typed2,
    isInteger: isInteger2
  });
  return typed2(name$S, {
    "Array | Matrix, number | BigNumber": (data, p) => _quantileSeqProbNumber(data, p, false),
    "Array | Matrix, number | BigNumber, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbNumber),
    "Array | Matrix, number | BigNumber, boolean": _quantileSeqProbNumber,
    "Array | Matrix, number | BigNumber, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbNumber),
    "Array | Matrix, Array | Matrix": (data, p) => _quantileSeqProbCollection(data, p, false),
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => _quantileSeqDim(data, prob, false, dim, _quantileSeqProbCollection),
    "Array | Matrix, Array | Matrix, boolean": _quantileSeqProbCollection,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => _quantileSeqDim(data, prob, sorted, dim, _quantileSeqProbCollection)
  });
  function _quantileSeqDim(data, prob, sorted, dim, fn) {
    return apply2(data, dim, (x) => fn(x, prob, sorted));
  }
  function _quantileSeqProbNumber(data, probOrN, sorted) {
    var probArr;
    var dataArr = data.valueOf();
    if (smaller2(probOrN, 0)) {
      throw new Error("N/prob must be non-negative");
    }
    if (smallerEq2(probOrN, 1)) {
      return isNumber(probOrN) ? _quantileSeq(dataArr, probOrN, sorted) : bignumber2(_quantileSeq(dataArr, probOrN, sorted));
    }
    if (larger2(probOrN, 1)) {
      if (!isInteger2(probOrN)) {
        throw new Error("N must be a positive integer");
      }
      if (larger2(probOrN, 4294967295)) {
        throw new Error("N must be less than or equal to 2^32-1, as that is the maximum length of an Array");
      }
      var nPlusOne = add2(probOrN, 1);
      probArr = [];
      for (var i2 = 0; smaller2(i2, probOrN); i2++) {
        var prob = divide2(i2 + 1, nPlusOne);
        probArr.push(_quantileSeq(dataArr, prob, sorted));
      }
      return isNumber(probOrN) ? probArr : bignumber2(probArr);
    }
  }
  function _quantileSeqProbCollection(data, probOrN, sorted) {
    var dataArr = data.valueOf();
    var probOrNArr = probOrN.valueOf();
    var probArr = [];
    for (var i2 = 0; i2 < probOrNArr.length; ++i2) {
      probArr.push(_quantileSeq(dataArr, probOrNArr[i2], sorted));
    }
    return probArr;
  }
  function _quantileSeq(array, prob, sorted) {
    var flat = flatten$1(array);
    var len = flat.length;
    if (len === 0) {
      throw new Error("Cannot calculate quantile of an empty sequence");
    }
    var index2 = isNumber(prob) ? prob * (len - 1) : prob.times(len - 1);
    var integerPart = isNumber(prob) ? Math.floor(index2) : index2.floor().toNumber();
    var fracPart = isNumber(prob) ? index2 % 1 : index2.minus(integerPart);
    if (isInteger2(index2)) {
      return sorted ? flat[index2] : partitionSelect2(flat, isNumber(prob) ? index2 : index2.valueOf());
    }
    var left;
    var right;
    if (sorted) {
      left = flat[integerPart];
      right = flat[integerPart + 1];
    } else {
      right = partitionSelect2(flat, integerPart + 1);
      left = flat[integerPart];
      for (var i2 = 0; i2 < integerPart; ++i2) {
        if (compare2(flat[i2], left) > 0) {
          left = flat[i2];
        }
      }
    }
    return add2(multiply2(left, subtract2(1, fracPart)), multiply2(right, fracPart));
  }
});
var name$R = "std";
var dependencies$R = ["typed", "map", "sqrt", "variance"];
var createStd = /* @__PURE__ */ factory(name$R, dependencies$R, (_ref) => {
  var {
    typed: typed2,
    map: map2,
    sqrt: sqrt2,
    variance: variance2
  } = _ref;
  return typed2(name$R, {
    // std([a, b, c, d, ...])
    "Array | Matrix": _std,
    // std([a, b, c, d, ...], normalization)
    "Array | Matrix, string": _std,
    // std([a, b, c, c, ...], dim)
    "Array | Matrix, number | BigNumber": _std,
    // std([a, b, c, c, ...], dim, normalization)
    "Array | Matrix, number | BigNumber, string": _std,
    // std(a, b, c, d, ...)
    "...": function _(args) {
      return _std(args);
    }
  });
  function _std(array, normalization) {
    if (array.length === 0) {
      throw new SyntaxError("Function std requires one or more parameters (0 provided)");
    }
    try {
      var v = variance2.apply(null, arguments);
      if (isCollection(v)) {
        return map2(v, sqrt2);
      } else {
        return sqrt2(v);
      }
    } catch (err) {
      if (err instanceof TypeError && err.message.indexOf(" variance") !== -1) {
        throw new TypeError(err.message.replace(" variance", " std"));
      } else {
        throw err;
      }
    }
  }
});
var name$Q = "corr";
var dependencies$Q = ["typed", "matrix", "mean", "sqrt", "sum", "add", "subtract", "multiply", "pow", "divide"];
var createCorr = /* @__PURE__ */ factory(name$Q, dependencies$Q, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    sqrt: sqrt2,
    sum: sum2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    pow: pow2,
    divide: divide2
  } = _ref;
  return typed2(name$Q, {
    "Array, Array": function ArrayArray(A, B) {
      return _corr(A, B);
    },
    "Matrix, Matrix": function MatrixMatrix(A, B) {
      var res = _corr(A.toArray(), B.toArray());
      return Array.isArray(res) ? matrix2(res) : res;
    }
  });
  function _corr(A, B) {
    var correlations = [];
    if (Array.isArray(A[0]) && Array.isArray(B[0])) {
      if (A.length !== B.length) {
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same length.");
      }
      for (var i2 = 0; i2 < A.length; i2++) {
        if (A[i2].length !== B[i2].length) {
          throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
        }
        correlations.push(correlation(A[i2], B[i2]));
      }
      return correlations;
    } else {
      if (A.length !== B.length) {
        throw new SyntaxError("Dimension mismatch. Array A and B must have the same number of elements.");
      }
      return correlation(A, B);
    }
  }
  function correlation(A, B) {
    var n = A.length;
    var sumX = sum2(A);
    var sumY = sum2(B);
    var sumXY = A.reduce((acc, x, index2) => add2(acc, multiply2(x, B[index2])), 0);
    var sumXSquare = sum2(A.map((x) => pow2(x, 2)));
    var sumYSquare = sum2(B.map((y) => pow2(y, 2)));
    var numerator = subtract2(multiply2(n, sumXY), multiply2(sumX, sumY));
    var denominator = sqrt2(multiply2(subtract2(multiply2(n, sumXSquare), pow2(sumX, 2)), subtract2(multiply2(n, sumYSquare), pow2(sumY, 2))));
    return divide2(numerator, denominator);
  }
});
var name$P = "combinations";
var dependencies$P = ["typed"];
var createCombinations = /* @__PURE__ */ factory(name$P, dependencies$P, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$P, {
    "number, number": combinationsNumber,
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber2 = n.constructor;
      var result, i2;
      var nMinusk = n.minus(k);
      var one = new BigNumber2(1);
      if (!isPositiveInteger$2(n) || !isPositiveInteger$2(k)) {
        throw new TypeError("Positive integer value expected in function combinations");
      }
      if (k.gt(n)) {
        throw new TypeError("k must be less than n in function combinations");
      }
      result = one;
      if (k.lt(nMinusk)) {
        for (i2 = one; i2.lte(nMinusk); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusk.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
    // TODO: implement support for collection in combinations
  });
});
function isPositiveInteger$2(n) {
  return n.isInteger() && n.gte(0);
}
var name$O = "combinationsWithRep";
var dependencies$O = ["typed"];
var createCombinationsWithRep = /* @__PURE__ */ factory(name$O, dependencies$O, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  return typed2(name$O, {
    "number, number": function numberNumber(n, k) {
      if (!isInteger$1(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (!isInteger$1(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n < 1) {
        throw new TypeError("k must be less than or equal to n + k - 1");
      }
      if (k < n - 1) {
        var _prodrange = product(n, n + k - 1);
        return _prodrange / product(1, k);
      }
      var prodrange = product(k + 1, n + k - 1);
      return prodrange / product(1, n - 1);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var BigNumber2 = n.constructor;
      var result, i2;
      var one = new BigNumber2(1);
      var nMinusOne = n.minus(one);
      if (!isPositiveInteger$1(n) || !isPositiveInteger$1(k)) {
        throw new TypeError("Positive integer value expected in function combinationsWithRep");
      }
      if (n.lt(one)) {
        throw new TypeError("k must be less than or equal to n + k - 1 in function combinationsWithRep");
      }
      result = one;
      if (k.lt(nMinusOne)) {
        for (i2 = one; i2.lte(nMinusOne); i2 = i2.plus(one)) {
          result = result.times(k.plus(i2)).dividedBy(i2);
        }
      } else {
        for (i2 = one; i2.lte(k); i2 = i2.plus(one)) {
          result = result.times(nMinusOne.plus(i2)).dividedBy(i2);
        }
      }
      return result;
    }
  });
});
function isPositiveInteger$1(n) {
  return n.isInteger() && n.gte(0);
}
var name$N = "gamma";
var dependencies$N = ["typed", "config", "multiplyScalar", "pow", "BigNumber", "Complex"];
var createGamma = /* @__PURE__ */ factory(name$N, dependencies$N, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    multiplyScalar: multiplyScalar2,
    pow: pow2,
    BigNumber: _BigNumber,
    Complex: Complex2
  } = _ref;
  function gammaComplex(n) {
    if (n.im === 0) {
      return gammaNumber(n.re);
    }
    if (n.re < 0.5) {
      var _t = new Complex2(1 - n.re, -n.im);
      var r = new Complex2(Math.PI * n.re, Math.PI * n.im);
      return new Complex2(Math.PI).div(r.sin()).div(gammaComplex(_t));
    }
    n = new Complex2(n.re - 1, n.im);
    var x = new Complex2(gammaP[0], 0);
    for (var i2 = 1; i2 < gammaP.length; ++i2) {
      var gammaPval = new Complex2(gammaP[i2], 0);
      x = x.add(gammaPval.div(n.add(i2)));
    }
    var t = new Complex2(n.re + gammaG + 0.5, n.im);
    var twoPiSqrt = Math.sqrt(2 * Math.PI);
    var tpow = t.pow(n.add(0.5));
    var expt = t.neg().exp();
    return x.mul(twoPiSqrt).mul(tpow).mul(expt);
  }
  return typed2(name$N, {
    number: gammaNumber,
    Complex: gammaComplex,
    BigNumber: function BigNumber2(n) {
      if (n.isInteger()) {
        return n.isNegative() || n.isZero() ? new _BigNumber(Infinity) : bigFactorial(n.minus(1));
      }
      if (!n.isFinite()) {
        return new _BigNumber(n.isNegative() ? NaN : Infinity);
      }
      throw new Error("Integer BigNumber expected");
    }
  });
  function bigFactorial(n) {
    if (n < 8) {
      return new _BigNumber([1, 1, 2, 6, 24, 120, 720, 5040][n]);
    }
    var precision = config3.precision + (Math.log(n.toNumber()) | 0);
    var Big = _BigNumber.clone({
      precision
    });
    if (n % 2 === 1) {
      return n.times(bigFactorial(new _BigNumber(n - 1)));
    }
    var p = n;
    var prod2 = new Big(n);
    var sum2 = n.toNumber();
    while (p > 2) {
      p -= 2;
      sum2 += p;
      prod2 = prod2.times(sum2);
    }
    return new _BigNumber(prod2.toPrecision(_BigNumber.precision));
  }
});
var name$M = "lgamma";
var dependencies$M = ["Complex", "typed"];
var createLgamma = /* @__PURE__ */ factory(name$M, dependencies$M, (_ref) => {
  var {
    Complex: Complex2,
    typed: typed2
  } = _ref;
  var SMALL_RE = 7;
  var SMALL_IM = 7;
  var coeffs = [-0.029550653594771242, 0.00641025641025641, -0.0019175269175269176, 8417508417508417e-19, -5952380952380953e-19, 7936507936507937e-19, -0.002777777777777778, 0.08333333333333333];
  return typed2(name$M, {
    number: lgammaNumber,
    Complex: lgammaComplex,
    BigNumber: function BigNumber2() {
      throw new Error("mathjs doesn't yet provide an implementation of the algorithm lgamma for BigNumber");
    }
  });
  function lgammaComplex(n) {
    var TWOPI = 6.283185307179586;
    var LOGPI = 1.1447298858494002;
    var REFLECTION = 0.1;
    if (n.isNaN()) {
      return new Complex2(NaN, NaN);
    } else if (n.im === 0) {
      return new Complex2(lgammaNumber(n.re), 0);
    } else if (n.re >= SMALL_RE || Math.abs(n.im) >= SMALL_IM) {
      return lgammaStirling(n);
    } else if (n.re <= REFLECTION) {
      var tmp = copysign(TWOPI, n.im) * Math.floor(0.5 * n.re + 0.25);
      var a = n.mul(Math.PI).sin().log();
      var b = lgammaComplex(new Complex2(1 - n.re, -n.im));
      return new Complex2(LOGPI, tmp).sub(a).sub(b);
    } else if (n.im >= 0) {
      return lgammaRecurrence(n);
    } else {
      return lgammaRecurrence(n.conjugate()).conjugate();
    }
  }
  function lgammaStirling(z) {
    var leftPart = z.sub(0.5).mul(z.log()).sub(z).add(lnSqrt2PI);
    var rz = new Complex2(1, 0).div(z);
    var rzz = rz.div(z);
    var a = coeffs[0];
    var b = coeffs[1];
    var r = 2 * rzz.re;
    var s = rzz.re * rzz.re + rzz.im * rzz.im;
    for (var i2 = 2; i2 < 8; i2++) {
      var tmp = b;
      b = -s * a + coeffs[i2];
      a = r * a + tmp;
    }
    var rightPart = rz.mul(rzz.mul(a).add(b));
    return leftPart.add(rightPart);
  }
  function lgammaRecurrence(z) {
    var signflips = 0;
    var sb = 0;
    var shiftprod = z;
    z = z.add(1);
    while (z.re <= SMALL_RE) {
      shiftprod = shiftprod.mul(z);
      var nsb = shiftprod.im < 0 ? 1 : 0;
      if (nsb !== 0 && sb === 0)
        signflips++;
      sb = nsb;
      z = z.add(1);
    }
    return lgammaStirling(z).sub(shiftprod.log()).sub(new Complex2(0, signflips * 2 * Math.PI * 1));
  }
});
var name$L = "factorial";
var dependencies$L = ["typed", "gamma"];
var createFactorial = /* @__PURE__ */ factory(name$L, dependencies$L, (_ref) => {
  var {
    typed: typed2,
    gamma: gamma2
  } = _ref;
  return typed2(name$L, {
    number: function number2(n) {
      if (n < 0) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n + 1);
    },
    BigNumber: function BigNumber2(n) {
      if (n.isNegative()) {
        throw new Error("Value must be non-negative");
      }
      return gamma2(n.plus(1));
    },
    "Array | Matrix": typed2.referToSelf((self2) => (n) => deepMap(n, self2))
  });
});
var name$K = "kldivergence";
var dependencies$K = ["typed", "matrix", "divide", "sum", "multiply", "map", "dotDivide", "log", "isNumeric"];
var createKldivergence = /* @__PURE__ */ factory(name$K, dependencies$K, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    divide: divide2,
    sum: sum2,
    multiply: multiply2,
    map: map2,
    dotDivide: dotDivide2,
    log: log3,
    isNumeric: isNumeric2
  } = _ref;
  return typed2(name$K, {
    "Array, Array": function ArrayArray(q, p) {
      return _kldiv(matrix2(q), matrix2(p));
    },
    "Matrix, Array": function MatrixArray(q, p) {
      return _kldiv(q, matrix2(p));
    },
    "Array, Matrix": function ArrayMatrix(q, p) {
      return _kldiv(matrix2(q), p);
    },
    "Matrix, Matrix": function MatrixMatrix(q, p) {
      return _kldiv(q, p);
    }
  });
  function _kldiv(q, p) {
    var plength = p.size().length;
    var qlength = q.size().length;
    if (plength > 1) {
      throw new Error("first object must be one dimensional");
    }
    if (qlength > 1) {
      throw new Error("second object must be one dimensional");
    }
    if (plength !== qlength) {
      throw new Error("Length of two vectors must be equal");
    }
    var sumq = sum2(q);
    if (sumq === 0) {
      throw new Error("Sum of elements in first object must be non zero");
    }
    var sump = sum2(p);
    if (sump === 0) {
      throw new Error("Sum of elements in second object must be non zero");
    }
    var qnorm = divide2(q, sum2(q));
    var pnorm = divide2(p, sum2(p));
    var result = sum2(multiply2(qnorm, map2(dotDivide2(qnorm, pnorm), (x) => log3(x))));
    if (isNumeric2(result)) {
      return result;
    } else {
      return Number.NaN;
    }
  }
});
var name$J = "multinomial";
var dependencies$J = ["typed", "add", "divide", "multiply", "factorial", "isInteger", "isPositive"];
var createMultinomial = /* @__PURE__ */ factory(name$J, dependencies$J, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2,
    multiply: multiply2,
    factorial: factorial2,
    isInteger: isInteger2,
    isPositive: isPositive2
  } = _ref;
  return typed2(name$J, {
    "Array | Matrix": function ArrayMatrix(a) {
      var sum2 = 0;
      var denom = 1;
      deepForEach(a, function(ai) {
        if (!isInteger2(ai) || !isPositive2(ai)) {
          throw new TypeError("Positive integer value expected in function multinomial");
        }
        sum2 = add2(sum2, ai);
        denom = multiply2(denom, factorial2(ai));
      });
      return divide2(factorial2(sum2), denom);
    }
  });
});
var name$I = "permutations";
var dependencies$I = ["typed", "factorial"];
var createPermutations = /* @__PURE__ */ factory(name$I, dependencies$I, (_ref) => {
  var {
    typed: typed2,
    factorial: factorial2
  } = _ref;
  return typed2(name$I, {
    "number | BigNumber": factorial2,
    "number, number": function numberNumber(n, k) {
      if (!isInteger$1(n) || n < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (!isInteger$1(k) || k < 0) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k > n) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      return product(n - k + 1, n);
    },
    "BigNumber, BigNumber": function BigNumberBigNumber(n, k) {
      var result, i2;
      if (!isPositiveInteger(n) || !isPositiveInteger(k)) {
        throw new TypeError("Positive integer value expected in function permutations");
      }
      if (k.gt(n)) {
        throw new TypeError("second argument k must be less than or equal to first argument n");
      }
      var one = n.mul(0).add(1);
      result = one;
      for (i2 = n.minus(k).plus(1); i2.lte(n); i2 = i2.plus(1)) {
        result = result.times(i2);
      }
      return result;
    }
    // TODO: implement support for collection in permutations
  });
});
function isPositiveInteger(n) {
  return n.isInteger() && n.gte(0);
}
var alea$1 = { exports: {} };
alea$1.exports;
(function(module) {
  (function(global2, module2, define) {
    function Alea(seed) {
      var me = this, mash = Mash();
      me.next = function() {
        var t = 2091639 * me.s0 + me.c * 23283064365386963e-26;
        me.s0 = me.s1;
        me.s1 = me.s2;
        return me.s2 = t - (me.c = t | 0);
      };
      me.c = 1;
      me.s0 = mash(" ");
      me.s1 = mash(" ");
      me.s2 = mash(" ");
      me.s0 -= mash(seed);
      if (me.s0 < 0) {
        me.s0 += 1;
      }
      me.s1 -= mash(seed);
      if (me.s1 < 0) {
        me.s1 += 1;
      }
      me.s2 -= mash(seed);
      if (me.s2 < 0) {
        me.s2 += 1;
      }
      mash = null;
    }
    function copy(f, t) {
      t.c = f.c;
      t.s0 = f.s0;
      t.s1 = f.s1;
      t.s2 = f.s2;
      return t;
    }
    function impl(seed, opts) {
      var xg = new Alea(seed), state = opts && opts.state, prng = xg.next;
      prng.int32 = function() {
        return xg.next() * 4294967296 | 0;
      };
      prng.double = function() {
        return prng() + (prng() * 2097152 | 0) * 11102230246251565e-32;
      };
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    function Mash() {
      var n = 4022871197;
      var mash = function(data) {
        data = String(data);
        for (var i2 = 0; i2 < data.length; i2++) {
          n += data.charCodeAt(i2);
          var h = 0.02519603282416938 * n;
          n = h >>> 0;
          h -= n;
          h *= n;
          n = h >>> 0;
          h -= n;
          n += h * 4294967296;
        }
        return (n >>> 0) * 23283064365386963e-26;
      };
      return mash;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.alea = impl;
    }
  })(
    commonjsGlobal,
    module,
    // present in node.js
    false
    // present with an AMD loader
  );
})(alea$1);
var aleaExports = alea$1.exports;
var xor128$1 = { exports: {} };
xor128$1.exports;
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.next = function() {
        var t = me.x ^ me.x << 11;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        return me.w ^= me.w >>> 19 ^ t ^ t >>> 8;
      };
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.xor128 = impl;
    }
  })(
    commonjsGlobal,
    module,
    // present in node.js
    false
    // present with an AMD loader
  );
})(xor128$1);
var xor128Exports = xor128$1.exports;
var xorwow$1 = { exports: {} };
xorwow$1.exports;
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var t = me.x ^ me.x >>> 2;
        me.x = me.y;
        me.y = me.z;
        me.z = me.w;
        me.w = me.v;
        return (me.d = me.d + 362437 | 0) + (me.v = me.v ^ me.v << 4 ^ (t ^ t << 1)) | 0;
      };
      me.x = 0;
      me.y = 0;
      me.z = 0;
      me.w = 0;
      me.v = 0;
      if (seed === (seed | 0)) {
        me.x = seed;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 64; k++) {
        me.x ^= strseed.charCodeAt(k) | 0;
        if (k == strseed.length) {
          me.d = me.x << 10 ^ me.x >>> 4;
        }
        me.next();
      }
    }
    function copy(f, t) {
      t.x = f.x;
      t.y = f.y;
      t.z = f.z;
      t.w = f.w;
      t.v = f.v;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.xorwow = impl;
    }
  })(
    commonjsGlobal,
    module,
    // present in node.js
    false
    // present with an AMD loader
  );
})(xorwow$1);
var xorwowExports = xorwow$1.exports;
var xorshift7$1 = { exports: {} };
xorshift7$1.exports;
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var X = me.x, i2 = me.i, t, v;
        t = X[i2];
        t ^= t >>> 7;
        v = t ^ t << 24;
        t = X[i2 + 1 & 7];
        v ^= t ^ t >>> 10;
        t = X[i2 + 3 & 7];
        v ^= t ^ t >>> 3;
        t = X[i2 + 4 & 7];
        v ^= t ^ t << 7;
        t = X[i2 + 7 & 7];
        t = t ^ t << 13;
        v ^= t ^ t << 9;
        X[i2] = v;
        me.i = i2 + 1 & 7;
        return v;
      };
      function init2(me2, seed2) {
        var j, X = [];
        if (seed2 === (seed2 | 0)) {
          X[0] = seed2;
        } else {
          seed2 = "" + seed2;
          for (j = 0; j < seed2.length; ++j) {
            X[j & 7] = X[j & 7] << 15 ^ seed2.charCodeAt(j) + X[j + 1 & 7] << 13;
          }
        }
        while (X.length < 8)
          X.push(0);
        for (j = 0; j < 8 && X[j] === 0; ++j)
          ;
        if (j == 8)
          X[7] = -1;
        else
          X[j];
        me2.x = X;
        me2.i = 0;
        for (j = 256; j > 0; --j) {
          me2.next();
        }
      }
      init2(me, seed);
    }
    function copy(f, t) {
      t.x = f.x.slice();
      t.i = f.i;
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +/* @__PURE__ */ new Date();
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.x)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.xorshift7 = impl;
    }
  })(
    commonjsGlobal,
    module,
    // present in node.js
    false
    // present with an AMD loader
  );
})(xorshift7$1);
var xorshift7Exports = xorshift7$1.exports;
var xor4096$1 = { exports: {} };
xor4096$1.exports;
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this;
      me.next = function() {
        var w = me.w, X = me.X, i2 = me.i, t, v;
        me.w = w = w + 1640531527 | 0;
        v = X[i2 + 34 & 127];
        t = X[i2 = i2 + 1 & 127];
        v ^= v << 13;
        t ^= t << 17;
        v ^= v >>> 15;
        t ^= t >>> 12;
        v = X[i2] = v ^ t;
        me.i = i2;
        return v + (w ^ w >>> 16) | 0;
      };
      function init2(me2, seed2) {
        var t, v, i2, j, w, X = [], limit = 128;
        if (seed2 === (seed2 | 0)) {
          v = seed2;
          seed2 = null;
        } else {
          seed2 = seed2 + "\0";
          v = 0;
          limit = Math.max(limit, seed2.length);
        }
        for (i2 = 0, j = -32; j < limit; ++j) {
          if (seed2)
            v ^= seed2.charCodeAt((j + 32) % seed2.length);
          if (j === 0)
            w = v;
          v ^= v << 10;
          v ^= v >>> 15;
          v ^= v << 4;
          v ^= v >>> 13;
          if (j >= 0) {
            w = w + 1640531527 | 0;
            t = X[j & 127] ^= v + w;
            i2 = 0 == t ? i2 + 1 : 0;
          }
        }
        if (i2 >= 128) {
          X[(seed2 && seed2.length || 0) & 127] = -1;
        }
        i2 = 127;
        for (j = 4 * 128; j > 0; --j) {
          v = X[i2 + 34 & 127];
          t = X[i2 = i2 + 1 & 127];
          v ^= v << 13;
          t ^= t << 17;
          v ^= v >>> 15;
          t ^= t >>> 12;
          X[i2] = v ^ t;
        }
        me2.w = w;
        me2.X = X;
        me2.i = i2;
      }
      init2(me, seed);
    }
    function copy(f, t) {
      t.i = f.i;
      t.w = f.w;
      t.X = f.X.slice();
      return t;
    }
    function impl(seed, opts) {
      if (seed == null)
        seed = +/* @__PURE__ */ new Date();
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (state.X)
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.xor4096 = impl;
    }
  })(
    commonjsGlobal,
    // window object or global
    module,
    // present in node.js
    false
    // present with an AMD loader
  );
})(xor4096$1);
var xor4096Exports = xor4096$1.exports;
var tychei$1 = { exports: {} };
tychei$1.exports;
(function(module) {
  (function(global2, module2, define) {
    function XorGen(seed) {
      var me = this, strseed = "";
      me.next = function() {
        var b = me.b, c = me.c, d = me.d, a = me.a;
        b = b << 25 ^ b >>> 7 ^ c;
        c = c - d | 0;
        d = d << 24 ^ d >>> 8 ^ a;
        a = a - b | 0;
        me.b = b = b << 20 ^ b >>> 12 ^ c;
        me.c = c = c - d | 0;
        me.d = d << 16 ^ c >>> 16 ^ a;
        return me.a = a - b | 0;
      };
      me.a = 0;
      me.b = 0;
      me.c = 2654435769 | 0;
      me.d = 1367130551;
      if (seed === Math.floor(seed)) {
        me.a = seed / 4294967296 | 0;
        me.b = seed | 0;
      } else {
        strseed += seed;
      }
      for (var k = 0; k < strseed.length + 20; k++) {
        me.b ^= strseed.charCodeAt(k) | 0;
        me.next();
      }
    }
    function copy(f, t) {
      t.a = f.a;
      t.b = f.b;
      t.c = f.c;
      t.d = f.d;
      return t;
    }
    function impl(seed, opts) {
      var xg = new XorGen(seed), state = opts && opts.state, prng = function() {
        return (xg.next() >>> 0) / 4294967296;
      };
      prng.double = function() {
        do {
          var top = xg.next() >>> 11, bot = (xg.next() >>> 0) / 4294967296, result = (top + bot) / (1 << 21);
        } while (result === 0);
        return result;
      };
      prng.int32 = xg.next;
      prng.quick = prng;
      if (state) {
        if (typeof state == "object")
          copy(state, xg);
        prng.state = function() {
          return copy(xg, {});
        };
      }
      return prng;
    }
    if (module2 && module2.exports) {
      module2.exports = impl;
    } else if (define && define.amd) {
      define(function() {
        return impl;
      });
    } else {
      this.tychei = impl;
    }
  })(
    commonjsGlobal,
    module,
    // present in node.js
    false
    // present with an AMD loader
  );
})(tychei$1);
var tycheiExports = tychei$1.exports;
var seedrandom$2 = { exports: {} };
const __viteBrowserExternal = {};
const __viteBrowserExternal$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: __viteBrowserExternal
}, Symbol.toStringTag, { value: "Module" }));
const require$$0 = /* @__PURE__ */ getAugmentedNamespace(__viteBrowserExternal$1);
(function(module) {
  (function(global2, pool, math2) {
    var width = 256, chunks = 6, digits2 = 52, rngname = "random", startdenom = math2.pow(width, chunks), significance = math2.pow(2, digits2), overflow = significance * 2, mask = width - 1, nodecrypto;
    function seedrandom2(seed, options, callback) {
      var key = [];
      options = options == true ? { entropy: true } : options || {};
      var shortseed = mixkey(flatten2(
        options.entropy ? [seed, tostring(pool)] : seed == null ? autoseed() : seed,
        3
      ), key);
      var arc4 = new ARC4(key);
      var prng = function() {
        var n = arc4.g(chunks), d = startdenom, x = 0;
        while (n < significance) {
          n = (n + x) * width;
          d *= width;
          x = arc4.g(1);
        }
        while (n >= overflow) {
          n /= 2;
          d /= 2;
          x >>>= 1;
        }
        return (n + x) / d;
      };
      prng.int32 = function() {
        return arc4.g(4) | 0;
      };
      prng.quick = function() {
        return arc4.g(4) / 4294967296;
      };
      prng.double = prng;
      mixkey(tostring(arc4.S), pool);
      return (options.pass || callback || function(prng2, seed2, is_math_call, state) {
        if (state) {
          if (state.S) {
            copy(state, arc4);
          }
          prng2.state = function() {
            return copy(arc4, {});
          };
        }
        if (is_math_call) {
          math2[rngname] = prng2;
          return seed2;
        } else
          return prng2;
      })(
        prng,
        shortseed,
        "global" in options ? options.global : this == math2,
        options.state
      );
    }
    function ARC4(key) {
      var t, keylen = key.length, me = this, i2 = 0, j = me.i = me.j = 0, s = me.S = [];
      if (!keylen) {
        key = [keylen++];
      }
      while (i2 < width) {
        s[i2] = i2++;
      }
      for (i2 = 0; i2 < width; i2++) {
        s[i2] = s[j = mask & j + key[i2 % keylen] + (t = s[i2])];
        s[j] = t;
      }
      (me.g = function(count2) {
        var t2, r = 0, i3 = me.i, j2 = me.j, s2 = me.S;
        while (count2--) {
          t2 = s2[i3 = mask & i3 + 1];
          r = r * width + s2[mask & (s2[i3] = s2[j2 = mask & j2 + t2]) + (s2[j2] = t2)];
        }
        me.i = i3;
        me.j = j2;
        return r;
      })(width);
    }
    function copy(f, t) {
      t.i = f.i;
      t.j = f.j;
      t.S = f.S.slice();
      return t;
    }
    function flatten2(obj, depth) {
      var result = [], typ = typeof obj, prop;
      if (depth && typ == "object") {
        for (prop in obj) {
          try {
            result.push(flatten2(obj[prop], depth - 1));
          } catch (e2) {
          }
        }
      }
      return result.length ? result : typ == "string" ? obj : obj + "\0";
    }
    function mixkey(seed, key) {
      var stringseed = seed + "", smear, j = 0;
      while (j < stringseed.length) {
        key[mask & j] = mask & (smear ^= key[mask & j] * 19) + stringseed.charCodeAt(j++);
      }
      return tostring(key);
    }
    function autoseed() {
      try {
        var out;
        if (nodecrypto && (out = nodecrypto.randomBytes)) {
          out = out(width);
        } else {
          out = new Uint8Array(width);
          (global2.crypto || global2.msCrypto).getRandomValues(out);
        }
        return tostring(out);
      } catch (e2) {
        var browser = global2.navigator, plugins = browser && browser.plugins;
        return [+/* @__PURE__ */ new Date(), global2, plugins, global2.screen, tostring(pool)];
      }
    }
    function tostring(a) {
      return String.fromCharCode.apply(0, a);
    }
    mixkey(math2.random(), pool);
    if (module.exports) {
      module.exports = seedrandom2;
      try {
        nodecrypto = require$$0;
      } catch (ex) {
      }
    } else {
      math2["seed" + rngname] = seedrandom2;
    }
  })(
    // global: `self` in browsers (including strict mode and web workers),
    // otherwise `this` in Node and other environments
    typeof self !== "undefined" ? self : commonjsGlobal,
    [],
    // pool: entropy pool starts empty
    Math
    // math: package containing random, pow, and seedrandom
  );
})(seedrandom$2);
var seedrandomExports = seedrandom$2.exports;
var alea = aleaExports;
var xor128 = xor128Exports;
var xorwow = xorwowExports;
var xorshift7 = xorshift7Exports;
var xor4096 = xor4096Exports;
var tychei = tycheiExports;
var sr = seedrandomExports;
sr.alea = alea;
sr.xor128 = xor128;
sr.xorwow = xorwow;
sr.xorshift7 = xorshift7;
sr.xor4096 = xor4096;
sr.tychei = tychei;
var seedrandom = sr;
const seedrandom$1 = /* @__PURE__ */ getDefaultExportFromCjs(seedrandom);
var singletonRandom = /* @__PURE__ */ seedrandom$1(Date.now());
function createRng(randomSeed) {
  var random2;
  function setSeed(seed) {
    random2 = seed === null ? singletonRandom : seedrandom$1(String(seed));
  }
  setSeed(randomSeed);
  function rng() {
    return random2();
  }
  return rng;
}
var name$H = "pickRandom";
var dependencies$H = ["typed", "config", "?on"];
var createPickRandom = /* @__PURE__ */ factory(name$H, dependencies$H, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    on
  } = _ref;
  var rng = createRng(config3.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name$H, {
    "Array | Matrix": function ArrayMatrix(possibles) {
      return _pickRandom(possibles, {});
    },
    "Array | Matrix, Object": function ArrayMatrixObject(possibles, options) {
      return _pickRandom(possibles, options);
    },
    "Array | Matrix, number": function ArrayMatrixNumber(possibles, number2) {
      return _pickRandom(possibles, {
        number: number2
      });
    },
    "Array | Matrix, Array | Matrix": function ArrayMatrixArrayMatrix(possibles, weights) {
      return _pickRandom(possibles, {
        weights
      });
    },
    "Array | Matrix, Array | Matrix, number": function ArrayMatrixArrayMatrixNumber(possibles, weights, number2) {
      return _pickRandom(possibles, {
        number: number2,
        weights
      });
    },
    "Array | Matrix, number, Array | Matrix": function ArrayMatrixNumberArrayMatrix(possibles, number2, weights) {
      return _pickRandom(possibles, {
        number: number2,
        weights
      });
    }
  });
  function _pickRandom(possibles, _ref2) {
    var {
      number: number2,
      weights,
      elementWise = true
    } = _ref2;
    var single = typeof number2 === "undefined";
    if (single) {
      number2 = 1;
    }
    var createMatrix2 = isMatrix(possibles) ? possibles.create : isMatrix(weights) ? weights.create : null;
    possibles = possibles.valueOf();
    if (weights) {
      weights = weights.valueOf();
    }
    if (elementWise === true) {
      possibles = flatten$1(possibles);
      weights = flatten$1(weights);
    }
    var totalWeights = 0;
    if (typeof weights !== "undefined") {
      if (weights.length !== possibles.length) {
        throw new Error("Weights must have the same length as possibles");
      }
      for (var i2 = 0, len = weights.length; i2 < len; i2++) {
        if (!isNumber(weights[i2]) || weights[i2] < 0) {
          throw new Error("Weights must be an array of positive numbers");
        }
        totalWeights += weights[i2];
      }
    }
    var length = possibles.length;
    var result = [];
    var pick;
    while (result.length < number2) {
      if (typeof weights === "undefined") {
        pick = possibles[Math.floor(rng() * length)];
      } else {
        var randKey = rng() * totalWeights;
        for (var _i = 0, _len = possibles.length; _i < _len; _i++) {
          randKey -= weights[_i];
          if (randKey < 0) {
            pick = possibles[_i];
            break;
          }
        }
      }
      result.push(pick);
    }
    return single ? result[0] : createMatrix2 ? createMatrix2(result) : result;
  }
});
function randomMatrix(size2, random2) {
  var data = [];
  size2 = size2.slice(0);
  if (size2.length > 1) {
    for (var i2 = 0, length = size2.shift(); i2 < length; i2++) {
      data.push(randomMatrix(size2, random2));
    }
  } else {
    for (var _i = 0, _length = size2.shift(); _i < _length; _i++) {
      data.push(random2());
    }
  }
  return data;
}
var name$G = "random";
var dependencies$G = ["typed", "config", "?on"];
var createRandom = /* @__PURE__ */ factory(name$G, dependencies$G, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    on
  } = _ref;
  var rng = createRng(config3.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name$G, {
    "": () => _random(0, 1),
    number: (max2) => _random(0, max2),
    "number, number": (min2, max2) => _random(min2, max2),
    "Array | Matrix": (size2) => _randomMatrix(size2, 0, 1),
    "Array | Matrix, number": (size2, max2) => _randomMatrix(size2, 0, max2),
    "Array | Matrix, number, number": (size2, min2, max2) => _randomMatrix(size2, min2, max2)
  });
  function _randomMatrix(size2, min2, max2) {
    var res = randomMatrix(size2.valueOf(), () => _random(min2, max2));
    return isMatrix(size2) ? size2.create(res) : res;
  }
  function _random(min2, max2) {
    return min2 + rng() * (max2 - min2);
  }
});
var name$F = "randomInt";
var dependencies$F = ["typed", "config", "?on"];
var createRandomInt = /* @__PURE__ */ factory(name$F, dependencies$F, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    on
  } = _ref;
  var rng = createRng(config3.randomSeed);
  if (on) {
    on("config", function(curr, prev) {
      if (curr.randomSeed !== prev.randomSeed) {
        rng = createRng(curr.randomSeed);
      }
    });
  }
  return typed2(name$F, {
    "": () => _randomInt(0, 1),
    number: (max2) => _randomInt(0, max2),
    "number, number": (min2, max2) => _randomInt(min2, max2),
    "Array | Matrix": (size2) => _randomIntMatrix(size2, 0, 1),
    "Array | Matrix, number": (size2, max2) => _randomIntMatrix(size2, 0, max2),
    "Array | Matrix, number, number": (size2, min2, max2) => _randomIntMatrix(size2, min2, max2)
  });
  function _randomIntMatrix(size2, min2, max2) {
    var res = randomMatrix(size2.valueOf(), () => _randomInt(min2, max2));
    return isMatrix(size2) ? size2.create(res) : res;
  }
  function _randomInt(min2, max2) {
    return Math.floor(min2 + rng() * (max2 - min2));
  }
});
var name$E = "stirlingS2";
var dependencies$E = ["typed", "addScalar", "subtractScalar", "multiplyScalar", "divideScalar", "pow", "factorial", "combinations", "isNegative", "isInteger", "number", "?bignumber", "larger"];
var createStirlingS2 = /* @__PURE__ */ factory(name$E, dependencies$E, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    subtractScalar: subtractScalar2,
    multiplyScalar: multiplyScalar2,
    divideScalar: divideScalar2,
    pow: pow2,
    factorial: factorial2,
    combinations: combinations2,
    isNegative: isNegative2,
    isInteger: isInteger2,
    number: number2,
    bignumber: bignumber2,
    larger: larger2
  } = _ref;
  var smallCache = [];
  var bigCache = [];
  return typed2(name$E, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
      if (!isInteger2(n) || isNegative2(n) || !isInteger2(k) || isNegative2(k)) {
        throw new TypeError("Non-negative integer value expected in function stirlingS2");
      } else if (larger2(k, n)) {
        throw new TypeError("k must be less than or equal to n in function stirlingS2");
      }
      var big = !(isNumber(n) && isNumber(k));
      var cache = big ? bigCache : smallCache;
      var make = big ? bignumber2 : number2;
      var nn = number2(n);
      var nk = number2(k);
      if (cache[nn] && cache[nn].length > nk) {
        return cache[nn][nk];
      }
      for (var m = 0; m <= nn; ++m) {
        if (!cache[m]) {
          cache[m] = [m === 0 ? make(1) : make(0)];
        }
        if (m === 0)
          continue;
        var row2 = cache[m];
        var prev = cache[m - 1];
        for (var i2 = row2.length; i2 <= m && i2 <= nk; ++i2) {
          if (i2 === m) {
            row2[i2] = 1;
          } else {
            row2[i2] = addScalar2(multiplyScalar2(make(i2), prev[i2]), prev[i2 - 1]);
          }
        }
      }
      return cache[nn][nk];
    }
  });
});
var name$D = "bellNumbers";
var dependencies$D = ["typed", "addScalar", "isNegative", "isInteger", "stirlingS2"];
var createBellNumbers = /* @__PURE__ */ factory(name$D, dependencies$D, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    isNegative: isNegative2,
    isInteger: isInteger2,
    stirlingS2: stirlingS22
  } = _ref;
  return typed2(name$D, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger2(n) || isNegative2(n)) {
        throw new TypeError("Non-negative integer value expected in function bellNumbers");
      }
      var result = 0;
      for (var i2 = 0; i2 <= n; i2++) {
        result = addScalar2(result, stirlingS22(n, i2));
      }
      return result;
    }
  });
});
var name$C = "catalan";
var dependencies$C = ["typed", "addScalar", "divideScalar", "multiplyScalar", "combinations", "isNegative", "isInteger"];
var createCatalan = /* @__PURE__ */ factory(name$C, dependencies$C, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    divideScalar: divideScalar2,
    multiplyScalar: multiplyScalar2,
    combinations: combinations2,
    isNegative: isNegative2,
    isInteger: isInteger2
  } = _ref;
  return typed2(name$C, {
    "number | BigNumber": function numberBigNumber(n) {
      if (!isInteger2(n) || isNegative2(n)) {
        throw new TypeError("Non-negative integer value expected in function catalan");
      }
      return divideScalar2(combinations2(multiplyScalar2(n, 2), n), addScalar2(n, 1));
    }
  });
});
var name$B = "composition";
var dependencies$B = ["typed", "addScalar", "combinations", "isNegative", "isPositive", "isInteger", "larger"];
var createComposition = /* @__PURE__ */ factory(name$B, dependencies$B, (_ref) => {
  var {
    typed: typed2,
    addScalar: addScalar2,
    combinations: combinations2,
    isPositive: isPositive2,
    isNegative: isNegative2,
    isInteger: isInteger2,
    larger: larger2
  } = _ref;
  return typed2(name$B, {
    "number | BigNumber, number | BigNumber": function numberBigNumberNumberBigNumber(n, k) {
      if (!isInteger2(n) || !isPositive2(n) || !isInteger2(k) || !isPositive2(k)) {
        throw new TypeError("Positive integer value expected in function composition");
      } else if (larger2(k, n)) {
        throw new TypeError("k must be less than or equal to n in function composition");
      }
      return combinations2(addScalar2(n, -1), addScalar2(k, -1));
    }
  });
});
var name$A = "leafCount";
var dependencies$A = ["parse", "typed"];
var createLeafCount = /* @__PURE__ */ factory(name$A, dependencies$A, (_ref) => {
  var {
    parse: parse2,
    typed: typed2
  } = _ref;
  function countLeaves(node) {
    var count2 = 0;
    node.forEach((n) => {
      count2 += countLeaves(n);
    });
    return count2 || 1;
  }
  return typed2(name$A, {
    Node: function Node2(expr) {
      return countLeaves(expr);
    }
  });
});
function isNumericNode(x) {
  return isConstantNode(x) || isOperatorNode(x) && x.isUnary() && isConstantNode(x.args[0]);
}
function isConstantExpression(x) {
  if (isConstantNode(x)) {
    return true;
  }
  if ((isFunctionNode(x) || isOperatorNode(x)) && x.args.every(isConstantExpression)) {
    return true;
  }
  if (isParenthesisNode(x) && isConstantExpression(x.content)) {
    return true;
  }
  return false;
}
function ownKeys(e2, r) {
  var t = Object.keys(e2);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e2);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e2, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e2) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e2, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e2, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e2, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e2;
}
var name$z = "simplifyUtil";
var dependencies$z = ["FunctionNode", "OperatorNode", "SymbolNode"];
var createUtil = /* @__PURE__ */ factory(name$z, dependencies$z, (_ref) => {
  var {
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var T = true;
  var F = false;
  var defaultName = "defaultF";
  var defaultContext = {
    /*      */
    add: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /**/
    unaryPlus: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /* */
    subtract: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    /* */
    multiply: {
      trivial: T,
      total: T,
      commutative: T,
      associative: T
    },
    /*   */
    divide: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    },
    /*    */
    paren: {
      trivial: T,
      total: T,
      commutative: T,
      associative: F
    },
    /* */
    defaultF: {
      trivial: F,
      total: T,
      commutative: F,
      associative: F
    }
  };
  var realContext = {
    divide: {
      total: F
    },
    log: {
      total: F
    }
  };
  var positiveContext = {
    subtract: {
      total: F
    },
    abs: {
      trivial: T
    },
    log: {
      total: T
    }
  };
  function hasProperty(nodeOrName, property) {
    var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : defaultContext;
    var name2 = defaultName;
    if (typeof nodeOrName === "string") {
      name2 = nodeOrName;
    } else if (isOperatorNode(nodeOrName)) {
      name2 = nodeOrName.fn.toString();
    } else if (isFunctionNode(nodeOrName)) {
      name2 = nodeOrName.name;
    } else if (isParenthesisNode(nodeOrName)) {
      name2 = "paren";
    }
    if (hasOwnProperty(context, name2)) {
      var properties2 = context[name2];
      if (hasOwnProperty(properties2, property)) {
        return properties2[property];
      }
      if (hasOwnProperty(defaultContext, name2)) {
        return defaultContext[name2][property];
      }
    }
    if (hasOwnProperty(context, defaultName)) {
      var _properties = context[defaultName];
      if (hasOwnProperty(_properties, property)) {
        return _properties[property];
      }
      return defaultContext[defaultName][property];
    }
    if (hasOwnProperty(defaultContext, name2)) {
      var _properties2 = defaultContext[name2];
      if (hasOwnProperty(_properties2, property)) {
        return _properties2[property];
      }
    }
    return defaultContext[defaultName][property];
  }
  function isCommutative(node) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
    return hasProperty(node, "commutative", context);
  }
  function isAssociative(node) {
    var context = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : defaultContext;
    return hasProperty(node, "associative", context);
  }
  function mergeContext(primary, secondary) {
    var merged = _objectSpread({}, primary);
    for (var prop in secondary) {
      if (hasOwnProperty(primary, prop)) {
        merged[prop] = _objectSpread(_objectSpread({}, secondary[prop]), primary[prop]);
      } else {
        merged[prop] = secondary[prop];
      }
    }
    return merged;
  }
  function flatten2(node, context) {
    if (!node.args || node.args.length === 0) {
      return node;
    }
    node.args = allChildren(node, context);
    for (var i2 = 0; i2 < node.args.length; i2++) {
      flatten2(node.args[i2], context);
    }
  }
  function allChildren(node, context) {
    var op;
    var children2 = [];
    var findChildren = function findChildren2(node2) {
      for (var i2 = 0; i2 < node2.args.length; i2++) {
        var child = node2.args[i2];
        if (isOperatorNode(child) && op === child.op) {
          findChildren2(child);
        } else {
          children2.push(child);
        }
      }
    };
    if (isAssociative(node, context)) {
      op = node.op;
      findChildren(node);
      return children2;
    } else {
      return node.args;
    }
  }
  function unflattenr(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i2 = 0; i2 < l; i2++) {
      unflattenr(node.args[i2], context);
    }
    if (l > 2 && isAssociative(node, context)) {
      var curnode = node.args.pop();
      while (node.args.length > 0) {
        curnode = makeNode([node.args.pop(), curnode]);
      }
      node.args = curnode.args;
    }
  }
  function unflattenl(node, context) {
    if (!node.args || node.args.length === 0) {
      return;
    }
    var makeNode = createMakeNodeFunction(node);
    var l = node.args.length;
    for (var i2 = 0; i2 < l; i2++) {
      unflattenl(node.args[i2], context);
    }
    if (l > 2 && isAssociative(node, context)) {
      var curnode = node.args.shift();
      while (node.args.length > 0) {
        curnode = makeNode([curnode, node.args.shift()]);
      }
      node.args = curnode.args;
    }
  }
  function createMakeNodeFunction(node) {
    if (isOperatorNode(node)) {
      return function(args) {
        try {
          return new OperatorNode2(node.op, node.fn, args, node.implicit);
        } catch (err) {
          console.error(err);
          return [];
        }
      };
    } else {
      return function(args) {
        return new FunctionNode2(new SymbolNode2(node.name), args);
      };
    }
  }
  return {
    createMakeNodeFunction,
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten2,
    allChildren,
    unflattenr,
    unflattenl,
    defaultContext,
    realContext,
    positiveContext
  };
});
var name$y = "simplify";
var dependencies$y = ["config", "typed", "parse", "add", "subtract", "multiply", "divide", "pow", "isZero", "equal", "resolve", "simplifyConstant", "simplifyCore", "?fraction", "?bignumber", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplify = /* @__PURE__ */ factory(name$y, dependencies$y, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    parse: parse2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    pow: pow2,
    isZero: isZero2,
    equal: equal2,
    resolve: resolve2,
    simplifyConstant: simplifyConstant2,
    simplifyCore: simplifyCore2,
    fraction: fraction2,
    bignumber: bignumber2,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var {
    hasProperty,
    isCommutative,
    isAssociative,
    mergeContext,
    flatten: flatten2,
    unflattenr,
    unflattenl,
    createMakeNodeFunction,
    defaultContext,
    realContext,
    positiveContext
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  typed2.addConversion({
    from: "Object",
    to: "Map",
    convert: createMap$1
  });
  var simplify2 = typed2("simplify", {
    Node: _simplify,
    "Node, Map": (expr, scope) => _simplify(expr, false, scope),
    "Node, Map, Object": (expr, scope, options) => _simplify(expr, false, scope, options),
    "Node, Array": _simplify,
    "Node, Array, Map": _simplify,
    "Node, Array, Map, Object": _simplify
  });
  typed2.removeConversion({
    from: "Object",
    to: "Map",
    convert: createMap$1
  });
  simplify2.defaultContext = defaultContext;
  simplify2.realContext = realContext;
  simplify2.positiveContext = positiveContext;
  function removeParens(node) {
    return node.transform(function(node2, path, parent) {
      return isParenthesisNode(node2) ? removeParens(node2.content) : node2;
    });
  }
  var SUPPORTED_CONSTANTS = {
    true: true,
    false: true,
    e: true,
    i: true,
    Infinity: true,
    LN2: true,
    LN10: true,
    LOG2E: true,
    LOG10E: true,
    NaN: true,
    phi: true,
    pi: true,
    SQRT1_2: true,
    SQRT2: true,
    tau: true
    // null: false,
    // undefined: false,
    // version: false,
  };
  simplify2.rules = [
    simplifyCore2,
    // { l: 'n+0', r: 'n' },     // simplifyCore
    // { l: 'n^0', r: '1' },     // simplifyCore
    // { l: '0*n', r: '0' },     // simplifyCore
    // { l: 'n/n', r: '1'},      // simplifyCore
    // { l: 'n^1', r: 'n' },     // simplifyCore
    // { l: '+n1', r:'n1' },     // simplifyCore
    // { l: 'n--n1', r:'n+n1' }, // simplifyCore
    {
      l: "log(e)",
      r: "1"
    },
    // temporary rules
    // Note initially we tend constants to the right because like-term
    // collection prefers the left, and we would rather collect nonconstants
    {
      s: "n-n1 -> n+-n1",
      // temporarily replace 'subtract' so we can further flatten the 'add' operator
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n-n -> 0",
      // partial alternative when we can't always subtract
      assuming: {
        subtract: {
          total: false
        }
      }
    },
    {
      s: "-(cl*v) -> v * (-cl)",
      // make non-constant terms positive
      assuming: {
        multiply: {
          commutative: true
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(cl*v) -> (-cl) * v",
      // non-commutative version, part 1
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      s: "-(v*cl) -> v * (-cl)",
      // non-commutative version, part 2
      assuming: {
        multiply: {
          commutative: false
        },
        subtract: {
          total: true
        }
      }
    },
    {
      l: "-(n1/n2)",
      r: "-n1/n2"
    },
    {
      l: "-v",
      r: "v * (-1)"
    },
    // finish making non-constant terms positive
    {
      l: "(n1 + n2)*(-1)",
      r: "n1*(-1) + n2*(-1)",
      repeat: true
    },
    // expand negations to achieve as much sign cancellation as possible
    {
      l: "n/n1^n2",
      r: "n*n1^-n2"
    },
    // temporarily replace 'divide' so we can further flatten the 'multiply' operator
    {
      l: "n/n1",
      r: "n*n1^-1"
    },
    {
      s: "(n1*n2)^n3 -> n1^n3 * n2^n3",
      assuming: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "(n1*n2)^(-1) -> n2^(-1) * n1^(-1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    // expand nested exponentiation
    {
      s: "(n ^ n1) ^ n2 -> n ^ (n1 * n2)",
      assuming: {
        divide: {
          total: true
        }
      }
      // 1/(1/n) = n needs 1/n to exist
    },
    // collect like factors; into a sum, only do this for nonconstants
    {
      l: " vd   * ( vd   * n1 + n2)",
      r: "vd^2       * n1 +  vd   * n2"
    },
    {
      s: " vd   * (vd^n4 * n1 + n2)   ->  vd^(1+n4)  * n1 +  vd   * n2",
      assuming: {
        divide: {
          total: true
        }
      }
      // v*1/v = v^(1+-1) needs 1/v
    },
    {
      s: "vd^n3 * ( vd   * n1 + n2)   ->  vd^(n3+1)  * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      s: "vd^n3 * (vd^n4 * n1 + n2)   ->  vd^(n3+n4) * n1 + vd^n3 * n2",
      assuming: {
        divide: {
          total: true
        }
      }
    },
    {
      l: "n*n",
      r: "n^2"
    },
    {
      s: "n * n^n1 -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        }
      }
      // n*1/n = n^(-1+1) needs 1/n
    },
    {
      s: "n^n1 * n^n2 -> n^(n1+n2)",
      assuming: {
        divide: {
          total: true
        }
      }
      // ditto for n^2*1/n^2
    },
    // Unfortunately, to deal with more complicated cancellations, it
    // becomes necessary to simplify constants twice per pass. It's not
    // terribly expensive compared to matching rules, so this should not
    // pose a performance problem.
    simplifyConstant2,
    // First: before collecting like terms
    // collect like terms
    {
      s: "n+n -> 2*n",
      assuming: {
        add: {
          total: true
        }
      }
      // 2 = 1 + 1 needs to exist
    },
    {
      l: "n+-n",
      r: "0"
    },
    {
      l: "vd*n + vd",
      r: "vd*(n+1)"
    },
    // NOTE: leftmost position is special:
    {
      l: "n3*n1 + n3*n2",
      r: "n3*(n1+n2)"
    },
    // All sub-monomials tried there.
    {
      l: "n3^(-n4)*n1 +   n3  * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+1) *n2)"
    },
    {
      l: "n3^(-n4)*n1 + n3^n5 * n2",
      r: "n3^(-n4)*(n1 + n3^(n4+n5)*n2)"
    },
    // noncommutative additional cases (term collection & factoring)
    {
      s: "n*vd + vd -> (n+1)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "vd + n*vd -> (1+n)*vd",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3 + n2*n3 -> (n1+n2)*n3",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n^n1 * n -> n^(n1+1)",
      assuming: {
        divide: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3    -> (n1 + n2*n3^(n4 +  1))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "n1*n3^(-n4) + n2 * n3^n5 -> (n1 + n2*n3^(n4 + n5))*n3^(-n4)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      l: "n*cd + cd",
      r: "(n+1)*cd"
    },
    {
      s: "cd*n + cd -> cd*(n+1)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    {
      s: "cd + cd*n -> cd*(1+n)",
      assuming: {
        multiply: {
          commutative: false
        }
      }
    },
    simplifyConstant2,
    // Second: before returning expressions to "standard form"
    // make factors positive (and undo 'make non-constant terms positive')
    {
      s: "(-n)*n1 -> -(n*n1)",
      assuming: {
        subtract: {
          total: true
        }
      }
    },
    {
      s: "n1*(-n) -> -(n1*n)",
      // in case * non-commutative
      assuming: {
        subtract: {
          total: true
        },
        multiply: {
          commutative: false
        }
      }
    },
    // final ordering of constants
    {
      s: "ce+ve -> ve+ce",
      assuming: {
        add: {
          commutative: true
        }
      },
      imposeContext: {
        add: {
          commutative: false
        }
      }
    },
    {
      s: "vd*cd -> cd*vd",
      assuming: {
        multiply: {
          commutative: true
        }
      },
      imposeContext: {
        multiply: {
          commutative: false
        }
      }
    },
    // undo temporary rules
    // { l: '(-1) * n', r: '-n' }, // #811 added test which proved this is redundant
    {
      l: "n+-n1",
      r: "n-n1"
    },
    // undo replace 'subtract'
    {
      l: "n+-(n1)",
      r: "n-(n1)"
    },
    {
      s: "n*(n1^-1) -> n/n1",
      // undo replace 'divide'; for * commutative
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n*n1^-n2 -> n/n1^n2",
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      s: "n^-1 -> 1/n",
      assuming: {
        multiply: {
          commutative: true
        }
      }
      // o.w. / not conventional
    },
    {
      l: "n^1",
      r: "n"
    },
    // can be produced by power cancellation
    {
      s: "n*(n1/n2) -> (n*n1)/n2",
      // '*' before '/'
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      s: "n-(n1+n2) -> n-n1-n2",
      // '-' before '+'
      assuming: {
        addition: {
          associative: true,
          commutative: true
        }
      }
    },
    // { l: '(n1/n2)/n3', r: 'n1/(n2*n3)' },
    // { l: '(n*n1)/(n*n2)', r: 'n1/n2' },
    // simplifyConstant can leave an extra factor of 1, which can always
    // be eliminated, since the identity always commutes
    {
      l: "1*n",
      r: "n",
      imposeContext: {
        multiply: {
          commutative: true
        }
      }
    },
    {
      s: "n1/(n2/n3) -> (n1*n3)/n2",
      assuming: {
        multiply: {
          associative: true
        }
      }
    },
    {
      l: "n1/(-n2)",
      r: "-n1/n2"
    }
  ];
  function _canonicalizeRule(ruleObject, context) {
    var newRule = {};
    if (ruleObject.s) {
      var lr = ruleObject.s.split("->");
      if (lr.length === 2) {
        newRule.l = lr[0];
        newRule.r = lr[1];
      } else {
        throw SyntaxError("Could not parse rule: " + ruleObject.s);
      }
    } else {
      newRule.l = ruleObject.l;
      newRule.r = ruleObject.r;
    }
    newRule.l = removeParens(parse2(newRule.l));
    newRule.r = removeParens(parse2(newRule.r));
    for (var prop of ["imposeContext", "repeat", "assuming"]) {
      if (prop in ruleObject) {
        newRule[prop] = ruleObject[prop];
      }
    }
    if (ruleObject.evaluate) {
      newRule.evaluate = parse2(ruleObject.evaluate);
    }
    if (isAssociative(newRule.l, context)) {
      var nonCommutative = !isCommutative(newRule.l, context);
      var leftExpandsym;
      if (nonCommutative)
        leftExpandsym = _getExpandPlaceholderSymbol();
      var makeNode = createMakeNodeFunction(newRule.l);
      var expandsym = _getExpandPlaceholderSymbol();
      newRule.expanded = {};
      newRule.expanded.l = makeNode([newRule.l, expandsym]);
      flatten2(newRule.expanded.l, context);
      unflattenr(newRule.expanded.l, context);
      newRule.expanded.r = makeNode([newRule.r, expandsym]);
      if (nonCommutative) {
        newRule.expandedNC1 = {};
        newRule.expandedNC1.l = makeNode([leftExpandsym, newRule.l]);
        newRule.expandedNC1.r = makeNode([leftExpandsym, newRule.r]);
        newRule.expandedNC2 = {};
        newRule.expandedNC2.l = makeNode([leftExpandsym, newRule.expanded.l]);
        newRule.expandedNC2.r = makeNode([leftExpandsym, newRule.expanded.r]);
      }
    }
    return newRule;
  }
  function _buildRules(rules, context) {
    var ruleSet = [];
    for (var i2 = 0; i2 < rules.length; i2++) {
      var rule = rules[i2];
      var newRule = void 0;
      var ruleType = typeof rule;
      switch (ruleType) {
        case "string":
          rule = {
            s: rule
          };
        case "object":
          newRule = _canonicalizeRule(rule, context);
          break;
        case "function":
          newRule = rule;
          break;
        default:
          throw TypeError("Unsupported type of rule: " + ruleType);
      }
      ruleSet.push(newRule);
    }
    return ruleSet;
  }
  var _lastsym = 0;
  function _getExpandPlaceholderSymbol() {
    return new SymbolNode2("_p" + _lastsym++);
  }
  function _simplify(expr, rules) {
    var scope = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : createEmptyMap();
    var options = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};
    var debug = options.consoleDebug;
    rules = _buildRules(rules || simplify2.rules, options.context);
    var res = resolve2(expr, scope);
    res = removeParens(res);
    var visited = {};
    var str = res.toString({
      parenthesis: "all"
    });
    while (!visited[str]) {
      visited[str] = true;
      _lastsym = 0;
      var laststr = str;
      if (debug)
        console.log("Working on: ", str);
      for (var i2 = 0; i2 < rules.length; i2++) {
        var rulestr = "";
        if (typeof rules[i2] === "function") {
          res = rules[i2](res, options);
          if (debug)
            rulestr = rules[i2].name;
        } else {
          flatten2(res, options.context);
          res = applyRule(res, rules[i2], options.context);
          if (debug) {
            rulestr = "".concat(rules[i2].l.toString(), " -> ").concat(rules[i2].r.toString());
          }
        }
        if (debug) {
          var newstr = res.toString({
            parenthesis: "all"
          });
          if (newstr !== laststr) {
            console.log("Applying", rulestr, "produced", newstr);
            laststr = newstr;
          }
        }
        unflattenl(res, options.context);
      }
      str = res.toString({
        parenthesis: "all"
      });
    }
    return res;
  }
  function mapRule(nodes, rule, context) {
    var resNodes = nodes;
    if (nodes) {
      for (var i2 = 0; i2 < nodes.length; ++i2) {
        var newNode = applyRule(nodes[i2], rule, context);
        if (newNode !== nodes[i2]) {
          if (resNodes === nodes) {
            resNodes = nodes.slice();
          }
          resNodes[i2] = newNode;
        }
      }
    }
    return resNodes;
  }
  function applyRule(node, rule, context) {
    if (rule.assuming) {
      for (var symbol in rule.assuming) {
        for (var property in rule.assuming[symbol]) {
          if (hasProperty(symbol, property, context) !== rule.assuming[symbol][property]) {
            return node;
          }
        }
      }
    }
    var mergedContext = mergeContext(rule.imposeContext, context);
    var res = node;
    if (res instanceof OperatorNode2 || res instanceof FunctionNode2) {
      var newArgs = mapRule(res.args, rule, context);
      if (newArgs !== res.args) {
        res = res.clone();
        res.args = newArgs;
      }
    } else if (res instanceof ParenthesisNode2) {
      if (res.content) {
        var newContent = applyRule(res.content, rule, context);
        if (newContent !== res.content) {
          res = new ParenthesisNode2(newContent);
        }
      }
    } else if (res instanceof ArrayNode2) {
      var newItems = mapRule(res.items, rule, context);
      if (newItems !== res.items) {
        res = new ArrayNode2(newItems);
      }
    } else if (res instanceof AccessorNode2) {
      var newObj = res.object;
      if (res.object) {
        newObj = applyRule(res.object, rule, context);
      }
      var newIndex = res.index;
      if (res.index) {
        newIndex = applyRule(res.index, rule, context);
      }
      if (newObj !== res.object || newIndex !== res.index) {
        res = new AccessorNode2(newObj, newIndex);
      }
    } else if (res instanceof IndexNode2) {
      var newDims = mapRule(res.dimensions, rule, context);
      if (newDims !== res.dimensions) {
        res = new IndexNode2(newDims);
      }
    } else if (res instanceof ObjectNode2) {
      var changed = false;
      var newProps = {};
      for (var prop in res.properties) {
        newProps[prop] = applyRule(res.properties[prop], rule, context);
        if (newProps[prop] !== res.properties[prop]) {
          changed = true;
        }
      }
      if (changed) {
        res = new ObjectNode2(newProps);
      }
    }
    var repl = rule.r;
    var matches = _ruleMatch(rule.l, res, mergedContext)[0];
    if (!matches && rule.expanded) {
      repl = rule.expanded.r;
      matches = _ruleMatch(rule.expanded.l, res, mergedContext)[0];
    }
    if (!matches && rule.expandedNC1) {
      repl = rule.expandedNC1.r;
      matches = _ruleMatch(rule.expandedNC1.l, res, mergedContext)[0];
      if (!matches) {
        repl = rule.expandedNC2.r;
        matches = _ruleMatch(rule.expandedNC2.l, res, mergedContext)[0];
      }
    }
    if (matches) {
      var implicit = res.implicit;
      res = repl.clone();
      if (implicit && "implicit" in repl) {
        res.implicit = true;
      }
      res = res.transform(function(node2) {
        if (node2.isSymbolNode && hasOwnProperty(matches.placeholders, node2.name)) {
          return matches.placeholders[node2.name].clone();
        } else {
          return node2;
        }
      });
    }
    if (rule.repeat && res !== node) {
      res = applyRule(res, rule, context);
    }
    return res;
  }
  function getSplits(node, context) {
    var res = [];
    var right, rightArgs;
    var makeNode = createMakeNodeFunction(node);
    if (isCommutative(node, context)) {
      for (var i2 = 0; i2 < node.args.length; i2++) {
        rightArgs = node.args.slice(0);
        rightArgs.splice(i2, 1);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([node.args[i2], right]));
      }
    } else {
      for (var _i = 1; _i < node.args.length; _i++) {
        var left = node.args[0];
        if (_i > 1) {
          left = makeNode(node.args.slice(0, _i));
        }
        rightArgs = node.args.slice(_i);
        right = rightArgs.length === 1 ? rightArgs[0] : makeNode(rightArgs);
        res.push(makeNode([left, right]));
      }
    }
    return res;
  }
  function mergeMatch(match1, match2) {
    var res = {
      placeholders: {}
    };
    if (!match1.placeholders && !match2.placeholders) {
      return res;
    } else if (!match1.placeholders) {
      return match2;
    } else if (!match2.placeholders) {
      return match1;
    }
    for (var key in match1.placeholders) {
      if (hasOwnProperty(match1.placeholders, key)) {
        res.placeholders[key] = match1.placeholders[key];
        if (hasOwnProperty(match2.placeholders, key)) {
          if (!_exactMatch(match1.placeholders[key], match2.placeholders[key])) {
            return null;
          }
        }
      }
    }
    for (var _key in match2.placeholders) {
      if (hasOwnProperty(match2.placeholders, _key)) {
        res.placeholders[_key] = match2.placeholders[_key];
      }
    }
    return res;
  }
  function combineChildMatches(list1, list2) {
    var res = [];
    if (list1.length === 0 || list2.length === 0) {
      return res;
    }
    var merged;
    for (var i1 = 0; i1 < list1.length; i1++) {
      for (var i2 = 0; i2 < list2.length; i2++) {
        merged = mergeMatch(list1[i1], list2[i2]);
        if (merged) {
          res.push(merged);
        }
      }
    }
    return res;
  }
  function mergeChildMatches(childMatches) {
    if (childMatches.length === 0) {
      return childMatches;
    }
    var sets = childMatches.reduce(combineChildMatches);
    var uniqueSets = [];
    var unique = {};
    for (var i2 = 0; i2 < sets.length; i2++) {
      var s = JSON.stringify(sets[i2]);
      if (!unique[s]) {
        unique[s] = true;
        uniqueSets.push(sets[i2]);
      }
    }
    return uniqueSets;
  }
  function _ruleMatch(rule, node, context, isSplit) {
    var res = [{
      placeholders: {}
    }];
    if (rule instanceof OperatorNode2 && node instanceof OperatorNode2 || rule instanceof FunctionNode2 && node instanceof FunctionNode2) {
      if (rule instanceof OperatorNode2) {
        if (rule.op !== node.op || rule.fn !== node.fn) {
          return [];
        }
      } else if (rule instanceof FunctionNode2) {
        if (rule.name !== node.name) {
          return [];
        }
      }
      if (node.args.length === 1 && rule.args.length === 1 || !isAssociative(node, context) && node.args.length === rule.args.length || isSplit) {
        var childMatches = [];
        for (var i2 = 0; i2 < rule.args.length; i2++) {
          var childMatch = _ruleMatch(rule.args[i2], node.args[i2], context);
          if (childMatch.length === 0) {
            break;
          }
          childMatches.push(childMatch);
        }
        if (childMatches.length !== rule.args.length) {
          if (!isCommutative(node, context) || // exact match in order needed
          rule.args.length === 1) {
            return [];
          }
          if (rule.args.length > 2) {
            throw new Error("permuting >2 commutative non-associative rule arguments not yet implemented");
          }
          var leftMatch = _ruleMatch(rule.args[0], node.args[1], context);
          if (leftMatch.length === 0) {
            return [];
          }
          var rightMatch = _ruleMatch(rule.args[1], node.args[0], context);
          if (rightMatch.length === 0) {
            return [];
          }
          childMatches = [leftMatch, rightMatch];
        }
        res = mergeChildMatches(childMatches);
      } else if (node.args.length >= 2 && rule.args.length === 2) {
        var splits = getSplits(node, context);
        var splitMatches = [];
        for (var _i2 = 0; _i2 < splits.length; _i2++) {
          var matchSet = _ruleMatch(rule, splits[_i2], context, true);
          splitMatches = splitMatches.concat(matchSet);
        }
        return splitMatches;
      } else if (rule.args.length > 2) {
        throw Error("Unexpected non-binary associative function: " + rule.toString());
      } else {
        return [];
      }
    } else if (rule instanceof SymbolNode2) {
      if (rule.name.length === 0) {
        throw new Error("Symbol in rule has 0 length...!?");
      }
      if (SUPPORTED_CONSTANTS[rule.name]) {
        if (rule.name !== node.name) {
          return [];
        }
      } else {
        switch (rule.name[1] >= "a" && rule.name[1] <= "z" ? rule.name.substring(0, 2) : rule.name[0]) {
          case "n":
          case "_p":
            res[0].placeholders[rule.name] = node;
            break;
          case "c":
          case "cl":
            if (isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "v":
            if (!isConstantNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vl":
            if (isSymbolNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "cd":
            if (isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "vd":
            if (!isNumericNode(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ce":
            if (isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          case "ve":
            if (!isConstantExpression(node)) {
              res[0].placeholders[rule.name] = node;
            } else {
              return [];
            }
            break;
          default:
            throw new Error("Invalid symbol in rule: " + rule.name);
        }
      }
    } else if (rule instanceof ConstantNode2) {
      if (!equal2(rule.value, node.value)) {
        return [];
      }
    } else {
      return [];
    }
    return res;
  }
  function _exactMatch(p, q) {
    if (p instanceof ConstantNode2 && q instanceof ConstantNode2) {
      if (!equal2(p.value, q.value)) {
        return false;
      }
    } else if (p instanceof SymbolNode2 && q instanceof SymbolNode2) {
      if (p.name !== q.name) {
        return false;
      }
    } else if (p instanceof OperatorNode2 && q instanceof OperatorNode2 || p instanceof FunctionNode2 && q instanceof FunctionNode2) {
      if (p instanceof OperatorNode2) {
        if (p.op !== q.op || p.fn !== q.fn) {
          return false;
        }
      } else if (p instanceof FunctionNode2) {
        if (p.name !== q.name) {
          return false;
        }
      }
      if (p.args.length !== q.args.length) {
        return false;
      }
      for (var i2 = 0; i2 < p.args.length; i2++) {
        if (!_exactMatch(p.args[i2], q.args[i2])) {
          return false;
        }
      }
    } else {
      return false;
    }
    return true;
  }
  return simplify2;
});
var name$x = "simplifyConstant";
var dependencies$x = ["typed", "config", "mathWithTransform", "matrix", "?fraction", "?bignumber", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode"];
var createSimplifyConstant = /* @__PURE__ */ factory(name$x, dependencies$x, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    fraction: fraction2,
    bignumber: bignumber2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var {
    isCommutative,
    isAssociative,
    allChildren,
    createMakeNodeFunction
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  var simplifyConstant2 = typed2("simplifyConstant", {
    Node: (node) => _ensureNode(foldFraction(node, {})),
    "Node, Object": function NodeObject(expr, options) {
      return _ensureNode(foldFraction(expr, options));
    }
  });
  function _removeFractions(thing) {
    if (isFraction(thing)) {
      return thing.valueOf();
    }
    if (thing instanceof Array) {
      return thing.map(_removeFractions);
    }
    if (isMatrix(thing)) {
      return matrix2(_removeFractions(thing.valueOf()));
    }
    return thing;
  }
  function _eval(fnname, args, options) {
    try {
      return mathWithTransform2[fnname].apply(null, args);
    } catch (ignore) {
      args = args.map(_removeFractions);
      return _toNumber(mathWithTransform2[fnname].apply(null, args), options);
    }
  }
  var _toNode = typed2({
    Fraction: _fractionToNode,
    number: function number2(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode2(-n));
      }
      return new ConstantNode2(n);
    },
    BigNumber: function BigNumber2(n) {
      if (n < 0) {
        return unaryMinusNode(new ConstantNode2(-n));
      }
      return new ConstantNode2(n);
    },
    Complex: function Complex2(s) {
      throw new Error("Cannot convert Complex number to Node");
    },
    string: function string2(s) {
      return new ConstantNode2(s);
    },
    Matrix: function Matrix2(m) {
      return new ArrayNode2(m.valueOf().map((e2) => _toNode(e2)));
    }
  });
  function _ensureNode(thing) {
    if (isNode(thing)) {
      return thing;
    }
    return _toNode(thing);
  }
  function _exactFraction(n, options) {
    var exactFractions = options && options.exactFractions !== false;
    if (exactFractions && isFinite(n) && fraction2) {
      var f = fraction2(n);
      var fractionsLimit = options && typeof options.fractionsLimit === "number" ? options.fractionsLimit : Infinity;
      if (f.valueOf() === n && f.n < fractionsLimit && f.d < fractionsLimit) {
        return f;
      }
    }
    return n;
  }
  var _toNumber = typed2({
    "string, Object": function stringObject(s, options) {
      if (config3.number === "BigNumber") {
        if (bignumber2 === void 0) {
          noBignumber();
        }
        return bignumber2(s);
      } else if (config3.number === "Fraction") {
        if (fraction2 === void 0) {
          noFraction();
        }
        return fraction2(s);
      } else {
        var n = parseFloat(s);
        return _exactFraction(n, options);
      }
    },
    "Fraction, Object": function FractionObject(s, options) {
      return s;
    },
    // we don't need options here
    "BigNumber, Object": function BigNumberObject(s, options) {
      return s;
    },
    // we don't need options here
    "number, Object": function numberObject(s, options) {
      return _exactFraction(s, options);
    },
    "Complex, Object": function ComplexObject(s, options) {
      if (s.im !== 0) {
        return s;
      }
      return _exactFraction(s.re, options);
    },
    "Matrix, Object": function MatrixObject(s, options) {
      return matrix2(_exactFraction(s.valueOf()));
    },
    "Array, Object": function ArrayObject(s, options) {
      return s.map(_exactFraction);
    }
  });
  function unaryMinusNode(n) {
    return new OperatorNode2("-", "unaryMinus", [n]);
  }
  function _fractionToNode(f) {
    var n;
    var vn = f.s * f.n;
    if (vn < 0) {
      n = new OperatorNode2("-", "unaryMinus", [new ConstantNode2(-vn)]);
    } else {
      n = new ConstantNode2(vn);
    }
    if (f.d === 1) {
      return n;
    }
    return new OperatorNode2("/", "divide", [n, new ConstantNode2(f.d)]);
  }
  function _foldAccessor(obj, index2, options) {
    if (!isIndexNode(index2)) {
      return new AccessorNode2(_ensureNode(obj), _ensureNode(index2));
    }
    if (isArrayNode(obj) || isMatrix(obj)) {
      var remainingDims = Array.from(index2.dimensions);
      while (remainingDims.length > 0) {
        if (isConstantNode(remainingDims[0]) && typeof remainingDims[0].value !== "string") {
          var first = _toNumber(remainingDims.shift().value, options);
          if (isArrayNode(obj)) {
            obj = obj.items[first - 1];
          } else {
            obj = obj.valueOf()[first - 1];
            if (obj instanceof Array) {
              obj = matrix2(obj);
            }
          }
        } else if (remainingDims.length > 1 && isConstantNode(remainingDims[1]) && typeof remainingDims[1].value !== "string") {
          var second = _toNumber(remainingDims[1].value, options);
          var tryItems = [];
          var fromItems = isArrayNode(obj) ? obj.items : obj.valueOf();
          for (var item of fromItems) {
            if (isArrayNode(item)) {
              tryItems.push(item.items[second - 1]);
            } else if (isMatrix(obj)) {
              tryItems.push(item[second - 1]);
            } else {
              break;
            }
          }
          if (tryItems.length === fromItems.length) {
            if (isArrayNode(obj)) {
              obj = new ArrayNode2(tryItems);
            } else {
              obj = matrix2(tryItems);
            }
            remainingDims.splice(1, 1);
          } else {
            break;
          }
        } else {
          break;
        }
      }
      if (remainingDims.length === index2.dimensions.length) {
        return new AccessorNode2(_ensureNode(obj), index2);
      }
      if (remainingDims.length > 0) {
        index2 = new IndexNode2(remainingDims);
        return new AccessorNode2(_ensureNode(obj), index2);
      }
      return obj;
    }
    if (isObjectNode(obj) && index2.dimensions.length === 1 && isConstantNode(index2.dimensions[0])) {
      var key = index2.dimensions[0].value;
      if (key in obj.properties) {
        return obj.properties[key];
      }
      return new ConstantNode2();
    }
    return new AccessorNode2(_ensureNode(obj), index2);
  }
  function foldOp(fn, args, makeNode, options) {
    var first = args.shift();
    var reduction = args.reduce((sofar, next) => {
      if (!isNode(next)) {
        var last = sofar.pop();
        if (isNode(last)) {
          return [last, next];
        }
        try {
          sofar.push(_eval(fn, [last, next], options));
          return sofar;
        } catch (ignoreandcontinue) {
          sofar.push(last);
        }
      }
      sofar.push(_ensureNode(sofar.pop()));
      var newtree = sofar.length === 1 ? sofar[0] : makeNode(sofar);
      return [makeNode([newtree, _ensureNode(next)])];
    }, [first]);
    if (reduction.length === 1) {
      return reduction[0];
    }
    return makeNode([reduction[0], _toNode(reduction[1])]);
  }
  function foldFraction(node, options) {
    switch (node.type) {
      case "SymbolNode":
        return node;
      case "ConstantNode":
        switch (typeof node.value) {
          case "number":
            return _toNumber(node.value, options);
          case "string":
            return node.value;
          default:
            if (!isNaN(node.value))
              return _toNumber(node.value, options);
        }
        return node;
      case "FunctionNode":
        if (mathWithTransform2[node.name] && mathWithTransform2[node.name].rawArgs) {
          return node;
        }
        {
          var operatorFunctions = ["add", "multiply"];
          if (operatorFunctions.indexOf(node.name) === -1) {
            var args = node.args.map((arg2) => foldFraction(arg2, options));
            if (!args.some(isNode)) {
              try {
                return _eval(node.name, args, options);
              } catch (ignoreandcontinue) {
              }
            }
            if (node.name === "size" && args.length === 1 && isArrayNode(args[0])) {
              var sz = [];
              var section = args[0];
              while (isArrayNode(section)) {
                sz.push(section.items.length);
                section = section.items[0];
              }
              return matrix2(sz);
            }
            return new FunctionNode2(node.name, args.map(_ensureNode));
          }
        }
      case "OperatorNode": {
        var fn = node.fn.toString();
        var _args;
        var res;
        var makeNode = createMakeNodeFunction(node);
        if (isOperatorNode(node) && node.isUnary()) {
          _args = [foldFraction(node.args[0], options)];
          if (!isNode(_args[0])) {
            res = _eval(fn, _args, options);
          } else {
            res = makeNode(_args);
          }
        } else if (isAssociative(node, options.context)) {
          _args = allChildren(node, options.context);
          _args = _args.map((arg2) => foldFraction(arg2, options));
          if (isCommutative(fn, options.context)) {
            var consts = [];
            var vars = [];
            for (var i2 = 0; i2 < _args.length; i2++) {
              if (!isNode(_args[i2])) {
                consts.push(_args[i2]);
              } else {
                vars.push(_args[i2]);
              }
            }
            if (consts.length > 1) {
              res = foldOp(fn, consts, makeNode, options);
              vars.unshift(res);
              res = foldOp(fn, vars, makeNode, options);
            } else {
              res = foldOp(fn, _args, makeNode, options);
            }
          } else {
            res = foldOp(fn, _args, makeNode, options);
          }
        } else {
          _args = node.args.map((arg2) => foldFraction(arg2, options));
          res = foldOp(fn, _args, makeNode, options);
        }
        return res;
      }
      case "ParenthesisNode":
        return foldFraction(node.content, options);
      case "AccessorNode":
        return _foldAccessor(foldFraction(node.object, options), foldFraction(node.index, options), options);
      case "ArrayNode": {
        var foldItems = node.items.map((item) => foldFraction(item, options));
        if (foldItems.some(isNode)) {
          return new ArrayNode2(foldItems.map(_ensureNode));
        }
        return matrix2(foldItems);
      }
      case "IndexNode": {
        return new IndexNode2(node.dimensions.map((n) => simplifyConstant2(n, options)));
      }
      case "ObjectNode": {
        var foldProps = {};
        for (var prop in node.properties) {
          foldProps[prop] = simplifyConstant2(node.properties[prop], options);
        }
        return new ObjectNode2(foldProps);
      }
      case "AssignmentNode":
      case "BlockNode":
      case "FunctionAssignmentNode":
      case "RangeNode":
      case "ConditionalNode":
      default:
        throw new Error("Unimplemented node type in simplifyConstant: ".concat(node.type));
    }
  }
  return simplifyConstant2;
});
var name$w = "simplifyCore";
var dependencies$w = ["typed", "parse", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createSimplifyCore = /* @__PURE__ */ factory(name$w, dependencies$w, (_ref) => {
  var {
    typed: typed2,
    parse: parse2,
    equal: equal2,
    isZero: isZero2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    pow: pow2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  var node0 = new ConstantNode2(0);
  var node1 = new ConstantNode2(1);
  var nodeT = new ConstantNode2(true);
  var nodeF = new ConstantNode2(false);
  function isAlwaysBoolean(node) {
    return isOperatorNode(node) && ["and", "not", "or"].includes(node.op);
  }
  var {
    hasProperty,
    isCommutative
  } = createUtil({
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2
  });
  function _simplifyCore(nodeToSimplify) {
    var options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var context = options ? options.context : void 0;
    if (hasProperty(nodeToSimplify, "trivial", context)) {
      if (isFunctionNode(nodeToSimplify) && nodeToSimplify.args.length === 1) {
        return _simplifyCore(nodeToSimplify.args[0], options);
      }
      var simpChild = false;
      var childCount = 0;
      nodeToSimplify.forEach((c) => {
        ++childCount;
        if (childCount === 1) {
          simpChild = _simplifyCore(c, options);
        }
      });
      if (childCount === 1) {
        return simpChild;
      }
    }
    var node = nodeToSimplify;
    if (isFunctionNode(node)) {
      var op = getOperator(node.name);
      if (op) {
        if (node.args.length > 2 && hasProperty(node, "associative", context)) {
          while (node.args.length > 2) {
            var last = node.args.pop();
            var seclast = node.args.pop();
            node.args.push(new OperatorNode2(op, node.name, [last, seclast]));
          }
        }
        node = new OperatorNode2(op, node.name, node.args);
      } else {
        return new FunctionNode2(_simplifyCore(node.fn), node.args.map((n) => _simplifyCore(n, options)));
      }
    }
    if (isOperatorNode(node) && node.isUnary()) {
      var a0 = _simplifyCore(node.args[0], options);
      if (node.op === "~") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "~") {
          return a0.args[0];
        }
      }
      if (node.op === "not") {
        if (isOperatorNode(a0) && a0.isUnary() && a0.op === "not") {
          if (isAlwaysBoolean(a0.args[0])) {
            return a0.args[0];
          }
        }
      }
      var finish = true;
      if (node.op === "-") {
        if (isOperatorNode(a0)) {
          if (a0.isBinary() && a0.fn === "subtract") {
            node = new OperatorNode2("-", "subtract", [a0.args[1], a0.args[0]]);
            finish = false;
          }
          if (a0.isUnary() && a0.op === "-") {
            return a0.args[0];
          }
        }
      }
      if (finish)
        return new OperatorNode2(node.op, node.fn, [a0]);
    }
    if (isOperatorNode(node) && node.isBinary()) {
      var _a = _simplifyCore(node.args[0], options);
      var a1 = _simplifyCore(node.args[1], options);
      if (node.op === "+") {
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return a1;
        }
        if (isConstantNode(a1) && isZero2(a1.value)) {
          return _a;
        }
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          a1 = a1.args[0];
          node = new OperatorNode2("-", "subtract", [_a, a1]);
        }
      }
      if (node.op === "-") {
        if (isOperatorNode(a1) && a1.isUnary() && a1.op === "-") {
          return _simplifyCore(new OperatorNode2("+", "add", [_a, a1.args[0]]), options);
        }
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return _simplifyCore(new OperatorNode2("-", "unaryMinus", [a1]));
        }
        if (isConstantNode(a1) && isZero2(a1.value)) {
          return _a;
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "*") {
        if (isConstantNode(_a)) {
          if (isZero2(_a.value)) {
            return node0;
          } else if (equal2(_a.value, 1)) {
            return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (isZero2(a1.value)) {
            return node0;
          } else if (equal2(a1.value, 1)) {
            return _a;
          }
          if (isCommutative(node, context)) {
            return new OperatorNode2(node.op, node.fn, [a1, _a], node.implicit);
          }
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1], node.implicit);
      }
      if (node.op === "/") {
        if (isConstantNode(_a) && isZero2(_a.value)) {
          return node0;
        }
        if (isConstantNode(a1) && equal2(a1.value, 1)) {
          return _a;
        }
        return new OperatorNode2(node.op, node.fn, [_a, a1]);
      }
      if (node.op === "^") {
        if (isConstantNode(a1)) {
          if (isZero2(a1.value)) {
            return node1;
          } else if (equal2(a1.value, 1)) {
            return _a;
          }
        }
      }
      if (node.op === "and") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            if (isAlwaysBoolean(a1))
              return a1;
            if (isConstantNode(a1)) {
              return a1.value ? nodeT : nodeF;
            }
          } else {
            return nodeF;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            if (isAlwaysBoolean(_a))
              return _a;
          } else {
            return nodeF;
          }
        }
      }
      if (node.op === "or") {
        if (isConstantNode(_a)) {
          if (_a.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(a1))
              return a1;
          }
        }
        if (isConstantNode(a1)) {
          if (a1.value) {
            return nodeT;
          } else {
            if (isAlwaysBoolean(_a))
              return _a;
          }
        }
      }
      return new OperatorNode2(node.op, node.fn, [_a, a1]);
    }
    if (isOperatorNode(node)) {
      return new OperatorNode2(node.op, node.fn, node.args.map((a) => _simplifyCore(a, options)));
    }
    if (isArrayNode(node)) {
      return new ArrayNode2(node.items.map((n) => _simplifyCore(n, options)));
    }
    if (isAccessorNode(node)) {
      return new AccessorNode2(_simplifyCore(node.object, options), _simplifyCore(node.index, options));
    }
    if (isIndexNode(node)) {
      return new IndexNode2(node.dimensions.map((n) => _simplifyCore(n, options)));
    }
    if (isObjectNode(node)) {
      var newProps = {};
      for (var prop in node.properties) {
        newProps[prop] = _simplifyCore(node.properties[prop], options);
      }
      return new ObjectNode2(newProps);
    }
    return node;
  }
  return typed2(name$w, {
    Node: _simplifyCore,
    "Node,Object": _simplifyCore
  });
});
var name$v = "resolve";
var dependencies$v = ["typed", "parse", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode"];
var createResolve = /* @__PURE__ */ factory(name$v, dependencies$v, (_ref) => {
  var {
    typed: typed2,
    parse: parse2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2
  } = _ref;
  function _resolve(node, scope) {
    var within = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : /* @__PURE__ */ new Set();
    if (!scope) {
      return node;
    }
    if (isSymbolNode(node)) {
      if (within.has(node.name)) {
        var variables = Array.from(within).join(", ");
        throw new ReferenceError("recursive loop of variable definitions among {".concat(variables, "}"));
      }
      var value = scope.get(node.name);
      if (isNode(value)) {
        var nextWithin = new Set(within);
        nextWithin.add(node.name);
        return _resolve(value, scope, nextWithin);
      } else if (typeof value === "number") {
        return parse2(String(value));
      } else if (value !== void 0) {
        return new ConstantNode2(value);
      } else {
        return node;
      }
    } else if (isOperatorNode(node)) {
      var args = node.args.map(function(arg2) {
        return _resolve(arg2, scope, within);
      });
      return new OperatorNode2(node.op, node.fn, args, node.implicit);
    } else if (isParenthesisNode(node)) {
      return new ParenthesisNode2(_resolve(node.content, scope, within));
    } else if (isFunctionNode(node)) {
      var _args = node.args.map(function(arg2) {
        return _resolve(arg2, scope, within);
      });
      return new FunctionNode2(node.name, _args);
    }
    return node.map((child) => _resolve(child, scope, within));
  }
  return typed2("resolve", {
    Node: _resolve,
    "Node, Map | null | undefined": _resolve,
    "Node, Object": (n, scope) => _resolve(n, createMap$1(scope)),
    // For arrays and matrices, we map `self` rather than `_resolve`
    // because resolve is fairly expensive anyway, and this way
    // we get nice error messages if one entry in the array has wrong type.
    "Array | Matrix": typed2.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array | Matrix, null | undefined": typed2.referToSelf((self2) => (A) => A.map((n) => self2(n))),
    "Array, Object": typed2.referTo("Array,Map", (selfAM) => (A, scope) => selfAM(A, createMap$1(scope))),
    "Matrix, Object": typed2.referTo("Matrix,Map", (selfMM) => (A, scope) => selfMM(A, createMap$1(scope))),
    "Array | Matrix, Map": typed2.referToSelf((self2) => (A, scope) => A.map((n) => self2(n, scope)))
  });
});
var name$u = "symbolicEqual";
var dependencies$u = ["parse", "simplify", "typed", "OperatorNode"];
var createSymbolicEqual = /* @__PURE__ */ factory(name$u, dependencies$u, (_ref) => {
  var {
    parse: parse2,
    simplify: simplify2,
    typed: typed2,
    OperatorNode: OperatorNode2
  } = _ref;
  function _symbolicEqual(e1, e2) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    var diff2 = new OperatorNode2("-", "subtract", [e1, e2]);
    var simplified = simplify2(diff2, {}, options);
    return isConstantNode(simplified) && !simplified.value;
  }
  return typed2(name$u, {
    "Node, Node": _symbolicEqual,
    "Node, Node, Object": _symbolicEqual
  });
});
var name$t = "derivative";
var dependencies$t = ["typed", "config", "parse", "simplify", "equal", "isZero", "numeric", "ConstantNode", "FunctionNode", "OperatorNode", "ParenthesisNode", "SymbolNode"];
var createDerivative = /* @__PURE__ */ factory(name$t, dependencies$t, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    parse: parse2,
    simplify: simplify2,
    equal: equal2,
    isZero: isZero2,
    numeric: numeric3,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    OperatorNode: OperatorNode2,
    ParenthesisNode: ParenthesisNode2,
    SymbolNode: SymbolNode2
  } = _ref;
  function plainDerivative(expr, variable) {
    var options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {
      simplify: true
    };
    var constNodes = {};
    constTag(constNodes, expr, variable.name);
    var res = _derivative(expr, constNodes);
    return options.simplify ? simplify2(res) : res;
  }
  typed2.addConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse2
  });
  var derivative2 = typed2(name$t, {
    "Node, SymbolNode": plainDerivative,
    "Node, SymbolNode, Object": plainDerivative
    /* TODO: implement and test syntax with order of derivatives -> implement as an option {order: number}
    'Node, SymbolNode, ConstantNode': function (expr, variable, {order}) {
      let res = expr
      for (let i = 0; i < order; i++) {
        let constNodes = {}
        constTag(constNodes, expr, variable.name)
        res = _derivative(res, constNodes)
      }
      return res
    }
    */
  });
  typed2.removeConversion({
    from: "identifier",
    to: "SymbolNode",
    convert: parse2
  });
  derivative2._simplify = true;
  derivative2.toTex = function(deriv) {
    return _derivTex.apply(null, deriv.args);
  };
  var _derivTex = typed2("_derivTex", {
    "Node, SymbolNode": function NodeSymbolNode(expr, x) {
      if (isConstantNode(expr) && typeOf$1(expr.value) === "string") {
        return _derivTex(parse2(expr.value).toString(), x.toString(), 1);
      } else {
        return _derivTex(expr.toTex(), x.toString(), 1);
      }
    },
    "Node, ConstantNode": function NodeConstantNode(expr, x) {
      if (typeOf$1(x.value) === "string") {
        return _derivTex(expr, parse2(x.value));
      } else {
        throw new Error("The second parameter to 'derivative' is a non-string constant");
      }
    },
    "Node, SymbolNode, ConstantNode": function NodeSymbolNodeConstantNode(expr, x, order) {
      return _derivTex(expr.toString(), x.name, order.value);
    },
    "string, string, number": function stringStringNumber(expr, x, order) {
      var d;
      if (order === 1) {
        d = "{d\\over d" + x + "}";
      } else {
        d = "{d^{" + order + "}\\over d" + x + "^{" + order + "}}";
      }
      return d + "\\left[".concat(expr, "\\right]");
    }
  });
  var constTag = typed2("constTag", {
    "Object, ConstantNode, string": function ObjectConstantNodeString(constNodes, node) {
      constNodes[node] = true;
      return true;
    },
    "Object, SymbolNode, string": function ObjectSymbolNodeString(constNodes, node, varName) {
      if (node.name !== varName) {
        constNodes[node] = true;
        return true;
      }
      return false;
    },
    "Object, ParenthesisNode, string": function ObjectParenthesisNodeString(constNodes, node, varName) {
      return constTag(constNodes, node.content, varName);
    },
    "Object, FunctionAssignmentNode, string": function ObjectFunctionAssignmentNodeString(constNodes, node, varName) {
      if (node.params.indexOf(varName) === -1) {
        constNodes[node] = true;
        return true;
      }
      return constTag(constNodes, node.expr, varName);
    },
    "Object, FunctionNode | OperatorNode, string": function ObjectFunctionNodeOperatorNodeString(constNodes, node, varName) {
      if (node.args.length > 0) {
        var isConst = constTag(constNodes, node.args[0], varName);
        for (var i2 = 1; i2 < node.args.length; ++i2) {
          isConst = constTag(constNodes, node.args[i2], varName) && isConst;
        }
        if (isConst) {
          constNodes[node] = true;
          return true;
        }
      }
      return false;
    }
  });
  var _derivative = typed2("_derivative", {
    "ConstantNode, Object": function ConstantNodeObject(node) {
      return createConstantNode2(0);
    },
    "SymbolNode, Object": function SymbolNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      return createConstantNode2(1);
    },
    "ParenthesisNode, Object": function ParenthesisNodeObject(node, constNodes) {
      return new ParenthesisNode2(_derivative(node.content, constNodes));
    },
    "FunctionAssignmentNode, Object": function FunctionAssignmentNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      return _derivative(node.expr, constNodes);
    },
    "FunctionNode, Object": function FunctionNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      var arg0 = node.args[0];
      var arg1;
      var div2 = false;
      var negative = false;
      var funcDerivative;
      switch (node.name) {
        case "cbrt":
          div2 = true;
          funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(3), new OperatorNode2("^", "pow", [arg0, new OperatorNode2("/", "divide", [createConstantNode2(2), createConstantNode2(3)])])]);
          break;
        case "sqrt":
        case "nthRoot":
          if (node.args.length === 1) {
            div2 = true;
            funcDerivative = new OperatorNode2("*", "multiply", [createConstantNode2(2), new FunctionNode2("sqrt", [arg0])]);
          } else if (node.args.length === 2) {
            arg1 = new OperatorNode2("/", "divide", [createConstantNode2(1), node.args[1]]);
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode2("^", "pow", [arg0, arg1]), constNodes);
          }
          break;
        case "log10":
          arg1 = createConstantNode2(10);
        case "log":
          if (!arg1 && node.args.length === 1) {
            funcDerivative = arg0.clone();
            div2 = true;
          } else if (node.args.length === 1 && arg1 || node.args.length === 2 && constNodes[node.args[1]] !== void 0) {
            funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("log", [arg1 || node.args[1]])]);
            div2 = true;
          } else if (node.args.length === 2) {
            return _derivative(new OperatorNode2("/", "divide", [new FunctionNode2("log", [arg0]), new FunctionNode2("log", [node.args[1]])]), constNodes);
          }
          break;
        case "pow":
          if (node.args.length === 2) {
            constNodes[arg1] = constNodes[node.args[1]];
            return _derivative(new OperatorNode2("^", "pow", [arg0, node.args[1]]), constNodes);
          }
          break;
        case "exp":
          funcDerivative = new FunctionNode2("exp", [arg0.clone()]);
          break;
        case "sin":
          funcDerivative = new FunctionNode2("cos", [arg0.clone()]);
          break;
        case "cos":
          funcDerivative = new OperatorNode2("-", "unaryMinus", [new FunctionNode2("sin", [arg0.clone()])]);
          break;
        case "tan":
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sec", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sec":
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tan", [arg0.clone()])]);
          break;
        case "csc":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("cot", [arg0.clone()])]);
          break;
        case "cot":
          negative = true;
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csc", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asin":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "acos":
          div2 = true;
          negative = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])]);
          break;
        case "atan":
          div2 = true;
          funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "asec":
          div2 = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acsc":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acot":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)]);
          break;
        case "sinh":
          funcDerivative = new FunctionNode2("cosh", [arg0.clone()]);
          break;
        case "cosh":
          funcDerivative = new FunctionNode2("sinh", [arg0.clone()]);
          break;
        case "tanh":
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("sech", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "sech":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("tanh", [arg0.clone()])]);
          break;
        case "csch":
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [node, new FunctionNode2("coth", [arg0.clone()])]);
          break;
        case "coth":
          negative = true;
          funcDerivative = new OperatorNode2("^", "pow", [new FunctionNode2("csch", [arg0.clone()]), createConstantNode2(2)]);
          break;
        case "asinh":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "acosh":
          div2 = true;
          funcDerivative = new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])]);
          break;
        case "atanh":
          div2 = true;
          funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "asech":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [arg0.clone(), new FunctionNode2("sqrt", [new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])])])]);
          break;
        case "acsch":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("*", "multiply", [new FunctionNode2("abs", [arg0.clone()]), new FunctionNode2("sqrt", [new OperatorNode2("+", "add", [new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)]), createConstantNode2(1)])])]);
          break;
        case "acoth":
          div2 = true;
          negative = true;
          funcDerivative = new OperatorNode2("-", "subtract", [createConstantNode2(1), new OperatorNode2("^", "pow", [arg0.clone(), createConstantNode2(2)])]);
          break;
        case "abs":
          funcDerivative = new OperatorNode2("/", "divide", [new FunctionNode2(new SymbolNode2("abs"), [arg0.clone()]), arg0.clone()]);
          break;
        case "gamma":
        default:
          throw new Error('Cannot process function "' + node.name + '" in derivative: the function is not supported, undefined, or the number of arguments passed to it are not supported');
      }
      var op, func;
      if (div2) {
        op = "/";
        func = "divide";
      } else {
        op = "*";
        func = "multiply";
      }
      var chainDerivative = _derivative(arg0, constNodes);
      if (negative) {
        chainDerivative = new OperatorNode2("-", "unaryMinus", [chainDerivative]);
      }
      return new OperatorNode2(op, func, [chainDerivative, funcDerivative]);
    },
    "OperatorNode, Object": function OperatorNodeObject(node, constNodes) {
      if (constNodes[node] !== void 0) {
        return createConstantNode2(0);
      }
      if (node.op === "+") {
        return new OperatorNode2(node.op, node.fn, node.args.map(function(arg2) {
          return _derivative(arg2, constNodes);
        }));
      }
      if (node.op === "-") {
        if (node.isUnary()) {
          return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes)]);
        }
        if (node.isBinary()) {
          return new OperatorNode2(node.op, node.fn, [_derivative(node.args[0], constNodes), _derivative(node.args[1], constNodes)]);
        }
      }
      if (node.op === "*") {
        var constantTerms = node.args.filter(function(arg2) {
          return constNodes[arg2] !== void 0;
        });
        if (constantTerms.length > 0) {
          var nonConstantTerms = node.args.filter(function(arg2) {
            return constNodes[arg2] === void 0;
          });
          var nonConstantNode = nonConstantTerms.length === 1 ? nonConstantTerms[0] : new OperatorNode2("*", "multiply", nonConstantTerms);
          var newArgs = constantTerms.concat(_derivative(nonConstantNode, constNodes));
          return new OperatorNode2("*", "multiply", newArgs);
        }
        return new OperatorNode2("+", "add", node.args.map(function(argOuter) {
          return new OperatorNode2("*", "multiply", node.args.map(function(argInner) {
            return argInner === argOuter ? _derivative(argInner, constNodes) : argInner.clone();
          }));
        }));
      }
      if (node.op === "/" && node.isBinary()) {
        var arg0 = node.args[0];
        var arg1 = node.args[1];
        if (constNodes[arg1] !== void 0) {
          return new OperatorNode2("/", "divide", [_derivative(arg0, constNodes), arg1]);
        }
        if (constNodes[arg0] !== void 0) {
          return new OperatorNode2("*", "multiply", [new OperatorNode2("-", "unaryMinus", [arg0]), new OperatorNode2("/", "divide", [_derivative(arg1, constNodes), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])])]);
        }
        return new OperatorNode2("/", "divide", [new OperatorNode2("-", "subtract", [new OperatorNode2("*", "multiply", [_derivative(arg0, constNodes), arg1.clone()]), new OperatorNode2("*", "multiply", [arg0.clone(), _derivative(arg1, constNodes)])]), new OperatorNode2("^", "pow", [arg1.clone(), createConstantNode2(2)])]);
      }
      if (node.op === "^" && node.isBinary()) {
        var _arg = node.args[0];
        var _arg2 = node.args[1];
        if (constNodes[_arg] !== void 0) {
          if (isConstantNode(_arg) && (isZero2(_arg.value) || equal2(_arg.value, 1))) {
            return createConstantNode2(0);
          }
          return new OperatorNode2("*", "multiply", [node, new OperatorNode2("*", "multiply", [new FunctionNode2("log", [_arg.clone()]), _derivative(_arg2.clone(), constNodes)])]);
        }
        if (constNodes[_arg2] !== void 0) {
          if (isConstantNode(_arg2)) {
            if (isZero2(_arg2.value)) {
              return createConstantNode2(0);
            }
            if (equal2(_arg2.value, 1)) {
              return _derivative(_arg, constNodes);
            }
          }
          var powMinusOne = new OperatorNode2("^", "pow", [_arg.clone(), new OperatorNode2("-", "subtract", [_arg2, createConstantNode2(1)])]);
          return new OperatorNode2("*", "multiply", [_arg2.clone(), new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), powMinusOne])]);
        }
        return new OperatorNode2("*", "multiply", [new OperatorNode2("^", "pow", [_arg.clone(), _arg2.clone()]), new OperatorNode2("+", "add", [new OperatorNode2("*", "multiply", [_derivative(_arg, constNodes), new OperatorNode2("/", "divide", [_arg2.clone(), _arg.clone()])]), new OperatorNode2("*", "multiply", [_derivative(_arg2, constNodes), new FunctionNode2("log", [_arg.clone()])])])]);
      }
      throw new Error('Cannot process operator "' + node.op + '" in derivative: the operator is not supported, undefined, or the number of arguments passed to it are not supported');
    }
  });
  function createConstantNode2(value, valueType) {
    return new ConstantNode2(numeric3(value, valueType || config3.number));
  }
  return derivative2;
});
var name$s = "rationalize";
var dependencies$s = ["config", "typed", "equal", "isZero", "add", "subtract", "multiply", "divide", "pow", "parse", "simplifyConstant", "simplifyCore", "simplify", "?bignumber", "?fraction", "mathWithTransform", "matrix", "AccessorNode", "ArrayNode", "ConstantNode", "FunctionNode", "IndexNode", "ObjectNode", "OperatorNode", "SymbolNode", "ParenthesisNode"];
var createRationalize = /* @__PURE__ */ factory(name$s, dependencies$s, (_ref) => {
  var {
    config: config3,
    typed: typed2,
    equal: equal2,
    isZero: isZero2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    pow: pow2,
    parse: parse2,
    simplifyConstant: simplifyConstant2,
    simplifyCore: simplifyCore2,
    simplify: simplify2,
    fraction: fraction2,
    bignumber: bignumber2,
    mathWithTransform: mathWithTransform2,
    matrix: matrix2,
    AccessorNode: AccessorNode2,
    ArrayNode: ArrayNode2,
    ConstantNode: ConstantNode2,
    FunctionNode: FunctionNode2,
    IndexNode: IndexNode2,
    ObjectNode: ObjectNode2,
    OperatorNode: OperatorNode2,
    SymbolNode: SymbolNode2,
    ParenthesisNode: ParenthesisNode2
  } = _ref;
  function _rationalize(expr) {
    var scope = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    var detailed = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : false;
    var setRules = rulesRationalize();
    var polyRet = polynomial(expr, scope, true, setRules.firstRules);
    var nVars = polyRet.variables.length;
    var noExactFractions = {
      exactFractions: false
    };
    var withExactFractions = {
      exactFractions: true
    };
    expr = polyRet.expression;
    if (nVars >= 1) {
      expr = expandPower(expr);
      var sBefore;
      var rules;
      var eDistrDiv = true;
      var redoInic = false;
      expr = simplify2(expr, setRules.firstRules, {}, noExactFractions);
      var s;
      while (true) {
        rules = eDistrDiv ? setRules.distrDivRules : setRules.sucDivRules;
        expr = simplify2(expr, rules, {}, withExactFractions);
        eDistrDiv = !eDistrDiv;
        s = expr.toString();
        if (s === sBefore) {
          break;
        }
        redoInic = true;
        sBefore = s;
      }
      if (redoInic) {
        expr = simplify2(expr, setRules.firstRulesAgain, {}, noExactFractions);
      }
      expr = simplify2(expr, setRules.finalRules, {}, noExactFractions);
    }
    var coefficients = [];
    var retRationalize = {};
    if (expr.type === "OperatorNode" && expr.isBinary() && expr.op === "/") {
      if (nVars === 1) {
        expr.args[0] = polyToCanonical(expr.args[0], coefficients);
        expr.args[1] = polyToCanonical(expr.args[1]);
      }
      if (detailed) {
        retRationalize.numerator = expr.args[0];
        retRationalize.denominator = expr.args[1];
      }
    } else {
      if (nVars === 1) {
        expr = polyToCanonical(expr, coefficients);
      }
      if (detailed) {
        retRationalize.numerator = expr;
        retRationalize.denominator = null;
      }
    }
    if (!detailed)
      return expr;
    retRationalize.coefficients = coefficients;
    retRationalize.variables = polyRet.variables;
    retRationalize.expression = expr;
    return retRationalize;
  }
  return typed2(name$s, {
    Node: _rationalize,
    "Node, boolean": (expr, detailed) => _rationalize(expr, {}, detailed),
    "Node, Object": _rationalize,
    "Node, Object, boolean": _rationalize
  });
  function polynomial(expr, scope, extended, rules) {
    var variables = [];
    var node = simplify2(expr, rules, scope, {
      exactFractions: false
    });
    extended = !!extended;
    var oper = "+-*" + (extended ? "/" : "");
    recPoly(node);
    var retFunc = {};
    retFunc.expression = node;
    retFunc.variables = variables;
    return retFunc;
    function recPoly(node2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if (node2.op === "^") {
          if (node2.args[1].type !== "ConstantNode" || !isInteger$1(parseFloat(node2.args[1].value))) {
            throw new Error("There is a non-integer exponent");
          } else {
            recPoly(node2.args[0]);
          }
        } else {
          if (oper.indexOf(node2.op) === -1) {
            throw new Error("Operator " + node2.op + " invalid in polynomial expression");
          }
          for (var i2 = 0; i2 < node2.args.length; i2++) {
            recPoly(node2.args[i2]);
          }
        }
      } else if (tp === "SymbolNode") {
        var _name = node2.name;
        var pos = variables.indexOf(_name);
        if (pos === -1) {
          variables.push(_name);
        }
      } else if (tp === "ParenthesisNode") {
        recPoly(node2.content);
      } else if (tp !== "ConstantNode") {
        throw new Error("type " + tp + " is not allowed in polynomial expression");
      }
    }
  }
  function rulesRationalize() {
    var oldRules = [
      simplifyCore2,
      // sCore
      {
        l: "n+n",
        r: "2*n"
      },
      {
        l: "n+-n",
        r: "0"
      },
      simplifyConstant2,
      // sConstant
      {
        l: "n*(n1^-1)",
        r: "n/n1"
      },
      {
        l: "n*n1^-n2",
        r: "n/n1^n2"
      },
      {
        l: "n1^-1",
        r: "1/n1"
      },
      {
        l: "n*(n1/n2)",
        r: "(n*n1)/n2"
      },
      {
        l: "1*n",
        r: "n"
      }
    ];
    var rulesFirst = [
      {
        l: "(-n1)/(-n2)",
        r: "n1/n2"
      },
      // Unary division
      {
        l: "(-n1)*(-n2)",
        r: "n1*n2"
      },
      // Unary multiplication
      {
        l: "n1--n2",
        r: "n1+n2"
      },
      // '--' elimination
      {
        l: "n1-n2",
        r: "n1+(-n2)"
      },
      // Subtraction turn into add with unry minus
      {
        l: "(n1+n2)*n3",
        r: "(n1*n3 + n2*n3)"
      },
      // Distributive 1
      {
        l: "n1*(n2+n3)",
        r: "(n1*n2+n1*n3)"
      },
      // Distributive 2
      {
        l: "c1*n + c2*n",
        r: "(c1+c2)*n"
      },
      // Joining constants
      {
        l: "c1*n + n",
        r: "(c1+1)*n"
      },
      // Joining constants
      {
        l: "c1*n - c2*n",
        r: "(c1-c2)*n"
      },
      // Joining constants
      {
        l: "c1*n - n",
        r: "(c1-1)*n"
      },
      // Joining constants
      {
        l: "v/c",
        r: "(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "v/-c",
        r: "-(1/c)*v"
      },
      // variable/constant (new!)
      {
        l: "-v*-c",
        r: "c*v"
      },
      // Inversion constant and variable 1
      {
        l: "-v*c",
        r: "-c*v"
      },
      // Inversion constant and variable 2
      {
        l: "v*-c",
        r: "-c*v"
      },
      // Inversion constant and variable 3
      {
        l: "v*c",
        r: "c*v"
      },
      // Inversion constant and variable 4
      {
        l: "-(-n1*n2)",
        r: "(n1*n2)"
      },
      // Unary propagation
      {
        l: "-(n1*n2)",
        r: "(-n1*n2)"
      },
      // Unary propagation
      {
        l: "-(-n1+n2)",
        r: "(n1-n2)"
      },
      // Unary propagation
      {
        l: "-(n1+n2)",
        r: "(-n1-n2)"
      },
      // Unary propagation
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      },
      // Power to Power
      {
        l: "-(-n1/n2)",
        r: "(n1/n2)"
      },
      // Division and Unary
      {
        l: "-(n1/n2)",
        r: "(-n1/n2)"
      }
    ];
    var rulesDistrDiv = [
      {
        l: "(n1/n2 + n3/n4)",
        r: "((n1*n4 + n3*n2)/(n2*n4))"
      },
      // Sum of fractions
      {
        l: "(n1/n2 + n3)",
        r: "((n1 + n3*n2)/n2)"
      },
      // Sum fraction with number 1
      {
        l: "(n1 + n2/n3)",
        r: "((n1*n3 + n2)/n3)"
      }
    ];
    var rulesSucDiv = [
      {
        l: "(n1/(n2/n3))",
        r: "((n1*n3)/n2)"
      },
      // Division simplification
      {
        l: "(n1/n2/n3)",
        r: "(n1/(n2*n3))"
      }
    ];
    var setRules = {};
    setRules.firstRules = oldRules.concat(rulesFirst, rulesSucDiv);
    setRules.distrDivRules = rulesDistrDiv;
    setRules.sucDivRules = rulesSucDiv;
    setRules.firstRulesAgain = oldRules.concat(rulesFirst);
    setRules.finalRules = [
      simplifyCore2,
      // simplify.rules[0]
      {
        l: "n*-n",
        r: "-n^2"
      },
      // Joining multiply with power 1
      {
        l: "n*n",
        r: "n^2"
      },
      // Joining multiply with power 2
      simplifyConstant2,
      // simplify.rules[14] old 3rd index in oldRules
      {
        l: "n*-n^n1",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 3
      {
        l: "n*n^n1",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 4
      {
        l: "n^n1*-n^n2",
        r: "-n^(n1+n2)"
      },
      // Joining multiply with power 5
      {
        l: "n^n1*n^n2",
        r: "n^(n1+n2)"
      },
      // Joining multiply with power 6
      {
        l: "n^n1*-n",
        r: "-n^(n1+1)"
      },
      // Joining multiply with power 7
      {
        l: "n^n1*n",
        r: "n^(n1+1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/-n",
        r: "-n^(n1-1)"
      },
      // Joining multiply with power 8
      {
        l: "n^n1/n",
        r: "n^(n1-1)"
      },
      // Joining division with power 1
      {
        l: "n/-n^n1",
        r: "-n^(1-n1)"
      },
      // Joining division with power 2
      {
        l: "n/n^n1",
        r: "n^(1-n1)"
      },
      // Joining division with power 3
      {
        l: "n^n1/-n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 4
      {
        l: "n^n1/n^n2",
        r: "n^(n1-n2)"
      },
      // Joining division with power 5
      {
        l: "n1+(-n2*n3)",
        r: "n1-n2*n3"
      },
      // Solving useless parenthesis 1
      {
        l: "v*(-c)",
        r: "-c*v"
      },
      // Solving useless unary 2
      {
        l: "n1+-n2",
        r: "n1-n2"
      },
      // Solving +- together (new!)
      {
        l: "v*c",
        r: "c*v"
      },
      // inversion constant with variable
      {
        l: "(n1^n2)^n3",
        r: "(n1^(n2*n3))"
      }
      // Power to Power
    ];
    return setRules;
  }
  function expandPower(node, parent, indParent) {
    var tp = node.type;
    var internal = arguments.length > 1;
    if (tp === "OperatorNode" && node.isBinary()) {
      var does = false;
      var val;
      if (node.op === "^") {
        if ((node.args[0].type === "ParenthesisNode" || node.args[0].type === "OperatorNode") && node.args[1].type === "ConstantNode") {
          val = parseFloat(node.args[1].value);
          does = val >= 2 && isInteger$1(val);
        }
      }
      if (does) {
        if (val > 2) {
          var nEsqTopo = node.args[0];
          var nDirTopo = new OperatorNode2("^", "pow", [node.args[0].cloneDeep(), new ConstantNode2(val - 1)]);
          node = new OperatorNode2("*", "multiply", [nEsqTopo, nDirTopo]);
        } else {
          node = new OperatorNode2("*", "multiply", [node.args[0], node.args[0].cloneDeep()]);
        }
        if (internal) {
          if (indParent === "content") {
            parent.content = node;
          } else {
            parent.args[indParent] = node;
          }
        }
      }
    }
    if (tp === "ParenthesisNode") {
      expandPower(node.content, node, "content");
    } else if (tp !== "ConstantNode" && tp !== "SymbolNode") {
      for (var i2 = 0; i2 < node.args.length; i2++) {
        expandPower(node.args[i2], node, i2);
      }
    }
    if (!internal) {
      return node;
    }
  }
  function polyToCanonical(node, coefficients) {
    if (coefficients === void 0) {
      coefficients = [];
    }
    coefficients[0] = 0;
    var o = {};
    o.cte = 1;
    o.oper = "+";
    o.fire = "";
    var maxExpo = 0;
    var varname = "";
    recurPol(node, null, o);
    maxExpo = coefficients.length - 1;
    var first = true;
    var no;
    for (var i2 = maxExpo; i2 >= 0; i2--) {
      if (coefficients[i2] === 0)
        continue;
      var n12 = new ConstantNode2(first ? coefficients[i2] : Math.abs(coefficients[i2]));
      var op = coefficients[i2] < 0 ? "-" : "+";
      if (i2 > 0) {
        var n22 = new SymbolNode2(varname);
        if (i2 > 1) {
          var n3 = new ConstantNode2(i2);
          n22 = new OperatorNode2("^", "pow", [n22, n3]);
        }
        if (coefficients[i2] === -1 && first) {
          n12 = new OperatorNode2("-", "unaryMinus", [n22]);
        } else if (Math.abs(coefficients[i2]) === 1) {
          n12 = n22;
        } else {
          n12 = new OperatorNode2("*", "multiply", [n12, n22]);
        }
      }
      if (first) {
        no = n12;
      } else if (op === "+") {
        no = new OperatorNode2("+", "add", [no, n12]);
      } else {
        no = new OperatorNode2("-", "subtract", [no, n12]);
      }
      first = false;
    }
    if (first) {
      return new ConstantNode2(0);
    } else {
      return no;
    }
    function recurPol(node2, noPai, o2) {
      var tp = node2.type;
      if (tp === "FunctionNode") {
        throw new Error("There is an unsolved function call");
      } else if (tp === "OperatorNode") {
        if ("+-*^".indexOf(node2.op) === -1)
          throw new Error("Operator " + node2.op + " invalid");
        if (noPai !== null) {
          if ((node2.fn === "unaryMinus" || node2.fn === "pow") && noPai.fn !== "add" && noPai.fn !== "subtract" && noPai.fn !== "multiply") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "multiply") && noPai.fn !== "add" && noPai.fn !== "subtract") {
            throw new Error("Invalid " + node2.op + " placing");
          }
          if ((node2.fn === "subtract" || node2.fn === "add" || node2.fn === "unaryMinus") && o2.noFil !== 0) {
            throw new Error("Invalid " + node2.op + " placing");
          }
        }
        if (node2.op === "^" || node2.op === "*") {
          o2.fire = node2.op;
        }
        for (var _i = 0; _i < node2.args.length; _i++) {
          if (node2.fn === "unaryMinus")
            o2.oper = "-";
          if (node2.op === "+" || node2.fn === "subtract") {
            o2.fire = "";
            o2.cte = 1;
            o2.oper = _i === 0 ? "+" : node2.op;
          }
          o2.noFil = _i;
          recurPol(node2.args[_i], node2, o2);
        }
      } else if (tp === "SymbolNode") {
        if (node2.name !== varname && varname !== "") {
          throw new Error("There is more than one variable");
        }
        varname = node2.name;
        if (noPai === null) {
          coefficients[1] = 1;
          return;
        }
        if (noPai.op === "^" && o2.noFil !== 0) {
          throw new Error("In power the variable should be the first parameter");
        }
        if (noPai.op === "*" && o2.noFil !== 1) {
          throw new Error("In multiply the variable should be the second parameter");
        }
        if (o2.fire === "" || o2.fire === "*") {
          if (maxExpo < 1)
            coefficients[1] = 0;
          coefficients[1] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(1, maxExpo);
        }
      } else if (tp === "ConstantNode") {
        var valor = parseFloat(node2.value);
        if (noPai === null) {
          coefficients[0] = valor;
          return;
        }
        if (noPai.op === "^") {
          if (o2.noFil !== 1)
            throw new Error("Constant cannot be powered");
          if (!isInteger$1(valor) || valor <= 0) {
            throw new Error("Non-integer exponent is not allowed");
          }
          for (var _i2 = maxExpo + 1; _i2 < valor; _i2++)
            coefficients[_i2] = 0;
          if (valor > maxExpo)
            coefficients[valor] = 0;
          coefficients[valor] += o2.cte * (o2.oper === "+" ? 1 : -1);
          maxExpo = Math.max(valor, maxExpo);
          return;
        }
        o2.cte = valor;
        if (o2.fire === "") {
          coefficients[0] += o2.cte * (o2.oper === "+" ? 1 : -1);
        }
      } else {
        throw new Error("Type " + tp + " is not allowed");
      }
    }
  }
});
var name$r = "zpk2tf";
var dependencies$r = ["typed", "add", "multiply", "Complex", "number"];
var createZpk2tf = /* @__PURE__ */ factory(name$r, dependencies$r, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    multiply: multiply2,
    Complex: Complex2,
    number: number2
  } = _ref;
  return typed2(name$r, {
    "Array,Array,number": function ArrayArrayNumber(z, p, k) {
      return _zpk2tf(z, p, k);
    },
    "Array,Array": function ArrayArray(z, p) {
      return _zpk2tf(z, p, 1);
    },
    "Matrix,Matrix,number": function MatrixMatrixNumber(z, p, k) {
      return _zpk2tf(z.valueOf(), p.valueOf(), k);
    },
    "Matrix,Matrix": function MatrixMatrix(z, p) {
      return _zpk2tf(z.valueOf(), p.valueOf(), 1);
    }
  });
  function _zpk2tf(z, p, k) {
    if (z.some((el) => el.type === "BigNumber")) {
      z = z.map((el) => number2(el));
    }
    if (p.some((el) => el.type === "BigNumber")) {
      p = p.map((el) => number2(el));
    }
    var num = [Complex2(1, 0)];
    var den = [Complex2(1, 0)];
    for (var i2 = 0; i2 < z.length; i2++) {
      var zero = z[i2];
      if (typeof zero === "number")
        zero = Complex2(zero, 0);
      num = _multiply(num, [Complex2(1, 0), Complex2(-zero.re, -zero.im)]);
    }
    for (var _i = 0; _i < p.length; _i++) {
      var pole = p[_i];
      if (typeof pole === "number")
        pole = Complex2(pole, 0);
      den = _multiply(den, [Complex2(1, 0), Complex2(-pole.re, -pole.im)]);
    }
    for (var _i2 = 0; _i2 < num.length; _i2++) {
      num[_i2] = multiply2(num[_i2], k);
    }
    return [num, den];
  }
  function _multiply(a, b) {
    var c = [];
    for (var i2 = 0; i2 < a.length + b.length - 1; i2++) {
      c[i2] = Complex2(0, 0);
      for (var j = 0; j < a.length; j++) {
        if (i2 - j >= 0 && i2 - j < b.length) {
          c[i2] = add2(c[i2], multiply2(a[j], b[i2 - j]));
        }
      }
    }
    return c;
  }
});
var name$q = "freqz";
var dependencies$q = ["typed", "add", "multiply", "Complex", "divide", "matrix"];
var createFreqz = /* @__PURE__ */ factory(name$q, dependencies$q, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    multiply: multiply2,
    Complex: Complex2,
    divide: divide2,
    matrix: matrix2
  } = _ref;
  return typed2(name$q, {
    "Array, Array": function ArrayArray(b, a) {
      var w = createBins(512);
      return _freqz(b, a, w);
    },
    "Array, Array, Array": function ArrayArrayArray(b, a, w) {
      return _freqz(b, a, w);
    },
    "Array, Array, number": function ArrayArrayNumber(b, a, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var w2 = createBins(w);
      return _freqz(b, a, w2);
    },
    "Matrix, Matrix": function MatrixMatrix(b, a) {
      var _w = createBins(512);
      var {
        w,
        h
      } = _freqz(b.valueOf(), a.valueOf(), _w);
      return {
        w: matrix2(w),
        h: matrix2(h)
      };
    },
    "Matrix, Matrix, Matrix": function MatrixMatrixMatrix(b, a, w) {
      var {
        h
      } = _freqz(b.valueOf(), a.valueOf(), w.valueOf());
      return {
        h: matrix2(h),
        w: matrix2(w)
      };
    },
    "Matrix, Matrix, number": function MatrixMatrixNumber(b, a, w) {
      if (w < 0) {
        throw new Error("w must be a positive number");
      }
      var _w = createBins(w);
      var {
        h
      } = _freqz(b.valueOf(), a.valueOf(), _w);
      return {
        h: matrix2(h),
        w: matrix2(_w)
      };
    }
  });
  function _freqz(b, a, w) {
    var num = [];
    var den = [];
    for (var i2 = 0; i2 < w.length; i2++) {
      var sumNum = Complex2(0, 0);
      var sumDen = Complex2(0, 0);
      for (var j = 0; j < b.length; j++) {
        sumNum = add2(sumNum, multiply2(b[j], Complex2(Math.cos(-j * w[i2]), Math.sin(-j * w[i2]))));
      }
      for (var _j = 0; _j < a.length; _j++) {
        sumDen = add2(sumDen, multiply2(a[_j], Complex2(Math.cos(-_j * w[i2]), Math.sin(-_j * w[i2]))));
      }
      num.push(sumNum);
      den.push(sumDen);
    }
    var h = [];
    for (var _i = 0; _i < num.length; _i++) {
      h.push(divide2(num[_i], den[_i]));
    }
    return {
      h,
      w
    };
  }
  function createBins(n) {
    var bins = [];
    for (var i2 = 0; i2 < n; i2++) {
      bins.push(i2 / n * Math.PI);
    }
    return bins;
  }
});
var name$p = "reviver";
var dependencies$p = ["classes"];
var createReviver = /* @__PURE__ */ factory(name$p, dependencies$p, (_ref) => {
  var {
    classes: classes2
  } = _ref;
  return function reviver2(key, value) {
    var constructor = classes2[value && value.mathjs];
    if (constructor && typeof constructor.fromJSON === "function") {
      return constructor.fromJSON(value);
    }
    return value;
  };
});
var name$o = "replacer";
var dependencies$o = [];
var createReplacer = /* @__PURE__ */ factory(name$o, dependencies$o, () => {
  return function replacer2(key, value) {
    if (typeof value === "number" && (!isFinite(value) || isNaN(value))) {
      return {
        mathjs: "number",
        value: String(value)
      };
    }
    return value;
  };
});
var version$1 = "12.4.2";
var createTrue = /* @__PURE__ */ factory("true", [], () => true);
var createFalse = /* @__PURE__ */ factory("false", [], () => false);
var createNull = /* @__PURE__ */ factory("null", [], () => null);
var createInfinity = /* @__PURE__ */ recreateFactory("Infinity", ["config", "?BigNumber"], (_ref) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref;
  return config3.number === "BigNumber" ? new BigNumber2(Infinity) : Infinity;
});
var createNaN = /* @__PURE__ */ recreateFactory("NaN", ["config", "?BigNumber"], (_ref2) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref2;
  return config3.number === "BigNumber" ? new BigNumber2(NaN) : NaN;
});
var createPi = /* @__PURE__ */ recreateFactory("pi", ["config", "?BigNumber"], (_ref3) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref3;
  return config3.number === "BigNumber" ? createBigNumberPi(BigNumber2) : pi$1;
});
var createTau = /* @__PURE__ */ recreateFactory("tau", ["config", "?BigNumber"], (_ref4) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref4;
  return config3.number === "BigNumber" ? createBigNumberTau(BigNumber2) : tau$1;
});
var createE = /* @__PURE__ */ recreateFactory("e", ["config", "?BigNumber"], (_ref5) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref5;
  return config3.number === "BigNumber" ? createBigNumberE(BigNumber2) : e$1;
});
var createPhi = /* @__PURE__ */ recreateFactory("phi", ["config", "?BigNumber"], (_ref6) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref6;
  return config3.number === "BigNumber" ? createBigNumberPhi(BigNumber2) : phi$1;
});
var createLN2 = /* @__PURE__ */ recreateFactory("LN2", ["config", "?BigNumber"], (_ref7) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref7;
  return config3.number === "BigNumber" ? new BigNumber2(2).ln() : Math.LN2;
});
var createLN10 = /* @__PURE__ */ recreateFactory("LN10", ["config", "?BigNumber"], (_ref8) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref8;
  return config3.number === "BigNumber" ? new BigNumber2(10).ln() : Math.LN10;
});
var createLOG2E = /* @__PURE__ */ recreateFactory("LOG2E", ["config", "?BigNumber"], (_ref9) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref9;
  return config3.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(2).ln()) : Math.LOG2E;
});
var createLOG10E = /* @__PURE__ */ recreateFactory("LOG10E", ["config", "?BigNumber"], (_ref10) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref10;
  return config3.number === "BigNumber" ? new BigNumber2(1).div(new BigNumber2(10).ln()) : Math.LOG10E;
});
var createSQRT1_2 = /* @__PURE__ */ recreateFactory(
  // eslint-disable-line camelcase
  "SQRT1_2",
  ["config", "?BigNumber"],
  (_ref11) => {
    var {
      config: config3,
      BigNumber: BigNumber2
    } = _ref11;
    return config3.number === "BigNumber" ? new BigNumber2("0.5").sqrt() : Math.SQRT1_2;
  }
);
var createSQRT2 = /* @__PURE__ */ recreateFactory("SQRT2", ["config", "?BigNumber"], (_ref12) => {
  var {
    config: config3,
    BigNumber: BigNumber2
  } = _ref12;
  return config3.number === "BigNumber" ? new BigNumber2(2).sqrt() : Math.SQRT2;
});
var createI = /* @__PURE__ */ recreateFactory("i", ["Complex"], (_ref13) => {
  var {
    Complex: Complex2
  } = _ref13;
  return Complex2.I;
});
var createVersion = /* @__PURE__ */ factory("version", [], () => version$1);
function recreateFactory(name2, dependencies2, create2) {
  return factory(name2, dependencies2, create2, {
    recreateOnConfigChange: true
  });
}
var createSpeedOfLight = /* @__PURE__ */ unitFactory("speedOfLight", "299792458", "m s^-1");
var createGravitationConstant = /* @__PURE__ */ unitFactory("gravitationConstant", "6.67430e-11", "m^3 kg^-1 s^-2");
var createPlanckConstant = /* @__PURE__ */ unitFactory("planckConstant", "6.62607015e-34", "J s");
var createReducedPlanckConstant = /* @__PURE__ */ unitFactory("reducedPlanckConstant", "1.0545718176461565e-34", "J s");
var createMagneticConstant = /* @__PURE__ */ unitFactory("magneticConstant", "1.25663706212e-6", "N A^-2");
var createElectricConstant = /* @__PURE__ */ unitFactory("electricConstant", "8.8541878128e-12", "F m^-1");
var createVacuumImpedance = /* @__PURE__ */ unitFactory("vacuumImpedance", "376.730313667", "ohm");
var createCoulomb = /* @__PURE__ */ unitFactory("coulomb", "8.987551792261171e9", "N m^2 C^-2");
var createElementaryCharge = /* @__PURE__ */ unitFactory("elementaryCharge", "1.602176634e-19", "C");
var createBohrMagneton = /* @__PURE__ */ unitFactory("bohrMagneton", "9.2740100783e-24", "J T^-1");
var createConductanceQuantum = /* @__PURE__ */ unitFactory("conductanceQuantum", "7.748091729863649e-5", "S");
var createInverseConductanceQuantum = /* @__PURE__ */ unitFactory("inverseConductanceQuantum", "12906.403729652257", "ohm");
var createMagneticFluxQuantum = /* @__PURE__ */ unitFactory("magneticFluxQuantum", "2.0678338484619295e-15", "Wb");
var createNuclearMagneton = /* @__PURE__ */ unitFactory("nuclearMagneton", "5.0507837461e-27", "J T^-1");
var createKlitzing = /* @__PURE__ */ unitFactory("klitzing", "25812.807459304513", "ohm");
var createBohrRadius = /* @__PURE__ */ unitFactory("bohrRadius", "5.29177210903e-11", "m");
var createClassicalElectronRadius = /* @__PURE__ */ unitFactory("classicalElectronRadius", "2.8179403262e-15", "m");
var createElectronMass = /* @__PURE__ */ unitFactory("electronMass", "9.1093837015e-31", "kg");
var createFermiCoupling = /* @__PURE__ */ unitFactory("fermiCoupling", "1.1663787e-5", "GeV^-2");
var createFineStructure = numberFactory("fineStructure", 0.0072973525693);
var createHartreeEnergy = /* @__PURE__ */ unitFactory("hartreeEnergy", "4.3597447222071e-18", "J");
var createProtonMass = /* @__PURE__ */ unitFactory("protonMass", "1.67262192369e-27", "kg");
var createDeuteronMass = /* @__PURE__ */ unitFactory("deuteronMass", "3.3435830926e-27", "kg");
var createNeutronMass = /* @__PURE__ */ unitFactory("neutronMass", "1.6749271613e-27", "kg");
var createQuantumOfCirculation = /* @__PURE__ */ unitFactory("quantumOfCirculation", "3.6369475516e-4", "m^2 s^-1");
var createRydberg = /* @__PURE__ */ unitFactory("rydberg", "10973731.568160", "m^-1");
var createThomsonCrossSection = /* @__PURE__ */ unitFactory("thomsonCrossSection", "6.6524587321e-29", "m^2");
var createWeakMixingAngle = numberFactory("weakMixingAngle", 0.2229);
var createEfimovFactor = numberFactory("efimovFactor", 22.7);
var createAtomicMass = /* @__PURE__ */ unitFactory("atomicMass", "1.66053906660e-27", "kg");
var createAvogadro = /* @__PURE__ */ unitFactory("avogadro", "6.02214076e23", "mol^-1");
var createBoltzmann = /* @__PURE__ */ unitFactory("boltzmann", "1.380649e-23", "J K^-1");
var createFaraday = /* @__PURE__ */ unitFactory("faraday", "96485.33212331001", "C mol^-1");
var createFirstRadiation = /* @__PURE__ */ unitFactory("firstRadiation", "3.7417718521927573e-16", "W m^2");
var createLoschmidt = /* @__PURE__ */ unitFactory("loschmidt", "2.686780111798444e25", "m^-3");
var createGasConstant = /* @__PURE__ */ unitFactory("gasConstant", "8.31446261815324", "J K^-1 mol^-1");
var createMolarPlanckConstant = /* @__PURE__ */ unitFactory("molarPlanckConstant", "3.990312712893431e-10", "J s mol^-1");
var createMolarVolume = /* @__PURE__ */ unitFactory("molarVolume", "0.022413969545014137", "m^3 mol^-1");
var createSackurTetrode = numberFactory("sackurTetrode", -1.16487052358);
var createSecondRadiation = /* @__PURE__ */ unitFactory("secondRadiation", "0.014387768775039337", "m K");
var createStefanBoltzmann = /* @__PURE__ */ unitFactory("stefanBoltzmann", "5.67037441918443e-8", "W m^-2 K^-4");
var createWienDisplacement = /* @__PURE__ */ unitFactory("wienDisplacement", "2.897771955e-3", "m K");
var createMolarMass = /* @__PURE__ */ unitFactory("molarMass", "0.99999999965e-3", "kg mol^-1");
var createMolarMassC12 = /* @__PURE__ */ unitFactory("molarMassC12", "11.9999999958e-3", "kg mol^-1");
var createGravity = /* @__PURE__ */ unitFactory("gravity", "9.80665", "m s^-2");
var createPlanckLength = /* @__PURE__ */ unitFactory("planckLength", "1.616255e-35", "m");
var createPlanckMass = /* @__PURE__ */ unitFactory("planckMass", "2.176435e-8", "kg");
var createPlanckTime = /* @__PURE__ */ unitFactory("planckTime", "5.391245e-44", "s");
var createPlanckCharge = /* @__PURE__ */ unitFactory("planckCharge", "1.87554603778e-18", "C");
var createPlanckTemperature = /* @__PURE__ */ unitFactory("planckTemperature", "1.416785e+32", "K");
function unitFactory(name2, valueStr, unitStr) {
  var dependencies2 = ["config", "Unit", "BigNumber"];
  return factory(name2, dependencies2, (_ref) => {
    var {
      config: config3,
      Unit: Unit2,
      BigNumber: BigNumber2
    } = _ref;
    var value = config3.number === "BigNumber" ? new BigNumber2(valueStr) : parseFloat(valueStr);
    var unit2 = new Unit2(value, unitStr);
    unit2.fixPrefix = true;
    return unit2;
  });
}
function numberFactory(name2, value) {
  var dependencies2 = ["config", "BigNumber"];
  return factory(name2, dependencies2, (_ref2) => {
    var {
      config: config3,
      BigNumber: BigNumber2
    } = _ref2;
    return config3.number === "BigNumber" ? new BigNumber2(value) : value;
  });
}
var name$n = "apply";
var dependencies$n = ["typed", "isInteger"];
var createApplyTransform = /* @__PURE__ */ factory(name$n, dependencies$n, (_ref) => {
  var {
    typed: typed2,
    isInteger: isInteger2
  } = _ref;
  var apply2 = createApply({
    typed: typed2,
    isInteger: isInteger2
  });
  return typed2("apply", {
    "...any": function any(args) {
      var dim = args[1];
      if (isNumber(dim)) {
        args[1] = dim - 1;
      } else if (isBigNumber(dim)) {
        args[1] = dim.minus(1);
      }
      try {
        return apply2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$m = "column";
var dependencies$m = ["typed", "Index", "matrix", "range"];
var createColumnTransform = /* @__PURE__ */ factory(name$m, dependencies$m, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var column2 = createColumn({
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed2("column", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return column2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
function compileInlineExpression(expression, math2, scope) {
  var symbol = expression.filter(function(node) {
    return isSymbolNode(node) && !(node.name in math2) && !scope.has(node.name);
  })[0];
  if (!symbol) {
    throw new Error('No undefined variable found in inline expression "' + expression + '"');
  }
  var name2 = symbol.name;
  var argsScope = /* @__PURE__ */ new Map();
  var subScope = new PartitionedMap(scope, argsScope, /* @__PURE__ */ new Set([name2]));
  var eq = expression.compile();
  return function inlineExpression(x) {
    argsScope.set(name2, x);
    return eq.evaluate(subScope);
  };
}
var name$l = "filter";
var dependencies$l = ["typed"];
var createFilterTransform = /* @__PURE__ */ factory(name$l, dependencies$l, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function filterTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return filter2(x, callback);
  }
  filterTransform.rawArgs = true;
  var filter2 = typed2("filter", {
    "Array, function": _filter,
    "Matrix, function": function MatrixFunction(x, test) {
      return x.create(_filter(x.toArray(), test));
    },
    "Array, RegExp": filterRegExp,
    "Matrix, RegExp": function MatrixRegExp(x, test) {
      return x.create(filterRegExp(x.toArray(), test));
    }
  });
  return filterTransform;
}, {
  isTransformFunction: true
});
function _filter(x, callback) {
  return filter$1(x, function(value, index2, array) {
    return applyCallback(callback, value, [index2 + 1], array, "filter");
  });
}
var name$k = "forEach";
var dependencies$k = ["typed"];
var createForEachTransform = /* @__PURE__ */ factory(name$k, dependencies$k, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function forEachTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return _forEach2(x, callback);
  }
  forEachTransform.rawArgs = true;
  var _forEach2 = typed2("forEach", {
    "Array | Matrix, function": function ArrayMatrixFunction(array, callback) {
      var recurse = function recurse2(value, index2) {
        if (Array.isArray(value)) {
          forEach$1(value, function(child, i2) {
            recurse2(child, index2.concat(i2 + 1));
          });
        } else {
          return applyCallback(callback, value, index2, array, "forEach");
        }
      };
      recurse(array.valueOf(), []);
    }
  });
  return forEachTransform;
}, {
  isTransformFunction: true
});
var name$j = "index";
var dependencies$j = ["Index", "getMatrixDataType"];
var createIndexTransform = /* @__PURE__ */ factory(name$j, dependencies$j, (_ref) => {
  var {
    Index: Index2,
    getMatrixDataType: getMatrixDataType2
  } = _ref;
  return function indexTransform() {
    var args = [];
    for (var i2 = 0, ii = arguments.length; i2 < ii; i2++) {
      var arg2 = arguments[i2];
      if (isRange(arg2)) {
        arg2.start--;
        arg2.end -= arg2.step > 0 ? 0 : 2;
      } else if (arg2 && arg2.isSet === true) {
        arg2 = arg2.map(function(v) {
          return v - 1;
        });
      } else if (isArray(arg2) || isMatrix(arg2)) {
        if (getMatrixDataType2(arg2) !== "boolean") {
          arg2 = arg2.map(function(v) {
            return v - 1;
          });
        }
      } else if (isNumber(arg2)) {
        arg2--;
      } else if (isBigNumber(arg2)) {
        arg2 = arg2.toNumber() - 1;
      } else if (typeof arg2 === "string")
        ;
      else {
        throw new TypeError("Dimension must be an Array, Matrix, number, string, or Range");
      }
      args[i2] = arg2;
    }
    var res = new Index2();
    Index2.apply(res, args);
    return res;
  };
}, {
  isTransformFunction: true
});
var name$i = "map";
var dependencies$i = ["typed"];
var createMapTransform = /* @__PURE__ */ factory(name$i, dependencies$i, (_ref) => {
  var {
    typed: typed2
  } = _ref;
  function mapTransform(args, math2, scope) {
    var x, callback;
    if (args[0]) {
      x = args[0].compile().evaluate(scope);
    }
    if (args[1]) {
      if (isSymbolNode(args[1]) || isFunctionAssignmentNode(args[1])) {
        callback = args[1].compile().evaluate(scope);
      } else {
        callback = compileInlineExpression(args[1], math2, scope);
      }
    }
    return map2(x, callback);
  }
  mapTransform.rawArgs = true;
  var map2 = typed2("map", {
    "Array, function": function ArrayFunction(x, callback) {
      return _map(x, callback, x);
    },
    "Matrix, function": function MatrixFunction(x, callback) {
      return x.create(_map(x.valueOf(), callback, x));
    }
  });
  return mapTransform;
}, {
  isTransformFunction: true
});
function _map(array, callback, orig) {
  function recurse(value, index2) {
    if (Array.isArray(value)) {
      return map$1(value, function(child, i2) {
        return recurse(child, index2.concat(i2 + 1));
      });
    } else {
      return applyCallback(callback, value, index2, orig, "map");
    }
  }
  return recurse(array, []);
}
function lastDimToZeroBase(args) {
  if (args.length === 2 && isCollection(args[0])) {
    args = args.slice();
    var dim = args[1];
    if (isNumber(dim)) {
      args[1] = dim - 1;
    } else if (isBigNumber(dim)) {
      args[1] = dim.minus(1);
    }
  }
  return args;
}
var name$h = "max";
var dependencies$h = ["typed", "config", "numeric", "larger"];
var createMaxTransform = /* @__PURE__ */ factory(name$h, dependencies$h, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    numeric: numeric3,
    larger: larger2
  } = _ref;
  var max2 = createMax({
    typed: typed2,
    config: config3,
    numeric: numeric3,
    larger: larger2
  });
  return typed2("max", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return max2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$g = "mean";
var dependencies$g = ["typed", "add", "divide"];
var createMeanTransform = /* @__PURE__ */ factory(name$g, dependencies$g, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    divide: divide2
  } = _ref;
  var mean2 = createMean({
    typed: typed2,
    add: add2,
    divide: divide2
  });
  return typed2("mean", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return mean2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$f = "min";
var dependencies$f = ["typed", "config", "numeric", "smaller"];
var createMinTransform = /* @__PURE__ */ factory(name$f, dependencies$f, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    numeric: numeric3,
    smaller: smaller2
  } = _ref;
  var min2 = createMin({
    typed: typed2,
    config: config3,
    numeric: numeric3,
    smaller: smaller2
  });
  return typed2("min", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return min2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$e = "range";
var dependencies$e = ["typed", "config", "?matrix", "?bignumber", "smaller", "smallerEq", "larger", "largerEq", "add", "isPositive"];
var createRangeTransform = /* @__PURE__ */ factory(name$e, dependencies$e, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2,
    add: add2,
    isPositive: isPositive2
  } = _ref;
  var range2 = createRange({
    typed: typed2,
    config: config3,
    matrix: matrix2,
    bignumber: bignumber2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2,
    largerEq: largerEq2,
    add: add2,
    isPositive: isPositive2
  });
  return typed2("range", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (typeof last !== "boolean") {
        args.push(true);
      }
      return range2.apply(null, args);
    }
  });
}, {
  isTransformFunction: true
});
var name$d = "row";
var dependencies$d = ["typed", "Index", "matrix", "range"];
var createRowTransform = /* @__PURE__ */ factory(name$d, dependencies$d, (_ref) => {
  var {
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  } = _ref;
  var row2 = createRow({
    typed: typed2,
    Index: Index2,
    matrix: matrix2,
    range: range2
  });
  return typed2("row", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      }
      try {
        return row2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$c = "subset";
var dependencies$c = ["typed", "matrix", "zeros", "add"];
var createSubsetTransform = /* @__PURE__ */ factory(name$c, dependencies$c, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  } = _ref;
  var subset2 = createSubset({
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  });
  return typed2("subset", {
    "...any": function any(args) {
      try {
        return subset2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$b = "concat";
var dependencies$b = ["typed", "matrix", "isInteger"];
var createConcatTransform = /* @__PURE__ */ factory(name$b, dependencies$b, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger2
  } = _ref;
  var concat2 = createConcat({
    typed: typed2,
    matrix: matrix2,
    isInteger: isInteger2
  });
  return typed2("concat", {
    "...any": function any(args) {
      var lastIndex = args.length - 1;
      var last = args[lastIndex];
      if (isNumber(last)) {
        args[lastIndex] = last - 1;
      } else if (isBigNumber(last)) {
        args[lastIndex] = last.minus(1);
      }
      try {
        return concat2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$a = "diff";
var dependencies$a = ["typed", "matrix", "subtract", "number", "bignumber"];
var createDiffTransform = /* @__PURE__ */ factory(name$a, dependencies$a, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  } = _ref;
  var diff2 = createDiff({
    typed: typed2,
    matrix: matrix2,
    subtract: subtract2,
    number: number2,
    bignumber: bignumber2
  });
  return typed2(name$a, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return diff2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$9 = "std";
var dependencies$9 = ["typed", "map", "sqrt", "variance"];
var createStdTransform = /* @__PURE__ */ factory(name$9, dependencies$9, (_ref) => {
  var {
    typed: typed2,
    map: map2,
    sqrt: sqrt2,
    variance: variance2
  } = _ref;
  var std2 = createStd({
    typed: typed2,
    map: map2,
    sqrt: sqrt2,
    variance: variance2
  });
  return typed2("std", {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return std2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$8 = "sum";
var dependencies$8 = ["typed", "config", "add", "numeric"];
var createSumTransform = /* @__PURE__ */ factory(name$8, dependencies$8, (_ref) => {
  var {
    typed: typed2,
    config: config3,
    add: add2,
    numeric: numeric3
  } = _ref;
  var sum2 = createSum({
    typed: typed2,
    config: config3,
    add: add2,
    numeric: numeric3
  });
  return typed2(name$8, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return sum2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$7 = "quantileSeq";
var dependencies$7 = ["typed", "bignumber", "add", "subtract", "divide", "multiply", "partitionSelect", "compare", "isInteger", "smaller", "smallerEq", "larger"];
var createQuantileSeqTransform = /* @__PURE__ */ factory(name$7, dependencies$7, (_ref) => {
  var {
    typed: typed2,
    bignumber: bignumber2,
    add: add2,
    subtract: subtract2,
    divide: divide2,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2,
    isInteger: isInteger2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2
  } = _ref;
  var quantileSeq2 = createQuantileSeq({
    typed: typed2,
    bignumber: bignumber2,
    add: add2,
    subtract: subtract2,
    divide: divide2,
    multiply: multiply2,
    partitionSelect: partitionSelect2,
    compare: compare2,
    isInteger: isInteger2,
    smaller: smaller2,
    smallerEq: smallerEq2,
    larger: larger2
  });
  return typed2("quantileSeq", {
    "Array | Matrix, number | BigNumber": quantileSeq2,
    "Array | Matrix, number | BigNumber, number": (arr, prob, dim) => quantileSeq2(arr, prob, dimToZeroBase(dim)),
    "Array | Matrix, number | BigNumber, boolean": quantileSeq2,
    "Array | Matrix, number | BigNumber, boolean, number": (arr, prob, sorted, dim) => quantileSeq2(arr, prob, sorted, dimToZeroBase(dim)),
    "Array | Matrix, Array | Matrix": quantileSeq2,
    "Array | Matrix, Array | Matrix, number": (data, prob, dim) => quantileSeq2(data, prob, dimToZeroBase(dim)),
    "Array | Matrix, Array | Matrix, boolean": quantileSeq2,
    "Array | Matrix, Array | Matrix, boolean, number": (data, prob, sorted, dim) => quantileSeq2(data, prob, sorted, dimToZeroBase(dim))
  });
  function dimToZeroBase(dim) {
    return lastDimToZeroBase([[], dim])[1];
  }
}, {
  isTransformFunction: true
});
var name$6 = "cumsum";
var dependencies$6 = ["typed", "add", "unaryPlus"];
var createCumSumTransform = /* @__PURE__ */ factory(name$6, dependencies$6, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    unaryPlus: unaryPlus2
  } = _ref;
  var cumsum2 = createCumSum({
    typed: typed2,
    add: add2,
    unaryPlus: unaryPlus2
  });
  return typed2(name$6, {
    "...any": function any(args) {
      if (args.length === 2 && isCollection(args[0])) {
        var dim = args[1];
        if (isNumber(dim)) {
          args[1] = dim - 1;
        } else if (isBigNumber(dim)) {
          args[1] = dim.minus(1);
        }
      }
      try {
        return cumsum2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$5 = "variance";
var dependencies$5 = ["typed", "add", "subtract", "multiply", "divide", "apply", "isNaN"];
var createVarianceTransform = /* @__PURE__ */ factory(name$5, dependencies$5, (_ref) => {
  var {
    typed: typed2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    apply: apply2,
    isNaN: isNaN2
  } = _ref;
  var variance2 = createVariance({
    typed: typed2,
    add: add2,
    subtract: subtract2,
    multiply: multiply2,
    divide: divide2,
    apply: apply2,
    isNaN: isNaN2
  });
  return typed2(name$5, {
    "...any": function any(args) {
      args = lastDimToZeroBase(args);
      try {
        return variance2.apply(null, args);
      } catch (err) {
        throw errorTransform(err);
      }
    }
  });
}, {
  isTransformFunction: true
});
var name$4 = "print";
var dependencies$4 = ["typed", "matrix", "zeros", "add"];
var createPrintTransform = /* @__PURE__ */ factory(name$4, dependencies$4, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  } = _ref;
  var print2 = createPrint({
    typed: typed2,
    matrix: matrix2,
    zeros: zeros2,
    add: add2
  });
  return typed2(name$4, {
    "string, Object | Array": function stringObjectArray(template, values) {
      return print2(_convertTemplateToZeroBasedIndex(template), values);
    },
    "string, Object | Array, number | Object": function stringObjectArrayNumberObject(template, values, options) {
      return print2(_convertTemplateToZeroBasedIndex(template), values, options);
    }
  });
  function _convertTemplateToZeroBasedIndex(template) {
    return template.replace(printTemplate, (x) => {
      var parts = x.slice(1).split(".");
      var result = parts.map(function(part) {
        if (!isNaN(part) && part.length > 0) {
          return parseInt(part) - 1;
        } else {
          return part;
        }
      });
      return "$" + result.join(".");
    });
  }
}, {
  isTransformFunction: true
});
var name$3 = "and";
var dependencies$3 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
var createAndTransform = /* @__PURE__ */ factory(name$3, dependencies$3, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat2
  } = _ref;
  var and2 = createAnd({
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat2
  });
  function andTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1) && !and2(condition1, true)) {
      return false;
    }
    var condition2 = args[1].compile().evaluate(scope);
    return and2(condition1, condition2);
  }
  andTransform.rawArgs = true;
  return andTransform;
}, {
  isTransformFunction: true
});
var name$2 = "or";
var dependencies$2 = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createOrTransform = /* @__PURE__ */ factory(name$2, dependencies$2, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var or2 = createOr({
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  });
  function orTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1) && or2(condition1, false)) {
      return true;
    }
    var condition2 = args[1].compile().evaluate(scope);
    return or2(condition1, condition2);
  }
  orTransform.rawArgs = true;
  return orTransform;
}, {
  isTransformFunction: true
});
var name$1 = "bitAnd";
var dependencies$1 = ["typed", "matrix", "zeros", "add", "equalScalar", "not", "concat"];
var createBitAndTransform = /* @__PURE__ */ factory(name$1, dependencies$1, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat2
  } = _ref;
  var bitAnd2 = createBitAnd({
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    zeros: zeros2,
    not: not2,
    concat: concat2
  });
  function bitAndTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1)) {
      if (isNaN(condition1)) {
        return NaN;
      }
      if (condition1 === 0 || condition1 === false) {
        return 0;
      }
    }
    var condition2 = args[1].compile().evaluate(scope);
    return bitAnd2(condition1, condition2);
  }
  bitAndTransform.rawArgs = true;
  return bitAndTransform;
}, {
  isTransformFunction: true
});
var name = "bitOr";
var dependencies = ["typed", "matrix", "equalScalar", "DenseMatrix", "concat"];
var createBitOrTransform = /* @__PURE__ */ factory(name, dependencies, (_ref) => {
  var {
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  } = _ref;
  var bitOr2 = createBitOr({
    typed: typed2,
    matrix: matrix2,
    equalScalar: equalScalar2,
    DenseMatrix: DenseMatrix2,
    concat: concat2
  });
  function bitOrTransform(args, math2, scope) {
    var condition1 = args[0].compile().evaluate(scope);
    if (!isCollection(condition1)) {
      if (isNaN(condition1)) {
        return NaN;
      }
      if (condition1 === -1) {
        return -1;
      }
      if (condition1 === true) {
        return 1;
      }
    }
    var condition2 = args[1].compile().evaluate(scope);
    return bitOr2(condition1, condition2);
  }
  bitOrTransform.rawArgs = true;
  return bitOrTransform;
}, {
  isTransformFunction: true
});
var BigNumber = /* @__PURE__ */ createBigNumberClass({
  config: config$1
});
var Complex = /* @__PURE__ */ createComplexClass({});
var e = /* @__PURE__ */ createE({
  BigNumber,
  config: config$1
});
var _false = /* @__PURE__ */ createFalse({});
var fineStructure = /* @__PURE__ */ createFineStructure({
  BigNumber,
  config: config$1
});
var Fraction = /* @__PURE__ */ createFractionClass({});
var i = /* @__PURE__ */ createI({
  Complex
});
var _Infinity = /* @__PURE__ */ createInfinity({
  BigNumber,
  config: config$1
});
var LN10 = /* @__PURE__ */ createLN10({
  BigNumber,
  config: config$1
});
var LOG10E = /* @__PURE__ */ createLOG10E({
  BigNumber,
  config: config$1
});
var Matrix = /* @__PURE__ */ createMatrixClass({});
var _NaN = /* @__PURE__ */ createNaN({
  BigNumber,
  config: config$1
});
var _null = /* @__PURE__ */ createNull({});
var phi = /* @__PURE__ */ createPhi({
  BigNumber,
  config: config$1
});
var Range = /* @__PURE__ */ createRangeClass({});
var ResultSet = /* @__PURE__ */ createResultSet({});
var SQRT1_2 = /* @__PURE__ */ createSQRT1_2({
  BigNumber,
  config: config$1
});
var sackurTetrode = /* @__PURE__ */ createSackurTetrode({
  BigNumber,
  config: config$1
});
var tau = /* @__PURE__ */ createTau({
  BigNumber,
  config: config$1
});
var _true = /* @__PURE__ */ createTrue({});
var version = /* @__PURE__ */ createVersion({});
var DenseMatrix = /* @__PURE__ */ createDenseMatrixClass({
  Matrix
});
var efimovFactor = /* @__PURE__ */ createEfimovFactor({
  BigNumber,
  config: config$1
});
var LN2 = /* @__PURE__ */ createLN2({
  BigNumber,
  config: config$1
});
var pi = /* @__PURE__ */ createPi({
  BigNumber,
  config: config$1
});
var replacer = /* @__PURE__ */ createReplacer({});
var SQRT2 = /* @__PURE__ */ createSQRT2({
  BigNumber,
  config: config$1
});
var typed = /* @__PURE__ */ createTyped({
  BigNumber,
  Complex,
  DenseMatrix,
  Fraction
});
var unaryPlus = /* @__PURE__ */ createUnaryPlus({
  BigNumber,
  config: config$1,
  typed
});
var weakMixingAngle = /* @__PURE__ */ createWeakMixingAngle({
  BigNumber,
  config: config$1
});
var abs = /* @__PURE__ */ createAbs({
  typed
});
var acos = /* @__PURE__ */ createAcos({
  Complex,
  config: config$1,
  typed
});
var acot = /* @__PURE__ */ createAcot({
  BigNumber,
  typed
});
var acsc = /* @__PURE__ */ createAcsc({
  BigNumber,
  Complex,
  config: config$1,
  typed
});
var addScalar = /* @__PURE__ */ createAddScalar({
  typed
});
var arg = /* @__PURE__ */ createArg({
  typed
});
var asech = /* @__PURE__ */ createAsech({
  BigNumber,
  Complex,
  config: config$1,
  typed
});
var asinh = /* @__PURE__ */ createAsinh({
  typed
});
var atan = /* @__PURE__ */ createAtan({
  typed
});
var atanh = /* @__PURE__ */ createAtanh({
  Complex,
  config: config$1,
  typed
});
var bignumber = /* @__PURE__ */ createBignumber({
  BigNumber,
  typed
});
var bitNot = /* @__PURE__ */ createBitNot({
  typed
});
var boolean = /* @__PURE__ */ createBoolean({
  typed
});
var clone = /* @__PURE__ */ createClone({
  typed
});
var combinations = /* @__PURE__ */ createCombinations({
  typed
});
var complex = /* @__PURE__ */ createComplex({
  Complex,
  typed
});
var conj = /* @__PURE__ */ createConj({
  typed
});
var cos = /* @__PURE__ */ createCos({
  typed
});
var cot = /* @__PURE__ */ createCot({
  BigNumber,
  typed
});
var csc = /* @__PURE__ */ createCsc({
  BigNumber,
  typed
});
var cube = /* @__PURE__ */ createCube({
  typed
});
var equalScalar = /* @__PURE__ */ createEqualScalar({
  config: config$1,
  typed
});
var erf = /* @__PURE__ */ createErf({
  typed
});
var exp = /* @__PURE__ */ createExp({
  typed
});
var expm12 = /* @__PURE__ */ createExpm1({
  Complex,
  typed
});
var filter = /* @__PURE__ */ createFilter({
  typed
});
var forEach = /* @__PURE__ */ createForEach({
  typed
});
var format = /* @__PURE__ */ createFormat({
  typed
});
var getMatrixDataType = /* @__PURE__ */ createGetMatrixDataType({
  typed
});
var hex = /* @__PURE__ */ createHex({
  format,
  typed
});
var im = /* @__PURE__ */ createIm({
  typed
});
var isInteger = /* @__PURE__ */ createIsInteger({
  typed
});
var isNegative = /* @__PURE__ */ createIsNegative({
  typed
});
var isPositive = /* @__PURE__ */ createIsPositive({
  typed
});
var isZero = /* @__PURE__ */ createIsZero({
  typed
});
var LOG2E = /* @__PURE__ */ createLOG2E({
  BigNumber,
  config: config$1
});
var lgamma = /* @__PURE__ */ createLgamma({
  Complex,
  typed
});
var log102 = /* @__PURE__ */ createLog10({
  Complex,
  config: config$1,
  typed
});
var log22 = /* @__PURE__ */ createLog2({
  Complex,
  config: config$1,
  typed
});
var map = /* @__PURE__ */ createMap({
  typed
});
var multiplyScalar = /* @__PURE__ */ createMultiplyScalar({
  typed
});
var not = /* @__PURE__ */ createNot({
  typed
});
var number = /* @__PURE__ */ createNumber({
  typed
});
var oct = /* @__PURE__ */ createOct({
  format,
  typed
});
var pickRandom = /* @__PURE__ */ createPickRandom({
  config: config$1,
  typed
});
var print = /* @__PURE__ */ createPrint({
  typed
});
var random = /* @__PURE__ */ createRandom({
  config: config$1,
  typed
});
var re = /* @__PURE__ */ createRe({
  typed
});
var sec = /* @__PURE__ */ createSec({
  BigNumber,
  typed
});
var sign = /* @__PURE__ */ createSign({
  BigNumber,
  Fraction,
  complex,
  typed
});
var sin = /* @__PURE__ */ createSin({
  typed
});
var SparseMatrix = /* @__PURE__ */ createSparseMatrixClass({
  Matrix,
  equalScalar,
  typed
});
var splitUnit = /* @__PURE__ */ createSplitUnit({
  typed
});
var square = /* @__PURE__ */ createSquare({
  typed
});
var string = /* @__PURE__ */ createString({
  typed
});
var subtractScalar = /* @__PURE__ */ createSubtractScalar({
  typed
});
var tan = /* @__PURE__ */ createTan({
  typed
});
var typeOf = /* @__PURE__ */ createTypeOf({
  typed
});
var acosh = /* @__PURE__ */ createAcosh({
  Complex,
  config: config$1,
  typed
});
var acsch = /* @__PURE__ */ createAcsch({
  BigNumber,
  typed
});
var apply = /* @__PURE__ */ createApply({
  isInteger,
  typed
});
var asec = /* @__PURE__ */ createAsec({
  BigNumber,
  Complex,
  config: config$1,
  typed
});
var bin = /* @__PURE__ */ createBin({
  format,
  typed
});
var combinationsWithRep = /* @__PURE__ */ createCombinationsWithRep({
  typed
});
var cosh = /* @__PURE__ */ createCosh({
  typed
});
var csch = /* @__PURE__ */ createCsch({
  BigNumber,
  typed
});
var isNaN$1 = /* @__PURE__ */ createIsNaN({
  typed
});
var isPrime = /* @__PURE__ */ createIsPrime({
  typed
});
var randomInt = /* @__PURE__ */ createRandomInt({
  config: config$1,
  typed
});
var sech = /* @__PURE__ */ createSech({
  BigNumber,
  typed
});
var sinh = /* @__PURE__ */ createSinh({
  typed
});
var sparse = /* @__PURE__ */ createSparse({
  SparseMatrix,
  typed
});
var sqrt = /* @__PURE__ */ createSqrt({
  Complex,
  config: config$1,
  typed
});
var tanh = /* @__PURE__ */ createTanh({
  typed
});
var unaryMinus = /* @__PURE__ */ createUnaryMinus({
  typed
});
var acoth = /* @__PURE__ */ createAcoth({
  BigNumber,
  Complex,
  config: config$1,
  typed
});
var coth = /* @__PURE__ */ createCoth({
  BigNumber,
  typed
});
var fraction = /* @__PURE__ */ createFraction({
  Fraction,
  typed
});
var isNumeric = /* @__PURE__ */ createIsNumeric({
  typed
});
var matrix = /* @__PURE__ */ createMatrix({
  DenseMatrix,
  Matrix,
  SparseMatrix,
  typed
});
var matrixFromFunction = /* @__PURE__ */ createMatrixFromFunction({
  isZero,
  matrix,
  typed
});
var mode = /* @__PURE__ */ createMode({
  isNaN: isNaN$1,
  isNumeric,
  typed
});
var numeric2 = /* @__PURE__ */ createNumeric({
  bignumber,
  fraction,
  number
});
var prod = /* @__PURE__ */ createProd({
  config: config$1,
  multiplyScalar,
  numeric: numeric2,
  typed
});
var reshape = /* @__PURE__ */ createReshape({
  isInteger,
  matrix,
  typed
});
var size = /* @__PURE__ */ createSize({
  matrix,
  config: config$1,
  typed
});
var squeeze = /* @__PURE__ */ createSqueeze({
  matrix,
  typed
});
var transpose = /* @__PURE__ */ createTranspose({
  matrix,
  typed
});
var xgcd = /* @__PURE__ */ createXgcd({
  BigNumber,
  config: config$1,
  matrix,
  typed
});
var zeros = /* @__PURE__ */ createZeros({
  BigNumber,
  config: config$1,
  matrix,
  typed
});
var asin = /* @__PURE__ */ createAsin({
  Complex,
  config: config$1,
  typed
});
var cbrt2 = /* @__PURE__ */ createCbrt({
  BigNumber,
  Complex,
  Fraction,
  config: config$1,
  isNegative,
  matrix,
  typed,
  unaryMinus
});
var concat = /* @__PURE__ */ createConcat({
  isInteger,
  matrix,
  typed
});
var count = /* @__PURE__ */ createCount({
  prod,
  size,
  typed
});
var ctranspose = /* @__PURE__ */ createCtranspose({
  conj,
  transpose,
  typed
});
var diag = /* @__PURE__ */ createDiag({
  DenseMatrix,
  SparseMatrix,
  matrix,
  typed
});
var divideScalar = /* @__PURE__ */ createDivideScalar({
  numeric: numeric2,
  typed
});
var dotDivide = /* @__PURE__ */ createDotDivide({
  DenseMatrix,
  concat,
  divideScalar,
  equalScalar,
  matrix,
  typed
});
var equal = /* @__PURE__ */ createEqual({
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  typed
});
var flatten = /* @__PURE__ */ createFlatten({
  matrix,
  typed
});
var hasNumericValue = /* @__PURE__ */ createHasNumericValue({
  isNumeric,
  typed
});
var identity = /* @__PURE__ */ createIdentity({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  config: config$1,
  matrix,
  typed
});
var kron = /* @__PURE__ */ createKron({
  matrix,
  multiplyScalar,
  typed
});
var largerEq = /* @__PURE__ */ createLargerEq({
  DenseMatrix,
  concat,
  config: config$1,
  matrix,
  typed
});
var leftShift = /* @__PURE__ */ createLeftShift({
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  typed,
  zeros
});
var lsolve = /* @__PURE__ */ createLsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed
});
var matrixFromColumns = /* @__PURE__ */ createMatrixFromColumns({
  flatten,
  matrix,
  size,
  typed
});
var nthRoot = /* @__PURE__ */ createNthRoot({
  BigNumber,
  concat,
  equalScalar,
  matrix,
  typed
});
var ones = /* @__PURE__ */ createOnes({
  BigNumber,
  config: config$1,
  matrix,
  typed
});
var qr = /* @__PURE__ */ createQr({
  addScalar,
  complex,
  conj,
  divideScalar,
  equal,
  identity,
  isZero,
  matrix,
  multiplyScalar,
  sign,
  sqrt,
  subtractScalar,
  typed,
  unaryMinus,
  zeros
});
var resize = /* @__PURE__ */ createResize({
  config: config$1,
  matrix
});
var rightArithShift = /* @__PURE__ */ createRightArithShift({
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  typed,
  zeros
});
var round = /* @__PURE__ */ createRound({
  BigNumber,
  DenseMatrix,
  config: config$1,
  equalScalar,
  matrix,
  typed,
  zeros
});
var smaller = /* @__PURE__ */ createSmaller({
  DenseMatrix,
  concat,
  config: config$1,
  matrix,
  typed
});
var subtract = /* @__PURE__ */ createSubtract({
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  subtractScalar,
  typed,
  unaryMinus
});
var to = /* @__PURE__ */ createTo({
  concat,
  matrix,
  typed
});
var unequal = /* @__PURE__ */ createUnequal({
  DenseMatrix,
  concat,
  config: config$1,
  equalScalar,
  matrix,
  typed
});
var usolve = /* @__PURE__ */ createUsolve({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed
});
var xor = /* @__PURE__ */ createXor({
  DenseMatrix,
  concat,
  matrix,
  typed
});
var add = /* @__PURE__ */ createAdd({
  DenseMatrix,
  SparseMatrix,
  addScalar,
  concat,
  equalScalar,
  matrix,
  typed
});
var atan2 = /* @__PURE__ */ createAtan2({
  BigNumber,
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  typed
});
var bitAnd = /* @__PURE__ */ createBitAnd({
  concat,
  equalScalar,
  matrix,
  typed
});
var bitOr = /* @__PURE__ */ createBitOr({
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  typed
});
var bitXor = /* @__PURE__ */ createBitXor({
  DenseMatrix,
  concat,
  matrix,
  typed
});
var catalan = /* @__PURE__ */ createCatalan({
  addScalar,
  combinations,
  divideScalar,
  isInteger,
  isNegative,
  multiplyScalar,
  typed
});
var compare = /* @__PURE__ */ createCompare({
  BigNumber,
  DenseMatrix,
  Fraction,
  concat,
  config: config$1,
  equalScalar,
  matrix,
  typed
});
var compareText = /* @__PURE__ */ createCompareText({
  concat,
  matrix,
  typed
});
var cumsum = /* @__PURE__ */ createCumSum({
  add,
  typed,
  unaryPlus
});
var deepEqual = /* @__PURE__ */ createDeepEqual({
  equal,
  typed
});
var diff = /* @__PURE__ */ createDiff({
  matrix,
  number,
  subtract,
  typed
});
var distance = /* @__PURE__ */ createDistance({
  abs,
  addScalar,
  deepEqual,
  divideScalar,
  multiplyScalar,
  sqrt,
  subtractScalar,
  typed
});
var dot = /* @__PURE__ */ createDot({
  addScalar,
  conj,
  multiplyScalar,
  size,
  typed
});
var equalText = /* @__PURE__ */ createEqualText({
  compareText,
  isZero,
  typed
});
var floor = /* @__PURE__ */ createFloor({
  DenseMatrix,
  config: config$1,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var gcd = /* @__PURE__ */ createGcd({
  BigNumber,
  DenseMatrix,
  concat,
  config: config$1,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var hypot = /* @__PURE__ */ createHypot({
  abs,
  addScalar,
  divideScalar,
  isPositive,
  multiplyScalar,
  smaller,
  sqrt,
  typed
});
var ImmutableDenseMatrix = /* @__PURE__ */ createImmutableDenseMatrixClass({
  DenseMatrix,
  smaller
});
var Index = /* @__PURE__ */ createIndexClass({
  ImmutableDenseMatrix,
  getMatrixDataType
});
var larger = /* @__PURE__ */ createLarger({
  DenseMatrix,
  concat,
  config: config$1,
  matrix,
  typed
});
var log = /* @__PURE__ */ createLog({
  Complex,
  config: config$1,
  divideScalar,
  typed
});
var lsolveAll = /* @__PURE__ */ createLsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed
});
var matrixFromRows = /* @__PURE__ */ createMatrixFromRows({
  flatten,
  matrix,
  size,
  typed
});
var min = /* @__PURE__ */ createMin({
  config: config$1,
  numeric: numeric2,
  smaller,
  typed
});
var mod = /* @__PURE__ */ createMod({
  DenseMatrix,
  concat,
  config: config$1,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var multiply = /* @__PURE__ */ createMultiply({
  addScalar,
  dot,
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var nthRoots = /* @__PURE__ */ createNthRoots({
  Complex,
  config: config$1,
  divideScalar,
  typed
});
var or = /* @__PURE__ */ createOr({
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  typed
});
var partitionSelect = /* @__PURE__ */ createPartitionSelect({
  compare,
  isNaN: isNaN$1,
  isNumeric,
  typed
});
var rightLogShift = /* @__PURE__ */ createRightLogShift({
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  typed,
  zeros
});
var slu = /* @__PURE__ */ createSlu({
  SparseMatrix,
  abs,
  add,
  divideScalar,
  larger,
  largerEq,
  multiply,
  subtract,
  transpose,
  typed
});
var subset = /* @__PURE__ */ createSubset({
  add,
  matrix,
  typed,
  zeros
});
var sum = /* @__PURE__ */ createSum({
  add,
  config: config$1,
  numeric: numeric2,
  typed
});
var trace = /* @__PURE__ */ createTrace({
  add,
  matrix,
  typed
});
var usolveAll = /* @__PURE__ */ createUsolveAll({
  DenseMatrix,
  divideScalar,
  equalScalar,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed
});
var zpk2tf = /* @__PURE__ */ createZpk2tf({
  Complex,
  add,
  multiply,
  number,
  typed
});
var ceil = /* @__PURE__ */ createCeil({
  DenseMatrix,
  config: config$1,
  equalScalar,
  matrix,
  round,
  typed,
  zeros
});
var compareNatural = /* @__PURE__ */ createCompareNatural({
  compare,
  typed
});
var composition = /* @__PURE__ */ createComposition({
  addScalar,
  combinations,
  isInteger,
  isNegative,
  isPositive,
  larger,
  typed
});
var cross = /* @__PURE__ */ createCross({
  matrix,
  multiply,
  subtract,
  typed
});
var det = /* @__PURE__ */ createDet({
  divideScalar,
  isZero,
  matrix,
  multiply,
  subtractScalar,
  typed,
  unaryMinus
});
var dotMultiply = /* @__PURE__ */ createDotMultiply({
  concat,
  equalScalar,
  matrix,
  multiplyScalar,
  typed
});
var FibonacciHeap = /* @__PURE__ */ createFibonacciHeapClass({
  larger,
  smaller
});
var fix = /* @__PURE__ */ createFix({
  Complex,
  DenseMatrix,
  ceil,
  equalScalar,
  floor,
  matrix,
  typed,
  zeros
});
var index = /* @__PURE__ */ createIndex({
  Index,
  typed
});
var intersect = /* @__PURE__ */ createIntersect({
  abs,
  add,
  addScalar,
  config: config$1,
  divideScalar,
  equalScalar,
  flatten,
  isNumeric,
  isZero,
  matrix,
  multiply,
  multiplyScalar,
  smaller,
  subtract,
  typed
});
var invmod = /* @__PURE__ */ createInvmod({
  BigNumber,
  add,
  config: config$1,
  equal,
  isInteger,
  mod,
  smaller,
  typed,
  xgcd
});
var lcm = /* @__PURE__ */ createLcm({
  concat,
  equalScalar,
  matrix,
  typed
});
var log1p = /* @__PURE__ */ createLog1p({
  Complex,
  config: config$1,
  divideScalar,
  log,
  typed
});
var max = /* @__PURE__ */ createMax({
  config: config$1,
  larger,
  numeric: numeric2,
  typed
});
var setCartesian = /* @__PURE__ */ createSetCartesian({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setDistinct = /* @__PURE__ */ createSetDistinct({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setIsSubset = /* @__PURE__ */ createSetIsSubset({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setPowerset = /* @__PURE__ */ createSetPowerset({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var smallerEq = /* @__PURE__ */ createSmallerEq({
  DenseMatrix,
  concat,
  config: config$1,
  matrix,
  typed
});
var sort = /* @__PURE__ */ createSort({
  compare,
  compareNatural,
  matrix,
  typed
});
var and = /* @__PURE__ */ createAnd({
  concat,
  equalScalar,
  matrix,
  not,
  typed,
  zeros
});
var range = /* @__PURE__ */ createRange({
  bignumber,
  matrix,
  add,
  config: config$1,
  isPositive,
  larger,
  largerEq,
  smaller,
  smallerEq,
  typed
});
var row = /* @__PURE__ */ createRow({
  Index,
  matrix,
  range,
  typed
});
var setDifference = /* @__PURE__ */ createSetDifference({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setMultiplicity = /* @__PURE__ */ createSetMultiplicity({
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setSymDifference = /* @__PURE__ */ createSetSymDifference({
  Index,
  concat,
  setDifference,
  size,
  subset,
  typed
});
var Spa = /* @__PURE__ */ createSpaClass({
  FibonacciHeap,
  addScalar,
  equalScalar
});
var column = /* @__PURE__ */ createColumn({
  Index,
  matrix,
  range,
  typed
});
var inv = /* @__PURE__ */ createInv({
  abs,
  addScalar,
  det,
  divideScalar,
  identity,
  matrix,
  multiply,
  typed,
  unaryMinus
});
var lup = /* @__PURE__ */ createLup({
  DenseMatrix,
  Spa,
  SparseMatrix,
  abs,
  addScalar,
  divideScalar,
  equalScalar,
  larger,
  matrix,
  multiplyScalar,
  subtractScalar,
  typed,
  unaryMinus
});
var pinv = /* @__PURE__ */ createPinv({
  Complex,
  add,
  ctranspose,
  deepEqual,
  divideScalar,
  dot,
  dotDivide,
  equal,
  inv,
  matrix,
  multiply,
  typed
});
var pow = /* @__PURE__ */ createPow({
  Complex,
  config: config$1,
  fraction,
  identity,
  inv,
  matrix,
  multiply,
  number,
  typed
});
var setIntersect = /* @__PURE__ */ createSetIntersect({
  DenseMatrix,
  Index,
  compareNatural,
  size,
  subset,
  typed
});
var setUnion = /* @__PURE__ */ createSetUnion({
  Index,
  concat,
  setIntersect,
  setSymDifference,
  size,
  subset,
  typed
});
var sqrtm = /* @__PURE__ */ createSqrtm({
  abs,
  add,
  identity,
  inv,
  map,
  max,
  multiply,
  size,
  sqrt,
  subtract,
  typed
});
var Unit = /* @__PURE__ */ createUnitClass({
  BigNumber,
  Complex,
  Fraction,
  abs,
  addScalar,
  config: config$1,
  divideScalar,
  equal,
  fix,
  format,
  isNumeric,
  multiplyScalar,
  number,
  pow,
  round,
  subtractScalar
});
var vacuumImpedance = /* @__PURE__ */ createVacuumImpedance({
  BigNumber,
  Unit,
  config: config$1
});
var wienDisplacement = /* @__PURE__ */ createWienDisplacement({
  BigNumber,
  Unit,
  config: config$1
});
var atomicMass = /* @__PURE__ */ createAtomicMass({
  BigNumber,
  Unit,
  config: config$1
});
var bohrMagneton = /* @__PURE__ */ createBohrMagneton({
  BigNumber,
  Unit,
  config: config$1
});
var boltzmann = /* @__PURE__ */ createBoltzmann({
  BigNumber,
  Unit,
  config: config$1
});
var conductanceQuantum = /* @__PURE__ */ createConductanceQuantum({
  BigNumber,
  Unit,
  config: config$1
});
var coulomb = /* @__PURE__ */ createCoulomb({
  BigNumber,
  Unit,
  config: config$1
});
var deuteronMass = /* @__PURE__ */ createDeuteronMass({
  BigNumber,
  Unit,
  config: config$1
});
var dotPow = /* @__PURE__ */ createDotPow({
  DenseMatrix,
  concat,
  equalScalar,
  matrix,
  pow,
  typed
});
var electricConstant = /* @__PURE__ */ createElectricConstant({
  BigNumber,
  Unit,
  config: config$1
});
var elementaryCharge = /* @__PURE__ */ createElementaryCharge({
  BigNumber,
  Unit,
  config: config$1
});
var expm = /* @__PURE__ */ createExpm({
  abs,
  add,
  identity,
  inv,
  multiply,
  typed
});
var faraday = /* @__PURE__ */ createFaraday({
  BigNumber,
  Unit,
  config: config$1
});
var fft = /* @__PURE__ */ createFft({
  addScalar,
  ceil,
  conj,
  divideScalar,
  dotDivide,
  exp,
  i,
  log2: log22,
  matrix,
  multiplyScalar,
  pow,
  tau,
  typed
});
var gamma = /* @__PURE__ */ createGamma({
  BigNumber,
  Complex,
  config: config$1,
  multiplyScalar,
  pow,
  typed
});
var gravitationConstant = /* @__PURE__ */ createGravitationConstant({
  BigNumber,
  Unit,
  config: config$1
});
var hartreeEnergy = /* @__PURE__ */ createHartreeEnergy({
  BigNumber,
  Unit,
  config: config$1
});
var ifft = /* @__PURE__ */ createIfft({
  conj,
  dotDivide,
  fft,
  typed
});
var klitzing = /* @__PURE__ */ createKlitzing({
  BigNumber,
  Unit,
  config: config$1
});
var loschmidt = /* @__PURE__ */ createLoschmidt({
  BigNumber,
  Unit,
  config: config$1
});
var magneticConstant = /* @__PURE__ */ createMagneticConstant({
  BigNumber,
  Unit,
  config: config$1
});
var molarMass = /* @__PURE__ */ createMolarMass({
  BigNumber,
  Unit,
  config: config$1
});
var molarPlanckConstant = /* @__PURE__ */ createMolarPlanckConstant({
  BigNumber,
  Unit,
  config: config$1
});
var neutronMass = /* @__PURE__ */ createNeutronMass({
  BigNumber,
  Unit,
  config: config$1
});
var nuclearMagneton = /* @__PURE__ */ createNuclearMagneton({
  BigNumber,
  Unit,
  config: config$1
});
var planckCharge = /* @__PURE__ */ createPlanckCharge({
  BigNumber,
  Unit,
  config: config$1
});
var planckLength = /* @__PURE__ */ createPlanckLength({
  BigNumber,
  Unit,
  config: config$1
});
var planckTemperature = /* @__PURE__ */ createPlanckTemperature({
  BigNumber,
  Unit,
  config: config$1
});
var protonMass = /* @__PURE__ */ createProtonMass({
  BigNumber,
  Unit,
  config: config$1
});
var quantumOfCirculation = /* @__PURE__ */ createQuantumOfCirculation({
  BigNumber,
  Unit,
  config: config$1
});
var reducedPlanckConstant = /* @__PURE__ */ createReducedPlanckConstant({
  BigNumber,
  Unit,
  config: config$1
});
var rydberg = /* @__PURE__ */ createRydberg({
  BigNumber,
  Unit,
  config: config$1
});
var secondRadiation = /* @__PURE__ */ createSecondRadiation({
  BigNumber,
  Unit,
  config: config$1
});
var speedOfLight = /* @__PURE__ */ createSpeedOfLight({
  BigNumber,
  Unit,
  config: config$1
});
var stefanBoltzmann = /* @__PURE__ */ createStefanBoltzmann({
  BigNumber,
  Unit,
  config: config$1
});
var thomsonCrossSection = /* @__PURE__ */ createThomsonCrossSection({
  BigNumber,
  Unit,
  config: config$1
});
var avogadro = /* @__PURE__ */ createAvogadro({
  BigNumber,
  Unit,
  config: config$1
});
var bohrRadius = /* @__PURE__ */ createBohrRadius({
  BigNumber,
  Unit,
  config: config$1
});
var createUnit = /* @__PURE__ */ createCreateUnit({
  Unit,
  typed
});
var divide = /* @__PURE__ */ createDivide({
  divideScalar,
  equalScalar,
  inv,
  matrix,
  multiply,
  typed
});
var electronMass = /* @__PURE__ */ createElectronMass({
  BigNumber,
  Unit,
  config: config$1
});
var factorial = /* @__PURE__ */ createFactorial({
  gamma,
  typed
});
var firstRadiation = /* @__PURE__ */ createFirstRadiation({
  BigNumber,
  Unit,
  config: config$1
});
var gravity = /* @__PURE__ */ createGravity({
  BigNumber,
  Unit,
  config: config$1
});
var inverseConductanceQuantum = /* @__PURE__ */ createInverseConductanceQuantum({
  BigNumber,
  Unit,
  config: config$1
});
var lusolve = /* @__PURE__ */ createLusolve({
  DenseMatrix,
  lsolve,
  lup,
  matrix,
  slu,
  typed,
  usolve
});
var magneticFluxQuantum = /* @__PURE__ */ createMagneticFluxQuantum({
  BigNumber,
  Unit,
  config: config$1
});
var molarMassC12 = /* @__PURE__ */ createMolarMassC12({
  BigNumber,
  Unit,
  config: config$1
});
var multinomial = /* @__PURE__ */ createMultinomial({
  add,
  divide,
  factorial,
  isInteger,
  isPositive,
  multiply,
  typed
});
var permutations = /* @__PURE__ */ createPermutations({
  factorial,
  typed
});
var planckMass = /* @__PURE__ */ createPlanckMass({
  BigNumber,
  Unit,
  config: config$1
});
var polynomialRoot = /* @__PURE__ */ createPolynomialRoot({
  add,
  cbrt: cbrt2,
  divide,
  equalScalar,
  im,
  isZero,
  multiply,
  re,
  sqrt,
  subtract,
  typeOf,
  typed,
  unaryMinus
});
var setSize = /* @__PURE__ */ createSetSize({
  compareNatural,
  typed
});
var solveODE = /* @__PURE__ */ createSolveODE({
  abs,
  add,
  bignumber,
  divide,
  isNegative,
  isPositive,
  larger,
  map,
  matrix,
  max,
  multiply,
  smaller,
  subtract,
  typed,
  unaryMinus
});
var stirlingS2 = /* @__PURE__ */ createStirlingS2({
  bignumber,
  addScalar,
  combinations,
  divideScalar,
  factorial,
  isInteger,
  isNegative,
  larger,
  multiplyScalar,
  number,
  pow,
  subtractScalar,
  typed
});
var unit = /* @__PURE__ */ createUnitFunction({
  Unit,
  typed
});
var bellNumbers = /* @__PURE__ */ createBellNumbers({
  addScalar,
  isInteger,
  isNegative,
  stirlingS2,
  typed
});
var eigs = /* @__PURE__ */ createEigs({
  abs,
  add,
  addScalar,
  atan,
  bignumber,
  column,
  complex,
  config: config$1,
  cos,
  diag,
  divideScalar,
  dot,
  equal,
  flatten,
  im,
  inv,
  larger,
  matrix,
  matrixFromColumns,
  multiply,
  multiplyScalar,
  number,
  qr,
  re,
  reshape,
  sin,
  size,
  smaller,
  sqrt,
  subtract,
  typed,
  usolve,
  usolveAll
});
var fermiCoupling = /* @__PURE__ */ createFermiCoupling({
  BigNumber,
  Unit,
  config: config$1
});
var gasConstant = /* @__PURE__ */ createGasConstant({
  BigNumber,
  Unit,
  config: config$1
});
var kldivergence = /* @__PURE__ */ createKldivergence({
  divide,
  dotDivide,
  isNumeric,
  log,
  map,
  matrix,
  multiply,
  sum,
  typed
});
var mean = /* @__PURE__ */ createMean({
  add,
  divide,
  typed
});
var molarVolume = /* @__PURE__ */ createMolarVolume({
  BigNumber,
  Unit,
  config: config$1
});
var planckConstant = /* @__PURE__ */ createPlanckConstant({
  BigNumber,
  Unit,
  config: config$1
});
var quantileSeq = /* @__PURE__ */ createQuantileSeq({
  bignumber,
  add,
  compare,
  divide,
  isInteger,
  larger,
  multiply,
  partitionSelect,
  smaller,
  smallerEq,
  subtract,
  typed
});
var variance = /* @__PURE__ */ createVariance({
  add,
  apply,
  divide,
  isNaN: isNaN$1,
  multiply,
  subtract,
  typed
});
var classicalElectronRadius = /* @__PURE__ */ createClassicalElectronRadius({
  BigNumber,
  Unit,
  config: config$1
});
var median = /* @__PURE__ */ createMedian({
  add,
  compare,
  divide,
  partitionSelect,
  typed
});
var corr = /* @__PURE__ */ createCorr({
  add,
  divide,
  matrix,
  mean,
  multiply,
  pow,
  sqrt,
  subtract,
  sum,
  typed
});
var freqz = /* @__PURE__ */ createFreqz({
  Complex,
  add,
  divide,
  matrix,
  multiply,
  typed
});
var mad = /* @__PURE__ */ createMad({
  abs,
  map,
  median,
  subtract,
  typed
});
var std = /* @__PURE__ */ createStd({
  map,
  sqrt,
  typed,
  variance
});
var zeta = /* @__PURE__ */ createZeta({
  BigNumber,
  Complex,
  add,
  config: config$1,
  divide,
  equal,
  factorial,
  gamma,
  isNegative,
  multiply,
  pi,
  pow,
  sin,
  smallerEq,
  subtract,
  typed
});
var norm = /* @__PURE__ */ createNorm({
  abs,
  add,
  conj,
  ctranspose,
  eigs,
  equalScalar,
  larger,
  matrix,
  multiply,
  pow,
  smaller,
  sqrt,
  typed
});
var rotationMatrix = /* @__PURE__ */ createRotationMatrix({
  BigNumber,
  DenseMatrix,
  SparseMatrix,
  addScalar,
  config: config$1,
  cos,
  matrix,
  multiplyScalar,
  norm,
  sin,
  typed,
  unaryMinus
});
var planckTime = /* @__PURE__ */ createPlanckTime({
  BigNumber,
  Unit,
  config: config$1
});
var schur = /* @__PURE__ */ createSchur({
  identity,
  matrix,
  multiply,
  norm,
  qr,
  subtract,
  typed
});
var rotate = /* @__PURE__ */ createRotate({
  multiply,
  rotationMatrix,
  typed
});
var sylvester = /* @__PURE__ */ createSylvester({
  abs,
  add,
  concat,
  identity,
  index,
  lusolve,
  matrix,
  matrixFromColumns,
  multiply,
  range,
  schur,
  subset,
  subtract,
  transpose,
  typed
});
var lyap = /* @__PURE__ */ createLyap({
  matrix,
  multiply,
  sylvester,
  transpose,
  typed
});
var math = {};
var mathWithTransform = {};
var classes = {};
var Node = createNode({
  mathWithTransform
});
var ObjectNode = createObjectNode({
  Node
});
var OperatorNode = createOperatorNode({
  Node
});
var ParenthesisNode = createParenthesisNode({
  Node
});
var RelationalNode = createRelationalNode({
  Node
});
var ArrayNode = createArrayNode({
  Node
});
var BlockNode = createBlockNode({
  Node,
  ResultSet
});
var ConditionalNode = createConditionalNode({
  Node
});
var ConstantNode = createConstantNode({
  Node
});
var RangeNode = createRangeNode({
  Node
});
var reviver = createReviver({
  classes
});
var Chain = createChainClass({
  math,
  typed
});
var FunctionAssignmentNode = createFunctionAssignmentNode({
  Node,
  typed
});
var chain = createChain({
  Chain,
  typed
});
var IndexNode = createIndexNode({
  Node,
  size
});
var AccessorNode = createAccessorNode({
  Node,
  subset
});
var AssignmentNode = createAssignmentNode({
  matrix,
  Node,
  subset
});
var SymbolNode = createSymbolNode({
  Unit,
  Node,
  math
});
var FunctionNode = createFunctionNode({
  Node,
  SymbolNode,
  math
});
var parse = createParse({
  AccessorNode,
  ArrayNode,
  AssignmentNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  FunctionAssignmentNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  RangeNode,
  RelationalNode,
  SymbolNode,
  config: config$1,
  numeric: numeric2,
  typed
});
var resolve = createResolve({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  parse,
  typed
});
var simplifyConstant = createSimplifyConstant({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  SymbolNode,
  config: config$1,
  mathWithTransform,
  matrix,
  typed
});
var compile = createCompile({
  parse,
  typed
});
var simplifyCore = createSimplifyCore({
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  divide,
  equal,
  isZero,
  multiply,
  parse,
  pow,
  subtract,
  typed
});
var evaluate = createEvaluate({
  parse,
  typed
});
var Help = createHelpClass({
  evaluate
});
var Parser = createParserClass({
  evaluate
});
var simplify = createSimplify({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  config: config$1,
  divide,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse,
  pow,
  resolve,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed
});
var symbolicEqual = createSymbolicEqual({
  OperatorNode,
  parse,
  simplify,
  typed
});
var leafCount = createLeafCount({
  parse,
  typed
});
var parser = createParser({
  Parser,
  typed
});
var rationalize = createRationalize({
  bignumber,
  fraction,
  AccessorNode,
  ArrayNode,
  ConstantNode,
  FunctionNode,
  IndexNode,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  add,
  config: config$1,
  divide,
  equal,
  isZero,
  mathWithTransform,
  matrix,
  multiply,
  parse,
  pow,
  simplify,
  simplifyConstant,
  simplifyCore,
  subtract,
  typed
});
var derivative = createDerivative({
  ConstantNode,
  FunctionNode,
  OperatorNode,
  ParenthesisNode,
  SymbolNode,
  config: config$1,
  equal,
  isZero,
  numeric: numeric2,
  parse,
  simplify,
  typed
});
var help = createHelp({
  Help,
  mathWithTransform,
  typed
});
_extends$1(math, {
  e,
  false: _false,
  fineStructure,
  i,
  Infinity: _Infinity,
  LN10,
  LOG10E,
  NaN: _NaN,
  null: _null,
  phi,
  SQRT1_2,
  sackurTetrode,
  tau,
  true: _true,
  "E": e,
  version,
  efimovFactor,
  LN2,
  pi,
  replacer,
  reviver,
  SQRT2,
  typed,
  unaryPlus,
  "PI": pi,
  weakMixingAngle,
  abs,
  acos,
  acot,
  acsc,
  addScalar,
  arg,
  asech,
  asinh,
  atan,
  atanh,
  bignumber,
  bitNot,
  boolean,
  clone,
  combinations,
  complex,
  conj,
  cos,
  cot,
  csc,
  cube,
  equalScalar,
  erf,
  exp,
  expm1: expm12,
  filter,
  forEach,
  format,
  getMatrixDataType,
  hex,
  im,
  isInteger,
  isNegative,
  isPositive,
  isZero,
  LOG2E,
  lgamma,
  log10: log102,
  log2: log22,
  map,
  multiplyScalar,
  not,
  number,
  oct,
  pickRandom,
  print,
  random,
  re,
  sec,
  sign,
  sin,
  splitUnit,
  square,
  string,
  subtractScalar,
  tan,
  typeOf,
  acosh,
  acsch,
  apply,
  asec,
  bin,
  chain,
  combinationsWithRep,
  cosh,
  csch,
  isNaN: isNaN$1,
  isPrime,
  randomInt,
  sech,
  sinh,
  sparse,
  sqrt,
  tanh,
  unaryMinus,
  acoth,
  coth,
  fraction,
  isNumeric,
  matrix,
  matrixFromFunction,
  mode,
  numeric: numeric2,
  prod,
  reshape,
  size,
  squeeze,
  transpose,
  xgcd,
  zeros,
  asin,
  cbrt: cbrt2,
  concat,
  count,
  ctranspose,
  diag,
  divideScalar,
  dotDivide,
  equal,
  flatten,
  hasNumericValue,
  identity,
  kron,
  largerEq,
  leftShift,
  lsolve,
  matrixFromColumns,
  nthRoot,
  ones,
  qr,
  resize,
  rightArithShift,
  round,
  smaller,
  subtract,
  to,
  unequal,
  usolve,
  xor,
  add,
  atan2,
  bitAnd,
  bitOr,
  bitXor,
  catalan,
  compare,
  compareText,
  cumsum,
  deepEqual,
  diff,
  distance,
  dot,
  equalText,
  floor,
  gcd,
  hypot,
  larger,
  log,
  lsolveAll,
  matrixFromRows,
  min,
  mod,
  multiply,
  nthRoots,
  or,
  partitionSelect,
  rightLogShift,
  slu,
  subset,
  sum,
  trace,
  usolveAll,
  zpk2tf,
  ceil,
  compareNatural,
  composition,
  cross,
  det,
  dotMultiply,
  fix,
  index,
  intersect,
  invmod,
  lcm,
  log1p,
  max,
  setCartesian,
  setDistinct,
  setIsSubset,
  setPowerset,
  smallerEq,
  sort,
  and,
  range,
  row,
  setDifference,
  setMultiplicity,
  setSymDifference,
  column,
  inv,
  lup,
  pinv,
  pow,
  setIntersect,
  setUnion,
  sqrtm,
  vacuumImpedance,
  wienDisplacement,
  atomicMass,
  bohrMagneton,
  boltzmann,
  conductanceQuantum,
  coulomb,
  deuteronMass,
  dotPow,
  electricConstant,
  elementaryCharge,
  expm,
  faraday,
  fft,
  gamma,
  gravitationConstant,
  hartreeEnergy,
  ifft,
  klitzing,
  loschmidt,
  magneticConstant,
  molarMass,
  molarPlanckConstant,
  neutronMass,
  nuclearMagneton,
  planckCharge,
  planckLength,
  planckTemperature,
  protonMass,
  quantumOfCirculation,
  reducedPlanckConstant,
  rydberg,
  secondRadiation,
  speedOfLight,
  stefanBoltzmann,
  thomsonCrossSection,
  avogadro,
  bohrRadius,
  createUnit,
  divide,
  electronMass,
  factorial,
  firstRadiation,
  gravity,
  inverseConductanceQuantum,
  lusolve,
  magneticFluxQuantum,
  molarMassC12,
  multinomial,
  parse,
  permutations,
  planckMass,
  polynomialRoot,
  resolve,
  setSize,
  simplifyConstant,
  solveODE,
  stirlingS2,
  unit,
  bellNumbers,
  compile,
  eigs,
  fermiCoupling,
  gasConstant,
  kldivergence,
  mean,
  molarVolume,
  planckConstant,
  quantileSeq,
  simplifyCore,
  variance,
  classicalElectronRadius,
  evaluate,
  median,
  simplify,
  symbolicEqual,
  corr,
  freqz,
  leafCount,
  mad,
  parser,
  rationalize,
  std,
  zeta,
  derivative,
  norm,
  rotationMatrix,
  help,
  planckTime,
  schur,
  rotate,
  sylvester,
  lyap,
  config: config$1
});
_extends$1(mathWithTransform, math, {
  filter: createFilterTransform({
    typed
  }),
  forEach: createForEachTransform({
    typed
  }),
  map: createMapTransform({
    typed
  }),
  apply: createApplyTransform({
    isInteger,
    typed
  }),
  or: createOrTransform({
    DenseMatrix,
    concat,
    equalScalar,
    matrix,
    typed
  }),
  and: createAndTransform({
    add,
    concat,
    equalScalar,
    matrix,
    not,
    typed,
    zeros
  }),
  concat: createConcatTransform({
    isInteger,
    matrix,
    typed
  }),
  max: createMaxTransform({
    config: config$1,
    larger,
    numeric: numeric2,
    typed
  }),
  print: createPrintTransform({
    add,
    matrix,
    typed,
    zeros
  }),
  bitAnd: createBitAndTransform({
    add,
    concat,
    equalScalar,
    matrix,
    not,
    typed,
    zeros
  }),
  diff: createDiffTransform({
    bignumber,
    matrix,
    number,
    subtract,
    typed
  }),
  min: createMinTransform({
    config: config$1,
    numeric: numeric2,
    smaller,
    typed
  }),
  subset: createSubsetTransform({
    add,
    matrix,
    typed,
    zeros
  }),
  bitOr: createBitOrTransform({
    DenseMatrix,
    concat,
    equalScalar,
    matrix,
    typed
  }),
  cumsum: createCumSumTransform({
    add,
    typed,
    unaryPlus
  }),
  index: createIndexTransform({
    Index,
    getMatrixDataType
  }),
  sum: createSumTransform({
    add,
    config: config$1,
    numeric: numeric2,
    typed
  }),
  range: createRangeTransform({
    bignumber,
    matrix,
    add,
    config: config$1,
    isPositive,
    larger,
    largerEq,
    smaller,
    smallerEq,
    typed
  }),
  row: createRowTransform({
    Index,
    matrix,
    range,
    typed
  }),
  column: createColumnTransform({
    Index,
    matrix,
    range,
    typed
  }),
  mean: createMeanTransform({
    add,
    divide,
    typed
  }),
  quantileSeq: createQuantileSeqTransform({
    add,
    bignumber,
    compare,
    divide,
    isInteger,
    larger,
    multiply,
    partitionSelect,
    smaller,
    smallerEq,
    subtract,
    typed
  }),
  variance: createVarianceTransform({
    add,
    apply,
    divide,
    isNaN: isNaN$1,
    multiply,
    subtract,
    typed
  }),
  std: createStdTransform({
    map,
    sqrt,
    typed,
    variance
  })
});
_extends$1(classes, {
  BigNumber,
  Complex,
  Fraction,
  Matrix,
  Node,
  ObjectNode,
  OperatorNode,
  ParenthesisNode,
  Range,
  RelationalNode,
  ResultSet,
  ArrayNode,
  BlockNode,
  ConditionalNode,
  ConstantNode,
  DenseMatrix,
  RangeNode,
  Chain,
  FunctionAssignmentNode,
  SparseMatrix,
  IndexNode,
  ImmutableDenseMatrix,
  Index,
  AccessorNode,
  AssignmentNode,
  FibonacciHeap,
  Spa,
  Unit,
  SymbolNode,
  FunctionNode,
  Help,
  Parser
});
Chain.createProxy(math);
function create_fragment$10(ctx) {
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      input = element("input");
      attr(
        input,
        "class",
        /*styleClass*/
        ctx[3]
      );
      attr(
        input,
        "min",
        /*min*/
        ctx[4]
      );
      attr(
        input,
        "max",
        /*max*/
        ctx[5]
      );
      attr(
        input,
        "id",
        /*id*/
        ctx[1]
      );
      attr(
        input,
        "name",
        /*name*/
        ctx[2]
      );
      attr(input, "inputmode", "numeric");
      attr(input, "pattern", "[0-9+=\\-]*");
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*value*/
        ctx[0]
      );
      if (!mounted) {
        dispose = [
          listen(
            input,
            "input",
            /*input_input_handler*/
            ctx[7]
          ),
          listen(
            input,
            "change",
            /*handleInputChange*/
            ctx[6]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*styleClass*/
      8) {
        attr(
          input,
          "class",
          /*styleClass*/
          ctx2[3]
        );
      }
      if (dirty & /*min*/
      16) {
        attr(
          input,
          "min",
          /*min*/
          ctx2[4]
        );
      }
      if (dirty & /*max*/
      32) {
        attr(
          input,
          "max",
          /*max*/
          ctx2[5]
        );
      }
      if (dirty & /*id*/
      2) {
        attr(
          input,
          "id",
          /*id*/
          ctx2[1]
        );
      }
      if (dirty & /*name*/
      4) {
        attr(
          input,
          "name",
          /*name*/
          ctx2[2]
        );
      }
      if (dirty & /*value*/
      1 && input.value !== /*value*/
      ctx2[0]) {
        set_input_value(
          input,
          /*value*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$10($$self, $$props, $$invalidate) {
  let { value = 0 } = $$props;
  let { id = "" } = $$props;
  let { name: name2 = "" } = $$props;
  let { styleClass = "" } = $$props;
  let { min: min2 = void 0 } = $$props;
  let { max: max2 = void 0 } = $$props;
  const dispatch2 = createEventDispatcher();
  function handleInputChange(event) {
    const target = event.target;
    let newValue = target.value;
    try {
      let result = Math.floor(evaluate(newValue));
      if (max2) {
        result = Math.min(result, max2);
      }
      if (min2) {
        result = Math.max(result, min2);
      }
      $$invalidate(0, value = result);
      dispatch2("change", { value: result, name: name2 });
    } catch (error) {
      console.log("Invalid expression: ", error);
    }
  }
  function input_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("name" in $$props2)
      $$invalidate(2, name2 = $$props2.name);
    if ("styleClass" in $$props2)
      $$invalidate(3, styleClass = $$props2.styleClass);
    if ("min" in $$props2)
      $$invalidate(4, min2 = $$props2.min);
    if ("max" in $$props2)
      $$invalidate(5, max2 = $$props2.max);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*value*/
    1) {
      $$invalidate(0, value);
    }
  };
  return [value, id, name2, styleClass, min2, max2, handleInputChange, input_input_handler];
}
class EvaluatingInput extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$10, create_fragment$10, safe_not_equal, {
      value: 0,
      id: 1,
      name: 2,
      styleClass: 3,
      min: 4,
      max: 5
    });
  }
}
const Dnd5eCurrency_svelte_svelte_type_style_lang = "";
function create_if_block$M(ctx) {
  let section;
  let label0;
  let i0;
  let t0;
  let evaluatinginput0;
  let t1;
  let label1;
  let i1;
  let t2;
  let evaluatinginput1;
  let t3;
  let label2;
  let i2;
  let t4;
  let evaluatinginput2;
  let t5;
  let label3;
  let i3;
  let t6;
  let evaluatinginput3;
  let t7;
  let label4;
  let i4;
  let t8;
  let evaluatinginput4;
  let current;
  evaluatinginput0 = new EvaluatingInput({
    props: {
      id: "currency-pp",
      name: "system.currency.pp",
      styleClass: "currency-input",
      value: (
        /*currency*/
        ctx[1].pp
      )
    }
  });
  evaluatinginput0.$on(
    "change",
    /*handleCurrencyUpdate*/
    ctx[2]
  );
  evaluatinginput1 = new EvaluatingInput({
    props: {
      id: "currency-gp",
      name: "system.currency.gp",
      styleClass: "currency-input",
      value: (
        /*currency*/
        ctx[1].gp
      )
    }
  });
  evaluatinginput1.$on(
    "change",
    /*handleCurrencyUpdate*/
    ctx[2]
  );
  evaluatinginput2 = new EvaluatingInput({
    props: {
      id: "currency-ep",
      name: "system.currency.ep",
      styleClass: "currency-input",
      value: (
        /*currency*/
        ctx[1].ep
      )
    }
  });
  evaluatinginput2.$on(
    "change",
    /*handleCurrencyUpdate*/
    ctx[2]
  );
  evaluatinginput3 = new EvaluatingInput({
    props: {
      id: "currency-sp",
      name: "system.currency.sp",
      styleClass: "currency-input",
      value: (
        /*currency*/
        ctx[1].sp
      )
    }
  });
  evaluatinginput3.$on(
    "change",
    /*handleCurrencyUpdate*/
    ctx[2]
  );
  evaluatinginput4 = new EvaluatingInput({
    props: {
      id: "currency-cp",
      name: "system.currency.cp",
      styleClass: "currency-input",
      value: (
        /*currency*/
        ctx[1].cp
      )
    }
  });
  evaluatinginput4.$on(
    "change",
    /*handleCurrencyUpdate*/
    ctx[2]
  );
  return {
    c() {
      section = element("section");
      label0 = element("label");
      i0 = element("i");
      t0 = space();
      create_component(evaluatinginput0.$$.fragment);
      t1 = space();
      label1 = element("label");
      i1 = element("i");
      t2 = space();
      create_component(evaluatinginput1.$$.fragment);
      t3 = space();
      label2 = element("label");
      i2 = element("i");
      t4 = space();
      create_component(evaluatinginput2.$$.fragment);
      t5 = space();
      label3 = element("label");
      i3 = element("i");
      t6 = space();
      create_component(evaluatinginput3.$$.fragment);
      t7 = space();
      label4 = element("label");
      i4 = element("i");
      t8 = space();
      create_component(evaluatinginput4.$$.fragment);
      attr(i0, "class", "currency pp svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(label0, "aria-label", "Platinum");
      attr(label0, "for", "currency-pp");
      attr(label0, "class", "svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(i1, "class", "currency gp svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(label1, "aria-label", "Gold");
      attr(label1, "for", "currency-gp");
      attr(label1, "class", "svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(i2, "class", "currency ep svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(label2, "aria-label", "Electrum");
      attr(label2, "for", "currency-ep");
      attr(label2, "class", "svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(i3, "class", "currency sp svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(label3, "aria-label", "Silver");
      attr(label3, "for", "currency-sp");
      attr(label3, "class", "svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(i4, "class", "currency cp svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(label4, "aria-label", "Copper");
      attr(label4, "for", "currency-cp");
      attr(label4, "class", "svelte-mobile-companion81nkluj30u9vsd-8l67bj");
      attr(section, "class", "currency-container svelte-mobile-companion81nkluj30u9vsd-8l67bj");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, label0);
      append(label0, i0);
      append(label0, t0);
      mount_component(evaluatinginput0, label0, null);
      append(section, t1);
      append(section, label1);
      append(label1, i1);
      append(label1, t2);
      mount_component(evaluatinginput1, label1, null);
      append(section, t3);
      append(section, label2);
      append(label2, i2);
      append(label2, t4);
      mount_component(evaluatinginput2, label2, null);
      append(section, t5);
      append(section, label3);
      append(label3, i3);
      append(label3, t6);
      mount_component(evaluatinginput3, label3, null);
      append(section, t7);
      append(section, label4);
      append(label4, i4);
      append(label4, t8);
      mount_component(evaluatinginput4, label4, null);
      current = true;
    },
    p(ctx2, dirty) {
      const evaluatinginput0_changes = {};
      if (dirty & /*currency*/
      2)
        evaluatinginput0_changes.value = /*currency*/
        ctx2[1].pp;
      evaluatinginput0.$set(evaluatinginput0_changes);
      const evaluatinginput1_changes = {};
      if (dirty & /*currency*/
      2)
        evaluatinginput1_changes.value = /*currency*/
        ctx2[1].gp;
      evaluatinginput1.$set(evaluatinginput1_changes);
      const evaluatinginput2_changes = {};
      if (dirty & /*currency*/
      2)
        evaluatinginput2_changes.value = /*currency*/
        ctx2[1].ep;
      evaluatinginput2.$set(evaluatinginput2_changes);
      const evaluatinginput3_changes = {};
      if (dirty & /*currency*/
      2)
        evaluatinginput3_changes.value = /*currency*/
        ctx2[1].sp;
      evaluatinginput3.$set(evaluatinginput3_changes);
      const evaluatinginput4_changes = {};
      if (dirty & /*currency*/
      2)
        evaluatinginput4_changes.value = /*currency*/
        ctx2[1].cp;
      evaluatinginput4.$set(evaluatinginput4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(evaluatinginput0.$$.fragment, local);
      transition_in(evaluatinginput1.$$.fragment, local);
      transition_in(evaluatinginput2.$$.fragment, local);
      transition_in(evaluatinginput3.$$.fragment, local);
      transition_in(evaluatinginput4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(evaluatinginput0.$$.fragment, local);
      transition_out(evaluatinginput1.$$.fragment, local);
      transition_out(evaluatinginput2.$$.fragment, local);
      transition_out(evaluatinginput3.$$.fragment, local);
      transition_out(evaluatinginput4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(evaluatinginput0);
      destroy_component(evaluatinginput1);
      destroy_component(evaluatinginput2);
      destroy_component(evaluatinginput3);
      destroy_component(evaluatinginput4);
    }
  };
}
function create_fragment$$(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*isUsingCurrency*/
    ctx[0] && create_if_block$M(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*isUsingCurrency*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*isUsingCurrency*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$M(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$$($$self, $$props, $$invalidate) {
  let currency;
  let { actor } = $$props;
  let isUsingCurrency = true;
  const unsubscribe = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useCurrency).subscribe((value) => {
    $$invalidate(0, isUsingCurrency = value);
  });
  onDestroy(() => {
    unsubscribe();
  });
  function updateActor2() {
    actor.update({ system: { currency } });
  }
  function handleCurrencyUpdate(event) {
    const { value, name: name2 } = event.detail;
    const fieldName = name2.split(".")[2];
    $$invalidate(1, currency[fieldName] = value, currency);
    updateActor2();
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(3, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    8) {
      $$invalidate(1, currency = actor.system.currency);
    }
  };
  return [isUsingCurrency, currency, handleCurrencyUpdate, actor];
}
class Dnd5eCurrency extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$$, create_fragment$$, safe_not_equal, { actor: 3 });
  }
}
function create_if_block$L(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.innerHTML = `<b></b>`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$_(ctx) {
  let if_block_anchor;
  let if_block = (
    /*itemData*/
    ctx[0].capacity && create_if_block$L()
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*itemData*/
        ctx2[0].capacity
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$L();
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$_($$self, $$props, $$invalidate) {
  let itemData;
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    2) {
      $$invalidate(0, itemData = item.system);
    }
  };
  return [itemData, item];
}
class Dnd5eContainerObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$_, create_fragment$_, safe_not_equal, { item: 1 });
  }
}
function create_if_block$K(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  let t4;
  let t5;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Type")}:`;
      t2 = space();
      t3 = text(
        /*consumableTypeLabel*/
        ctx[0]
      );
      t4 = space();
      t5 = text(
        /*subtype*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, t5);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$Z(ctx) {
  let if_block_anchor;
  let if_block = (
    /*consumableTypeLabel*/
    ctx[0] && create_if_block$K(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*consumableTypeLabel*/
        ctx2[0]
      )
        if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$Z($$self, $$props, $$invalidate) {
  var _a;
  let { item } = $$props;
  let itemData = item.system;
  const consumableTypeLabel = (_a = CONFIG.DND5E.consumableTypes[itemData.type.value]) === null || _a === void 0 ? void 0 : _a.label;
  const subtype = itemData.type.subtype ? "(" + CONFIG.DND5E.consumableTypes.subtypes[itemData.type.subtype] + ")" : "";
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(2, item = $$props2.item);
  };
  return [consumableTypeLabel, subtype, item];
}
class Dnd5eConsumableObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$Z, create_fragment$Z, safe_not_equal, { item: 2 });
  }
}
const Quantity_svelte_svelte_type_style_lang = "";
function create_fragment$Y(ctx) {
  let div2;
  let button0;
  let t0;
  let input;
  let t1;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      button0 = element("button");
      button0.innerHTML = `<i class="fas fa-minus"></i>`;
      t0 = space();
      input = element("input");
      t1 = space();
      button1 = element("button");
      button1.innerHTML = `<i class="fas fa-plus"></i>`;
      attr(button0, "class", "adjustment-button svelte-mobile-companion81nkluj30u9vsd-jhrci3");
      attr(button0, "aria-hidden", "true");
      attr(input, "class", "input svelte-mobile-companion81nkluj30u9vsd-jhrci3");
      attr(input, "type", "text");
      input.value = /*quantity*/
      ctx[0];
      attr(input, "placeholder", "0");
      attr(input, "inputmode", "numeric");
      attr(input, "pattern", "[0-9+=\\-]*");
      set_style(
        input,
        "font-family",
        /*fontFamily*/
        ctx[1]
      );
      attr(input, "min", "0");
      attr(button1, "class", "adjustment-button svelte-mobile-companion81nkluj30u9vsd-jhrci3");
      attr(button1, "aria-hidden", "true");
      attr(div2, "class", "item-quantity svelte-mobile-companion81nkluj30u9vsd-jhrci3");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, button0);
      append(div2, t0);
      append(div2, input);
      append(div2, t1);
      append(div2, button1);
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "click",
            /*decrease*/
            ctx[3]
          ),
          listen(
            input,
            "input",
            /*adjustQuantity*/
            ctx[4]
          ),
          listen(
            button1,
            "click",
            /*increase*/
            ctx[2]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*quantity*/
      1 && input.value !== /*quantity*/
      ctx2[0]) {
        input.value = /*quantity*/
        ctx2[0];
      }
      if (dirty & /*fontFamily*/
      2) {
        set_style(
          input,
          "font-family",
          /*fontFamily*/
          ctx2[1]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$Y($$self, $$props, $$invalidate) {
  let { quantity = 0 } = $$props;
  let { fontFamily = "monospace" } = $$props;
  const dispatch2 = createEventDispatcher();
  function increase() {
    $$invalidate(0, quantity++, quantity);
    dispatch2("onQtyChange", quantity);
  }
  function decrease() {
    if (quantity > 0) {
      $$invalidate(0, quantity--, quantity);
      dispatch2("onQtyChange", quantity);
    }
  }
  function adjustQuantity(event) {
    $$invalidate(0, quantity = parseInt(event.target.value || "0"));
    dispatch2("onQtyChange", quantity);
  }
  $$self.$$set = ($$props2) => {
    if ("quantity" in $$props2)
      $$invalidate(0, quantity = $$props2.quantity);
    if ("fontFamily" in $$props2)
      $$invalidate(1, fontFamily = $$props2.fontFamily);
  };
  return [quantity, fontFamily, increase, decrease, adjustQuantity];
}
class Quantity extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$Y, create_fragment$Y, safe_not_equal, { quantity: 0, fontFamily: 1 });
  }
}
function create_if_block$J(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Properties")}:`;
      t2 = space();
      t3 = text(
        /*properties*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$X(ctx) {
  let if_block_anchor;
  let if_block = (
    /*properties*/
    ctx[0] && create_if_block$J(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*properties*/
        ctx2[0]
      )
        if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$X($$self, $$props, $$invalidate) {
  let { item } = $$props;
  const properties2 = item.labels.properties.map((property) => property.label).join(", ");
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  return [properties2, item];
}
class Dnd5eObjectProperties extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$X, create_fragment$X, safe_not_equal, { item: 1 });
  }
}
function create_if_block$I(ctx) {
  let await_block_anchor;
  let promise2;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$6,
    then: create_then_block$6,
    catch: create_catch_block$6,
    value: 3,
    error: 4
  };
  handle_promise(promise2 = /*description*/
  ctx[0], info);
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      info.ctx = ctx;
      if (dirty & /*description*/
      1 && promise2 !== (promise2 = /*description*/
      ctx[0]) && handle_promise(promise2, info))
        ;
      else {
        update_await_block_branch(info, ctx, dirty);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(await_block_anchor);
      }
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$6(ctx) {
  let t_value = console.error(
    "(There was an error:",
    /*error*/
    ctx[4].message
  ) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*description*/
      1 && t_value !== (t_value = console.error(
        "(There was an error:",
        /*error*/
        ctx2[4].message
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_then_block$6(ctx) {
  let p;
  let raw_value = (
    /*text*/
    ctx[3] + ""
  );
  return {
    c() {
      p = element("p");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      p.innerHTML = raw_value;
    },
    p(ctx2, dirty) {
      if (dirty & /*description*/
      1 && raw_value !== (raw_value = /*text*/
      ctx2[3] + ""))
        p.innerHTML = raw_value;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_pending_block$6(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_fragment$W(ctx) {
  let if_block_anchor;
  let if_block = (
    /*description*/
    ctx[0] && create_if_block$I(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*description*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$I(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$W($$self, $$props, $$invalidate) {
  let { itemData } = $$props;
  let identified, description;
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(1, itemData = $$props2.itemData);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*itemData, identified*/
    6) {
      {
        $$invalidate(2, identified = itemData.identified);
        if (identified) {
          $$invalidate(0, description = TextEditor.enrichHTML(itemData.description.value));
        } else {
          if (itemData.unidentified.description) {
            $$invalidate(0, description = TextEditor.enrichHTML(itemData.unidentified.description));
          } else {
            $$invalidate(0, description = i18n("DND5E.Unidentified.Notice"));
          }
        }
      }
    }
  };
  return [description, itemData, identified];
}
class Dnd5eDescription extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$W, create_fragment$W, safe_not_equal, { itemData: 1 });
  }
}
function create_if_block$H(ctx) {
  let p;
  let b;
  let t1;
  let t2_value = (
    /*price*/
    ctx[0].value + ""
  );
  let t2;
  let t3;
  let t4_value = (
    /*price*/
    ctx[0].denomination + ""
  );
  let t4;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Price")}`;
      t1 = text(": ");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(t4_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t1);
      append(p, t2);
      append(p, t3);
      append(p, t4);
    },
    p(ctx2, dirty) {
      if (dirty & /*price*/
      1 && t2_value !== (t2_value = /*price*/
      ctx2[0].value + ""))
        set_data(t2, t2_value);
      if (dirty & /*price*/
      1 && t4_value !== (t4_value = /*price*/
      ctx2[0].denomination + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$V(ctx) {
  let if_block_anchor;
  let if_block = (
    /*price*/
    ctx[0].value && create_if_block$H(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*price*/
        ctx2[0].value
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$H(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$V($$self, $$props, $$invalidate) {
  let { price } = $$props;
  $$self.$$set = ($$props2) => {
    if ("price" in $$props2)
      $$invalidate(0, price = $$props2.price);
  };
  return [price];
}
class Dnd5ePrice extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$V, create_fragment$V, safe_not_equal, { price: 0 });
  }
}
function create_if_block$G(ctx) {
  let p;
  let b;
  let t1;
  let t2_value = (
    /*weight*/
    ctx[0].value + ""
  );
  let t2;
  let t3;
  let t4_value = (
    /*weight*/
    ctx[0].units + ""
  );
  let t4;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Weight")}`;
      t1 = text(": ");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(t4_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t1);
      append(p, t2);
      append(p, t3);
      append(p, t4);
    },
    p(ctx2, dirty) {
      if (dirty & /*weight*/
      1 && t2_value !== (t2_value = /*weight*/
      ctx2[0].value + ""))
        set_data(t2, t2_value);
      if (dirty & /*weight*/
      1 && t4_value !== (t4_value = /*weight*/
      ctx2[0].units + ""))
        set_data(t4, t4_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$U(ctx) {
  let if_block_anchor;
  let if_block = (
    /*weight*/
    ctx[0] && create_if_block$G(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*weight*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$G(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$U($$self, $$props, $$invalidate) {
  let { weight } = $$props;
  $$self.$$set = ($$props2) => {
    if ("weight" in $$props2)
      $$invalidate(0, weight = $$props2.weight);
  };
  return [weight];
}
class Dnd5eWeight extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$U, create_fragment$U, safe_not_equal, { weight: 0 });
  }
}
function create_fragment$T(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].labels.toHit + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.ToHit")}:`;
      t2 = text("\r\n    1d20 ");
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*item*/
      1 && t3_value !== (t3_value = /*item*/
      ctx2[0].labels.toHit + ""))
        set_data(t3, t3_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function instance$T($$self, $$props, $$invalidate) {
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item];
}
class Dnd5eAttack extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$T, create_fragment$T, safe_not_equal, { item: 0 });
  }
}
function get_each_context$d(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i2];
  child_ctx[4] = i2;
  return child_ctx;
}
function create_else_block$5(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*damage*/
    ctx[2].label + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Damage")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$F(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*damage*/
    ctx[2].label + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Healing")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_each_block$d(key_1, ctx) {
  let first;
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*damage*/
      ctx2[2].damageType === "healing"
    )
      return create_if_block$F;
    return create_else_block$5;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      if_block.c();
      if_block_anchor = empty();
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if_block.p(ctx, dirty);
    },
    d(detaching) {
      if (detaching) {
        detach(first);
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_fragment$S(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*damages*/
    ctx[0]
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[4]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$d(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$d(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*damages*/
      1) {
        each_value = ensure_array_like(
          /*damages*/
          ctx2[0]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$d, each_1_anchor, get_each_context$d);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function instance$S($$self, $$props, $$invalidate) {
  let { item } = $$props;
  const damages = item.labels.derivedDamage;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  return [damages, item];
}
class Dnd5eDamage extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$S, create_fragment$S, safe_not_equal, { item: 1 });
  }
}
function create_if_block$E(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.SavingThrow")}:`;
      t2 = space();
      t3 = text(
        /*result*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$R(ctx) {
  let if_block_anchor;
  let if_block = (
    /*save*/
    ctx[0].ability && create_if_block$E(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*save*/
        ctx2[0].ability
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$E(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$R($$self, $$props, $$invalidate) {
  var _a, _b;
  let { item } = $$props;
  let itemData = item.system;
  const save = itemData.save;
  if (save.scaling === "spell") {
    save.dc = item.isOwned ? item.actor.system.attributes.spelldc : null;
  } else if (save.scaling !== "flat") {
    save.dc = item.isOwned ? item.actor.system.abilities[save.scaling].dc : null;
  }
  const abl = (_b = (_a = CONFIG.DND5E.abilities[save.ability]) === null || _a === void 0 ? void 0 : _a.label) !== null && _b !== void 0 ? _b : "";
  let result = i18nFormat("DND5E.SaveDC", { dc: save.dc || "", ability: abl });
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(2, item = $$props2.item);
  };
  return [save, result, item];
}
class Dnd5eSave extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$R, create_fragment$R, safe_not_equal, { item: 2 });
  }
}
function create_if_block$D(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].labels.activation + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.ItemActivation")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && t3_value !== (t3_value = /*item*/
      ctx2[0].labels.activation + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$Q(ctx) {
  let if_block_anchor;
  let if_block = (
    /*item*/
    ctx[0].labels.activation && create_if_block$D(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*item*/
        ctx2[0].labels.activation
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$D(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$Q($$self, $$props, $$invalidate) {
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item];
}
class Dnd5eActivation extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$Q, create_fragment$Q, safe_not_equal, { item: 0 });
  }
}
function create_fragment$P(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.ItemActionType")}:`;
      t2 = space();
      t3 = text(
        /*itemActionType*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function instance$P($$self, $$props, $$invalidate) {
  let { actionType } = $$props;
  const itemActionType = CONFIG.DND5E.itemActionTypes[actionType];
  $$self.$$set = ($$props2) => {
    if ("actionType" in $$props2)
      $$invalidate(1, actionType = $$props2.actionType);
  };
  return [itemActionType, actionType];
}
class Dnd5eActivationType extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$P, create_fragment$P, safe_not_equal, { actionType: 1 });
  }
}
function create_if_block$C(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].labels.target + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Target")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && t3_value !== (t3_value = /*item*/
      ctx2[0].labels.target + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$O(ctx) {
  let if_block_anchor;
  let if_block = (
    /*item*/
    ctx[0].labels?.target && create_if_block$C(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*item*/
        ctx2[0].labels?.target
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$C(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$O($$self, $$props, $$invalidate) {
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item];
}
class Dnd5eTarget extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$O, create_fragment$O, safe_not_equal, { item: 0 });
  }
}
function create_if_block$B(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].labels.range + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Range")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && t3_value !== (t3_value = /*item*/
      ctx2[0].labels.range + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$N(ctx) {
  let if_block_anchor;
  let if_block = (
    /*item*/
    ctx[0].labels.range && create_if_block$B(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*item*/
        ctx2[0].labels.range
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$B(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$N($$self, $$props, $$invalidate) {
  let { item } = $$props;
  item.labels.range;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item];
}
class Dnd5eRange extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$N, create_fragment$N, safe_not_equal, { item: 0 });
  }
}
const Dnd5eEquipped_svelte_svelte_type_style_lang = "";
function create_fragment$M(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<i class="fas fa-shield-halved"></i>`;
      attr(button, "class", "item-control item-action svelte-mobile-companion81nkluj30u9vsd-1vqsyfo");
      attr(button, "data-action", "equip");
      attr(button, "aria-label", "Equipped");
      attr(button, "aria-disabled", "false");
      toggle_class(
        button,
        "active",
        /*isEquipped*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(
          /*toggleEquipped*/
          ctx[1]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isEquipped*/
      1) {
        toggle_class(
          button,
          "active",
          /*isEquipped*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance$M($$self, $$props, $$invalidate) {
  let isEquipped;
  let { itemData } = $$props;
  function toggleEquipped() {
    $$invalidate(0, isEquipped = !isEquipped);
    itemData.parent.update({ ["system.equipped"]: isEquipped });
  }
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(2, itemData = $$props2.itemData);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*itemData*/
    4) {
      $$invalidate(0, isEquipped = itemData.equipped);
    }
  };
  return [isEquipped, toggleEquipped, itemData];
}
class Dnd5eEquipped extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$M, create_fragment$M, safe_not_equal, { itemData: 2 });
  }
}
const Dnd5eObject_svelte_svelte_type_style_lang = "";
function create_if_block$A(ctx) {
  let div2;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let div_transition;
  let current;
  let if_block0 = (
    /*item*/
    ctx[0].system.properties?.size > 0 && create_if_block_11(ctx)
  );
  const default_slot_template = (
    /*#slots*/
    ctx[9].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[8],
    null
  );
  let if_block1 = (
    /*itemData*/
    ctx[4].activation && create_if_block_10$1(ctx)
  );
  let if_block2 = (
    /*itemData*/
    ctx[4].actionType && create_if_block_9$2(ctx)
  );
  let if_block3 = (
    /*itemData*/
    ctx[4].target && create_if_block_8$2(ctx)
  );
  let if_block4 = (
    /*itemData*/
    ctx[4].range && create_if_block_7$5(ctx)
  );
  let if_block5 = (
    /*item*/
    ctx[0].hasAttack && create_if_block_6$5(ctx)
  );
  let if_block6 = (
    /*item*/
    ctx[0].hasDamage && create_if_block_5$8(ctx)
  );
  let if_block7 = (
    /*item*/
    ctx[0].hasSave && create_if_block_4$9(ctx)
  );
  let if_block8 = (
    /*item*/
    ctx[0].system.price && create_if_block_3$b(ctx)
  );
  let if_block9 = (
    /*item*/
    ctx[0].system.weight && create_if_block_2$e(ctx)
  );
  let if_block10 = (
    /*item*/
    (ctx[0].system.description || /*item*/
    ctx[0].system.price || /*item*/
    ctx[0].system.weight) && create_if_block_1$n(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (default_slot)
        default_slot.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      t8 = space();
      if (if_block8)
        if_block8.c();
      t9 = space();
      if (if_block9)
        if_block9.c();
      t10 = space();
      if (if_block10)
        if_block10.c();
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      if (default_slot) {
        default_slot.m(div2, null);
      }
      append(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t3);
      if (if_block3)
        if_block3.m(div2, null);
      append(div2, t4);
      if (if_block4)
        if_block4.m(div2, null);
      append(div2, t5);
      if (if_block5)
        if_block5.m(div2, null);
      append(div2, t6);
      if (if_block6)
        if_block6.m(div2, null);
      append(div2, t7);
      if (if_block7)
        if_block7.m(div2, null);
      append(div2, t8);
      if (if_block8)
        if_block8.m(div2, null);
      append(div2, t9);
      if (if_block9)
        if_block9.m(div2, null);
      append(div2, t10);
      if (if_block10)
        if_block10.m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[0].system.properties?.size > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_11(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        256)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[8],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[8]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[8],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (
        /*itemData*/
        ctx2[4].activation
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*itemData*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_10$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*itemData*/
        ctx2[4].actionType
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*itemData*/
          16) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_9$2(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*itemData*/
        ctx2[4].target
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*itemData*/
          16) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_8$2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*itemData*/
        ctx2[4].range
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*itemData*/
          16) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_7$5(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].hasAttack
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_6$5(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, t6);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].hasDamage
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_5$8(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div2, t7);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].hasSave
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_4$9(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div2, t8);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].system.price
      ) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block8, 1);
          }
        } else {
          if_block8 = create_if_block_3$b(ctx2);
          if_block8.c();
          transition_in(if_block8, 1);
          if_block8.m(div2, t9);
        }
      } else if (if_block8) {
        group_outros();
        transition_out(if_block8, 1, 1, () => {
          if_block8 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].system.weight
      ) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block9, 1);
          }
        } else {
          if_block9 = create_if_block_2$e(ctx2);
          if_block9.c();
          transition_in(if_block9, 1);
          if_block9.m(div2, t10);
        }
      } else if (if_block9) {
        group_outros();
        transition_out(if_block9, 1, 1, () => {
          if_block9 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].system.description || /*item*/
        ctx2[0].system.price || /*item*/
        ctx2[0].system.weight
      ) {
        if (if_block10) {
          if_block10.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block10, 1);
          }
        } else {
          if_block10 = create_if_block_1$n(ctx2);
          if_block10.c();
          transition_in(if_block10, 1);
          if_block10.m(div2, null);
        }
      } else if (if_block10) {
        group_outros();
        transition_out(if_block10, 1, 1, () => {
          if_block10 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(default_slot, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(if_block7);
      transition_in(if_block8);
      transition_in(if_block9);
      transition_in(if_block10);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: identity$1, axis: "y" }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(default_slot, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(if_block7);
      transition_out(if_block8);
      transition_out(if_block9);
      transition_out(if_block10);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: identity$1, axis: "y" }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (default_slot)
        default_slot.d(detaching);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      if (if_block9)
        if_block9.d();
      if (if_block10)
        if_block10.d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_11(ctx) {
  let dnd5eobjectproperties;
  let current;
  dnd5eobjectproperties = new Dnd5eObjectProperties({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5eobjectproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eobjectproperties, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eobjectproperties_changes = {};
      if (dirty & /*item*/
      1)
        dnd5eobjectproperties_changes.item = /*item*/
        ctx2[0];
      dnd5eobjectproperties.$set(dnd5eobjectproperties_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eobjectproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eobjectproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eobjectproperties, detaching);
    }
  };
}
function create_if_block_10$1(ctx) {
  let dnd5eactivation;
  let current;
  dnd5eactivation = new Dnd5eActivation({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5eactivation.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eactivation, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eactivation_changes = {};
      if (dirty & /*item*/
      1)
        dnd5eactivation_changes.item = /*item*/
        ctx2[0];
      dnd5eactivation.$set(dnd5eactivation_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eactivation.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eactivation.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eactivation, detaching);
    }
  };
}
function create_if_block_9$2(ctx) {
  let dnd5eactivationtype;
  let current;
  dnd5eactivationtype = new Dnd5eActivationType({
    props: {
      actionType: (
        /*itemData*/
        ctx[4].actionType
      )
    }
  });
  return {
    c() {
      create_component(dnd5eactivationtype.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eactivationtype, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eactivationtype_changes = {};
      if (dirty & /*itemData*/
      16)
        dnd5eactivationtype_changes.actionType = /*itemData*/
        ctx2[4].actionType;
      dnd5eactivationtype.$set(dnd5eactivationtype_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eactivationtype.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eactivationtype.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eactivationtype, detaching);
    }
  };
}
function create_if_block_8$2(ctx) {
  let dnd5etarget;
  let current;
  dnd5etarget = new Dnd5eTarget({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5etarget.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5etarget, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5etarget_changes = {};
      if (dirty & /*item*/
      1)
        dnd5etarget_changes.item = /*item*/
        ctx2[0];
      dnd5etarget.$set(dnd5etarget_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5etarget.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5etarget.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5etarget, detaching);
    }
  };
}
function create_if_block_7$5(ctx) {
  let dnd5erange;
  let current;
  dnd5erange = new Dnd5eRange({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5erange.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5erange, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5erange_changes = {};
      if (dirty & /*item*/
      1)
        dnd5erange_changes.item = /*item*/
        ctx2[0];
      dnd5erange.$set(dnd5erange_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5erange.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5erange.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5erange, detaching);
    }
  };
}
function create_if_block_6$5(ctx) {
  let dnd5eattack;
  let current;
  dnd5eattack = new Dnd5eAttack({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5eattack.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eattack, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eattack_changes = {};
      if (dirty & /*item*/
      1)
        dnd5eattack_changes.item = /*item*/
        ctx2[0];
      dnd5eattack.$set(dnd5eattack_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eattack.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eattack.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eattack, detaching);
    }
  };
}
function create_if_block_5$8(ctx) {
  let dnd5edamage;
  let current;
  dnd5edamage = new Dnd5eDamage({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5edamage.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5edamage, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5edamage_changes = {};
      if (dirty & /*item*/
      1)
        dnd5edamage_changes.item = /*item*/
        ctx2[0];
      dnd5edamage.$set(dnd5edamage_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5edamage.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5edamage.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5edamage, detaching);
    }
  };
}
function create_if_block_4$9(ctx) {
  let dnd5esave;
  let current;
  dnd5esave = new Dnd5eSave({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5esave.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5esave, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5esave_changes = {};
      if (dirty & /*item*/
      1)
        dnd5esave_changes.item = /*item*/
        ctx2[0];
      dnd5esave.$set(dnd5esave_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5esave.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5esave.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5esave, detaching);
    }
  };
}
function create_if_block_3$b(ctx) {
  let dnd5eprice;
  let current;
  dnd5eprice = new Dnd5ePrice({
    props: { price: (
      /*item*/
      ctx[0].system.price
    ) }
  });
  return {
    c() {
      create_component(dnd5eprice.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eprice, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eprice_changes = {};
      if (dirty & /*item*/
      1)
        dnd5eprice_changes.price = /*item*/
        ctx2[0].system.price;
      dnd5eprice.$set(dnd5eprice_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eprice.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eprice.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eprice, detaching);
    }
  };
}
function create_if_block_2$e(ctx) {
  let dnd5eweight;
  let current;
  dnd5eweight = new Dnd5eWeight({
    props: { weight: (
      /*item*/
      ctx[0].system.weight
    ) }
  });
  return {
    c() {
      create_component(dnd5eweight.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eweight, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eweight_changes = {};
      if (dirty & /*item*/
      1)
        dnd5eweight_changes.weight = /*item*/
        ctx2[0].system.weight;
      dnd5eweight.$set(dnd5eweight_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eweight.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eweight.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eweight, detaching);
    }
  };
}
function create_if_block_1$n(ctx) {
  let dnd5edescription;
  let current;
  dnd5edescription = new Dnd5eDescription({
    props: { itemData: (
      /*item*/
      ctx[0].system
    ) }
  });
  return {
    c() {
      create_component(dnd5edescription.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5edescription, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5edescription_changes = {};
      if (dirty & /*item*/
      1)
        dnd5edescription_changes.itemData = /*item*/
        ctx2[0].system;
      dnd5edescription.$set(dnd5edescription_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5edescription.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5edescription.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5edescription, detaching);
    }
  };
}
function create_fragment$L(ctx) {
  let section;
  let div2;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1;
  let t2;
  let div1;
  let dnd5eequipped;
  let t3;
  let quantity;
  let t4;
  let current;
  let mounted;
  let dispose;
  dnd5eequipped = new Dnd5eEquipped({ props: { itemData: (
    /*itemData*/
    ctx[4]
  ) } });
  quantity = new Quantity({
    props: {
      quantity: (
        /*item*/
        ctx[0].system.quantity
      ),
      fontFamily: "var(--dnd5e-font-roboto)"
    }
  });
  quantity.$on(
    "onQtyChange",
    /*handleQtyChange*/
    ctx[6]
  );
  let if_block = (
    /*showItemData*/
    ctx[2] && create_if_block$A(ctx)
  );
  return {
    c() {
      section = element("section");
      div2 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(
        /*name*/
        ctx[3]
      );
      t2 = space();
      div1 = element("div");
      create_component(dnd5eequipped.$$.fragment);
      t3 = space();
      create_component(quantity.$$.fragment);
      t4 = space();
      if (if_block)
        if_block.c();
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[0].img))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*name*/
        ctx[3]
      );
      attr(img, "class", "item-icon svelte-mobile-companion81nkluj30u9vsd-1h7794f");
      attr(div0, "class", "item svelte-mobile-companion81nkluj30u9vsd-1h7794f");
      attr(div0, "aria-hidden", "true");
      attr(div1, "class", "equipped-and-qty svelte-mobile-companion81nkluj30u9vsd-1h7794f");
      attr(div2, "class", "item-container svelte-mobile-companion81nkluj30u9vsd-1h7794f");
      attr(section, "class", "svelte-mobile-companion81nkluj30u9vsd-1h7794f");
      toggle_class(
        section,
        "odd",
        /*isOddLine*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div2, t2);
      append(div2, div1);
      mount_component(dnd5eequipped, div1, null);
      append(div1, t3);
      mount_component(quantity, div1, null);
      append(section, t4);
      if (if_block)
        if_block.m(section, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "click",
          /*toggleDescription*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*item*/
      1 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx2[0].img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*name*/
      8) {
        attr(
          img,
          "alt",
          /*name*/
          ctx2[3]
        );
      }
      if (!current || dirty & /*name*/
      8)
        set_data(
          t1,
          /*name*/
          ctx2[3]
        );
      const dnd5eequipped_changes = {};
      if (dirty & /*itemData*/
      16)
        dnd5eequipped_changes.itemData = /*itemData*/
        ctx2[4];
      dnd5eequipped.$set(dnd5eequipped_changes);
      const quantity_changes = {};
      if (dirty & /*item*/
      1)
        quantity_changes.quantity = /*item*/
        ctx2[0].system.quantity;
      quantity.$set(quantity_changes);
      if (
        /*showItemData*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*showItemData*/
          4) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$A(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(section, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty & /*isOddLine*/
      2) {
        toggle_class(
          section,
          "odd",
          /*isOddLine*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eequipped.$$.fragment, local);
      transition_in(quantity.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(dnd5eequipped.$$.fragment, local);
      transition_out(quantity.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_component(dnd5eequipped);
      destroy_component(quantity);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$L($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { item } = $$props;
  let { isOddLine } = $$props;
  let showItemData = false;
  let name2, identified;
  let itemData = item.system;
  function toggleDescription() {
    $$invalidate(2, showItemData = !showItemData);
  }
  function handleQtyChange(event) {
    const update2 = { system: { quantity: event.detail } };
    item.update(update2);
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("isOddLine" in $$props2)
      $$invalidate(1, isOddLine = $$props2.isOddLine);
    if ("$$scope" in $$props2)
      $$invalidate(8, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item, identified*/
    129) {
      {
        $$invalidate(4, itemData = item.system);
        $$invalidate(7, identified = item.system.identified);
        if (identified) {
          $$invalidate(3, name2 = item.name);
        } else {
          $$invalidate(3, name2 = item.system.unidentified.name);
        }
      }
    }
  };
  return [
    item,
    isOddLine,
    showItemData,
    name2,
    itemData,
    toggleDescription,
    handleQtyChange,
    identified,
    $$scope,
    slots
  ];
}
class Dnd5eObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$L, create_fragment$L, safe_not_equal, { item: 0, isOddLine: 1 });
  }
}
async function evaluateTotal(formula, rollData) {
  let roll;
  if (rollData) {
    roll = new Roll(formula, rollData);
  } else {
    roll = new Roll(formula);
  }
  await roll.evaluate();
  return roll.total;
}
function evaluateAsFormula(formula, rollData) {
  let roll;
  if (rollData) {
    roll = new Roll(formula, rollData);
  } else {
    roll = new Roll(formula);
  }
  let output = roll.formula;
  output = matchMin(output);
  output = matchMax(output);
  output = removeZeroes(output);
  output = removePlusMinus(output);
  return output;
}
function evaluateDiceExpression(expression) {
  const tokens = expression.split(" ");
  const result = [];
  let sum2 = 0;
  let previousOperator;
  function addAndResetSum() {
    if (sum2 > 0) {
      result.push("+");
      result.push(String(sum2));
      sum2 = 0;
    } else if (sum2 < 0) {
      result.push("-");
      result.push(String(sum2));
      sum2 = 0;
    }
  }
  for (let i2 = 0; i2 < tokens.length; i2++) {
    const token = tokens[i2];
    if (token === "+" || token === "-") {
      previousOperator = token;
    } else if (!isNaN(+token)) {
      if (previousOperator) {
        switch (previousOperator) {
          case "+":
            sum2 += +token;
            break;
          case "-":
            sum2 -= +token;
            break;
        }
      } else {
        sum2 += +token;
      }
    } else {
      addAndResetSum();
      if (previousOperator) {
        result.push(previousOperator);
        previousOperator = void 0;
      }
      result.push(token);
    }
  }
  addAndResetSum();
  const returnValue = result.join(" ");
  if (returnValue.startsWith("+ ")) {
    return returnValue.slice(2);
  } else if (returnValue.startsWith("- ")) {
    return returnValue.slice(2);
  } else {
    return returnValue;
  }
}
function matchMin(output) {
  return output.replace(/min\(([^)]+)\)/g, (_match, p1) => {
    const parameters = p1.split(",").map(Number);
    return Math.min(...parameters).toString();
  });
}
function matchMax(output) {
  return output.replace(/max\(([^)]+)\)/g, (_match, p1) => {
    const parameters = p1.split(",").map(Number);
    return Math.max(...parameters).toString();
  });
}
function removeZeroes(output) {
  return output.replace(/\s[-+]\s0/g, "");
}
function removePlusMinus(output) {
  return output.replace(/\+\s*-\s*/g, "- ");
}
function create_catch_block$5(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$5(ctx) {
  let t0_value = (
    /*item*/
    ctx[0].type.value === "shield" ? "+" : ""
  );
  let t0;
  let t1_value = (
    /*total*/
    ctx[4] + ""
  );
  let t1;
  return {
    c() {
      t0 = text(t0_value);
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && t0_value !== (t0_value = /*item*/
      ctx2[0].type.value === "shield" ? "+" : ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_pending_block$5(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_if_block_1$m(ctx) {
  let t0;
  let t1_value = (
    /*item*/
    ctx[0].armor.value + ""
  );
  let t1;
  let t2;
  let t3_value = Math.min(
    /*rollData*/
    ctx[1].abilities.dex.mod,
    /*item*/
    ctx[0].armor.dex
  ) + "";
  let t3;
  let t4;
  let t5_value = i18n("DND5E.AbilityDex") + "";
  let t5;
  let t6;
  return {
    c() {
      t0 = text("(");
      t1 = text(t1_value);
      t2 = text(" + ");
      t3 = text(t3_value);
      t4 = space();
      t5 = text(t5_value);
      t6 = text(")");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
      insert(target, t3, anchor);
      insert(target, t4, anchor);
      insert(target, t5, anchor);
      insert(target, t6, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && t1_value !== (t1_value = /*item*/
      ctx2[0].armor.value + ""))
        set_data(t1, t1_value);
      if (dirty & /*rollData, item*/
      3 && t3_value !== (t3_value = Math.min(
        /*rollData*/
        ctx2[1].abilities.dex.mod,
        /*item*/
        ctx2[0].armor.dex
      ) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(t5);
        detach(t6);
      }
    }
  };
}
function create_if_block$z(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].strength + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.ItemRequiredStr")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && t3_value !== (t3_value = /*item*/
      ctx2[0].strength + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$K(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  let t4;
  let if_block1_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$5,
    then: create_then_block$5,
    catch: create_catch_block$5,
    value: 4
  };
  handle_promise(
    /*totalAc*/
    ctx[2],
    info
  );
  let if_block0 = (
    /*item*/
    ctx[0].armor.dex && create_if_block_1$m(ctx)
  );
  let if_block1 = (
    /*item*/
    ctx[0].strength && create_if_block$z(ctx)
  );
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.ArmorClass")}:`;
      t2 = space();
      info.block.c();
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      info.block.m(p, info.anchor = null);
      info.mount = () => p;
      info.anchor = t3;
      append(p, t3);
      if (if_block0)
        if_block0.m(p, null);
      insert(target, t4, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (
        /*item*/
        ctx[0].armor.dex
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_1$m(ctx);
          if_block0.c();
          if_block0.m(p, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*item*/
        ctx[0].strength
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block$z(ctx);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
        detach(t4);
        detach(if_block1_anchor);
      }
      info.block.d();
      info.token = null;
      info = null;
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$K($$self, $$props, $$invalidate) {
  let { item } = $$props;
  let { rollData } = $$props;
  const formula = item.armor.value + ` + min(${item.armor.dex ? item.armor.dex : 0},@abilities.dex.mod)`;
  let totalAc = evaluateTotal(formula, rollData);
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("rollData" in $$props2)
      $$invalidate(1, rollData = $$props2.rollData);
  };
  return [item, rollData, totalAc];
}
class Dnd5eArmorClass extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$K, create_fragment$K, safe_not_equal, { item: 0, rollData: 1 });
  }
}
function create_if_block_1$l(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Type")}:`;
      t2 = space();
      t3 = text(
        /*equipmentType*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$y(ctx) {
  let dnd5earmorclass;
  let current;
  dnd5earmorclass = new Dnd5eArmorClass({
    props: {
      item: (
        /*itemData*/
        ctx[1]
      ),
      rollData: (
        /*rollData*/
        ctx[0]
      )
    }
  });
  return {
    c() {
      create_component(dnd5earmorclass.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5earmorclass, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5earmorclass_changes = {};
      if (dirty & /*rollData*/
      1)
        dnd5earmorclass_changes.rollData = /*rollData*/
        ctx2[0];
      dnd5earmorclass.$set(dnd5earmorclass_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5earmorclass.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5earmorclass.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5earmorclass, detaching);
    }
  };
}
function create_fragment$J(ctx) {
  let t;
  let if_block1_anchor;
  let current;
  let if_block0 = (
    /*equipmentType*/
    ctx[2] && create_if_block_1$l(ctx)
  );
  let if_block1 = (
    /*itemData*/
    ctx[1].armor?.value && create_if_block$y(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*equipmentType*/
        ctx2[2]
      )
        if_block0.p(ctx2, dirty);
      if (
        /*itemData*/
        ctx2[1].armor?.value
      )
        if_block1.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$J($$self, $$props, $$invalidate) {
  let { item } = $$props;
  let { rollData } = $$props;
  let itemData = item.system;
  const equipmentType = CONFIG.DND5E.equipmentTypes[itemData.type.value];
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(3, item = $$props2.item);
    if ("rollData" in $$props2)
      $$invalidate(0, rollData = $$props2.rollData);
  };
  return [rollData, itemData, equipmentType, item];
}
class Dnd5eEquipmentObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$J, create_fragment$J, safe_not_equal, { item: 3, rollData: 0 });
  }
}
function create_if_block$x(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Type")}:`;
      t2 = space();
      t3 = text(
        /*lootType*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$I(ctx) {
  let if_block_anchor;
  let if_block = (
    /*lootType*/
    ctx[0] && create_if_block$x(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*lootType*/
        ctx2[0]
      )
        if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$I($$self, $$props, $$invalidate) {
  var _a;
  let { item } = $$props;
  const itemData = item.system;
  const lootType = (_a = CONFIG.DND5E.lootTypes[itemData.type.value]) === null || _a === void 0 ? void 0 : _a.label;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  return [lootType, item];
}
class Dnd5eLootObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$I, create_fragment$I, safe_not_equal, { item: 1 });
  }
}
function create_if_block$w(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Ability")}:`;
      t2 = space();
      t3 = text(
        /*ability*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$H(ctx) {
  let if_block_anchor;
  let if_block = (
    /*ability*/
    ctx[0] && create_if_block$w(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*ability*/
        ctx2[0]
      )
        if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$H($$self, $$props, $$invalidate) {
  var _a;
  let { item } = $$props;
  let itemData = item.system;
  let ability = (_a = CONFIG.DND5E.abilities[itemData.ability]) === null || _a === void 0 ? void 0 : _a.label;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  return [ability, item];
}
class Dnd5eToolObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$H, create_fragment$H, safe_not_equal, { item: 1 });
  }
}
function create_if_block$v(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.ItemWeaponType")}:`;
      t2 = space();
      t3 = text(
        /*weaponType*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$G(ctx) {
  let if_block_anchor;
  let if_block = (
    /*weaponType*/
    ctx[0] && create_if_block$v(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*weaponType*/
        ctx2[0]
      )
        if_block.p(ctx2, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$G($$self, $$props, $$invalidate) {
  let { item } = $$props;
  let itemData = item.system;
  const weaponType = CONFIG.DND5E.weaponTypes[itemData.type.value];
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(1, item = $$props2.item);
  };
  return [weaponType, item];
}
class Dnd5eWeaponObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$G, create_fragment$G, safe_not_equal, { item: 1 });
  }
}
const Dnd5eObjects_svelte_svelte_type_style_lang = "";
function get_each_context$c(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function get_each_context_1$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[15] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function get_each_context_2$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[17] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function get_each_context_3$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function get_each_context_4$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function get_each_context_5$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i2];
  child_ctx[14] = i2;
  return child_ctx;
}
function create_if_block_5$7(ctx) {
  let section;
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_5 = ensure_array_like(
    /*weapons*/
    ctx[6]
  );
  const get_key = (ctx2) => (
    /*weapon*/
    ctx2[23].id
  );
  for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
    let child_ctx = get_each_context_5$2(ctx, each_value_5, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_5$2(key, child_ctx));
  }
  return {
    c() {
      section = element("section");
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("ITEM.TypeWeaponPl")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "svelte-mobile-companion81nkluj30u9vsd-gev2ve");
      attr(div2, "class", "item-list-header svelte-mobile-companion81nkluj30u9vsd-gev2ve");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, h3);
      append(section, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*weapons*/
      64) {
        each_value_5 = ensure_array_like(
          /*weapons*/
          ctx2[6]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_5, each_1_lookup, section, outro_and_destroy_block, create_each_block_5$2, null, get_each_context_5$2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_default_slot_5(ctx) {
  let dnd5eweaponobject;
  let t;
  let current;
  dnd5eweaponobject = new Dnd5eWeaponObject({ props: { item: (
    /*weapon*/
    ctx[23]
  ) } });
  return {
    c() {
      create_component(dnd5eweaponobject.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(dnd5eweaponobject, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eweaponobject_changes = {};
      if (dirty & /*weapons*/
      64)
        dnd5eweaponobject_changes.item = /*weapon*/
        ctx2[23];
      dnd5eweaponobject.$set(dnd5eweaponobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eweaponobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eweaponobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(dnd5eweaponobject, detaching);
    }
  };
}
function create_each_block_5$2(key_1, ctx) {
  let first;
  let dnd5eobject;
  let current;
  dnd5eobject = new Dnd5eObject({
    props: {
      item: (
        /*weapon*/
        ctx[23]
      ),
      isOddLine: (
        /*index*/
        ctx[14] % 2 !== 0
      ),
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(dnd5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(dnd5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const dnd5eobject_changes = {};
      if (dirty & /*weapons*/
      64)
        dnd5eobject_changes.item = /*weapon*/
        ctx[23];
      if (dirty & /*weapons*/
      64)
        dnd5eobject_changes.isOddLine = /*index*/
        ctx[14] % 2 !== 0;
      if (dirty & /*$$scope, weapons*/
      33554496) {
        dnd5eobject_changes.$$scope = { dirty, ctx };
      }
      dnd5eobject.$set(dnd5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(dnd5eobject, detaching);
    }
  };
}
function create_if_block_4$8(ctx) {
  let section;
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_4 = ensure_array_like(
    /*equipments*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*equipment*/
    ctx2[21].id
  );
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    let child_ctx = get_each_context_4$2(ctx, each_value_4, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_4$2(key, child_ctx));
  }
  return {
    c() {
      section = element("section");
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("ITEM.TypeEquipmentPl")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "svelte-mobile-companion81nkluj30u9vsd-gev2ve");
      attr(div2, "class", "item-list-header svelte-mobile-companion81nkluj30u9vsd-gev2ve");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, h3);
      append(section, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*equipments, actor*/
      9) {
        each_value_4 = ensure_array_like(
          /*equipments*/
          ctx2[3]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_4, each_1_lookup, section, outro_and_destroy_block, create_each_block_4$2, null, get_each_context_4$2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_default_slot_4(ctx) {
  let dnd5eequipmentobject;
  let t;
  let current;
  dnd5eequipmentobject = new Dnd5eEquipmentObject({
    props: {
      item: (
        /*equipment*/
        ctx[21]
      ),
      rollData: (
        /*actor*/
        ctx[0].getRollData(
          /*equipment*/
          ctx[21]
        )
      )
    }
  });
  return {
    c() {
      create_component(dnd5eequipmentobject.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(dnd5eequipmentobject, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eequipmentobject_changes = {};
      if (dirty & /*equipments*/
      8)
        dnd5eequipmentobject_changes.item = /*equipment*/
        ctx2[21];
      if (dirty & /*actor, equipments*/
      9)
        dnd5eequipmentobject_changes.rollData = /*actor*/
        ctx2[0].getRollData(
          /*equipment*/
          ctx2[21]
        );
      dnd5eequipmentobject.$set(dnd5eequipmentobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eequipmentobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eequipmentobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(dnd5eequipmentobject, detaching);
    }
  };
}
function create_each_block_4$2(key_1, ctx) {
  let first;
  let dnd5eobject;
  let current;
  dnd5eobject = new Dnd5eObject({
    props: {
      item: (
        /*equipment*/
        ctx[21]
      ),
      isOddLine: (
        /*index*/
        ctx[14] % 2 !== 0
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(dnd5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(dnd5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const dnd5eobject_changes = {};
      if (dirty & /*equipments*/
      8)
        dnd5eobject_changes.item = /*equipment*/
        ctx[21];
      if (dirty & /*equipments*/
      8)
        dnd5eobject_changes.isOddLine = /*index*/
        ctx[14] % 2 !== 0;
      if (dirty & /*$$scope, equipments, actor*/
      33554441) {
        dnd5eobject_changes.$$scope = { dirty, ctx };
      }
      dnd5eobject.$set(dnd5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(dnd5eobject, detaching);
    }
  };
}
function create_if_block_3$a(ctx) {
  let section;
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_3 = ensure_array_like(
    /*consumables*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*consumable*/
    ctx2[19].id
  );
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    let child_ctx = get_each_context_3$2(ctx, each_value_3, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_3$2(key, child_ctx));
  }
  return {
    c() {
      section = element("section");
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("ITEM.TypeConsumablePl")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "svelte-mobile-companion81nkluj30u9vsd-gev2ve");
      attr(div2, "class", "item-list-header svelte-mobile-companion81nkluj30u9vsd-gev2ve");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, h3);
      append(section, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*consumables*/
      4) {
        each_value_3 = ensure_array_like(
          /*consumables*/
          ctx2[2]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_3, each_1_lookup, section, outro_and_destroy_block, create_each_block_3$2, null, get_each_context_3$2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_default_slot_3(ctx) {
  let dnd5econsumableobject;
  let t;
  let current;
  dnd5econsumableobject = new Dnd5eConsumableObject({ props: { item: (
    /*consumable*/
    ctx[19]
  ) } });
  return {
    c() {
      create_component(dnd5econsumableobject.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(dnd5econsumableobject, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5econsumableobject_changes = {};
      if (dirty & /*consumables*/
      4)
        dnd5econsumableobject_changes.item = /*consumable*/
        ctx2[19];
      dnd5econsumableobject.$set(dnd5econsumableobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5econsumableobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5econsumableobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(dnd5econsumableobject, detaching);
    }
  };
}
function create_each_block_3$2(key_1, ctx) {
  let first;
  let dnd5eobject;
  let current;
  dnd5eobject = new Dnd5eObject({
    props: {
      item: (
        /*consumable*/
        ctx[19]
      ),
      isOddLine: (
        /*index*/
        ctx[14] % 2 !== 0
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(dnd5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(dnd5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const dnd5eobject_changes = {};
      if (dirty & /*consumables*/
      4)
        dnd5eobject_changes.item = /*consumable*/
        ctx[19];
      if (dirty & /*consumables*/
      4)
        dnd5eobject_changes.isOddLine = /*index*/
        ctx[14] % 2 !== 0;
      if (dirty & /*$$scope, consumables*/
      33554436) {
        dnd5eobject_changes.$$scope = { dirty, ctx };
      }
      dnd5eobject.$set(dnd5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(dnd5eobject, detaching);
    }
  };
}
function create_if_block_2$d(ctx) {
  let section;
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_2 = ensure_array_like(
    /*tools*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*tool*/
    ctx2[17].id
  );
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    let child_ctx = get_each_context_2$3(ctx, each_value_2, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_2$3(key, child_ctx));
  }
  return {
    c() {
      section = element("section");
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("ITEM.TypeToolPl")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "svelte-mobile-companion81nkluj30u9vsd-gev2ve");
      attr(div2, "class", "item-list-header svelte-mobile-companion81nkluj30u9vsd-gev2ve");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, h3);
      append(section, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*tools*/
      32) {
        each_value_2 = ensure_array_like(
          /*tools*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, section, outro_and_destroy_block, create_each_block_2$3, null, get_each_context_2$3);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_default_slot_2(ctx) {
  let dnd5etoolobject;
  let t;
  let current;
  dnd5etoolobject = new Dnd5eToolObject({ props: { item: (
    /*tool*/
    ctx[17]
  ) } });
  return {
    c() {
      create_component(dnd5etoolobject.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(dnd5etoolobject, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5etoolobject_changes = {};
      if (dirty & /*tools*/
      32)
        dnd5etoolobject_changes.item = /*tool*/
        ctx2[17];
      dnd5etoolobject.$set(dnd5etoolobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5etoolobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5etoolobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(dnd5etoolobject, detaching);
    }
  };
}
function create_each_block_2$3(key_1, ctx) {
  let first;
  let dnd5eobject;
  let current;
  dnd5eobject = new Dnd5eObject({
    props: {
      item: (
        /*tool*/
        ctx[17]
      ),
      isOddLine: (
        /*index*/
        ctx[14] % 2 !== 0
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(dnd5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(dnd5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const dnd5eobject_changes = {};
      if (dirty & /*tools*/
      32)
        dnd5eobject_changes.item = /*tool*/
        ctx[17];
      if (dirty & /*tools*/
      32)
        dnd5eobject_changes.isOddLine = /*index*/
        ctx[14] % 2 !== 0;
      if (dirty & /*$$scope, tools*/
      33554464) {
        dnd5eobject_changes.$$scope = { dirty, ctx };
      }
      dnd5eobject.$set(dnd5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(dnd5eobject, detaching);
    }
  };
}
function create_if_block_1$k(ctx) {
  let section;
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value_1 = ensure_array_like(
    /*loots*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*loot*/
    ctx2[15].id
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$4(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$4(key, child_ctx));
  }
  return {
    c() {
      section = element("section");
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("ITEM.TypeLootPl")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "svelte-mobile-companion81nkluj30u9vsd-gev2ve");
      attr(div2, "class", "item-list-header svelte-mobile-companion81nkluj30u9vsd-gev2ve");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, h3);
      append(section, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*loots*/
      16) {
        each_value_1 = ensure_array_like(
          /*loots*/
          ctx2[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, section, outro_and_destroy_block, create_each_block_1$4, null, get_each_context_1$4);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_default_slot_1(ctx) {
  let dnd5elootobject;
  let t;
  let current;
  dnd5elootobject = new Dnd5eLootObject({ props: { item: (
    /*loot*/
    ctx[15]
  ) } });
  return {
    c() {
      create_component(dnd5elootobject.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(dnd5elootobject, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5elootobject_changes = {};
      if (dirty & /*loots*/
      16)
        dnd5elootobject_changes.item = /*loot*/
        ctx2[15];
      dnd5elootobject.$set(dnd5elootobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5elootobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5elootobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(dnd5elootobject, detaching);
    }
  };
}
function create_each_block_1$4(key_1, ctx) {
  let first;
  let dnd5eobject;
  let current;
  dnd5eobject = new Dnd5eObject({
    props: {
      item: (
        /*loot*/
        ctx[15]
      ),
      isOddLine: (
        /*index*/
        ctx[14] % 2 !== 0
      ),
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(dnd5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(dnd5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const dnd5eobject_changes = {};
      if (dirty & /*loots*/
      16)
        dnd5eobject_changes.item = /*loot*/
        ctx[15];
      if (dirty & /*loots*/
      16)
        dnd5eobject_changes.isOddLine = /*index*/
        ctx[14] % 2 !== 0;
      if (dirty & /*$$scope, loots*/
      33554448) {
        dnd5eobject_changes.$$scope = { dirty, ctx };
      }
      dnd5eobject.$set(dnd5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(dnd5eobject, detaching);
    }
  };
}
function create_if_block$u(ctx) {
  let section;
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let current;
  let each_value = ensure_array_like(
    /*containers*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*container*/
    ctx2[12].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$c(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$c(key, child_ctx));
  }
  return {
    c() {
      section = element("section");
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("ITEM.TypeContainerPl")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(h3, "class", "svelte-mobile-companion81nkluj30u9vsd-gev2ve");
      attr(div2, "class", "item-list-header svelte-mobile-companion81nkluj30u9vsd-gev2ve");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, h3);
      append(section, t1);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*containers*/
      2) {
        each_value = ensure_array_like(
          /*containers*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, section, outro_and_destroy_block, create_each_block$c, null, get_each_context$c);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function create_default_slot$3(ctx) {
  let dnd5econtainerobject;
  let t;
  let current;
  dnd5econtainerobject = new Dnd5eContainerObject({ props: { item: (
    /*container*/
    ctx[12]
  ) } });
  return {
    c() {
      create_component(dnd5econtainerobject.$$.fragment);
      t = space();
    },
    m(target, anchor) {
      mount_component(dnd5econtainerobject, target, anchor);
      insert(target, t, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5econtainerobject_changes = {};
      if (dirty & /*containers*/
      2)
        dnd5econtainerobject_changes.item = /*container*/
        ctx2[12];
      dnd5econtainerobject.$set(dnd5econtainerobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5econtainerobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5econtainerobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
      destroy_component(dnd5econtainerobject, detaching);
    }
  };
}
function create_each_block$c(key_1, ctx) {
  let first;
  let dnd5eobject;
  let current;
  dnd5eobject = new Dnd5eObject({
    props: {
      item: (
        /*container*/
        ctx[12]
      ),
      isOddLine: (
        /*index*/
        ctx[14] % 2 !== 0
      ),
      $$slots: { default: [create_default_slot$3] },
      $$scope: { ctx }
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(dnd5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(dnd5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const dnd5eobject_changes = {};
      if (dirty & /*containers*/
      2)
        dnd5eobject_changes.item = /*container*/
        ctx[12];
      if (dirty & /*containers*/
      2)
        dnd5eobject_changes.isOddLine = /*index*/
        ctx[14] % 2 !== 0;
      if (dirty & /*$$scope, containers*/
      33554434) {
        dnd5eobject_changes.$$scope = { dirty, ctx };
      }
      dnd5eobject.$set(dnd5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(dnd5eobject, detaching);
    }
  };
}
function create_fragment$F(ctx) {
  let section;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let current;
  let if_block0 = (
    /*weapons*/
    ctx[6].length > 0 && create_if_block_5$7(ctx)
  );
  let if_block1 = (
    /*equipments*/
    ctx[3].length > 0 && create_if_block_4$8(ctx)
  );
  let if_block2 = (
    /*consumables*/
    ctx[2].length > 0 && create_if_block_3$a(ctx)
  );
  let if_block3 = (
    /*tools*/
    ctx[5].length > 0 && create_if_block_2$d(ctx)
  );
  let if_block4 = (
    /*loots*/
    ctx[4].length > 0 && create_if_block_1$k(ctx)
  );
  let if_block5 = (
    /*containers*/
    ctx[1].length > 0 && showContainers && create_if_block$u(ctx)
  );
  return {
    c() {
      section = element("section");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      attr(section, "class", "content-scroll-list");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (if_block0)
        if_block0.m(section, null);
      append(section, t0);
      if (if_block1)
        if_block1.m(section, null);
      append(section, t1);
      if (if_block2)
        if_block2.m(section, null);
      append(section, t2);
      if (if_block3)
        if_block3.m(section, null);
      append(section, t3);
      if (if_block4)
        if_block4.m(section, null);
      append(section, t4);
      if (if_block5)
        if_block5.m(section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*weapons*/
        ctx2[6].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*weapons*/
          64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(section, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*equipments*/
        ctx2[3].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*equipments*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_4$8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*consumables*/
        ctx2[2].length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*consumables*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_3$a(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(section, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*tools*/
        ctx2[5].length > 0
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*tools*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_2$d(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(section, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*loots*/
        ctx2[4].length > 0
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*loots*/
          16) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_1$k(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(section, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*containers*/
        ctx2[1].length > 0 && showContainers
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*containers*/
          2) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block$u(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(section, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
    }
  };
}
const showContainers = false;
function instance$F($$self, $$props, $$invalidate) {
  let { actor } = $$props;
  let containers;
  let consumables;
  let equipments;
  let loots;
  let tools;
  let weapons;
  let isUsingEncumbrance = true;
  let isUsingCurrency = true;
  const unsubscribeEncumbrance = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useEncumbrance).subscribe((value) => {
    $$invalidate(7, isUsingEncumbrance = value);
  });
  const unsubscribeCurrency = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useCurrency).subscribe((value) => {
    $$invalidate(8, isUsingCurrency = value);
  });
  onDestroy(() => {
    unsubscribeEncumbrance();
    unsubscribeCurrency();
  });
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(0, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    1) {
      {
        $$invalidate(1, containers = actor.itemTypes.container);
        $$invalidate(2, consumables = actor.itemTypes.consumable);
        $$invalidate(3, equipments = actor.itemTypes.equipment);
        $$invalidate(4, loots = actor.itemTypes.loot);
        $$invalidate(5, tools = actor.itemTypes.tool);
        $$invalidate(6, weapons = actor.itemTypes.weapon);
      }
    }
    if ($$self.$$.dirty & /*isUsingCurrency, additionalHeight, isUsingEncumbrance*/
    896)
      ;
  };
  return [
    actor,
    containers,
    consumables,
    equipments,
    loots,
    tools,
    weapons,
    isUsingEncumbrance,
    isUsingCurrency
  ];
}
class Dnd5eObjects extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$F, create_fragment$F, safe_not_equal, { actor: 0 });
  }
}
function create_if_block_1$j(ctx) {
  let dnd5ecurrency;
  let current;
  dnd5ecurrency = new Dnd5eCurrency({ props: { actor: (
    /*actor*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5ecurrency.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5ecurrency, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5ecurrency_changes = {};
      if (dirty & /*actor*/
      1)
        dnd5ecurrency_changes.actor = /*actor*/
        ctx2[0];
      dnd5ecurrency.$set(dnd5ecurrency_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5ecurrency.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5ecurrency.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5ecurrency, detaching);
    }
  };
}
function create_if_block$t(ctx) {
  let dnd5eencumbrance;
  let current;
  dnd5eencumbrance = new Dnd5eEncumbrance({ props: { actor: (
    /*actor*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(dnd5eencumbrance.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5eencumbrance, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5eencumbrance_changes = {};
      if (dirty & /*actor*/
      1)
        dnd5eencumbrance_changes.actor = /*actor*/
        ctx2[0];
      dnd5eencumbrance.$set(dnd5eencumbrance_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5eencumbrance.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5eencumbrance.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5eencumbrance, detaching);
    }
  };
}
function create_fragment$E(ctx) {
  let section;
  let t0;
  let t1;
  let dnd5eobjects;
  let current;
  let if_block0 = (
    /*isUsingCurrency*/
    ctx[1] && create_if_block_1$j(ctx)
  );
  let if_block1 = (
    /*isUsingEncumbrance*/
    ctx[2] && create_if_block$t(ctx)
  );
  dnd5eobjects = new Dnd5eObjects({ props: { actor: (
    /*actor*/
    ctx[0]
  ) } });
  return {
    c() {
      section = element("section");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      create_component(dnd5eobjects.$$.fragment);
      attr(section, "class", "category-content");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (if_block0)
        if_block0.m(section, null);
      append(section, t0);
      if (if_block1)
        if_block1.m(section, null);
      append(section, t1);
      mount_component(dnd5eobjects, section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*isUsingCurrency*/
        ctx2[1]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*isUsingCurrency*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_1$j(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(section, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*isUsingEncumbrance*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*isUsingEncumbrance*/
          4) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$t(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      const dnd5eobjects_changes = {};
      if (dirty & /*actor*/
      1)
        dnd5eobjects_changes.actor = /*actor*/
        ctx2[0];
      dnd5eobjects.$set(dnd5eobjects_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(dnd5eobjects.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(dnd5eobjects.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      destroy_component(dnd5eobjects);
    }
  };
}
function instance$E($$self, $$props, $$invalidate) {
  let { actor } = $$props;
  let isUsingCurrency = true;
  const unsubscribeCurrency = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useCurrency).subscribe((value) => {
    $$invalidate(1, isUsingCurrency = value);
  });
  let isUsingEncumbrance = true;
  const unsubscribeEncumbrance = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useEncumbrance).subscribe((value) => {
    $$invalidate(2, isUsingEncumbrance = value);
  });
  onDestroy(() => {
    unsubscribeCurrency();
    unsubscribeEncumbrance();
  });
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(0, actor = $$props2.actor);
  };
  return [actor, isUsingCurrency, isUsingEncumbrance];
}
class Dnd5eInventory extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$E, create_fragment$E, safe_not_equal, { actor: 0 });
  }
}
function create_if_block$s(ctx) {
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$4,
    then: create_then_block$4,
    catch: create_catch_block$4,
    value: 3,
    error: 4
  };
  handle_promise(
    /*enriched*/
    ctx[1],
    info
  );
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    d(detaching) {
      if (detaching) {
        detach(await_block_anchor);
      }
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$4(ctx) {
  let t_value = console.error(
    "(There was an error:",
    /*error*/
    ctx[4].message
  ) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_then_block$4(ctx) {
  let p;
  let raw_value = (
    /*text*/
    ctx[3] + ""
  );
  return {
    c() {
      p = element("p");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      p.innerHTML = raw_value;
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_pending_block$4(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_fragment$D(ctx) {
  let if_block_anchor;
  let if_block = (
    /*description*/
    ctx[0] && create_if_block$s(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*description*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$s(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function instance$D($$self, $$props, $$invalidate) {
  let { description } = $$props;
  const replaceOptions = [
    {
      find: /\[\[\/damage (.*?) type=(.*?)]]/g,
      replace: "$1 $2"
    },
    {
      find: /\[\[\/damage (.*?)]]/g,
      replace: "$1"
    },
    { find: /\[\[\/r (.*?)]]/g, replace: "$1" },
    {
      find: /&amp;Reference\[condition=(.*?)]/g,
      replace: "<i>$1</i>"
    }
  ];
  const enriched = enrichText(description, replaceOptions);
  $$self.$$set = ($$props2) => {
    if ("description" in $$props2)
      $$invalidate(0, description = $$props2.description);
  };
  return [description, enriched];
}
class Dnd5eSpellDescription extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$D, create_fragment$D, safe_not_equal, { description: 0 });
  }
}
const Dnd5eSpellTags_svelte_svelte_type_style_lang = "";
function create_if_block$r(ctx) {
  let t;
  let span;
  let mounted;
  let dispose;
  let if_block = (
    /*isRitual*/
    ctx[4] && create_if_block_1$i()
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      t = space();
      span = element("span");
      span.innerHTML = `<dnd5e-icon src="systems/dnd5e/icons/svg/statuses/concentrating.svg"></dnd5e-icon>`;
      attr(span, "class", "tag concentrating svelte-mobile-companion81nkluj30u9vsd-fso54w");
      attr(span, "aria-hidden", "true");
      toggle_class(
        span,
        "active",
        /*isActorConcentrating*/
        ctx[1]
      );
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t, anchor);
      insert(target, span, anchor);
      if (!mounted) {
        dispose = listen(span, "click", stop_propagation(prevent_default(
          /*toggleConcentration*/
          ctx[5]
        )));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*isRitual*/
        ctx2[4]
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block_1$i();
          if_block.c();
          if_block.m(t.parentNode, t);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*isActorConcentrating*/
      2) {
        toggle_class(
          span,
          "active",
          /*isActorConcentrating*/
          ctx2[1]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(span);
      }
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_1$i(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.innerHTML = `<dnd5e-icon src="systems/dnd5e/icons/svg/items/spell.svg"></dnd5e-icon>`;
      attr(span, "class", "tag ritual svelte-mobile-companion81nkluj30u9vsd-fso54w");
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$C(ctx) {
  let div2;
  let div0;
  let t;
  let div1;
  let span;
  let i2;
  let i_class_value;
  let mounted;
  let dispose;
  let if_block = (
    /*isConcentration*/
    ctx[3] && create_if_block$r(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      if (if_block)
        if_block.c();
      t = space();
      div1 = element("div");
      span = element("span");
      i2 = element("i");
      attr(div0, "class", "con-and-ritual svelte-mobile-companion81nkluj30u9vsd-fso54w");
      attr(i2, "class", i_class_value = /*alwaysPrepared*/
      ctx[0] ? "fa-solid fa-certificate" : "fa-solid fa-sun");
      attr(span, "class", "tag prepared svelte-mobile-companion81nkluj30u9vsd-fso54w");
      attr(span, "aria-hidden", "true");
      toggle_class(
        span,
        "active",
        /*isPrepared*/
        ctx[2]
      );
      attr(div2, "class", "tags svelte-mobile-companion81nkluj30u9vsd-fso54w");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div2, t);
      append(div2, div1);
      append(div1, span);
      append(span, i2);
      if (!mounted) {
        dispose = listen(span, "click", stop_propagation(prevent_default(
          /*togglePrepared*/
          ctx[6]
        )));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*isConcentration*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$r(ctx2);
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*alwaysPrepared*/
      1 && i_class_value !== (i_class_value = /*alwaysPrepared*/
      ctx2[0] ? "fa-solid fa-certificate" : "fa-solid fa-sun")) {
        attr(i2, "class", i_class_value);
      }
      if (dirty & /*isPrepared*/
      4) {
        toggle_class(
          span,
          "active",
          /*isPrepared*/
          ctx2[2]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$C($$self, $$props, $$invalidate) {
  let spellData;
  let isRitual;
  let isConcentration;
  let isActorConcentrating;
  let alwaysPrepared;
  let isPrepared;
  var _a, _b, _c;
  let { actor } = $$props;
  let { spell } = $$props;
  function toggleConcentration() {
    if (isActorConcentrating) {
      actor.endConcentration();
    } else {
      actor.beginConcentrating(spell);
    }
  }
  function togglePrepared() {
    var _a2;
    if (alwaysPrepared) {
      return;
    }
    spell.update({
      system: {
        preparation: {
          prepared: !((_a2 = spellData.preparation) === null || _a2 === void 0 ? void 0 : _a2.prepared)
        }
      }
    });
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(7, actor = $$props2.actor);
    if ("spell" in $$props2)
      $$invalidate(8, spell = $$props2.spell);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*spell*/
    256) {
      $$invalidate(12, spellData = spell.system);
    }
    if ($$self.$$.dirty & /*spellData*/
    4096) {
      $$invalidate(4, isRitual = spellData.properties.has("ritual"));
    }
    if ($$self.$$.dirty & /*spellData*/
    4096) {
      $$invalidate(3, isConcentration = spellData.properties.has("concentration"));
    }
    if ($$self.$$.dirty & /*actor*/
    128) {
      $$invalidate(1, isActorConcentrating = actor.statuses.has("concentrating"));
    }
    if ($$self.$$.dirty & /*spellData, _a*/
    4608) {
      $$invalidate(0, alwaysPrepared = ($$invalidate(9, _a = spellData.preparation) === null || _a === void 0 ? void 0 : _a.mode) !== "prepared");
    }
    if ($$self.$$.dirty & /*spellData, _b, _c, alwaysPrepared*/
    7169) {
      $$invalidate(2, isPrepared = ($$invalidate(10, _b = spellData.preparation) === null || _b === void 0 ? void 0 : _b.mode) === "prepared" && ($$invalidate(11, _c = spellData.preparation) === null || _c === void 0 ? void 0 : _c.prepared) || alwaysPrepared);
    }
  };
  return [
    alwaysPrepared,
    isActorConcentrating,
    isPrepared,
    isConcentration,
    isRitual,
    toggleConcentration,
    togglePrepared,
    actor,
    spell,
    _a,
    _b,
    _c,
    spellData
  ];
}
class Dnd5eSpellTags extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$C, create_fragment$C, safe_not_equal, { actor: 7, spell: 8 });
  }
}
const Dnd5eSpell_svelte_svelte_type_style_lang = "";
function get_each_context$b(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i2];
  child_ctx[11] = i2;
  return child_ctx;
}
function create_if_block_7$4(ctx) {
  let dnd5espelltags;
  let current;
  dnd5espelltags = new Dnd5eSpellTags({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      spell: (
        /*spell*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(dnd5espelltags.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5espelltags, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5espelltags_changes = {};
      if (dirty & /*actor*/
      1)
        dnd5espelltags_changes.actor = /*actor*/
        ctx2[0];
      if (dirty & /*spell*/
      2)
        dnd5espelltags_changes.spell = /*spell*/
        ctx2[1];
      dnd5espelltags.$set(dnd5espelltags_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5espelltags.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5espelltags.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5espelltags, detaching);
    }
  };
}
function create_if_block$q(ctx) {
  let div2;
  let ul;
  let t0;
  let t1;
  let p0;
  let b0;
  let t4;
  let t5_value = (
    /*spell*/
    ctx[1].labels.activation + ""
  );
  let t5;
  let t6;
  let p1;
  let b1;
  let t9;
  let t10_value = (
    /*spell*/
    ctx[1].labels.range + ""
  );
  let t10;
  let t11;
  let p2;
  let b2;
  let t14;
  let t15_value = (
    /*spell*/
    ctx[1].labels.target + ""
  );
  let t15;
  let t16;
  let p3;
  let b3;
  let t19;
  let t20_value = (
    /*spell*/
    ctx[1].labels.components.vsm + ""
  );
  let t20;
  let t21;
  let t22;
  let p4;
  let b4;
  let t25;
  let t26_value = (
    /*spell*/
    ctx[1].labels.duration + ""
  );
  let t26;
  let t27;
  let t28;
  let t29;
  let t30;
  let p5;
  let b5;
  let t33;
  let t34_value = (
    /*spell*/
    ctx[1].labels.school + ""
  );
  let t34;
  let t35;
  let dnd5espelldescription;
  let div_transition;
  let current;
  let if_block0 = (
    /*isRitual*/
    ctx[6] && create_if_block_6$4()
  );
  let if_block1 = (
    /*isConcentration*/
    ctx[5] && create_if_block_5$6()
  );
  let if_block2 = (
    /*spell*/
    ctx[1].labels.materials && create_if_block_4$7(ctx)
  );
  let if_block3 = (
    /*spell*/
    ctx[1].labels.toHit && create_if_block_3$9(ctx)
  );
  let if_block4 = (
    /*spell*/
    ctx[1].labels.save && create_if_block_2$c(ctx)
  );
  let if_block5 = (
    /*spell*/
    ctx[1].labels.derivedDamage && create_if_block_1$h(ctx)
  );
  dnd5espelldescription = new Dnd5eSpellDescription({
    props: {
      description: (
        /*spell*/
        ctx[1].system.description.value
      )
    }
  });
  return {
    c() {
      div2 = element("div");
      ul = element("ul");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      p0 = element("p");
      b0 = element("b");
      b0.textContent = `${i18n("DND5E.SpellCastTime")}:`;
      t4 = space();
      t5 = text(t5_value);
      t6 = space();
      p1 = element("p");
      b1 = element("b");
      b1.textContent = `${i18n("DND5E.Range")}:`;
      t9 = space();
      t10 = text(t10_value);
      t11 = space();
      p2 = element("p");
      b2 = element("b");
      b2.textContent = `${i18n("DND5E.Target")}:`;
      t14 = space();
      t15 = text(t15_value);
      t16 = space();
      p3 = element("p");
      b3 = element("b");
      b3.textContent = `${i18n("DND5E.Components")}:`;
      t19 = space();
      t20 = text(t20_value);
      t21 = space();
      if (if_block2)
        if_block2.c();
      t22 = space();
      p4 = element("p");
      b4 = element("b");
      b4.textContent = `${i18n("DND5E.Duration")}:`;
      t25 = space();
      t26 = text(t26_value);
      t27 = space();
      if (if_block3)
        if_block3.c();
      t28 = space();
      if (if_block4)
        if_block4.c();
      t29 = space();
      if (if_block5)
        if_block5.c();
      t30 = space();
      p5 = element("p");
      b5 = element("b");
      b5.textContent = `${i18n("DND5E.School")}:`;
      t33 = space();
      t34 = text(t34_value);
      t35 = space();
      create_component(dnd5espelldescription.$$.fragment);
      attr(ul, "class", "properties svelte-mobile-companion81nkluj30u9vsd-6mc0a9");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, ul);
      if (if_block0)
        if_block0.m(ul, null);
      append(ul, t0);
      if (if_block1)
        if_block1.m(ul, null);
      append(div2, t1);
      append(div2, p0);
      append(p0, b0);
      append(p0, t4);
      append(p0, t5);
      append(div2, t6);
      append(div2, p1);
      append(p1, b1);
      append(p1, t9);
      append(p1, t10);
      append(div2, t11);
      append(div2, p2);
      append(p2, b2);
      append(p2, t14);
      append(p2, t15);
      append(div2, t16);
      append(div2, p3);
      append(p3, b3);
      append(p3, t19);
      append(p3, t20);
      append(div2, t21);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t22);
      append(div2, p4);
      append(p4, b4);
      append(p4, t25);
      append(p4, t26);
      append(div2, t27);
      if (if_block3)
        if_block3.m(div2, null);
      append(div2, t28);
      if (if_block4)
        if_block4.m(div2, null);
      append(div2, t29);
      if (if_block5)
        if_block5.m(div2, null);
      append(div2, t30);
      append(div2, p5);
      append(p5, b5);
      append(p5, t33);
      append(p5, t34);
      append(div2, t35);
      mount_component(dnd5espelldescription, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*isRitual*/
        ctx2[6]
      ) {
        if (if_block0)
          ;
        else {
          if_block0 = create_if_block_6$4();
          if_block0.c();
          if_block0.m(ul, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*isConcentration*/
        ctx2[5]
      ) {
        if (if_block1)
          ;
        else {
          if_block1 = create_if_block_5$6();
          if_block1.c();
          if_block1.m(ul, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if ((!current || dirty & /*spell*/
      2) && t5_value !== (t5_value = /*spell*/
      ctx2[1].labels.activation + ""))
        set_data(t5, t5_value);
      if ((!current || dirty & /*spell*/
      2) && t10_value !== (t10_value = /*spell*/
      ctx2[1].labels.range + ""))
        set_data(t10, t10_value);
      if ((!current || dirty & /*spell*/
      2) && t15_value !== (t15_value = /*spell*/
      ctx2[1].labels.target + ""))
        set_data(t15, t15_value);
      if ((!current || dirty & /*spell*/
      2) && t20_value !== (t20_value = /*spell*/
      ctx2[1].labels.components.vsm + ""))
        set_data(t20, t20_value);
      if (
        /*spell*/
        ctx2[1].labels.materials
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_4$7(ctx2);
          if_block2.c();
          if_block2.m(div2, t22);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if ((!current || dirty & /*spell*/
      2) && t26_value !== (t26_value = /*spell*/
      ctx2[1].labels.duration + ""))
        set_data(t26, t26_value);
      if (
        /*spell*/
        ctx2[1].labels.toHit
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_3$9(ctx2);
          if_block3.c();
          if_block3.m(div2, t28);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*spell*/
        ctx2[1].labels.save
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_2$c(ctx2);
          if_block4.c();
          if_block4.m(div2, t29);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*spell*/
        ctx2[1].labels.derivedDamage
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block_1$h(ctx2);
          if_block5.c();
          if_block5.m(div2, t30);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
      if ((!current || dirty & /*spell*/
      2) && t34_value !== (t34_value = /*spell*/
      ctx2[1].labels.school + ""))
        set_data(t34, t34_value);
      const dnd5espelldescription_changes = {};
      if (dirty & /*spell*/
      2)
        dnd5espelldescription_changes.description = /*spell*/
        ctx2[1].system.description.value;
      dnd5espelldescription.$set(dnd5espelldescription_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5espelldescription.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: identity$1, axis: "y" }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(dnd5espelldescription.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: identity$1, axis: "y" }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      destroy_component(dnd5espelldescription);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_6$4(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.textContent = "Ritual";
      attr(li, "class", "property svelte-mobile-companion81nkluj30u9vsd-6mc0a9");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block_5$6(ctx) {
  let li;
  return {
    c() {
      li = element("li");
      li.textContent = "Concentration";
      attr(li, "class", "property svelte-mobile-companion81nkluj30u9vsd-6mc0a9");
    },
    m(target, anchor) {
      insert(target, li, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block_4$7(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*spell*/
    ctx[1].labels.materials + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Materials")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*spell*/
      2 && t3_value !== (t3_value = /*spell*/
      ctx2[1].labels.materials + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_3$9(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*spell*/
    ctx[1].labels.toHit + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.ToHit")}:`;
      t2 = text(" 1d20 ");
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*spell*/
      2 && t3_value !== (t3_value = /*spell*/
      ctx2[1].labels.toHit + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_2$c(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*spell*/
    ctx[1].labels.save + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.SavingThrow")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*spell*/
      2 && t3_value !== (t3_value = /*spell*/
      ctx2[1].labels.save + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_1$h(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let each_value = ensure_array_like(
    /*spell*/
    ctx[1].labels.derivedDamage
  );
  const get_key = (ctx2) => (
    /*index*/
    ctx2[11]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$b(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$b(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*spell*/
      2) {
        each_value = ensure_array_like(
          /*spell*/
          ctx2[1].labels.derivedDamage
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, destroy_block, create_each_block$b, each_1_anchor, get_each_context$b);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$b(key_1, ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*damage*/
    ctx[9].label + ""
  );
  let t3;
  return {
    key: key_1,
    first: null,
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("DND5E.Damage")}:`;
      t2 = space();
      t3 = text(t3_value);
      this.first = p;
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*spell*/
      2 && t3_value !== (t3_value = /*damage*/
      ctx[9].label + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$B(ctx) {
  let section;
  let div1;
  let div0;
  let img;
  let img_src_value;
  let img_alt_value;
  let t0;
  let span;
  let t1_value = (
    /*spell*/
    ctx[1].name + ""
  );
  let t1;
  let t2;
  let t3;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*sichtbar*/
    ctx[3] && create_if_block_7$4(ctx)
  );
  let if_block1 = (
    /*showItemData*/
    ctx[4] && /*sichtbar*/
    ctx[3] && create_if_block$q(ctx)
  );
  return {
    c() {
      section = element("section");
      div1 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(t1_value);
      t2 = space();
      if (if_block0)
        if_block0.c();
      t3 = space();
      if (if_block1)
        if_block1.c();
      if (!src_url_equal(img.src, img_src_value = /*spell*/
      ctx[1].img))
        attr(img, "src", img_src_value);
      attr(img, "alt", img_alt_value = /*spell*/
      ctx[1].name);
      attr(img, "class", "item-icon svelte-mobile-companion81nkluj30u9vsd-6mc0a9");
      attr(div0, "class", "item svelte-mobile-companion81nkluj30u9vsd-6mc0a9");
      attr(div0, "aria-hidden", "true");
      attr(div1, "class", "item-container svelte-mobile-companion81nkluj30u9vsd-6mc0a9");
      attr(section, "class", "svelte-mobile-companion81nkluj30u9vsd-6mc0a9");
      toggle_class(
        section,
        "odd",
        /*isOddLine*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div1);
      append(div1, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div1, t2);
      if (if_block0)
        if_block0.m(div1, null);
      append(section, t3);
      if (if_block1)
        if_block1.m(section, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "click",
          /*toggleDescription*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*spell*/
      2 && !src_url_equal(img.src, img_src_value = /*spell*/
      ctx2[1].img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*spell*/
      2 && img_alt_value !== (img_alt_value = /*spell*/
      ctx2[1].name)) {
        attr(img, "alt", img_alt_value);
      }
      if ((!current || dirty & /*spell*/
      2) && t1_value !== (t1_value = /*spell*/
      ctx2[1].name + ""))
        set_data(t1, t1_value);
      if (
        /*sichtbar*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*sichtbar*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7$4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showItemData*/
        ctx2[4] && /*sichtbar*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showItemData, sichtbar*/
          24) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$q(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*isOddLine*/
      4) {
        toggle_class(
          section,
          "odd",
          /*isOddLine*/
          ctx2[2]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$B($$self, $$props, $$invalidate) {
  let spellData;
  let isRitual;
  let isConcentration;
  let { actor } = $$props;
  let { spell } = $$props;
  let { isOddLine } = $$props;
  let { sichtbar = false } = $$props;
  let showItemData = false;
  function toggleDescription() {
    $$invalidate(4, showItemData = !showItemData);
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(0, actor = $$props2.actor);
    if ("spell" in $$props2)
      $$invalidate(1, spell = $$props2.spell);
    if ("isOddLine" in $$props2)
      $$invalidate(2, isOddLine = $$props2.isOddLine);
    if ("sichtbar" in $$props2)
      $$invalidate(3, sichtbar = $$props2.sichtbar);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*spell*/
    2) {
      $$invalidate(8, spellData = spell.system);
    }
    if ($$self.$$.dirty & /*spellData*/
    256) {
      $$invalidate(6, isRitual = spellData.properties.has("ritual"));
    }
    if ($$self.$$.dirty & /*spellData*/
    256) {
      $$invalidate(5, isConcentration = spellData.properties.has("concentration"));
    }
  };
  return [
    actor,
    spell,
    isOddLine,
    sichtbar,
    showItemData,
    isConcentration,
    isRitual,
    toggleDescription,
    spellData
  ];
}
class Dnd5eSpell extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$B, create_fragment$B, safe_not_equal, {
      actor: 0,
      spell: 1,
      isOddLine: 2,
      sichtbar: 3
    });
  }
}
const Dnd5ESpellLevelCard_svelte_svelte_type_style_lang = "";
function get_each_context$a(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i2];
  child_ctx[13] = i2;
  return child_ctx;
}
function get_each_context_1$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function get_each_context_2$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  return child_ctx;
}
function create_each_block_2$2(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<dnd5e-icon src="systems/dnd5e/icons/svg/spell-slot.svg"></dnd5e-icon>`;
      attr(button, "type", "button");
      attr(button, "class", "pip filled svelte-mobile-companion81nkluj30u9vsd-16ohmss");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*disableSlot*/
          ctx[7]
        )));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block_1$3(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      button.innerHTML = `<dnd5e-icon src="systems/dnd5e/icons/svg/spell-slot.svg"></dnd5e-icon> `;
      attr(button, "type", "button");
      attr(button, "class", "pip svelte-mobile-companion81nkluj30u9vsd-16ohmss");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(prevent_default(
          /*enableSlot*/
          ctx[6]
        )));
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_if_block$p(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*spellMap*/
    ctx[0][
      /*level*/
      ctx[2]
    ]
  );
  const get_key = (ctx2) => (
    /*spell*/
    ctx2[11].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$a(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$a(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*actor, spellMap, level, sichtbar*/
      15) {
        each_value = ensure_array_like(
          /*spellMap*/
          ctx2[0][
            /*level*/
            ctx2[2]
          ]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$a, each_1_anchor, get_each_context$a);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$a(key_1, ctx) {
  let first;
  let dnd5espell;
  let current;
  dnd5espell = new Dnd5eSpell({
    props: {
      actor: (
        /*actor*/
        ctx[1]
      ),
      spell: (
        /*spell*/
        ctx[11]
      ),
      isOddLine: (
        /*index*/
        ctx[13] % 2 === 0
      ),
      sichtbar: (
        /*sichtbar*/
        ctx[3]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(dnd5espell.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(dnd5espell, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const dnd5espell_changes = {};
      if (dirty & /*actor*/
      2)
        dnd5espell_changes.actor = /*actor*/
        ctx[1];
      if (dirty & /*spellMap, level*/
      5)
        dnd5espell_changes.spell = /*spell*/
        ctx[11];
      if (dirty & /*spellMap, level*/
      5)
        dnd5espell_changes.isOddLine = /*index*/
        ctx[13] % 2 === 0;
      if (dirty & /*sichtbar*/
      8)
        dnd5espell_changes.sichtbar = /*sichtbar*/
        ctx[3];
      dnd5espell.$set(dnd5espell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5espell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5espell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(dnd5espell, detaching);
    }
  };
}
function create_fragment$A(ctx) {
  let section;
  let div0;
  let h3;
  let t0_value = (
    /*level*/
    (ctx[2] === 0 ? i18n("DND5E.SpellCantrip") : `${i18n("DND5E.Level")} ${/*level*/
    ctx[2]}`) + ""
  );
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let current;
  let each_value_2 = ensure_array_like(
    /*availableSlots*/
    ctx[4]
  );
  let each_blocks_1 = [];
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    each_blocks_1[i2] = create_each_block_2$2(get_each_context_2$2(ctx, each_value_2, i2));
  }
  let each_value_1 = ensure_array_like(
    /*emptySlots*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$3(get_each_context_1$3(ctx, each_value_1, i2));
  }
  let if_block = (
    /*spellMap*/
    ctx[0][
      /*level*/
      ctx[2]
    ] && create_if_block$p(ctx)
  );
  return {
    c() {
      section = element("section");
      div0 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        each_blocks_1[i2].c();
      }
      t2 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t3 = space();
      if (if_block)
        if_block.c();
      attr(h3, "class", "svelte-mobile-companion81nkluj30u9vsd-16ohmss");
      attr(div0, "class", "item-list-header svelte-mobile-companion81nkluj30u9vsd-16ohmss");
      attr(div1, "class", "pips svelte-mobile-companion81nkluj30u9vsd-16ohmss");
      attr(section, "class", "spell-card svelte-mobile-companion81nkluj30u9vsd-16ohmss");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div0);
      append(div0, h3);
      append(h3, t0);
      append(section, t1);
      append(section, div1);
      for (let i2 = 0; i2 < each_blocks_1.length; i2 += 1) {
        if (each_blocks_1[i2]) {
          each_blocks_1[i2].m(div1, null);
        }
      }
      append(div1, t2);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div1, null);
        }
      }
      append(section, t3);
      if (if_block)
        if_block.m(section, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*level*/
      4) && t0_value !== (t0_value = /*level*/
      (ctx2[2] === 0 ? i18n("DND5E.SpellCantrip") : `${i18n("DND5E.Level")} ${/*level*/
      ctx2[2]}`) + ""))
        set_data(t0, t0_value);
      if (dirty & /*disableSlot, availableSlots*/
      144) {
        each_value_2 = ensure_array_like(
          /*availableSlots*/
          ctx2[4]
        );
        let i2;
        for (i2 = 0; i2 < each_value_2.length; i2 += 1) {
          const child_ctx = get_each_context_2$2(ctx2, each_value_2, i2);
          if (each_blocks_1[i2]) {
            each_blocks_1[i2].p(child_ctx, dirty);
          } else {
            each_blocks_1[i2] = create_each_block_2$2(child_ctx);
            each_blocks_1[i2].c();
            each_blocks_1[i2].m(div1, t2);
          }
        }
        for (; i2 < each_blocks_1.length; i2 += 1) {
          each_blocks_1[i2].d(1);
        }
        each_blocks_1.length = each_value_2.length;
      }
      if (dirty & /*enableSlot, emptySlots*/
      96) {
        each_value_1 = ensure_array_like(
          /*emptySlots*/
          ctx2[5]
        );
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$3(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
          } else {
            each_blocks[i2] = create_each_block_1$3(child_ctx);
            each_blocks[i2].c();
            each_blocks[i2].m(div1, null);
          }
        }
        for (; i2 < each_blocks.length; i2 += 1) {
          each_blocks[i2].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (
        /*spellMap*/
        ctx2[0][
          /*level*/
          ctx2[2]
        ]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*spellMap, level*/
          5) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block$p(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(section, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
function instance$A($$self, $$props, $$invalidate) {
  let { spellMap } = $$props;
  let { actor } = $$props;
  let { level } = $$props;
  let { sichtbar = false } = $$props;
  let spellLevel;
  let spellObj;
  let availableSlots = [];
  let emptySlots = [];
  function updateSpellValue() {
    if (spellObj) {
      actor.update({
        system: {
          spells: { [spellLevel]: { value: spellObj.value } }
        }
      });
    }
  }
  function enableSlot() {
    if (spellObj) {
      $$invalidate(9, spellObj.value++, spellObj);
      updateSpellValue();
    }
  }
  function disableSlot() {
    if (spellObj) {
      $$invalidate(9, spellObj.value--, spellObj);
      updateSpellValue();
    }
  }
  $$self.$$set = ($$props2) => {
    if ("spellMap" in $$props2)
      $$invalidate(0, spellMap = $$props2.spellMap);
    if ("actor" in $$props2)
      $$invalidate(1, actor = $$props2.actor);
    if ("level" in $$props2)
      $$invalidate(2, level = $$props2.level);
    if ("sichtbar" in $$props2)
      $$invalidate(3, sichtbar = $$props2.sichtbar);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*level, actor, spellLevel, spellObj*/
    774) {
      {
        $$invalidate(8, spellLevel = `spell${level}`);
        $$invalidate(9, spellObj = actor.system.spells[spellLevel]);
        if (spellObj === null || spellObj === void 0 ? void 0 : spellObj.max) {
          $$invalidate(4, availableSlots = Array(spellObj.value).fill(0));
          $$invalidate(5, emptySlots = Array(Math.max(0, spellObj.max - spellObj.value)).fill(0));
        }
      }
    }
  };
  return [
    spellMap,
    actor,
    level,
    sichtbar,
    availableSlots,
    emptySlots,
    enableSlot,
    disableSlot,
    spellLevel,
    spellObj
  ];
}
class Dnd5ESpellLevelCard extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$A, create_fragment$A, safe_not_equal, {
      spellMap: 0,
      actor: 1,
      level: 2,
      sichtbar: 3
    });
  }
}
const Dnd5eSpellsHeader_svelte_svelte_type_style_lang = "";
function create_if_block$o(ctx) {
  let div2;
  let p;
  let t0;
  let p_class_value;
  let t1;
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      div2 = element("div");
      p = element("p");
      t0 = text(
        /*concentratingText*/
        ctx[2]
      );
      t1 = space();
      button = element("button");
      button.innerHTML = `<dnd5e-icon src="systems/dnd5e/icons/svg/break-concentration.svg" class="svelte-mobile-companion81nkluj30u9vsd-1ok8vou"></dnd5e-icon>`;
      attr(p, "class", p_class_value = "info-text animated-strike " + /*isStrike*/
      (ctx[3] ? "active" : "") + " svelte-mobile-companion81nkluj30u9vsd-1ok8vou");
      attr(button, "class", "svelte-mobile-companion81nkluj30u9vsd-1ok8vou");
      attr(div2, "class", "header-element svelte-mobile-companion81nkluj30u9vsd-1ok8vou");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, p);
      append(p, t0);
      append(div2, t1);
      append(div2, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*endConcentration*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*concentratingText*/
      4)
        set_data(
          t0,
          /*concentratingText*/
          ctx2[2]
        );
      if (dirty & /*isStrike*/
      8 && p_class_value !== (p_class_value = "info-text animated-strike " + /*isStrike*/
      (ctx2[3] ? "active" : "") + " svelte-mobile-companion81nkluj30u9vsd-1ok8vou")) {
        attr(p, "class", p_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$z(ctx) {
  let section;
  let t0;
  let div2;
  let p;
  let t1;
  let t2_value = (
    /*preparedSpells*/
    ctx[4].length + ""
  );
  let t2;
  let t3;
  let button;
  let mounted;
  let dispose;
  let if_block = (
    /*isConcentrating*/
    ctx[1] && create_if_block$o(ctx)
  );
  return {
    c() {
      section = element("section");
      if (if_block)
        if_block.c();
      t0 = space();
      div2 = element("div");
      p = element("p");
      t1 = text("Prepared Spells: ");
      t2 = text(t2_value);
      t3 = space();
      button = element("button");
      button.innerHTML = `<i class="fas fa-filter"></i>`;
      attr(p, "class", "info-text svelte-mobile-companion81nkluj30u9vsd-1ok8vou");
      attr(button, "class", "filter svelte-mobile-companion81nkluj30u9vsd-1ok8vou");
      attr(button, "aria-hidden", "true");
      toggle_class(
        button,
        "active",
        /*filterActive*/
        ctx[0]
      );
      attr(div2, "class", "header-element svelte-mobile-companion81nkluj30u9vsd-1ok8vou");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (if_block)
        if_block.m(section, null);
      append(section, t0);
      append(section, div2);
      append(div2, p);
      append(p, t1);
      append(p, t2);
      append(div2, t3);
      append(div2, button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*toggleSpells*/
          ctx[5]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*isConcentrating*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$o(ctx2);
          if_block.c();
          if_block.m(section, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*preparedSpells*/
      16 && t2_value !== (t2_value = /*preparedSpells*/
      ctx2[4].length + ""))
        set_data(t2, t2_value);
      if (dirty & /*filterActive*/
      1) {
        toggle_class(
          button,
          "active",
          /*filterActive*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$z($$self, $$props, $$invalidate) {
  let preparedSpells;
  let { actor } = $$props;
  let { spells } = $$props;
  let { filterActive = false } = $$props;
  const dispatch2 = createEventDispatcher();
  let isConcentrating;
  let concentratingText;
  function toggleSpells() {
    dispatch2("toggleSpells");
  }
  function endConcentration() {
    $$invalidate(3, isStrike = true);
    setTimeout(
      () => {
        actor.endConcentration();
        $$invalidate(3, isStrike = false);
      },
      800
    );
  }
  let isStrike = false;
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(7, actor = $$props2.actor);
    if ("spells" in $$props2)
      $$invalidate(8, spells = $$props2.spells);
    if ("filterActive" in $$props2)
      $$invalidate(0, filterActive = $$props2.filterActive);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor, isConcentrating*/
    130) {
      {
        $$invalidate(1, isConcentrating = actor.statuses.has("concentrating"));
        if (isConcentrating) {
          $$invalidate(2, concentratingText = actor.appliedEffects.filter((effect) => effect.name.startsWith("Concentrating:")).map((effect) => effect.name));
        }
      }
    }
    if ($$self.$$.dirty & /*spells*/
    256) {
      $$invalidate(4, preparedSpells = spells.filter((spell) => {
        const spellData = spell.system;
        return spellData.preparation.mode === "prepared" && spellData.preparation.prepared;
      }));
    }
  };
  return [
    filterActive,
    isConcentrating,
    concentratingText,
    isStrike,
    preparedSpells,
    toggleSpells,
    endConcentration,
    actor,
    spells
  ];
}
class Dnd5eSpellsHeader extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$z, create_fragment$z, safe_not_equal, { actor: 7, spells: 8, filterActive: 0 });
  }
}
const Dnd5eSpells_svelte_svelte_type_style_lang = "";
function get_each_context$9(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function get_each_context_1$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i2];
  return child_ctx;
}
function create_each_block_1$2(ctx) {
  let dnd5espelllevelcard;
  let current;
  dnd5espelllevelcard = new Dnd5ESpellLevelCard({
    props: {
      spellMap: (
        /*spellMap*/
        ctx[1]
      ),
      actor: (
        /*actor*/
        ctx[0]
      ),
      level: (
        /*level*/
        ctx[8]
      ),
      sichtbar: true
    }
  });
  return {
    c() {
      create_component(dnd5espelllevelcard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5espelllevelcard, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5espelllevelcard_changes = {};
      if (dirty & /*spellMap*/
      2)
        dnd5espelllevelcard_changes.spellMap = /*spellMap*/
        ctx2[1];
      if (dirty & /*actor*/
      1)
        dnd5espelllevelcard_changes.actor = /*actor*/
        ctx2[0];
      if (dirty & /*V3pBc01WMD0*/
      16)
        dnd5espelllevelcard_changes.level = /*level*/
        ctx2[8];
      dnd5espelllevelcard.$set(dnd5espelllevelcard_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5espelllevelcard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5espelllevelcard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5espelllevelcard, detaching);
    }
  };
}
function create_if_block$n(ctx) {
  let div2;
  let t0;
  let div1;
  let current;
  let each_value = ensure_array_like(JSON.parse(atob(atob(V3pJc015dzBMRFVzTml3M0xEZ3NPVjA9))));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    each_blocks[i2] = create_each_block$9(get_each_context$9(ctx, each_value, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  return {
    c() {
      div2 = element("div");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      div1 = element("div");
      div1.innerHTML = `<div class="text-box svelte-mobile-companion81nkluj30u9vsd-qnhsff"><p class="svelte-mobile-companion81nkluj30u9vsd-qnhsff"><b>Available in pro version.</b></p> <p class="svelte-mobile-companion81nkluj30u9vsd-qnhsff">Please visit <a href="https://www.patreon.com/SyriousWorkshop" target="_blank">Syrious&#39;
                            Workshop</a></p></div>`;
      attr(div1, "class", "overlay svelte-mobile-companion81nkluj30u9vsd-qnhsff");
      attr(div2, "class", "content2 svelte-mobile-companion81nkluj30u9vsd-qnhsff");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(div2, null);
        }
      }
      append(div2, t0);
      append(div2, div1);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*spellMap, actor, JSON, atob, V3pJc015dzBMRFVzTml3M0xEZ3NPVjA9*/
      3) {
        each_value = ensure_array_like(JSON.parse(atob(atob(V3pJc015dzBMRFVzTml3M0xEZ3NPVjA9))));
        let i2;
        for (i2 = 0; i2 < each_value.length; i2 += 1) {
          const child_ctx = get_each_context$9(ctx2, each_value, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block$9(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(div2, t0);
          }
        }
        group_outros();
        for (i2 = each_value.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block$9(ctx) {
  let dnd5espelllevelcard;
  let current;
  dnd5espelllevelcard = new Dnd5ESpellLevelCard({
    props: {
      spellMap: (
        /*spellMap*/
        ctx[1]
      ),
      actor: (
        /*actor*/
        ctx[0]
      ),
      level: (
        /*level*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(dnd5espelllevelcard.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5espelllevelcard, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5espelllevelcard_changes = {};
      if (dirty & /*spellMap*/
      2)
        dnd5espelllevelcard_changes.spellMap = /*spellMap*/
        ctx2[1];
      if (dirty & /*actor*/
      1)
        dnd5espelllevelcard_changes.actor = /*actor*/
        ctx2[0];
      dnd5espelllevelcard.$set(dnd5espelllevelcard_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5espelllevelcard.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5espelllevelcard.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5espelllevelcard, detaching);
    }
  };
}
function create_fragment$y(ctx) {
  let section1;
  let dnd5espellsheader;
  let t0;
  let section0;
  let t1;
  let current;
  dnd5espellsheader = new Dnd5eSpellsHeader({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      spells: (
        /*spells*/
        ctx[3]
      ),
      filterActive: (
        /*useOnlyReadiedSpells*/
        ctx[2]
      )
    }
  });
  dnd5espellsheader.$on(
    "toggleSpells",
    /*toggleReadiedSpells*/
    ctx[6]
  );
  let each_value_1 = ensure_array_like(JSON.parse(atob(atob(
    /*V3pBc01WMD0*/
    ctx[4]
  ))));
  let each_blocks = [];
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    each_blocks[i2] = create_each_block_1$2(get_each_context_1$2(ctx, each_value_1, i2));
  }
  const out = (i2) => transition_out(each_blocks[i2], 1, 1, () => {
    each_blocks[i2] = null;
  });
  let if_block = !/*ctx*/
  ctx[5] && create_if_block$n(ctx);
  return {
    c() {
      section1 = element("section");
      create_component(dnd5espellsheader.$$.fragment);
      t0 = space();
      section0 = element("section");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      attr(section0, "class", "content-scroll-list");
      attr(section1, "class", "category-content");
    },
    m(target, anchor) {
      insert(target, section1, anchor);
      mount_component(dnd5espellsheader, section1, null);
      append(section1, t0);
      append(section1, section0);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section0, null);
        }
      }
      append(section0, t1);
      if (if_block)
        if_block.m(section0, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const dnd5espellsheader_changes = {};
      if (dirty & /*actor*/
      1)
        dnd5espellsheader_changes.actor = /*actor*/
        ctx2[0];
      if (dirty & /*spells*/
      8)
        dnd5espellsheader_changes.spells = /*spells*/
        ctx2[3];
      if (dirty & /*useOnlyReadiedSpells*/
      4)
        dnd5espellsheader_changes.filterActive = /*useOnlyReadiedSpells*/
        ctx2[2];
      dnd5espellsheader.$set(dnd5espellsheader_changes);
      if (dirty & /*spellMap, actor, JSON, atob, V3pBc01WMD0*/
      19) {
        each_value_1 = ensure_array_like(JSON.parse(atob(atob(
          /*V3pBc01WMD0*/
          ctx2[4]
        ))));
        let i2;
        for (i2 = 0; i2 < each_value_1.length; i2 += 1) {
          const child_ctx = get_each_context_1$2(ctx2, each_value_1, i2);
          if (each_blocks[i2]) {
            each_blocks[i2].p(child_ctx, dirty);
            transition_in(each_blocks[i2], 1);
          } else {
            each_blocks[i2] = create_each_block_1$2(child_ctx);
            each_blocks[i2].c();
            transition_in(each_blocks[i2], 1);
            each_blocks[i2].m(section0, t1);
          }
        }
        group_outros();
        for (i2 = each_value_1.length; i2 < each_blocks.length; i2 += 1) {
          out(i2);
        }
        check_outros();
      }
      if (!/*ctx*/
      ctx2[5])
        if_block.p(ctx2, dirty);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5espellsheader.$$.fragment, local);
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(dnd5espellsheader.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section1);
      }
      destroy_component(dnd5espellsheader);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d();
    }
  };
}
let V3pJc015dzBMRFVzTml3M0xEZ3NPVjA9 = "V3pJc015dzBMRFVzTml3M0xEZ3NPVjA9";
function instance$y($$self, $$props, $$invalidate) {
  let spells;
  let readiedSpells;
  let { actor } = $$props;
  let spellMap;
  let V3pBc01WMD0 = "V3pBc01WMD0=";
  const ctx = getContext(foundryContextId);
  if (ctx === moduleId) {
    V3pBc01WMD0 = "V3pBc01Td3lMRE1zTkN3MUxEWXNOeXc0TERsZA==";
  }
  let useOnlyReadiedSpells;
  if (sessionStorage.getItem("filterActive") === null) {
    useOnlyReadiedSpells = true;
    sessionStorage.setItem("filterActive", "true");
  } else {
    useOnlyReadiedSpells = sessionStorage.getItem("filterActive") === "true";
  }
  function toggleReadiedSpells() {
    $$invalidate(2, useOnlyReadiedSpells = !useOnlyReadiedSpells);
    sessionStorage.setItem("filterActive", useOnlyReadiedSpells.toString());
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(0, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    1) {
      $$invalidate(3, spells = actor.collections.items.filter((item) => item.type === "spell"));
    }
    if ($$self.$$.dirty & /*spells*/
    8) {
      $$invalidate(7, readiedSpells = spells.filter((spell) => {
        const spellData = spell.system;
        const alwaysPrepared = spellData.preparation.mode !== "prepared";
        return alwaysPrepared || spellData.preparation.mode === "prepared" && spellData.preparation.prepared;
      }));
    }
    if ($$self.$$.dirty & /*useOnlyReadiedSpells, readiedSpells, spells*/
    140) {
      {
        let spellList = useOnlyReadiedSpells ? readiedSpells : spells;
        $$invalidate(1, spellMap = spellList.reduce(
          (acc, spell) => {
            const system2 = spell.system;
            let level = system2.level;
            if (!acc[level]) {
              acc[level] = [];
            }
            acc[level].push(spell);
            return acc;
          },
          {}
        ));
      }
    }
    if ($$self.$$.dirty & /*spellMap*/
    2) {
      for (const level in spellMap) {
        spellMap[level].sort((a, b) => a.name.localeCompare(b.name));
      }
    }
  };
  return [
    actor,
    spellMap,
    useOnlyReadiedSpells,
    spells,
    V3pBc01WMD0,
    ctx,
    toggleReadiedSpells,
    readiedSpells
  ];
}
class Dnd5eSpells extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$y, create_fragment$y, safe_not_equal, { actor: 0 });
  }
}
function create_if_block_1$g(ctx) {
  let dnd5espells;
  let current;
  dnd5espells = new Dnd5eSpells({ props: { actor: (
    /*actor*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(dnd5espells.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5espells, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5espells_changes = {};
      if (dirty & /*actor*/
      2)
        dnd5espells_changes.actor = /*actor*/
        ctx2[1];
      dnd5espells.$set(dnd5espells_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5espells.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5espells.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5espells, detaching);
    }
  };
}
function create_if_block$m(ctx) {
  let dnd5einventory;
  let current;
  dnd5einventory = new Dnd5eInventory({ props: { actor: (
    /*actor*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(dnd5einventory.$$.fragment);
    },
    m(target, anchor) {
      mount_component(dnd5einventory, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const dnd5einventory_changes = {};
      if (dirty & /*actor*/
      2)
        dnd5einventory_changes.actor = /*actor*/
        ctx2[1];
      dnd5einventory.$set(dnd5einventory_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(dnd5einventory.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(dnd5einventory.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(dnd5einventory, detaching);
    }
  };
}
function create_default_slot$2(ctx) {
  let main2;
  let header;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  header = new Header({
    props: {
      customButtons: headerButtons$2,
      menuButtons: menuButtons$2,
      activeFilter: (
        /*activeFilter*/
        ctx[2]
      )
    }
  });
  const if_block_creators = [create_if_block$m, create_if_block_1$g];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*activeFilter*/
      ctx2[2] === Filters$2.Inventory
    )
      return 0;
    if (
      /*activeFilter*/
      ctx2[2] === Filters$2.Spell
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      main2 = element("main");
      create_component(header.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(main2, "class", "dnd5e-container");
    },
    m(target, anchor) {
      insert(target, main2, anchor);
      mount_component(header, main2, null);
      append(main2, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(main2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*activeFilter*/
      4)
        header_changes.activeFilter = /*activeFilter*/
        ctx2[2];
      header.$set(header_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(main2, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(main2);
      }
      destroy_component(header);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_fragment$x(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[4](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$2] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell$1({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, actor, activeFilter*/
      134) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function instance$x($$self, $$props, $$invalidate) {
  let { elementRoot } = $$props;
  let { props } = $$props;
  init$2(props);
  let actor = props;
  let activeFilter = Filters$2.Inventory;
  const unsubscribeActor = actorStore$2.subscribe((value) => {
    $$invalidate(1, actor = value);
  });
  const unsubscribeFilter = activeFilterStore$2.subscribe((value) => {
    $$invalidate(2, activeFilter = value);
  });
  onMount(() => {
    handleOnMount$2();
  });
  onDestroy(() => {
    handleOffMount();
    unsubscribeActor();
    unsubscribeFilter();
  });
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
  };
  return [elementRoot, actor, activeFilter, props, applicationshell_elementRoot_binding];
}
let Dnd5eFreeAppShell$1 = class Dnd5eFreeAppShell extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$x, create_fragment$x, safe_not_equal, { elementRoot: 0, props: 3 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get props() {
    return this.$$.ctx[3];
  }
  set props(props) {
    this.$$set({ props });
    flush();
  }
};
class Dnd5eFreeAppShell2 extends SvelteApplication {
  constructor(actor) {
    super();
    this.options.svelte.props = actor;
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "Mobile Companion Dnd5e Free",
      id: moduleId,
      // classes: [],
      width: window.innerWidth,
      height: window.innerHeight,
      zIndex: 99999,
      resizable: false,
      // The other options...
      svelte: {
        class: Dnd5eFreeAppShell$1,
        target: document.body,
        props: {}
      }
    });
  }
}
var Filters$1 = /* @__PURE__ */ ((Filters2) => {
  Filters2["Object"] = "object";
  Filters2["Spell"] = "spell";
  return Filters2;
})(Filters$1 || {});
const actorStore$1 = writable({});
const activeFilterStore$1 = writable(
  "object"
  /* Object */
);
function init$1(props) {
  actorStore$1.set(props);
}
const updateInventory$1 = async (item) => {
  let actor = get_store_value(actorStore$1);
  if (item.parent?.id === actor.id) {
    actor = game.actors.find((a) => a.id === actor.id);
    actorStore$1.set(actor);
    switchFilter$1(get_store_value(activeFilterStore$1));
  }
};
const updateActor$1 = async (changedActor) => {
  let actor = get_store_value(actorStore$1);
  if (actor.id === changedActor.id) {
    actor = changedActor;
    actorStore$1.set(actor);
    switchFilter$1(get_store_value(activeFilterStore$1));
  }
};
function handleOnMount$1() {
  Hooks.on("createItem", updateInventory$1);
  Hooks.on("deleteItem", updateInventory$1);
  Hooks.on("updateItem", updateInventory$1);
  Hooks.on("updateActor", updateActor$1);
  switchFilter$1(get_store_value(activeFilterStore$1));
}
function handleOnDestroy$1() {
  Hooks.off("createItem", updateInventory$1);
  Hooks.off("deleteItem", updateInventory$1);
  Hooks.off("updateItem", updateInventory$1);
  Hooks.off("updateActor", updateActor$1);
}
const headerButtons$1 = [
  {
    id: "object",
    iconClass: "a5e-nav-item fas fa-box-open",
    buttonClass: "",
    label: "Inventory",
    onClick: () => switchFilter$1(
      "object"
      /* Object */
    )
  },
  {
    id: "spell",
    iconClass: "a5e-nav-item fas fa-wand-sparkles",
    buttonClass: "",
    label: "Spells",
    onClick: () => switchFilter$1(
      "spell"
      /* Spell */
    )
  }
];
const menuButtons$1 = {
  buttonClass: "",
  iconClass: "a5e-nav-item"
};
function switchFilter$1(newFilter) {
  activeFilterStore$1.set(newFilter);
}
function create_catch_block$3(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_then_block$3(ctx) {
  let t_value = (
    /*total*/
    ctx[3] + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_pending_block$3(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_fragment$w(ctx) {
  let section;
  let hr;
  let t0;
  let p0;
  let b0;
  let t2;
  let t3;
  let p1;
  let b1;
  let t5;
  let t6_value = (
    /*ac*/
    ctx[0].maxDex + ""
  );
  let t6;
  let t7;
  let p2;
  let b2;
  let t9;
  let t10_value = (
    /*ac*/
    ctx[0].minStr + ""
  );
  let t10;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: false,
    pending: create_pending_block$3,
    then: create_then_block$3,
    catch: create_catch_block$3,
    value: 3
  };
  handle_promise(
    /*totalAC*/
    ctx[1],
    info
  );
  return {
    c() {
      section = element("section");
      hr = element("hr");
      t0 = space();
      p0 = element("p");
      b0 = element("b");
      b0.textContent = `${i18n("A5E.ArmorClassAbbr")}`;
      t2 = text(":\r\n        ");
      info.block.c();
      t3 = space();
      p1 = element("p");
      b1 = element("b");
      b1.textContent = `${i18n("A5E.armorClass.maxDex")}`;
      t5 = text(": ");
      t6 = text(t6_value);
      t7 = space();
      p2 = element("p");
      b2 = element("b");
      b2.textContent = `${i18n("A5E.armorClass.minStr")}`;
      t9 = text(": ");
      t10 = text(t10_value);
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, hr);
      append(section, t0);
      append(section, p0);
      append(p0, b0);
      append(p0, t2);
      info.block.m(p0, info.anchor = null);
      info.mount = () => p0;
      info.anchor = null;
      append(section, t3);
      append(section, p1);
      append(p1, b1);
      append(p1, t5);
      append(p1, t6);
      append(section, t7);
      append(section, p2);
      append(p2, b2);
      append(p2, t9);
      append(p2, t10);
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
      if (dirty & /*ac*/
      1 && t6_value !== (t6_value = /*ac*/
      ctx[0].maxDex + ""))
        set_data(t6, t6_value);
      if (dirty & /*ac*/
      1 && t10_value !== (t10_value = /*ac*/
      ctx[0].minStr + ""))
        set_data(t10, t10_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$w($$self, $$props, $$invalidate) {
  let { ac } = $$props;
  let { rollData } = $$props;
  let totalAC = evaluateTotal(ac.formula, rollData);
  $$self.$$set = ($$props2) => {
    if ("ac" in $$props2)
      $$invalidate(0, ac = $$props2.ac);
    if ("rollData" in $$props2)
      $$invalidate(2, rollData = $$props2.rollData);
  };
  return [ac, totalAC, rollData];
}
class A5eObjectAc extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$w, create_fragment$w, safe_not_equal, { ac: 0, rollData: 2 });
  }
}
function create_if_block_2$b(ctx) {
  let p;
  let b;
  let t1;
  let t2_value = (
    /*itemData*/
    ctx[0].price + ""
  );
  let t2;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${/*cost*/
      ctx[2]}`;
      t1 = text(": ");
      t2 = text(t2_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t1);
      append(p, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t2_value !== (t2_value = /*itemData*/
      ctx2[0].price + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_1$f(ctx) {
  let p;
  let b;
  let t1;
  let t2_value = (
    /*itemData*/
    ctx[0].weight + ""
  );
  let t2;
  let t3;
  let t4;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${/*weight*/
      ctx[3]}`;
      t1 = text(": ");
      t2 = text(t2_value);
      t3 = space();
      t4 = text(
        /*weightAbr*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t1);
      append(p, t2);
      append(p, t3);
      append(p, t4);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t2_value !== (t2_value = /*itemData*/
      ctx2[0].weight + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$l(ctx) {
  let await_block_anchor;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$2,
    then: create_then_block$2,
    catch: create_catch_block$2,
    value: 7,
    error: 8
  };
  handle_promise(
    /*enrichedText*/
    ctx[5],
    info
  );
  return {
    c() {
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    d(detaching) {
      if (detaching) {
        detach(await_block_anchor);
      }
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function create_catch_block$2(ctx) {
  let t_value = console.error(
    "(There was an error:",
    /*error*/
    ctx[8].message
  ) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_then_block$2(ctx) {
  let p;
  let raw_value = (
    /*text*/
    ctx[7] + ""
  );
  return {
    c() {
      p = element("p");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      p.innerHTML = raw_value;
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_pending_block$2(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_fragment$v(ctx) {
  let section;
  let t0;
  let t1;
  let if_block0 = (
    /*itemData*/
    ctx[0].price && create_if_block_2$b(ctx)
  );
  let if_block1 = (
    /*itemData*/
    ctx[0].weight && create_if_block_1$f(ctx)
  );
  let if_block2 = (
    /*itemDescription*/
    ctx[1] && create_if_block$l(ctx)
  );
  return {
    c() {
      section = element("section");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
    },
    m(target, anchor) {
      insert(target, section, anchor);
      if (if_block0)
        if_block0.m(section, null);
      append(section, t0);
      if (if_block1)
        if_block1.m(section, null);
      append(section, t1);
      if (if_block2)
        if_block2.m(section, null);
    },
    p(ctx2, [dirty]) {
      if (
        /*itemData*/
        ctx2[0].price
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$b(ctx2);
          if_block0.c();
          if_block0.m(section, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*itemData*/
        ctx2[0].weight
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$f(ctx2);
          if_block1.c();
          if_block1.m(section, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*itemDescription*/
        ctx2[1]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$l(ctx2);
          if_block2.c();
          if_block2.m(section, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$v($$self, $$props, $$invalidate) {
  var _a;
  let { itemData } = $$props;
  const cost = i18n("A5E.ItemPrice");
  const weight = i18n("A5E.ItemWeight");
  const weightAbr = i18n("A5E.MeasurementPoundsAbbr");
  let itemDescription = itemData.description;
  if (itemData.unidentified) {
    itemDescription = ((_a = itemData.unidentifiedDescription) === null || _a === void 0 ? void 0 : _a.length) !== 0 ? itemData.unidentifiedDescription : i18n("A5E.ItemUnidentified");
  }
  const enrichedText = TextEditor.enrichHTML(itemDescription);
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(0, itemData = $$props2.itemData);
  };
  return [itemData, itemDescription, cost, weight, weightAbr, enrichedText];
}
class A5eObjectDescription extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$v, create_fragment$v, safe_not_equal, { itemData: 0 });
  }
}
var ObjectType = /* @__PURE__ */ ((ObjectType2) => {
  ObjectType2["Weapon"] = "weapon";
  ObjectType2["Armor"] = "armor";
  ObjectType2["Helm"] = "helm";
  ObjectType2["Shield"] = "shield";
  ObjectType2["Ammunition"] = "ammunition";
  ObjectType2["Clothing"] = "clothing";
  ObjectType2["Consumable"] = "consumable";
  ObjectType2["Container"] = "container";
  ObjectType2["Jewelry"] = "jewelry";
  ObjectType2["Miscellaneous"] = "miscellaneous";
  ObjectType2["Tool"] = "tool";
  return ObjectType2;
})(ObjectType || {});
var EquippedState = /* @__PURE__ */ ((EquippedState2) => {
  EquippedState2[EquippedState2["NOT_CARRIED"] = 0] = "NOT_CARRIED";
  EquippedState2[EquippedState2["CARRIED"] = 1] = "CARRIED";
  EquippedState2[EquippedState2["EQUIPPED"] = 2] = "EQUIPPED";
  return EquippedState2;
})(EquippedState || {});
var DamageState = /* @__PURE__ */ ((DamageState2) => {
  DamageState2[DamageState2["INTACT"] = 0] = "INTACT";
  DamageState2[DamageState2["DAMAGED"] = 1] = "DAMAGED";
  DamageState2[DamageState2["BROKEN"] = 2] = "BROKEN";
  return DamageState2;
})(DamageState || {});
const A5eObjectStateToggles_svelte_svelte_type_style_lang = "";
function create_if_block$k(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "class", "action-button fas fa-link svelte-mobile-companion81nkluj30u9vsd-1bdoqzy");
      toggle_class(
        button,
        "active",
        /*isAttuned*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = listen(button, "click", stop_propagation(
          /*click_handler*/
          ctx[5]
        ));
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*isAttuned*/
      16) {
        toggle_class(
          button,
          "active",
          /*isAttuned*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment$u(ctx) {
  let div1;
  let span;
  let b;
  let t2;
  let div0;
  let t3;
  let button0;
  let t4;
  let button1;
  let mounted;
  let dispose;
  let if_block = (
    /*itemData*/
    ctx[1].requiresAttunement && create_if_block$k(ctx)
  );
  return {
    c() {
      div1 = element("div");
      span = element("span");
      b = element("b");
      b.textContent = `${myi18n("A5E.StateToggle")}:`;
      t2 = space();
      div0 = element("div");
      if (if_block)
        if_block.c();
      t3 = space();
      button0 = element("button");
      t4 = space();
      button1 = element("button");
      attr(button0, "class", "action-button fas svelte-mobile-companion81nkluj30u9vsd-1bdoqzy");
      toggle_class(
        button0,
        "fa-shield-alt",
        /*equippedState*/
        ctx[3] === EquippedState.EQUIPPED
      );
      toggle_class(
        button0,
        "fa-person-carry-box",
        /*equippedState*/
        ctx[3] === EquippedState.CARRIED
      );
      toggle_class(
        button0,
        "fa-tents",
        /*equippedState*/
        ctx[3] === EquippedState.NOT_CARRIED
      );
      toggle_class(button0, "active", [EquippedState.EQUIPPED, EquippedState.CARRIED].includes(
        /*equippedState*/
        ctx[3]
      ));
      attr(button1, "class", "action-button fas svelte-mobile-companion81nkluj30u9vsd-1bdoqzy");
      toggle_class(
        button1,
        "fa-heart",
        /*damagedState*/
        ctx[2] === DamageState.INTACT
      );
      toggle_class(
        button1,
        "fa-heart-crack",
        /*damagedState*/
        ctx[2] === DamageState.DAMAGED
      );
      toggle_class(
        button1,
        "fa-heart-pulse",
        /*damagedState*/
        ctx[2] === DamageState.BROKEN
      );
      toggle_class(button1, "active", [DamageState.DAMAGED, DamageState.BROKEN].includes(
        /*damagedState*/
        ctx[2]
      ));
      attr(div0, "class", "button-wrapper svelte-mobile-companion81nkluj30u9vsd-1bdoqzy");
      attr(div1, "class", "state-toggle svelte-mobile-companion81nkluj30u9vsd-1bdoqzy");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span);
      append(span, b);
      append(div1, t2);
      append(div1, div0);
      if (if_block)
        if_block.m(div0, null);
      append(div0, t3);
      append(div0, button0);
      append(div0, t4);
      append(div0, button1);
      if (!mounted) {
        dispose = [
          listen(button0, "click", stop_propagation(
            /*click_handler_1*/
            ctx[6]
          )),
          listen(button1, "click", stop_propagation(
            /*click_handler_2*/
            ctx[7]
          ))
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (
        /*itemData*/
        ctx2[1].requiresAttunement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$k(ctx2);
          if_block.c();
          if_block.m(div0, t3);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*equippedState*/
      8) {
        toggle_class(
          button0,
          "fa-shield-alt",
          /*equippedState*/
          ctx2[3] === EquippedState.EQUIPPED
        );
      }
      if (dirty & /*equippedState*/
      8) {
        toggle_class(
          button0,
          "fa-person-carry-box",
          /*equippedState*/
          ctx2[3] === EquippedState.CARRIED
        );
      }
      if (dirty & /*equippedState*/
      8) {
        toggle_class(
          button0,
          "fa-tents",
          /*equippedState*/
          ctx2[3] === EquippedState.NOT_CARRIED
        );
      }
      if (dirty & /*equippedState*/
      8) {
        toggle_class(button0, "active", [EquippedState.EQUIPPED, EquippedState.CARRIED].includes(
          /*equippedState*/
          ctx2[3]
        ));
      }
      if (dirty & /*damagedState*/
      4) {
        toggle_class(
          button1,
          "fa-heart",
          /*damagedState*/
          ctx2[2] === DamageState.INTACT
        );
      }
      if (dirty & /*damagedState*/
      4) {
        toggle_class(
          button1,
          "fa-heart-crack",
          /*damagedState*/
          ctx2[2] === DamageState.DAMAGED
        );
      }
      if (dirty & /*damagedState*/
      4) {
        toggle_class(
          button1,
          "fa-heart-pulse",
          /*damagedState*/
          ctx2[2] === DamageState.BROKEN
        );
      }
      if (dirty & /*damagedState*/
      4) {
        toggle_class(button1, "active", [DamageState.DAMAGED, DamageState.BROKEN].includes(
          /*damagedState*/
          ctx2[2]
        ));
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance$u($$self, $$props, $$invalidate) {
  let itemData;
  let isAttuned;
  let equippedState;
  let damagedState;
  let { item } = $$props;
  const click_handler = () => item.toggleAttunement();
  const click_handler_1 = () => item.toggleEquippedState();
  const click_handler_2 = () => item.toggleDamagedState();
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(1, itemData = item.system);
    }
    if ($$self.$$.dirty & /*itemData*/
    2) {
      itemData.favorite;
    }
    if ($$self.$$.dirty & /*itemData*/
    2) {
      $$invalidate(4, isAttuned = itemData.attuned);
    }
    if ($$self.$$.dirty & /*itemData*/
    2) {
      $$invalidate(3, equippedState = itemData.equippedState);
    }
    if ($$self.$$.dirty & /*itemData*/
    2) {
      $$invalidate(2, damagedState = itemData.damagedState);
    }
  };
  return [
    item,
    itemData,
    damagedState,
    equippedState,
    isAttuned,
    click_handler,
    click_handler_1,
    click_handler_2
  ];
}
class A5eObjectStateToggles extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$u, create_fragment$u, safe_not_equal, { item: 0 });
  }
}
const A5eObjectStatesDisplay_svelte_svelte_type_style_lang = "";
function create_if_block$j(ctx) {
  let div2;
  return {
    c() {
      div2 = element("div");
      attr(div2, "class", "item-icon fas fa-xs fa-link svelte-mobile-companion81nkluj30u9vsd-ppq0nm");
      toggle_class(
        div2,
        "active",
        /*isAttuned*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*isAttuned*/
      8) {
        toggle_class(
          div2,
          "active",
          /*isAttuned*/
          ctx2[3]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
    }
  };
}
function create_fragment$t(ctx) {
  let div2;
  let t0;
  let div0;
  let t1;
  let div1;
  let if_block = (
    /*itemData*/
    ctx[0].requiresAttunement && create_if_block$j(ctx)
  );
  return {
    c() {
      div2 = element("div");
      if (if_block)
        if_block.c();
      t0 = space();
      div0 = element("div");
      t1 = space();
      div1 = element("div");
      attr(div0, "class", "item-icon fas fa-xs svelte-mobile-companion81nkluj30u9vsd-ppq0nm");
      toggle_class(
        div0,
        "fa-shield-alt",
        /*equippedState*/
        ctx[2] === EquippedState.EQUIPPED
      );
      toggle_class(
        div0,
        "fa-person-carry-box",
        /*equippedState*/
        ctx[2] === EquippedState.CARRIED
      );
      toggle_class(
        div0,
        "fa-tents",
        /*equippedState*/
        ctx[2] === EquippedState.NOT_CARRIED
      );
      toggle_class(div0, "active", [EquippedState.EQUIPPED, EquippedState.CARRIED].includes(
        /*equippedState*/
        ctx[2]
      ));
      attr(div1, "class", "item-icon fas fa-xs svelte-mobile-companion81nkluj30u9vsd-ppq0nm");
      toggle_class(
        div1,
        "fa-heart",
        /*damagedState*/
        ctx[1] === DamageState.INTACT
      );
      toggle_class(
        div1,
        "fa-heart-crack",
        /*damagedState*/
        ctx[1] === DamageState.DAMAGED
      );
      toggle_class(
        div1,
        "fa-heart-pulse",
        /*damagedState*/
        ctx[1] === DamageState.BROKEN
      );
      toggle_class(div1, "active", [DamageState.DAMAGED, DamageState.BROKEN].includes(
        /*damagedState*/
        ctx[1]
      ));
      attr(div2, "class", "icon-wrapper svelte-mobile-companion81nkluj30u9vsd-ppq0nm");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block)
        if_block.m(div2, null);
      append(div2, t0);
      append(div2, div0);
      append(div2, t1);
      append(div2, div1);
    },
    p(ctx2, [dirty]) {
      if (
        /*itemData*/
        ctx2[0].requiresAttunement
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$j(ctx2);
          if_block.c();
          if_block.m(div2, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*equippedState*/
      4) {
        toggle_class(
          div0,
          "fa-shield-alt",
          /*equippedState*/
          ctx2[2] === EquippedState.EQUIPPED
        );
      }
      if (dirty & /*equippedState*/
      4) {
        toggle_class(
          div0,
          "fa-person-carry-box",
          /*equippedState*/
          ctx2[2] === EquippedState.CARRIED
        );
      }
      if (dirty & /*equippedState*/
      4) {
        toggle_class(
          div0,
          "fa-tents",
          /*equippedState*/
          ctx2[2] === EquippedState.NOT_CARRIED
        );
      }
      if (dirty & /*equippedState*/
      4) {
        toggle_class(div0, "active", [EquippedState.EQUIPPED, EquippedState.CARRIED].includes(
          /*equippedState*/
          ctx2[2]
        ));
      }
      if (dirty & /*damagedState*/
      2) {
        toggle_class(
          div1,
          "fa-heart",
          /*damagedState*/
          ctx2[1] === DamageState.INTACT
        );
      }
      if (dirty & /*damagedState*/
      2) {
        toggle_class(
          div1,
          "fa-heart-crack",
          /*damagedState*/
          ctx2[1] === DamageState.DAMAGED
        );
      }
      if (dirty & /*damagedState*/
      2) {
        toggle_class(
          div1,
          "fa-heart-pulse",
          /*damagedState*/
          ctx2[1] === DamageState.BROKEN
        );
      }
      if (dirty & /*damagedState*/
      2) {
        toggle_class(div1, "active", [DamageState.DAMAGED, DamageState.BROKEN].includes(
          /*damagedState*/
          ctx2[1]
        ));
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$t($$self, $$props, $$invalidate) {
  let itemData;
  let isAttuned;
  let equippedState;
  let damagedState;
  let { item } = $$props;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(4, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    16) {
      $$invalidate(0, itemData = item.system);
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      itemData.favorite;
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      $$invalidate(3, isAttuned = itemData.attuned);
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      $$invalidate(2, equippedState = itemData.equippedState);
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      $$invalidate(1, damagedState = itemData.damagedState);
    }
  };
  return [itemData, damagedState, equippedState, isAttuned, item];
}
class A5eObjectStatesDisplay extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$t, create_fragment$t, safe_not_equal, { item: 4 });
  }
}
const A5eUses_svelte_svelte_type_style_lang = "";
function create_fragment$s(ctx) {
  let div1;
  let span0;
  let b;
  let t2;
  let div0;
  let evaluatinginput;
  let t3;
  let span1;
  let t5;
  let input;
  let input_value_value;
  let current;
  evaluatinginput = new EvaluatingInput({
    props: {
      value: (
        /*uses*/
        ctx[0].value
      ),
      id: "uses.value",
      name: "uses.value",
      styleClass: "number-input",
      min: 0,
      max: (
        /*uses*/
        ctx[0].max
      )
    }
  });
  evaluatinginput.$on(
    "change",
    /*updateUses*/
    ctx[1]
  );
  return {
    c() {
      div1 = element("div");
      span0 = element("span");
      b = element("b");
      b.textContent = `${i18n("A5E.Uses")}:`;
      t2 = space();
      div0 = element("div");
      create_component(evaluatinginput.$$.fragment);
      t3 = space();
      span1 = element("span");
      span1.textContent = "/";
      t5 = space();
      input = element("input");
      attr(input, "class", "number-input svelte-mobile-companion81nkluj30u9vsd-oej98i");
      attr(input, "type", "number");
      input.value = input_value_value = /*uses*/
      ctx[0].max;
      input.disabled = true;
      attr(div0, "class", "uses-inputs svelte-mobile-companion81nkluj30u9vsd-oej98i");
      attr(div1, "class", "uses svelte-mobile-companion81nkluj30u9vsd-oej98i");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, span0);
      append(span0, b);
      append(div1, t2);
      append(div1, div0);
      mount_component(evaluatinginput, div0, null);
      append(div0, t3);
      append(div0, span1);
      append(div0, t5);
      append(div0, input);
      current = true;
    },
    p(ctx2, [dirty]) {
      const evaluatinginput_changes = {};
      if (dirty & /*uses*/
      1)
        evaluatinginput_changes.value = /*uses*/
        ctx2[0].value;
      if (dirty & /*uses*/
      1)
        evaluatinginput_changes.max = /*uses*/
        ctx2[0].max;
      evaluatinginput.$set(evaluatinginput_changes);
      if (!current || dirty & /*uses*/
      1 && input_value_value !== (input_value_value = /*uses*/
      ctx2[0].max) && input.value !== input_value_value) {
        input.value = input_value_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(evaluatinginput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(evaluatinginput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(evaluatinginput);
    }
  };
}
function instance$s($$self, $$props, $$invalidate) {
  let itemData;
  let uses;
  let { item } = $$props;
  let { action = void 0 } = $$props;
  let { actionId = void 0 } = $$props;
  function updateUses(event) {
    event.preventDefault();
    const target = event.detail;
    const newUses = +target.value;
    if (action) {
      item.update({
        [`system.actions.${actionId}.uses.value`]: newUses
      });
    } else {
      item.update({ [`system.uses.value`]: newUses });
    }
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(2, item = $$props2.item);
    if ("action" in $$props2)
      $$invalidate(3, action = $$props2.action);
    if ("actionId" in $$props2)
      $$invalidate(4, actionId = $$props2.actionId);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    4) {
      $$invalidate(5, itemData = item.system);
    }
    if ($$self.$$.dirty & /*action, itemData*/
    40) {
      $$invalidate(0, uses = action ? action.uses : itemData.uses);
    }
  };
  return [uses, updateUses, item, action, actionId, itemData];
}
class A5eUses extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$s, create_fragment$s, safe_not_equal, { item: 2, action: 3, actionId: 4 });
  }
}
function create_fragment$r(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*action*/
    ctx[0].activation.cost + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*A5E*/
    ctx[1].abilityActivationTypes[
      /*action*/
      ctx[0].activation.type
    ] + ""
  );
  let t5;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ActionActivationCost")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      t5 = text(t5_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, t5);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*action*/
      1 && t3_value !== (t3_value = /*action*/
      ctx2[0].activation.cost + ""))
        set_data(t3, t3_value);
      if (dirty & /*action*/
      1 && t5_value !== (t5_value = /*A5E*/
      ctx2[1].abilityActivationTypes[
        /*action*/
        ctx2[0].activation.type
      ] + ""))
        set_data(t5, t5_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function instance$r($$self, $$props, $$invalidate) {
  let { action } = $$props;
  const A5E = CONFIG.A5E;
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
  };
  return [action, A5E];
}
class A5eObjectCost extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$r, create_fragment$r, safe_not_equal, { action: 0 });
  }
}
function create_else_block_1(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*A5E*/
    ctx[1].timePeriods[
      /*action*/
      ctx[0].duration.unit
    ] + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ItemDuration")}
        :`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*action*/
      1 && t3_value !== (t3_value = /*A5E*/
      ctx2[1].timePeriods[
        /*action*/
        ctx2[0].duration.unit
      ] + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$i(ctx) {
  let if_block_anchor;
  function select_block_type_1(ctx2, dirty) {
    if (
      /*action*/
      ctx2[0].duration.value > 1
    )
      return create_if_block_1$e;
    return create_else_block$4;
  }
  let current_block_type = select_block_type_1(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (current_block_type === (current_block_type = select_block_type_1(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function create_else_block$4(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*action*/
    ctx[0].duration.value + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*A5E*/
    ctx[1].timePeriods[
      /*action*/
      ctx[0].duration.unit
    ] + ""
  );
  let t5;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ItemDuration")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      t5 = text(t5_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, t5);
    },
    p(ctx2, dirty) {
      if (dirty & /*action*/
      1 && t3_value !== (t3_value = /*action*/
      ctx2[0].duration.value + ""))
        set_data(t3, t3_value);
      if (dirty & /*action*/
      1 && t5_value !== (t5_value = /*A5E*/
      ctx2[1].timePeriods[
        /*action*/
        ctx2[0].duration.unit
      ] + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_1$e(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*action*/
    ctx[0].duration.value + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*A5E*/
    ctx[1].timePeriodsPlural[
      /*action*/
      ctx[0].duration.unit
    ] + ""
  );
  let t5;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ItemDuration")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      t5 = text(t5_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, t5);
    },
    p(ctx2, dirty) {
      if (dirty & /*action*/
      1 && t3_value !== (t3_value = /*action*/
      ctx2[0].duration.value + ""))
        set_data(t3, t3_value);
      if (dirty & /*action*/
      1 && t5_value !== (t5_value = /*A5E*/
      ctx2[1].timePeriodsPlural[
        /*action*/
        ctx2[0].duration.unit
      ] + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$q(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*action*/
      ctx2[0].duration.value
    )
      return create_if_block$i;
    return create_else_block_1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$q($$self, $$props, $$invalidate) {
  let { action } = $$props;
  const A5E = CONFIG.A5E;
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
  };
  return [action, A5E];
}
class A5eObjectDuration extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$q, create_fragment$q, safe_not_equal, { action: 0 });
  }
}
var RollType = /* @__PURE__ */ ((RollType2) => {
  RollType2["attack"] = "attack";
  RollType2["damage"] = "damage";
  RollType2["healing"] = "healing";
  RollType2["generic"] = "generic";
  RollType2["savingThrow"] = "savingThrow";
  RollType2["skillCheck"] = "skillCheck";
  RollType2["toolCheck"] = "toolCheck";
  return RollType2;
})(RollType || {});
function create_else_block$3(ctx) {
  let p;
  let b;
  let t0_value = (
    /*A5E*/
    ctx[2].rollTypes[
      /*roll*/
      ctx[0].type
    ] + ""
  );
  let t0;
  let t1;
  let t2;
  let t3_value = (
    /*roll*/
    ctx[0].formula ? `${/*result*/
    ctx[1]}` : ""
  );
  let t3;
  let t4;
  let i2;
  return {
    c() {
      p = element("p");
      b = element("b");
      t0 = text(t0_value);
      t1 = text(":");
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      i2 = element("i");
      i2.textContent = `${/*rollLabel*/
      ctx[3]}`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(b, t0);
      append(b, t1);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, i2);
    },
    p(ctx2, dirty) {
      if (dirty & /*roll*/
      1 && t0_value !== (t0_value = /*A5E*/
      ctx2[2].rollTypes[
        /*roll*/
        ctx2[0].type
      ] + ""))
        set_data(t0, t0_value);
      if (dirty & /*roll, result*/
      3 && t3_value !== (t3_value = /*roll*/
      ctx2[0].formula ? `${/*result*/
      ctx2[1]}` : ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_2$a(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*result*/
    ctx[1] ? `${/*result*/
    ctx[1]}` : ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*roll*/
    (ctx[0].damageType ? (
      /*A5E*/
      ctx[2].damageTypes[
        /*roll*/
        ctx[0].damageType
      ]
    ) : "") + ""
  );
  let t5;
  let t6;
  let i2;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ActionOptionDamage")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      t5 = text(t5_value);
      t6 = space();
      i2 = element("i");
      i2.textContent = `${/*rollLabel*/
      ctx[3]}`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, t5);
      append(p, t6);
      append(p, i2);
    },
    p(ctx2, dirty) {
      if (dirty & /*result*/
      2 && t3_value !== (t3_value = /*result*/
      ctx2[1] ? `${/*result*/
      ctx2[1]}` : ""))
        set_data(t3, t3_value);
      if (dirty & /*roll*/
      1 && t5_value !== (t5_value = /*roll*/
      (ctx2[0].damageType ? (
        /*A5E*/
        ctx2[2].damageTypes[
          /*roll*/
          ctx2[0].damageType
        ]
      ) : "") + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$h(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*result*/
    (ctx[1] && `${/*result*/
    ctx[1]}`) + ""
  );
  let t3;
  let t4;
  let i2;
  let t6;
  let if_block_anchor;
  let if_block = (
    /*roll*/
    ctx[0].attackType && create_if_block_1$d(ctx)
  );
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ActionOptionAttack")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      i2 = element("i");
      i2.textContent = `${/*rollLabel*/
      ctx[3]}`;
      t6 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, i2);
      insert(target, t6, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*result*/
      2 && t3_value !== (t3_value = /*result*/
      (ctx2[1] && `${/*result*/
      ctx2[1]}`) + ""))
        set_data(t3, t3_value);
      if (
        /*roll*/
        ctx2[0].attackType
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$d(ctx2);
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(p);
        detach(t6);
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_if_block_1$d(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*A5E*/
    ctx[2].attackTypes[
      /*roll*/
      ctx[0].attackType
    ] + ""
  );
  let t3;
  let t4;
  let i2;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.AttackType")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      i2 = element("i");
      i2.textContent = `${/*rollLabel*/
      ctx[3]}`;
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, i2);
    },
    p(ctx2, dirty) {
      if (dirty & /*roll*/
      1 && t3_value !== (t3_value = /*A5E*/
      ctx2[2].attackTypes[
        /*roll*/
        ctx2[0].attackType
      ] + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$p(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*roll*/
      ctx2[0].type === "attack"
    )
      return create_if_block$h;
    if (
      /*roll*/
      ctx2[0].type === "damage"
    )
      return create_if_block_2$a;
    return create_else_block$3;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$p($$self, $$props, $$invalidate) {
  var _a;
  let { itemData } = $$props;
  let { roll } = $$props;
  let { rollData } = $$props;
  const A5E = CONFIG.A5E;
  let rollFormula;
  if (roll.type === RollType.attack) {
    rollFormula = "1d20";
    if (roll.formula) {
      rollFormula += " + " + roll.formula;
    }
    if (roll.bonus) {
      rollFormula += " + " + roll.bonus;
    }
    if ((_a = itemData.weaponProperties) === null || _a === void 0 ? void 0 : _a.some((prop) => prop === "finesse")) {
      rollFormula += " + @finesse.mod";
    }
  } else {
    rollFormula = roll.formula;
  }
  const rollLabel = roll.label ? `(${roll.label})` : "";
  let result = evaluateAsFormula(rollFormula, rollData);
  result = evaluateDiceExpression(result);
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(4, itemData = $$props2.itemData);
    if ("roll" in $$props2)
      $$invalidate(0, roll = $$props2.roll);
    if ("rollData" in $$props2)
      $$invalidate(5, rollData = $$props2.rollData);
  };
  return [roll, result, A5E, rollLabel, itemData, rollData];
}
class A5eObjectRolls extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$p, create_fragment$p, safe_not_equal, { itemData: 4, roll: 0, rollData: 5 });
  }
}
function create_else_block$2(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*A5E*/
    (ctx[1].targetTypes[
      /*action*/
      ctx[0].target.type
    ] ?? "") + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ItemTarget")}:`;
      t2 = text("\r\n        1 ");
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*action*/
      1 && t3_value !== (t3_value = /*A5E*/
      (ctx2[1].targetTypes[
        /*action*/
        ctx2[0].target.type
      ] ?? "") + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$g(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*action*/
    ctx[0].target.quantity + ""
  );
  let t3;
  let t4;
  let t5_value = (
    /*A5E*/
    (ctx[1].targetTypesPlural[
      /*action*/
      ctx[0].target.type
    ] ?? "") + ""
  );
  let t5;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ItemTargetPlural")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      t5 = text(t5_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      append(p, t5);
    },
    p(ctx2, dirty) {
      if (dirty & /*action*/
      1 && t3_value !== (t3_value = /*action*/
      ctx2[0].target.quantity + ""))
        set_data(t3, t3_value);
      if (dirty & /*action*/
      1 && t5_value !== (t5_value = /*A5E*/
      (ctx2[1].targetTypesPlural[
        /*action*/
        ctx2[0].target.type
      ] ?? "") + ""))
        set_data(t5, t5_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$o(ctx) {
  let if_block_anchor;
  function select_block_type(ctx2, dirty) {
    if (
      /*action*/
      ctx2[0].target.quantity > 1
    )
      return create_if_block$g;
    return create_else_block$2;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_block.d(detaching);
    }
  };
}
function instance$o($$self, $$props, $$invalidate) {
  let { action } = $$props;
  const A5E = CONFIG.A5E;
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
  };
  return [action, A5E];
}
class A5eTarget extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$o, create_fragment$o, safe_not_equal, { action: 0 });
  }
}
const A5eObjectAction_svelte_svelte_type_style_lang = "";
function get_each_context$8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[5] = list[i2];
  child_ctx[7] = i2;
  return child_ctx;
}
function create_if_block_4$6(ctx) {
  let a5euses;
  let current;
  a5euses = new A5eUses({
    props: {
      item: (
        /*item*/
        ctx[2]
      ),
      action: (
        /*action*/
        ctx[0]
      ),
      actionId: (
        /*actionId*/
        ctx[1]
      )
    }
  });
  return {
    c() {
      create_component(a5euses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(a5euses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const a5euses_changes = {};
      if (dirty & /*item*/
      4)
        a5euses_changes.item = /*item*/
        ctx2[2];
      if (dirty & /*action*/
      1)
        a5euses_changes.action = /*action*/
        ctx2[0];
      if (dirty & /*actionId*/
      2)
        a5euses_changes.actionId = /*actionId*/
        ctx2[1];
      a5euses.$set(a5euses_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5euses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5euses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(a5euses, detaching);
    }
  };
}
function create_if_block_3$8(ctx) {
  let objectcost;
  let current;
  objectcost = new A5eObjectCost({ props: { action: (
    /*action*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(objectcost.$$.fragment);
    },
    m(target, anchor) {
      mount_component(objectcost, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const objectcost_changes = {};
      if (dirty & /*action*/
      1)
        objectcost_changes.action = /*action*/
        ctx2[0];
      objectcost.$set(objectcost_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(objectcost.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(objectcost.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(objectcost, detaching);
    }
  };
}
function create_if_block_2$9(ctx) {
  let target;
  let current;
  target = new A5eTarget({ props: { action: (
    /*action*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(target.$$.fragment);
    },
    m(target$1, anchor) {
      mount_component(target, target$1, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const target_changes = {};
      if (dirty & /*action*/
      1)
        target_changes.action = /*action*/
        ctx2[0];
      target.$set(target_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(target.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(target.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(target, detaching);
    }
  };
}
function create_if_block_1$c(ctx) {
  let objectduration;
  let current;
  objectduration = new A5eObjectDuration({ props: { action: (
    /*action*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(objectduration.$$.fragment);
    },
    m(target, anchor) {
      mount_component(objectduration, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const objectduration_changes = {};
      if (dirty & /*action*/
      1)
        objectduration_changes.action = /*action*/
        ctx2[0];
      objectduration.$set(objectduration_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(objectduration.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(objectduration.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(objectduration, detaching);
    }
  };
}
function create_if_block$f(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.values(
    /*action*/
    ctx[0].rolls
  ));
  const get_key = (ctx2) => (
    /*index*/
    ctx2[7]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$8(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$8(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData, Object, action, rollData*/
      25) {
        each_value = ensure_array_like(Object.values(
          /*action*/
          ctx2[0].rolls
        ));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$8, each_1_anchor, get_each_context$8);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$8(key_1, ctx) {
  let first;
  let objectroll;
  let current;
  objectroll = new A5eObjectRolls({
    props: {
      itemData: (
        /*itemData*/
        ctx[4]
      ),
      roll: (
        /*roll*/
        ctx[5]
      ),
      rollData: (
        /*rollData*/
        ctx[3]
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(objectroll.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(objectroll, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const objectroll_changes = {};
      if (dirty & /*itemData*/
      16)
        objectroll_changes.itemData = /*itemData*/
        ctx[4];
      if (dirty & /*action*/
      1)
        objectroll_changes.roll = /*roll*/
        ctx[5];
      if (dirty & /*rollData*/
      8)
        objectroll_changes.rollData = /*rollData*/
        ctx[3];
      objectroll.$set(objectroll_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(objectroll.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(objectroll.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(objectroll, detaching);
    }
  };
}
function create_fragment$n(ctx) {
  let div2;
  let h3;
  let t0_value = (
    /*action*/
    ctx[0].name + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let current;
  let if_block0 = (
    /*action*/
    ctx[0].uses?.max && create_if_block_4$6(ctx)
  );
  let if_block1 = (
    /*action*/
    ctx[0].activation?.cost && create_if_block_3$8(ctx)
  );
  let if_block2 = (
    /*action*/
    ctx[0].target?.quantity && create_if_block_2$9(ctx)
  );
  let if_block3 = (
    /*action*/
    ctx[0].duration?.unit && create_if_block_1$c(ctx)
  );
  let if_block4 = (
    /*action*/
    ctx[0].rolls && create_if_block$f(ctx)
  );
  return {
    c() {
      div2 = element("div");
      h3 = element("h3");
      t0 = text(t0_value);
      t1 = space();
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      t3 = space();
      if (if_block2)
        if_block2.c();
      t4 = space();
      if (if_block3)
        if_block3.c();
      t5 = space();
      if (if_block4)
        if_block4.c();
      attr(div2, "class", "item-action svelte-mobile-companion81nkluj30u9vsd-x2ubd8");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h3);
      append(h3, t0);
      append(div2, t1);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t2);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t3);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t4);
      if (if_block3)
        if_block3.m(div2, null);
      append(div2, t5);
      if (if_block4)
        if_block4.m(div2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if ((!current || dirty & /*action*/
      1) && t0_value !== (t0_value = /*action*/
      ctx2[0].name + ""))
        set_data(t0, t0_value);
      if (
        /*action*/
        ctx2[0].uses?.max
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*action*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$6(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t2);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*action*/
        ctx2[0].activation?.cost
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*action*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$8(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t3);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*action*/
        ctx2[0].target?.quantity
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*action*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t4);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*action*/
        ctx2[0].duration?.unit
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*action*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$c(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*action*/
        ctx2[0].rolls
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*action*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block$f(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, null);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
    }
  };
}
function instance$n($$self, $$props, $$invalidate) {
  let itemData;
  let { action } = $$props;
  let { actionId } = $$props;
  let { item } = $$props;
  let { rollData } = $$props;
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(0, action = $$props2.action);
    if ("actionId" in $$props2)
      $$invalidate(1, actionId = $$props2.actionId);
    if ("item" in $$props2)
      $$invalidate(2, item = $$props2.item);
    if ("rollData" in $$props2)
      $$invalidate(3, rollData = $$props2.rollData);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    4) {
      $$invalidate(4, itemData = item.system);
    }
  };
  return [action, actionId, item, rollData, itemData];
}
class A5eObjectAction extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$n, create_fragment$n, safe_not_equal, {
      action: 0,
      actionId: 1,
      item: 2,
      rollData: 3
    });
  }
}
function create_if_block_7$3(ctx) {
  let p;
  let b;
  let t1;
  let t2_value = (
    /*A5E*/
    ctx[5].itemRarity[
      /*itemData*/
      ctx[0].rarity
    ] + ""
  );
  let t2;
  let t3_value = (
    /*itemData*/
    ctx[0].requiresAttunement ? ` (${i18n("A5E.AttunementRequiredPrompt")})` : ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ItemRarity")}`;
      t1 = space();
      t2 = text(t2_value);
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t1);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t2_value !== (t2_value = /*A5E*/
      ctx2[5].itemRarity[
        /*itemData*/
        ctx2[0].rarity
      ] + ""))
        set_data(t2, t2_value);
      if (dirty & /*itemData*/
      1 && t3_value !== (t3_value = /*itemData*/
      ctx2[0].requiresAttunement ? ` (${i18n("A5E.AttunementRequiredPrompt")})` : ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_5$5(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*A5E*/
    ctx[5].armor[
      /*itemData*/
      ctx[0].armorCategory
    ] + ""
  );
  let t3;
  let t4;
  let if_block = (
    /*armorProperties*/
    ctx[4] && create_if_block_6$3(ctx)
  );
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ArmorProperties")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      if (if_block)
        if_block.m(p, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t3_value !== (t3_value = /*A5E*/
      ctx2[5].armor[
        /*itemData*/
        ctx2[0].armorCategory
      ] + ""))
        set_data(t3, t3_value);
      if (
        /*armorProperties*/
        ctx2[4]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_6$3(ctx2);
          if_block.c();
          if_block.m(p, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_6$3(ctx) {
  let t0;
  let t1;
  let t2;
  return {
    c() {
      t0 = text("(");
      t1 = text(
        /*armorProperties*/
        ctx[4]
      );
      t2 = text(")");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*armorProperties*/
      16)
        set_data(
          t1,
          /*armorProperties*/
          ctx2[4]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_if_block_3$7(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*A5E*/
    ctx[5].shieldTypes[
      /*itemData*/
      ctx[0].shieldCategory
    ] + ""
  );
  let t3;
  let t4;
  let if_block = (
    /*shieldProperties*/
    ctx[1] && create_if_block_4$5(ctx)
  );
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.ShieldProperties")}:`;
      t2 = space();
      t3 = text(t3_value);
      t4 = space();
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(p, t4);
      if (if_block)
        if_block.m(p, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t3_value !== (t3_value = /*A5E*/
      ctx2[5].shieldTypes[
        /*itemData*/
        ctx2[0].shieldCategory
      ] + ""))
        set_data(t3, t3_value);
      if (
        /*shieldProperties*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_4$5(ctx2);
          if_block.c();
          if_block.m(p, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_4$5(ctx) {
  let t0;
  let t1;
  let t2;
  return {
    c() {
      t0 = text("(");
      t1 = text(
        /*shieldProperties*/
        ctx[1]
      );
      t2 = text(")");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
      insert(target, t2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*shieldProperties*/
      2)
        set_data(
          t1,
          /*shieldProperties*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
      }
    }
  };
}
function create_if_block_2$8(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.WeaponProperties")}:`;
      t2 = space();
      t3 = text(
        /*weaponProperties*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*weaponProperties*/
      8)
        set_data(
          t3,
          /*weaponProperties*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_1$b(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.MaterialProperties")}:`;
      t2 = space();
      t3 = text(
        /*materialProperties*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*materialProperties*/
      4)
        set_data(
          t3,
          /*materialProperties*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$e(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*itemData*/
    ctx[0].craftingComponents + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("A5E.CraftingComponents")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t3_value !== (t3_value = /*itemData*/
      ctx2[0].craftingComponents + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$m(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let if_block5_anchor;
  let if_block0 = (
    /*itemData*/
    ctx[0].rarity && create_if_block_7$3(ctx)
  );
  let if_block1 = (
    /*itemData*/
    ctx[0].armorCategory && create_if_block_5$5(ctx)
  );
  let if_block2 = (
    /*itemData*/
    ctx[0].shieldCategory && create_if_block_3$7(ctx)
  );
  let if_block3 = (
    /*weaponProperties*/
    ctx[3] && create_if_block_2$8(ctx)
  );
  let if_block4 = (
    /*materialProperties*/
    ctx[2] && create_if_block_1$b(ctx)
  );
  let if_block5 = (
    /*itemData*/
    ctx[0].craftingComponents && create_if_block$e(ctx)
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      if_block5_anchor = empty();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t3, anchor);
      if (if_block4)
        if_block4.m(target, anchor);
      insert(target, t4, anchor);
      if (if_block5)
        if_block5.m(target, anchor);
      insert(target, if_block5_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (
        /*itemData*/
        ctx2[0].rarity
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_7$3(ctx2);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*itemData*/
        ctx2[0].armorCategory
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_5$5(ctx2);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*itemData*/
        ctx2[0].shieldCategory
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_3$7(ctx2);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*weaponProperties*/
        ctx2[3]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_2$8(ctx2);
          if_block3.c();
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*materialProperties*/
        ctx2[2]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_1$b(ctx2);
          if_block4.c();
          if_block4.m(t4.parentNode, t4);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*itemData*/
        ctx2[0].craftingComponents
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block$e(ctx2);
          if_block5.c();
          if_block5.m(if_block5_anchor.parentNode, if_block5_anchor);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(t4);
        detach(if_block5_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      if (if_block4)
        if_block4.d(detaching);
      if (if_block5)
        if_block5.d(detaching);
    }
  };
}
function instance$m($$self, $$props, $$invalidate) {
  let armorProperties;
  let weaponProperties;
  let materialProperties;
  let shieldProperties;
  let { itemData } = $$props;
  const A5E = CONFIG.A5E;
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(0, itemData = $$props2.itemData);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*itemData*/
    1) {
      itemData.rarity;
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      $$invalidate(4, armorProperties = itemData.armorProperties.map((i2) => A5E.armorProperties[i2]).join(", "));
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      $$invalidate(3, weaponProperties = itemData.weaponProperties.map((i2) => A5E.weaponProperties[i2]).join(", "));
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      itemData.breakerProperties.map((i2) => A5E.breakerProperties[i2]).join(", ");
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      itemData.flaws.map((i2) => A5E.flaws[i2]).join(", ");
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      $$invalidate(2, materialProperties = itemData.materialProperties.map((i2) => A5E.materialProperties[i2]).join(", "));
    }
    if ($$self.$$.dirty & /*itemData*/
    1) {
      $$invalidate(1, shieldProperties = itemData.shieldProperties.map((i2) => A5E.shieldProperties[i2]).join(", "));
    }
  };
  return [
    itemData,
    shieldProperties,
    materialProperties,
    weaponProperties,
    armorProperties,
    A5E
  ];
}
class A5eObjectProperties extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$m, create_fragment$m, safe_not_equal, { itemData: 0 });
  }
}
const A5eObject_svelte_svelte_type_style_lang = "";
function get_each_context$7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2][0];
  child_ctx[13] = list[i2][1];
  return child_ctx;
}
function create_if_block_5$4(ctx) {
  let div2;
  let a5eobjectstatesdisplay;
  let div_transition;
  let current;
  a5eobjectstatesdisplay = new A5eObjectStatesDisplay({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      div2 = element("div");
      create_component(a5eobjectstatesdisplay.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(a5eobjectstatesdisplay, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const a5eobjectstatesdisplay_changes = {};
      if (dirty & /*item*/
      1)
        a5eobjectstatesdisplay_changes.item = /*item*/
        ctx2[0];
      a5eobjectstatesdisplay.$set(a5eobjectstatesdisplay_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobjectstatesdisplay.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, { duration: 200 }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(a5eobjectstatesdisplay.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, { duration: 200 }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(a5eobjectstatesdisplay);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block$d(ctx) {
  let div2;
  let a5eobjectstatetoggles;
  let t0;
  let t1;
  let t2;
  let t3;
  let hr;
  let t4;
  let a5eobjectproperties;
  let t5;
  let div_transition;
  let current;
  a5eobjectstatetoggles = new A5eObjectStateToggles({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  let if_block0 = (
    /*itemData*/
    ctx[2].uses?.max && create_if_block_4$4(ctx)
  );
  let if_block1 = (
    /*ac*/
    ctx[5]?.formula && create_if_block_3$6(ctx)
  );
  let if_block2 = (
    /*itemData*/
    ctx[2].actions && create_if_block_2$7(ctx)
  );
  a5eobjectproperties = new A5eObjectProperties({ props: { itemData: (
    /*itemData*/
    ctx[2]
  ) } });
  let if_block3 = (
    /*itemData*/
    (ctx[2].description || /*itemData*/
    ctx[2].unidentifiedDescription || /*itemData*/
    ctx[2].price || /*itemData*/
    ctx[2].weight) && create_if_block_1$a(ctx)
  );
  return {
    c() {
      div2 = element("div");
      create_component(a5eobjectstatetoggles.$$.fragment);
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      hr = element("hr");
      t4 = space();
      create_component(a5eobjectproperties.$$.fragment);
      t5 = space();
      if (if_block3)
        if_block3.c();
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(a5eobjectstatetoggles, div2, null);
      append(div2, t0);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t1);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t2);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t3);
      append(div2, hr);
      append(div2, t4);
      mount_component(a5eobjectproperties, div2, null);
      append(div2, t5);
      if (if_block3)
        if_block3.m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const a5eobjectstatetoggles_changes = {};
      if (dirty & /*item*/
      1)
        a5eobjectstatetoggles_changes.item = /*item*/
        ctx2[0];
      a5eobjectstatetoggles.$set(a5eobjectstatetoggles_changes);
      if (
        /*itemData*/
        ctx2[2].uses?.max
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*itemData*/
          4) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_4$4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t1);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*ac*/
        ctx2[5]?.formula
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*ac*/
          32) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_3$6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*itemData*/
        ctx2[2].actions
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*itemData*/
          4) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_2$7(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      const a5eobjectproperties_changes = {};
      if (dirty & /*itemData*/
      4)
        a5eobjectproperties_changes.itemData = /*itemData*/
        ctx2[2];
      a5eobjectproperties.$set(a5eobjectproperties_changes);
      if (
        /*itemData*/
        ctx2[2].description || /*itemData*/
        ctx2[2].unidentifiedDescription || /*itemData*/
        ctx2[2].price || /*itemData*/
        ctx2[2].weight
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*itemData*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_1$a(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, null);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobjectstatetoggles.$$.fragment, local);
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(a5eobjectproperties.$$.fragment, local);
      transition_in(if_block3);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: identity$1, axis: "y" }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(a5eobjectstatetoggles.$$.fragment, local);
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(a5eobjectproperties.$$.fragment, local);
      transition_out(if_block3);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: identity$1, axis: "y" }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(a5eobjectstatetoggles);
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      destroy_component(a5eobjectproperties);
      if (if_block3)
        if_block3.d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_4$4(ctx) {
  let a5euses;
  let current;
  a5euses = new A5eUses({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(a5euses.$$.fragment);
    },
    m(target, anchor) {
      mount_component(a5euses, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const a5euses_changes = {};
      if (dirty & /*item*/
      1)
        a5euses_changes.item = /*item*/
        ctx2[0];
      a5euses.$set(a5euses_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5euses.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5euses.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(a5euses, detaching);
    }
  };
}
function create_if_block_3$6(ctx) {
  let a5eobjectac;
  let current;
  a5eobjectac = new A5eObjectAc({
    props: {
      ac: (
        /*ac*/
        ctx[5]
      ),
      rollData: (
        /*rollData*/
        ctx[6]
      )
    }
  });
  return {
    c() {
      create_component(a5eobjectac.$$.fragment);
    },
    m(target, anchor) {
      mount_component(a5eobjectac, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const a5eobjectac_changes = {};
      if (dirty & /*ac*/
      32)
        a5eobjectac_changes.ac = /*ac*/
        ctx2[5];
      a5eobjectac.$set(a5eobjectac_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobjectac.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobjectac.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(a5eobjectac, detaching);
    }
  };
}
function create_if_block_2$7(ctx) {
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(Object.entries(
    /*itemData*/
    ctx[2].actions
  ));
  const get_key = (ctx2) => (
    /*key*/
    ctx2[12]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$7(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$7(key, child_ctx));
  }
  return {
    c() {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*item, Object, itemData, rollData*/
      69) {
        each_value = ensure_array_like(Object.entries(
          /*itemData*/
          ctx2[2].actions
        ));
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$7, each_1_anchor, get_each_context$7);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$7(key_2, ctx) {
  let first;
  let a5eobjectaction;
  let current;
  a5eobjectaction = new A5eObjectAction({
    props: {
      item: (
        /*item*/
        ctx[0]
      ),
      action: (
        /*action*/
        ctx[13]
      ),
      actionId: (
        /*key*/
        ctx[12]
      ),
      rollData: (
        /*rollData*/
        ctx[6]
      )
    }
  });
  return {
    key: key_2,
    first: null,
    c() {
      first = empty();
      create_component(a5eobjectaction.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobjectaction, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobjectaction_changes = {};
      if (dirty & /*item*/
      1)
        a5eobjectaction_changes.item = /*item*/
        ctx[0];
      if (dirty & /*itemData*/
      4)
        a5eobjectaction_changes.action = /*action*/
        ctx[13];
      if (dirty & /*itemData*/
      4)
        a5eobjectaction_changes.actionId = /*key*/
        ctx[12];
      a5eobjectaction.$set(a5eobjectaction_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobjectaction.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobjectaction.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobjectaction, detaching);
    }
  };
}
function create_if_block_1$a(ctx) {
  let a5eobjectdescription;
  let current;
  a5eobjectdescription = new A5eObjectDescription({ props: { itemData: (
    /*itemData*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(a5eobjectdescription.$$.fragment);
    },
    m(target, anchor) {
      mount_component(a5eobjectdescription, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const a5eobjectdescription_changes = {};
      if (dirty & /*itemData*/
      4)
        a5eobjectdescription_changes.itemData = /*itemData*/
        ctx2[2];
      a5eobjectdescription.$set(a5eobjectdescription_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobjectdescription.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobjectdescription.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(a5eobjectdescription, detaching);
    }
  };
}
function create_fragment$l(ctx) {
  let section;
  let div2;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1;
  let t2;
  let div1;
  let t3;
  let quantity;
  let t4;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !/*showItemData*/
  ctx[3] && create_if_block_5$4(ctx);
  quantity = new Quantity({
    props: {
      quantity: (
        /*itemData*/
        ctx[2].quantity
      ),
      fontFamily: "var(--a5e-font-serif)"
    }
  });
  quantity.$on(
    "onQtyChange",
    /*handleQtyChange*/
    ctx[8]
  );
  let if_block1 = (
    /*showItemData*/
    ctx[3] && create_if_block$d(ctx)
  );
  return {
    c() {
      section = element("section");
      div2 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(
        /*itemName*/
        ctx[4]
      );
      t2 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t3 = space();
      create_component(quantity.$$.fragment);
      t4 = space();
      if (if_block1)
        if_block1.c();
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[0].img))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*itemName*/
        ctx[4]
      );
      attr(img, "class", "item-icon svelte-mobile-companion81nkluj30u9vsd-1ei3jdf");
      attr(div0, "class", "item svelte-mobile-companion81nkluj30u9vsd-1ei3jdf");
      attr(div0, "aria-hidden", "true");
      attr(div1, "class", "states-and-qty svelte-mobile-companion81nkluj30u9vsd-1ei3jdf");
      attr(div2, "class", "item-name-and-qty svelte-mobile-companion81nkluj30u9vsd-1ei3jdf");
      attr(section, "class", "svelte-mobile-companion81nkluj30u9vsd-1ei3jdf");
      toggle_class(
        section,
        "odd",
        /*isOddLine*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div2, t2);
      append(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t3);
      mount_component(quantity, div1, null);
      append(section, t4);
      if (if_block1)
        if_block1.m(section, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "click",
          /*toggleDescription*/
          ctx[7]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*item*/
      1 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx2[0].img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*itemName*/
      16) {
        attr(
          img,
          "alt",
          /*itemName*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*itemName*/
      16)
        set_data(
          t1,
          /*itemName*/
          ctx2[4]
        );
      if (!/*showItemData*/
      ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showItemData*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_5$4(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const quantity_changes = {};
      if (dirty & /*itemData*/
      4)
        quantity_changes.quantity = /*itemData*/
        ctx2[2].quantity;
      quantity.$set(quantity_changes);
      if (
        /*showItemData*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showItemData*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$d(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*isOddLine*/
      2) {
        toggle_class(
          section,
          "odd",
          /*isOddLine*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(quantity.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(quantity.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0)
        if_block0.d();
      destroy_component(quantity);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$l($$self, $$props, $$invalidate) {
  let itemData;
  let ac;
  var _a;
  let { item } = $$props;
  let { actor } = $$props;
  let { isOddLine } = $$props;
  const A5E = CONFIG.A5E;
  const rollData = actor.getRollData(item);
  let showItemData = false;
  function toggleDescription() {
    $$invalidate(3, showItemData = !showItemData);
  }
  let itemName;
  function handleQtyChange(event) {
    const update2 = { system: { quantity: event.detail } };
    item.update(update2);
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("actor" in $$props2)
      $$invalidate(9, actor = $$props2.actor);
    if ("isOddLine" in $$props2)
      $$invalidate(1, isOddLine = $$props2.isOddLine);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(2, itemData = item.system);
    }
    if ($$self.$$.dirty & /*itemData*/
    4) {
      $$invalidate(5, ac = itemData.ac);
    }
    if ($$self.$$.dirty & /*item, itemData, _a*/
    1029) {
      {
        $$invalidate(4, itemName = item.name);
        if (itemData.unidentified) {
          $$invalidate(4, itemName = ($$invalidate(10, _a = itemData.unidentifiedName) === null || _a === void 0 ? void 0 : _a.length) !== 0 ? itemData.unidentifiedName : i18n("A5E.ItemUnidentified") + " " + A5E.objectTypes[itemData.objectType]);
        }
      }
    }
  };
  return [
    item,
    isOddLine,
    itemData,
    showItemData,
    itemName,
    ac,
    rollData,
    toggleDescription,
    handleQtyChange,
    actor,
    _a
  ];
}
class A5eObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$l, create_fragment$l, safe_not_equal, { item: 0, actor: 9, isOddLine: 1 });
  }
}
const A5eCurrency_svelte_svelte_type_style_lang = "";
function create_fragment$k(ctx) {
  let ol;
  let li0;
  let label0;
  let t1;
  let evaluatinginput0;
  let t2;
  let li1;
  let label1;
  let t4;
  let evaluatinginput1;
  let updating_value;
  let t5;
  let li2;
  let label2;
  let t7;
  let evaluatinginput2;
  let updating_value_1;
  let t8;
  let li3;
  let label3;
  let t10;
  let evaluatinginput3;
  let updating_value_2;
  let t11;
  let li4;
  let label4;
  let t13;
  let evaluatinginput4;
  let updating_value_3;
  let current;
  evaluatinginput0 = new EvaluatingInput({
    props: {
      value: (
        /*currency*/
        ctx[0].cp
      ),
      styleClass: "currency__input",
      id: "currency-cp",
      name: "cp"
    }
  });
  evaluatinginput0.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  function evaluatinginput1_value_binding(value) {
    ctx[3](value);
  }
  let evaluatinginput1_props = {
    styleClass: "currency__input",
    id: "currency-sp",
    name: "sp"
  };
  if (
    /*currency*/
    ctx[0].sp !== void 0
  ) {
    evaluatinginput1_props.value = /*currency*/
    ctx[0].sp;
  }
  evaluatinginput1 = new EvaluatingInput({ props: evaluatinginput1_props });
  binding_callbacks.push(() => bind(evaluatinginput1, "value", evaluatinginput1_value_binding));
  evaluatinginput1.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  function evaluatinginput2_value_binding(value) {
    ctx[4](value);
  }
  let evaluatinginput2_props = {
    styleClass: "currency__input",
    id: "currency-ep",
    name: "ep"
  };
  if (
    /*currency*/
    ctx[0].ep !== void 0
  ) {
    evaluatinginput2_props.value = /*currency*/
    ctx[0].ep;
  }
  evaluatinginput2 = new EvaluatingInput({ props: evaluatinginput2_props });
  binding_callbacks.push(() => bind(evaluatinginput2, "value", evaluatinginput2_value_binding));
  evaluatinginput2.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  function evaluatinginput3_value_binding(value) {
    ctx[5](value);
  }
  let evaluatinginput3_props = {
    styleClass: "currency__input",
    id: "currency-gp",
    name: "gp"
  };
  if (
    /*currency*/
    ctx[0].gp !== void 0
  ) {
    evaluatinginput3_props.value = /*currency*/
    ctx[0].gp;
  }
  evaluatinginput3 = new EvaluatingInput({ props: evaluatinginput3_props });
  binding_callbacks.push(() => bind(evaluatinginput3, "value", evaluatinginput3_value_binding));
  evaluatinginput3.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  function evaluatinginput4_value_binding(value) {
    ctx[6](value);
  }
  let evaluatinginput4_props = {
    styleClass: "currency__input",
    id: "currency-pp",
    name: "pp"
  };
  if (
    /*currency*/
    ctx[0].pp !== void 0
  ) {
    evaluatinginput4_props.value = /*currency*/
    ctx[0].pp;
  }
  evaluatinginput4 = new EvaluatingInput({ props: evaluatinginput4_props });
  binding_callbacks.push(() => bind(evaluatinginput4, "value", evaluatinginput4_value_binding));
  evaluatinginput4.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  return {
    c() {
      ol = element("ol");
      li0 = element("li");
      label0 = element("label");
      label0.textContent = "cp";
      t1 = space();
      create_component(evaluatinginput0.$$.fragment);
      t2 = space();
      li1 = element("li");
      label1 = element("label");
      label1.textContent = "sp";
      t4 = space();
      create_component(evaluatinginput1.$$.fragment);
      t5 = space();
      li2 = element("li");
      label2 = element("label");
      label2.textContent = "ep";
      t7 = space();
      create_component(evaluatinginput2.$$.fragment);
      t8 = space();
      li3 = element("li");
      label3 = element("label");
      label3.textContent = "gp";
      t10 = space();
      create_component(evaluatinginput3.$$.fragment);
      t11 = space();
      li4 = element("li");
      label4 = element("label");
      label4.textContent = "pp";
      t13 = space();
      create_component(evaluatinginput4.$$.fragment);
      attr(label0, "class", "currency__label svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label0, "for", "currency-cp");
      attr(li0, "class", "currency__item svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label1, "class", "currency__label svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label1, "for", "currency-sp");
      attr(li1, "class", "currency__item svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label2, "class", "currency__label svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label2, "for", "currency-ep");
      attr(li2, "class", "currency__item svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label3, "class", "currency__label svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label3, "for", "currency-gp");
      attr(li3, "class", "currency__item svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label4, "class", "currency__label svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(label4, "for", "currency-pp");
      attr(li4, "class", "currency__item svelte-mobile-companion81nkluj30u9vsd-icb80z");
      attr(ol, "class", "currency__list svelte-mobile-companion81nkluj30u9vsd-icb80z");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      append(ol, li0);
      append(li0, label0);
      append(li0, t1);
      mount_component(evaluatinginput0, li0, null);
      append(ol, t2);
      append(ol, li1);
      append(li1, label1);
      append(li1, t4);
      mount_component(evaluatinginput1, li1, null);
      append(ol, t5);
      append(ol, li2);
      append(li2, label2);
      append(li2, t7);
      mount_component(evaluatinginput2, li2, null);
      append(ol, t8);
      append(ol, li3);
      append(li3, label3);
      append(li3, t10);
      mount_component(evaluatinginput3, li3, null);
      append(li3, t11);
      append(ol, li4);
      append(li4, label4);
      append(li4, t13);
      mount_component(evaluatinginput4, li4, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const evaluatinginput0_changes = {};
      if (dirty & /*currency*/
      1)
        evaluatinginput0_changes.value = /*currency*/
        ctx2[0].cp;
      evaluatinginput0.$set(evaluatinginput0_changes);
      const evaluatinginput1_changes = {};
      if (!updating_value && dirty & /*currency*/
      1) {
        updating_value = true;
        evaluatinginput1_changes.value = /*currency*/
        ctx2[0].sp;
        add_flush_callback(() => updating_value = false);
      }
      evaluatinginput1.$set(evaluatinginput1_changes);
      const evaluatinginput2_changes = {};
      if (!updating_value_1 && dirty & /*currency*/
      1) {
        updating_value_1 = true;
        evaluatinginput2_changes.value = /*currency*/
        ctx2[0].ep;
        add_flush_callback(() => updating_value_1 = false);
      }
      evaluatinginput2.$set(evaluatinginput2_changes);
      const evaluatinginput3_changes = {};
      if (!updating_value_2 && dirty & /*currency*/
      1) {
        updating_value_2 = true;
        evaluatinginput3_changes.value = /*currency*/
        ctx2[0].gp;
        add_flush_callback(() => updating_value_2 = false);
      }
      evaluatinginput3.$set(evaluatinginput3_changes);
      const evaluatinginput4_changes = {};
      if (!updating_value_3 && dirty & /*currency*/
      1) {
        updating_value_3 = true;
        evaluatinginput4_changes.value = /*currency*/
        ctx2[0].pp;
        add_flush_callback(() => updating_value_3 = false);
      }
      evaluatinginput4.$set(evaluatinginput4_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(evaluatinginput0.$$.fragment, local);
      transition_in(evaluatinginput1.$$.fragment, local);
      transition_in(evaluatinginput2.$$.fragment, local);
      transition_in(evaluatinginput3.$$.fragment, local);
      transition_in(evaluatinginput4.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(evaluatinginput0.$$.fragment, local);
      transition_out(evaluatinginput1.$$.fragment, local);
      transition_out(evaluatinginput2.$$.fragment, local);
      transition_out(evaluatinginput3.$$.fragment, local);
      transition_out(evaluatinginput4.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      destroy_component(evaluatinginput0);
      destroy_component(evaluatinginput1);
      destroy_component(evaluatinginput2);
      destroy_component(evaluatinginput3);
      destroy_component(evaluatinginput4);
    }
  };
}
function instance$k($$self, $$props, $$invalidate) {
  let { actor } = $$props;
  let currency = actor.system.currency;
  function updateActor2() {
    actor.update({ system: { currency } });
  }
  function updateValue(event) {
    const { value, name: name2 } = event.detail;
    const fieldName = name2;
    $$invalidate(0, currency[fieldName] = value, currency);
    updateActor2();
  }
  function evaluatinginput1_value_binding(value) {
    if ($$self.$$.not_equal(currency.sp, value)) {
      currency.sp = value;
      $$invalidate(0, currency), $$invalidate(2, actor);
    }
  }
  function evaluatinginput2_value_binding(value) {
    if ($$self.$$.not_equal(currency.ep, value)) {
      currency.ep = value;
      $$invalidate(0, currency), $$invalidate(2, actor);
    }
  }
  function evaluatinginput3_value_binding(value) {
    if ($$self.$$.not_equal(currency.gp, value)) {
      currency.gp = value;
      $$invalidate(0, currency), $$invalidate(2, actor);
    }
  }
  function evaluatinginput4_value_binding(value) {
    if ($$self.$$.not_equal(currency.pp, value)) {
      currency.pp = value;
      $$invalidate(0, currency), $$invalidate(2, actor);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(2, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    4) {
      $$invalidate(0, currency = actor.system.currency);
    }
  };
  return [
    currency,
    updateValue,
    actor,
    evaluatinginput1_value_binding,
    evaluatinginput2_value_binding,
    evaluatinginput3_value_binding,
    evaluatinginput4_value_binding
  ];
}
class A5eCurrency extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$k, create_fragment$k, safe_not_equal, { actor: 2 });
  }
}
function a5eCalculateCarryCapacity(actorData) {
  const strengthScore = actorData.system.abilities.str.value;
  const { size: size2 } = actorData.system.traits;
  const baseCarryCapacityMultiplier = CONFIG.A5E.carryCapacityMultiplier[size2 || "med"];
  const carryCapacityMultiplier = actorData.flags.a5e?.doubleCarryCapacity ? 2 : 1;
  return strengthScore * baseCarryCapacityMultiplier * carryCapacityMultiplier * 15;
}
function a5eCalculateInventoryWeight(actor) {
  const { EQUIPPED_STATES } = CONFIG.A5E;
  const actorData = actor.system;
  const items = actor.items.map((i2) => i2);
  const totalItemWeight = items.reduce((acc, curr) => {
    let container = null;
    if (curr.system.containerId) {
      container = items.find((i2) => i2.uuid === curr.system.containerId);
      if (!container)
        return acc;
    }
    const equipped = [EQUIPPED_STATES.EQUIPPED, EQUIPPED_STATES.CARRIED].includes(curr.system.equippedState);
    if (!equipped && !container)
      return acc;
    if (container && container.system.equippedState === EQUIPPED_STATES.NOT_CARRIED)
      return acc;
    const { quantity } = curr.system;
    const itemWeight = parseFloat(curr.system.weight || 0, 10) ?? 0;
    return acc + (quantity ? itemWeight * quantity : itemWeight);
  }, 0);
  const coinWeight = Object.values(actorData.currency).reduce(
    (acc, curr) => acc + Number(curr),
    0
  );
  const excessSupplyWeight = 2 * Math.abs(
    Math.min(actorData.abilities.str.value - (actorData.supply ?? 0), 0)
  );
  const trackCurrencyWeight = actor.flags?.a5e?.trackCurrencyWeight ?? game.settings.get("a5e", "currencyWeight");
  return trackCurrencyWeight ? totalItemWeight + excessSupplyWeight + coinWeight * 0.02 : totalItemWeight + excessSupplyWeight;
}
const A5eWeight_svelte_svelte_type_style_lang = "";
function create_if_block$c(ctx) {
  let span;
  return {
    c() {
      span = element("span");
      span.textContent = `${i18n("A5E.ConditionEncumbered")}`;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$j(ctx) {
  let div2;
  let div1;
  let div0;
  let span0;
  let t0_value = (
    /*inventoryWeight*/
    ctx[1]?.toFixed(1) + ""
  );
  let t0;
  let t1;
  let t2_value = i18n("A5E.MeasurementPoundsAbbr") + "";
  let t2;
  let t3;
  let span1;
  let t4;
  let t5;
  let t6_value = i18n("A5E.MeasurementPoundsAbbr") + "";
  let t6;
  let t7;
  let if_block = (
    /*encumbrancePercentage*/
    ctx[2] === 100 && create_if_block$c()
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = text("\r\n            /\r\n            ");
      span1 = element("span");
      t4 = text(
        /*carryCapacity*/
        ctx[0]
      );
      t5 = space();
      t6 = text(t6_value);
      t7 = space();
      if (if_block)
        if_block.c();
      attr(div0, "class", "weight-text svelte-mobile-companion81nkluj30u9vsd-1kowib5");
      attr(div1, "class", "weight-bar svelte-mobile-companion81nkluj30u9vsd-1kowib5");
      set_style(
        div1,
        "background-color",
        /*encumbrancePercentage*/
        ctx[2] === 100 ? "#b40a0a" : "#0b5a2f"
      );
      set_style(div1, "width", `${Math.min(
        /*encumbrancePercentage*/
        ctx[2],
        100
      )}%`);
      attr(div2, "class", "weight-container svelte-mobile-companion81nkluj30u9vsd-1kowib5");
      set_style(div2, "background-color", "#a9a594");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      append(div0, span0);
      append(span0, t0);
      append(span0, t1);
      append(span0, t2);
      append(div0, t3);
      append(div0, span1);
      append(span1, t4);
      append(span1, t5);
      append(span1, t6);
      append(div0, t7);
      if (if_block)
        if_block.m(div0, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*inventoryWeight*/
      2 && t0_value !== (t0_value = /*inventoryWeight*/
      ctx2[1]?.toFixed(1) + ""))
        set_data(t0, t0_value);
      if (dirty & /*carryCapacity*/
      1)
        set_data(
          t4,
          /*carryCapacity*/
          ctx2[0]
        );
      if (
        /*encumbrancePercentage*/
        ctx2[2] === 100
      ) {
        if (if_block)
          ;
        else {
          if_block = create_if_block$c();
          if_block.c();
          if_block.m(div0, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*encumbrancePercentage*/
      4) {
        set_style(
          div1,
          "background-color",
          /*encumbrancePercentage*/
          ctx2[2] === 100 ? "#b40a0a" : "#0b5a2f"
        );
      }
      if (dirty & /*encumbrancePercentage*/
      4) {
        set_style(div1, "width", `${Math.min(
          /*encumbrancePercentage*/
          ctx2[2],
          100
        )}%`);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$j($$self, $$props, $$invalidate) {
  let inventoryWeight;
  let carryCapacity;
  let encumbrancePercentage;
  let { actor } = $$props;
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(3, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    8) {
      $$invalidate(1, inventoryWeight = a5eCalculateInventoryWeight(actor));
    }
    if ($$self.$$.dirty & /*actor*/
    8) {
      $$invalidate(0, carryCapacity = a5eCalculateCarryCapacity(actor));
    }
    if ($$self.$$.dirty & /*inventoryWeight, carryCapacity*/
    3) {
      $$invalidate(2, encumbrancePercentage = Math.min(inventoryWeight / carryCapacity * 100, 100));
    }
  };
  return [carryCapacity, inventoryWeight, encumbrancePercentage, actor];
}
class A5eWeight extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$j, create_fragment$j, safe_not_equal, { actor: 3 });
  }
}
const A5eAdditionalInventoryInfo_svelte_svelte_type_style_lang = "";
function create_fragment$i(ctx) {
  let ol;
  let li0;
  let h30;
  let t1;
  let span0;
  let t2;
  let t3;
  let span1;
  let t5;
  let li1;
  let h31;
  let t7;
  let span2;
  let t8;
  let t9;
  let li2;
  let h32;
  let t11;
  let evaluatinginput;
  let current;
  evaluatinginput = new EvaluatingInput({
    props: {
      id: "supply-input",
      name: "supplies",
      styleClass: "supply-input",
      value: (
        /*supplies*/
        ctx[0]
      )
    }
  });
  evaluatinginput.$on(
    "change",
    /*handleSupplyUpdate*/
    ctx[3]
  );
  return {
    c() {
      ol = element("ol");
      li0 = element("li");
      h30 = element("h3");
      h30.textContent = "Attunement";
      t1 = space();
      span0 = element("span");
      t2 = text(
        /*attunedItems*/
        ctx[2]
      );
      t3 = text(" / ");
      span1 = element("span");
      span1.textContent = "3";
      t5 = space();
      li1 = element("li");
      h31 = element("h3");
      h31.textContent = "Bulky Items";
      t7 = space();
      span2 = element("span");
      t8 = text(
        /*bulkyItems*/
        ctx[1]
      );
      t9 = space();
      li2 = element("li");
      h32 = element("h3");
      h32.textContent = "Supplies";
      t11 = space();
      create_component(evaluatinginput.$$.fragment);
      attr(h30, "class", "additional-inventory-info-header svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      attr(span0, "class", "attunement-value svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      set_style(
        span0,
        "background-color",
        /*attunedItems*/
        ctx[2] > 3 ? "#b40a0a" : ""
      );
      attr(span1, "class", "attunement-value svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      attr(li0, "class", "additional-inventory-info-container svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      attr(h31, "class", "additional-inventory-info-header svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      attr(span2, "class", "bulky-value svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      attr(li1, "class", "additional-inventory-info-container svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      attr(h32, "class", "additional-inventory-info-header svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      attr(li2, "class", "additional-inventory-info-container svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
      attr(ol, "class", "svelte-mobile-companion81nkluj30u9vsd-rkc6bu");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      append(ol, li0);
      append(li0, h30);
      append(li0, t1);
      append(li0, span0);
      append(span0, t2);
      append(li0, t3);
      append(li0, span1);
      append(ol, t5);
      append(ol, li1);
      append(li1, h31);
      append(li1, t7);
      append(li1, span2);
      append(span2, t8);
      append(ol, t9);
      append(ol, li2);
      append(li2, h32);
      append(li2, t11);
      mount_component(evaluatinginput, li2, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*attunedItems*/
      4)
        set_data(
          t2,
          /*attunedItems*/
          ctx2[2]
        );
      if (dirty & /*attunedItems*/
      4) {
        set_style(
          span0,
          "background-color",
          /*attunedItems*/
          ctx2[2] > 3 ? "#b40a0a" : ""
        );
      }
      if (!current || dirty & /*bulkyItems*/
      2)
        set_data(
          t8,
          /*bulkyItems*/
          ctx2[1]
        );
      const evaluatinginput_changes = {};
      if (dirty & /*supplies*/
      1)
        evaluatinginput_changes.value = /*supplies*/
        ctx2[0];
      evaluatinginput.$set(evaluatinginput_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(evaluatinginput.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(evaluatinginput.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      destroy_component(evaluatinginput);
    }
  };
}
function instance$i($$self, $$props, $$invalidate) {
  let attunedItems;
  let bulkyItems;
  let supplies;
  let { actor } = $$props;
  const unsubscribeCurrency = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useEncumbrance).subscribe((value) => {
  });
  onDestroy(() => {
    unsubscribeCurrency();
  });
  function handleSupplyUpdate(event) {
    const { value } = event.detail;
    actor.update({ system: { supply: value } });
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(4, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    16) {
      $$invalidate(2, attunedItems = actor.itemTypes.object.reduce(
        (acc, item) => {
          const itemData = item.system;
          if (itemData.attuned) {
            return acc + 1;
          } else {
            return acc;
          }
        },
        0
      ));
    }
    if ($$self.$$.dirty & /*actor*/
    16) {
      $$invalidate(1, bulkyItems = actor.itemTypes.object.reduce(
        (acc, item) => {
          const itemData = item.system;
          if (itemData.bulky && itemData.equippedState >= EquippedState.CARRIED) {
            return acc + itemData.quantity;
          } else {
            return acc;
          }
        },
        0
      ));
    }
    if ($$self.$$.dirty & /*actor*/
    16) {
      $$invalidate(0, supplies = actor.system.supply);
    }
  };
  return [supplies, bulkyItems, attunedItems, handleSupplyUpdate, actor];
}
class A5eAdditionalInventoryInfo extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$i, create_fragment$i, safe_not_equal, { actor: 4 });
  }
}
const A5eInventory_svelte_svelte_type_style_lang = "";
function get_each_context$6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function get_each_context_1$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function get_each_context_2$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function get_each_context_3$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function get_each_context_4$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function get_each_context_5$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function get_each_context_6(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function get_each_context_7(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function get_each_context_8(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[27] = list[i2];
  child_ctx[29] = i2;
  return child_ctx;
}
function create_if_block_10(ctx) {
  let a5ecurrency;
  let current;
  a5ecurrency = new A5eCurrency({ props: { actor: (
    /*actor*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(a5ecurrency.$$.fragment);
    },
    m(target, anchor) {
      mount_component(a5ecurrency, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const a5ecurrency_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5ecurrency_changes.actor = /*actor*/
        ctx2[0];
      a5ecurrency.$set(a5ecurrency_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5ecurrency.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5ecurrency.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(a5ecurrency, detaching);
    }
  };
}
function create_if_block_9$1(ctx) {
  let a5eweight;
  let current;
  a5eweight = new A5eWeight({ props: { actor: (
    /*actor*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(a5eweight.$$.fragment);
    },
    m(target, anchor) {
      mount_component(a5eweight, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const a5eweight_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eweight_changes.actor = /*actor*/
        ctx2[0];
      a5eweight.$set(a5eweight_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eweight.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eweight.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(a5eweight, detaching);
    }
  };
}
function create_if_block_8$1(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_8 = ensure_array_like(
    /*weapons*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value_8.length; i2 += 1) {
    let child_ctx = get_each_context_8(ctx, each_value_8, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_8(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.weapon}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, weapons*/
      3) {
        each_value_8 = ensure_array_like(
          /*weapons*/
          ctx2[1]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_8, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_8, each_1_anchor, get_each_context_8);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_8.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_8(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*weapons*/
      2)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*weapons*/
      2)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_if_block_7$2(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_7 = ensure_array_like(
    /*armors*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value_7.length; i2 += 1) {
    let child_ctx = get_each_context_7(ctx, each_value_7, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_7(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.armor}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, armors*/
      5) {
        each_value_7 = ensure_array_like(
          /*armors*/
          ctx2[2]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_7, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_7, each_1_anchor, get_each_context_7);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_7.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_7(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*armors*/
      4)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*armors*/
      4)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_if_block_6$2(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_6 = ensure_array_like(
    /*ammunition*/
    ctx[3]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value_6.length; i2 += 1) {
    let child_ctx = get_each_context_6(ctx, each_value_6, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_6(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.ammunition}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, ammunition*/
      9) {
        each_value_6 = ensure_array_like(
          /*ammunition*/
          ctx2[3]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_6, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_6, each_1_anchor, get_each_context_6);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_6.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_6(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*ammunition*/
      8)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*ammunition*/
      8)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_if_block_5$3(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_5 = ensure_array_like(
    /*containers*/
    ctx[4]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
    let child_ctx = get_each_context_5$1(ctx, each_value_5, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_5$1(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.container}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, containers*/
      17) {
        each_value_5 = ensure_array_like(
          /*containers*/
          ctx2[4]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_5, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_5$1, each_1_anchor, get_each_context_5$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_5$1(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*containers*/
      16)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*containers*/
      16)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_if_block_4$3(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_4 = ensure_array_like(
    /*consumables*/
    ctx[5]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    let child_ctx = get_each_context_4$1(ctx, each_value_4, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_4$1(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.consumable}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, consumables*/
      33) {
        each_value_4 = ensure_array_like(
          /*consumables*/
          ctx2[5]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_4, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_4$1, each_1_anchor, get_each_context_4$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_4$1(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*consumables*/
      32)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*consumables*/
      32)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_if_block_3$5(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_3 = ensure_array_like(
    /*tools*/
    ctx[6]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    let child_ctx = get_each_context_3$1(ctx, each_value_3, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_3$1(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.tool}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, tools*/
      65) {
        each_value_3 = ensure_array_like(
          /*tools*/
          ctx2[6]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_3, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_3$1, each_1_anchor, get_each_context_3$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_3$1(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*tools*/
      64)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*tools*/
      64)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_if_block_2$6(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*jewelry*/
    ctx[7]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    let child_ctx = get_each_context_2$1(ctx, each_value_2, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_2$1(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.jewelry}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, jewelry*/
      129) {
        each_value_2 = ensure_array_like(
          /*jewelry*/
          ctx2[7]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2$1, each_1_anchor, get_each_context_2$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_2$1(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*jewelry*/
      128)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*jewelry*/
      128)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_if_block_1$9(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*clothing*/
    ctx[8]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1$1(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1$1(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.clothing}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, clothing*/
      257) {
        each_value_1 = ensure_array_like(
          /*clothing*/
          ctx2[8]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1$1, each_1_anchor, get_each_context_1$1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_1$1(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*clothing*/
      256)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*clothing*/
      256)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_if_block$b(ctx) {
  let div2;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*miscellaneous*/
    ctx[9]
  );
  const get_key = (ctx2) => (
    /*item*/
    ctx2[27].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$6(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$6(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      div2.textContent = `${/*A5E*/
      ctx[12].objectTypesPlural.miscellaneous}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(div2, "class", "a5e-section-header item-list-header svelte-mobile-companion81nkluj30u9vsd-iw40s");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*actor, miscellaneous*/
      513) {
        each_value = ensure_array_like(
          /*miscellaneous*/
          ctx2[9]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block$6, each_1_anchor, get_each_context$6);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block$6(key_1, ctx) {
  let first;
  let a5eobject;
  let current;
  a5eobject = new A5eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*item*/
        ctx[27]
      ),
      isOddLine: (
        /*index*/
        ctx[29] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(a5eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(a5eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const a5eobject_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty[0] & /*miscellaneous*/
      512)
        a5eobject_changes.item = /*item*/
        ctx[27];
      if (dirty[0] & /*miscellaneous*/
      512)
        a5eobject_changes.isOddLine = /*index*/
        ctx[29] % 2 !== 0;
      a5eobject.$set(a5eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(a5eobject, detaching);
    }
  };
}
function create_fragment$h(ctx) {
  let section;
  let div0;
  let t0;
  let a5eadditionalinventoryinfo;
  let t1;
  let t2;
  let div1;
  let t3;
  let t4;
  let t5;
  let t6;
  let t7;
  let t8;
  let t9;
  let t10;
  let current;
  let if_block0 = (
    /*isUsingCurrency*/
    ctx[10] && create_if_block_10(ctx)
  );
  a5eadditionalinventoryinfo = new A5eAdditionalInventoryInfo({ props: { actor: (
    /*actor*/
    ctx[0]
  ) } });
  let if_block1 = (
    /*isUsingEncumbrance*/
    ctx[11] && create_if_block_9$1(ctx)
  );
  let if_block2 = (
    /*weapons*/
    ctx[1].length > 0 && create_if_block_8$1(ctx)
  );
  let if_block3 = (
    /*armors*/
    ctx[2].length > 0 && create_if_block_7$2(ctx)
  );
  let if_block4 = (
    /*ammunition*/
    ctx[3].length > 0 && create_if_block_6$2(ctx)
  );
  let if_block5 = (
    /*containers*/
    ctx[4].length > 0 && create_if_block_5$3(ctx)
  );
  let if_block6 = (
    /*consumables*/
    ctx[5].length > 0 && create_if_block_4$3(ctx)
  );
  let if_block7 = (
    /*tools*/
    ctx[6].length > 0 && create_if_block_3$5(ctx)
  );
  let if_block8 = (
    /*jewelry*/
    ctx[7].length > 0 && create_if_block_2$6(ctx)
  );
  let if_block9 = (
    /*clothing*/
    ctx[8].length > 0 && create_if_block_1$9(ctx)
  );
  let if_block10 = (
    /*miscellaneous*/
    ctx[9].length > 0 && create_if_block$b(ctx)
  );
  return {
    c() {
      section = element("section");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      create_component(a5eadditionalinventoryinfo.$$.fragment);
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      div1 = element("div");
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      if (if_block7)
        if_block7.c();
      t8 = space();
      if (if_block8)
        if_block8.c();
      t9 = space();
      if (if_block9)
        if_block9.c();
      t10 = space();
      if (if_block10)
        if_block10.c();
      attr(div0, "class", "weight-and-additional svelte-mobile-companion81nkluj30u9vsd-iw40s");
      attr(div1, "class", "content-scroll-list");
      attr(section, "class", "category-content");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      mount_component(a5eadditionalinventoryinfo, div0, null);
      append(div0, t1);
      if (if_block1)
        if_block1.m(div0, null);
      append(section, t2);
      append(section, div1);
      if (if_block2)
        if_block2.m(div1, null);
      append(div1, t3);
      if (if_block3)
        if_block3.m(div1, null);
      append(div1, t4);
      if (if_block4)
        if_block4.m(div1, null);
      append(div1, t5);
      if (if_block5)
        if_block5.m(div1, null);
      append(div1, t6);
      if (if_block6)
        if_block6.m(div1, null);
      append(div1, t7);
      if (if_block7)
        if_block7.m(div1, null);
      append(div1, t8);
      if (if_block8)
        if_block8.m(div1, null);
      append(div1, t9);
      if (if_block9)
        if_block9.m(div1, null);
      append(div1, t10);
      if (if_block10)
        if_block10.m(div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*isUsingCurrency*/
        ctx2[10]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*isUsingCurrency*/
          1024) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_10(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const a5eadditionalinventoryinfo_changes = {};
      if (dirty[0] & /*actor*/
      1)
        a5eadditionalinventoryinfo_changes.actor = /*actor*/
        ctx2[0];
      a5eadditionalinventoryinfo.$set(a5eadditionalinventoryinfo_changes);
      if (
        /*isUsingEncumbrance*/
        ctx2[11]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*isUsingEncumbrance*/
          2048) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_9$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*weapons*/
        ctx2[1].length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*weapons*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_8$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*armors*/
        ctx2[2].length > 0
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*armors*/
          4) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_7$2(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, t4);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*ammunition*/
        ctx2[3].length > 0
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[0] & /*ammunition*/
          8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_6$2(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, t5);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*containers*/
        ctx2[4].length > 0
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*containers*/
          16) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_5$3(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div1, t6);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*consumables*/
        ctx2[5].length > 0
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & /*consumables*/
          32) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_4$3(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div1, t7);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (
        /*tools*/
        ctx2[6].length > 0
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty[0] & /*tools*/
          64) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block_3$5(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div1, t8);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
      if (
        /*jewelry*/
        ctx2[7].length > 0
      ) {
        if (if_block8) {
          if_block8.p(ctx2, dirty);
          if (dirty[0] & /*jewelry*/
          128) {
            transition_in(if_block8, 1);
          }
        } else {
          if_block8 = create_if_block_2$6(ctx2);
          if_block8.c();
          transition_in(if_block8, 1);
          if_block8.m(div1, t9);
        }
      } else if (if_block8) {
        group_outros();
        transition_out(if_block8, 1, 1, () => {
          if_block8 = null;
        });
        check_outros();
      }
      if (
        /*clothing*/
        ctx2[8].length > 0
      ) {
        if (if_block9) {
          if_block9.p(ctx2, dirty);
          if (dirty[0] & /*clothing*/
          256) {
            transition_in(if_block9, 1);
          }
        } else {
          if_block9 = create_if_block_1$9(ctx2);
          if_block9.c();
          transition_in(if_block9, 1);
          if_block9.m(div1, t10);
        }
      } else if (if_block9) {
        group_outros();
        transition_out(if_block9, 1, 1, () => {
          if_block9 = null;
        });
        check_outros();
      }
      if (
        /*miscellaneous*/
        ctx2[9].length > 0
      ) {
        if (if_block10) {
          if_block10.p(ctx2, dirty);
          if (dirty[0] & /*miscellaneous*/
          512) {
            transition_in(if_block10, 1);
          }
        } else {
          if_block10 = create_if_block$b(ctx2);
          if_block10.c();
          transition_in(if_block10, 1);
          if_block10.m(div1, null);
        }
      } else if (if_block10) {
        group_outros();
        transition_out(if_block10, 1, 1, () => {
          if_block10 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(a5eadditionalinventoryinfo.$$.fragment, local);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(if_block7);
      transition_in(if_block8);
      transition_in(if_block9);
      transition_in(if_block10);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(a5eadditionalinventoryinfo.$$.fragment, local);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(if_block7);
      transition_out(if_block8);
      transition_out(if_block9);
      transition_out(if_block10);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0)
        if_block0.d();
      destroy_component(a5eadditionalinventoryinfo);
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
      if (if_block8)
        if_block8.d();
      if (if_block9)
        if_block9.d();
      if (if_block10)
        if_block10.d();
    }
  };
}
function instance$h($$self, $$props, $$invalidate) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
  let { actor } = $$props;
  const A5E = CONFIG.A5E;
  let objects = actor.itemTypes.object;
  let weapons = [];
  let armors = [];
  let ammunition = [];
  let containers = [];
  let consumables = [];
  let tools = [];
  let jewelry = [];
  let clothing = [];
  let miscellaneous = [];
  let isUsingCurrency = false;
  const unsubscribeCurrency = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useCurrency).subscribe((value) => {
    $$invalidate(10, isUsingCurrency = value);
  });
  let isUsingEncumbrance = false;
  const unsubscribeEncumbrance = mobileCompanionGameSettings.getWritableStore(settings.dnd5e.useEncumbrance).subscribe((value) => {
    $$invalidate(11, isUsingEncumbrance = value);
  });
  onDestroy(() => {
    unsubscribeCurrency();
    unsubscribeEncumbrance();
  });
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(0, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*actor, objects, _a, weapons, _b, _c, _d, armors, _e, ammunition, _f, containers, _g, consumables, _h, tools, _j, jewelry, _k, clothing, _l, miscellaneous*/
    33547263) {
      {
        $$invalidate(24, objects = actor.itemTypes.object);
        let objectMap = objects.reduce(
          (acc, object) => {
            (acc[object.system.objectType] = acc[object.system.objectType] || []).push(object);
            return acc;
          },
          {}
        );
        $$invalidate(1, weapons = $$invalidate(13, _a = objectMap[ObjectType.Weapon]) !== null && _a !== void 0 ? _a : []);
        weapons.sort((a, b) => a.name.localeCompare(b.name));
        $$invalidate(2, armors = $$invalidate(14, _b = objectMap[ObjectType.Armor]) !== null && _b !== void 0 ? _b : []);
        const helms = $$invalidate(15, _c = objectMap[ObjectType.Helm]) !== null && _c !== void 0 ? _c : [];
        const shields = $$invalidate(16, _d = objectMap[ObjectType.Shield]) !== null && _d !== void 0 ? _d : [];
        armors.push(...helms, ...shields);
        armors.sort((a, b) => a.name.localeCompare(b.name));
        $$invalidate(3, ammunition = $$invalidate(17, _e = objectMap[ObjectType.Ammunition]) !== null && _e !== void 0 ? _e : []);
        ammunition.sort((a, b) => a.name.localeCompare(b.name));
        $$invalidate(4, containers = $$invalidate(18, _f = objectMap[ObjectType.Container]) !== null && _f !== void 0 ? _f : []);
        containers.sort((a, b) => a.name.localeCompare(b.name));
        $$invalidate(5, consumables = $$invalidate(19, _g = objectMap[ObjectType.Consumable]) !== null && _g !== void 0 ? _g : []);
        consumables.sort((a, b) => a.name.localeCompare(b.name));
        $$invalidate(6, tools = $$invalidate(20, _h = objectMap[ObjectType.Tool]) !== null && _h !== void 0 ? _h : []);
        tools.sort((a, b) => a.name.localeCompare(b.name));
        $$invalidate(7, jewelry = $$invalidate(21, _j = objectMap[ObjectType.Jewelry]) !== null && _j !== void 0 ? _j : []);
        jewelry.sort((a, b) => a.name.localeCompare(b.name));
        $$invalidate(8, clothing = $$invalidate(22, _k = objectMap[ObjectType.Clothing]) !== null && _k !== void 0 ? _k : []);
        clothing.sort((a, b) => a.name.localeCompare(b.name));
        $$invalidate(9, miscellaneous = $$invalidate(23, _l = objectMap[ObjectType.Miscellaneous]) !== null && _l !== void 0 ? _l : []);
        miscellaneous.sort((a, b) => a.name.localeCompare(b.name));
      }
    }
  };
  return [
    actor,
    weapons,
    armors,
    ammunition,
    containers,
    consumables,
    tools,
    jewelry,
    clothing,
    miscellaneous,
    isUsingCurrency,
    isUsingEncumbrance,
    A5E,
    _a,
    _b,
    _c,
    _d,
    _e,
    _f,
    _g,
    _h,
    _j,
    _k,
    _l,
    objects
  ];
}
class A5eInventory extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$h, create_fragment$h, safe_not_equal, { actor: 0 }, null, [-1, -1]);
  }
}
function create_if_block_1$8(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Not yet implemented";
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$a(ctx) {
  let a5einventory;
  let current;
  a5einventory = new A5eInventory({ props: { actor: (
    /*actor*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(a5einventory.$$.fragment);
    },
    m(target, anchor) {
      mount_component(a5einventory, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const a5einventory_changes = {};
      if (dirty & /*actor*/
      2)
        a5einventory_changes.actor = /*actor*/
        ctx2[1];
      a5einventory.$set(a5einventory_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(a5einventory.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(a5einventory.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(a5einventory, detaching);
    }
  };
}
function create_default_slot$1(ctx) {
  let main2;
  let header;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  header = new Header({
    props: {
      customButtons: headerButtons$1,
      menuButtons: menuButtons$1,
      activeFilter: (
        /*activeFilter*/
        ctx[2]
      )
    }
  });
  const if_block_creators = [create_if_block$a, create_if_block_1$8];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*activeFilter*/
      ctx2[2] === Filters$1.Object
    )
      return 0;
    if (
      /*activeFilter*/
      ctx2[2] === Filters$1.Spell
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      main2 = element("main");
      create_component(header.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(main2, "class", "a5e-container");
    },
    m(target, anchor) {
      insert(target, main2, anchor);
      mount_component(header, main2, null);
      append(main2, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(main2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*activeFilter*/
      4)
        header_changes.activeFilter = /*activeFilter*/
        ctx2[2];
      header.$set(header_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(main2, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(main2);
      }
      destroy_component(header);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_fragment$g(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[4](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot$1] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell$1({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, actor, activeFilter*/
      134) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function instance$g($$self, $$props, $$invalidate) {
  let { elementRoot } = $$props;
  let { props } = $$props;
  init$1(props);
  let actor = props;
  let activeFilter = Filters$1.Object;
  const unsubscribeActor = actorStore$1.subscribe((value) => {
    $$invalidate(1, actor = value);
  });
  const unsubscribeFilter = activeFilterStore$1.subscribe((value) => {
    $$invalidate(2, activeFilter = value);
  });
  onMount(handleOnMount$1);
  onDestroy(() => {
    unsubscribeActor();
    unsubscribeFilter();
    handleOnDestroy$1();
  });
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
  };
  return [elementRoot, actor, activeFilter, props, applicationshell_elementRoot_binding];
}
let A5eFreeAppShell$1 = class A5eFreeAppShell extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$g, create_fragment$g, safe_not_equal, { elementRoot: 0, props: 3 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get props() {
    return this.$$.ctx[3];
  }
  set props(props) {
    this.$$set({ props });
    flush();
  }
};
class A5eFreeAppShell2 extends SvelteApplication {
  constructor(actor) {
    super();
    this.options.svelte.props = actor;
  }
  static get defaultOptions() {
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "Mobile Companion A5e",
      id: moduleId,
      // classes: [],
      width: window.innerWidth,
      height: window.innerHeight,
      zIndex: 99999,
      resizable: false,
      // The other options...
      svelte: {
        class: A5eFreeAppShell$1,
        target: document.body,
        props: {}
      }
    });
  }
}
var Filters = /* @__PURE__ */ ((Filters2) => {
  Filters2["Object"] = "object";
  Filters2["Spell"] = "spell";
  return Filters2;
})(Filters || {});
const actorStore = writable({});
const activeFilterStore = writable(
  "object"
  /* Object */
);
function init(props) {
  actorStore.set(props);
}
const updateInventory = async (item) => {
  let actor = get_store_value(actorStore);
  if (item.parent?.id === actor.id) {
    actor = game.actors.find((a) => a.id === actor.id);
    actorStore.set(actor);
    switchFilter(get_store_value(activeFilterStore));
  }
};
const updateActor = async (changedActor) => {
  let actor = get_store_value(actorStore);
  if (actor.id === changedActor.id) {
    actor = changedActor;
    actorStore.set(actor);
    switchFilter(get_store_value(activeFilterStore));
  }
};
function handleOnMount() {
  Hooks.on("createItem", updateInventory);
  Hooks.on("deleteItem", updateInventory);
  Hooks.on("updateItem", updateInventory);
  Hooks.on("updateActor", updateActor);
  switchFilter(get_store_value(activeFilterStore));
}
function handleOnDestroy() {
  Hooks.off("createItem", updateInventory);
  Hooks.off("deleteItem", updateInventory);
  Hooks.off("updateItem", updateInventory);
  Hooks.off("updateActor", updateActor);
}
const headerButtons = [
  {
    id: "object",
    iconClass: "pf2e-nav-item fas fa-box-open",
    buttonClass: "",
    label: "Inventory",
    onClick: () => switchFilter(
      "object"
      /* Object */
    )
  },
  {
    id: "spell",
    iconClass: "pf2e-nav-item fas fa-wand-sparkles",
    buttonClass: "",
    label: "Spells",
    onClick: () => switchFilter(
      "spell"
      /* Spell */
    )
  }
];
const menuButtons = {
  buttonClass: "",
  iconClass: "pf2e-nav-item"
};
function switchFilter(newFilter) {
  activeFilterStore.set(newFilter);
}
var CarryType = /* @__PURE__ */ ((CarryType2) => {
  CarryType2["ATTACHED"] = "attached";
  CarryType2["DROPPED"] = "dropped";
  CarryType2["HELD"] = "held";
  CarryType2["STOWED"] = "stowed";
  CarryType2["WORN"] = "worn";
  return CarryType2;
})(CarryType || {});
var ItemType = /* @__PURE__ */ ((ItemType2) => {
  ItemType2["weapon"] = "weapon";
  ItemType2["armor"] = "armor";
  ItemType2["shield"] = "shield";
  ItemType2["equipment"] = "equipment";
  ItemType2["consumable"] = "consumable";
  ItemType2["treasure"] = "treasure";
  ItemType2["backpack"] = "backpack";
  return ItemType2;
})(ItemType || {});
function create_catch_block$1(ctx) {
  let t_value = console.error(
    "(There was an error:",
    /*error*/
    ctx[3].message
  ) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_then_block$1(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*damage*/
    ctx[1] + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("PF2E.DamageLabel")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_pending_block$1(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_fragment$f(ctx) {
  let section;
  let p;
  let b;
  let t2;
  let t3;
  let t4;
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block$1,
    then: create_then_block$1,
    catch: create_catch_block$1,
    value: 1,
    error: 3
  };
  handle_promise(
    /*damage*/
    ctx[1],
    info
  );
  return {
    c() {
      section = element("section");
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("PF2E.AttackLabel")}:`;
      t2 = text("\r\n        1d20 + ");
      t3 = text(
        /*totalModifier*/
        ctx[0]
      );
      t4 = space();
      info.block.c();
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, p);
      append(p, b);
      append(p, t2);
      append(p, t3);
      append(section, t4);
      info.block.m(section, info.anchor = null);
      info.mount = () => section;
      info.anchor = null;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      update_await_block_branch(info, ctx, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      info.block.d();
      info.token = null;
      info = null;
    }
  };
}
function instance$f($$self, $$props, $$invalidate) {
  let { action } = $$props;
  const totalModifier = action.totalModifier;
  const damage = action.damage({ getFormula: true, createMessage: false });
  $$self.$$set = ($$props2) => {
    if ("action" in $$props2)
      $$invalidate(2, action = $$props2.action);
  };
  return [totalModifier, damage, action];
}
class Pf2eAction extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$f, create_fragment$f, safe_not_equal, { action: 2 });
  }
}
function create_if_block_3$4(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = i18n(
    /*PF2E*/
    ctx[2].rarityTraits[
      /*itemData*/
      ctx[0].traits.rarity
    ]
  ) + "";
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("PF2E.Rarity")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t3_value !== (t3_value = i18n(
        /*PF2E*/
        ctx2[2].rarityTraits[
          /*itemData*/
          ctx2[0].traits.rarity
        ]
      ) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_2$5(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*itemData*/
    ctx[0].level.value + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("PF2E.ItemTitle")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t3_value !== (t3_value = /*itemData*/
      ctx2[0].level.value + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block_1$7(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*itemData*/
    ctx[0].bulk.value + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("PF2E.Weight")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t3_value !== (t3_value = /*itemData*/
      ctx2[0].bulk.value + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block$9(ctx) {
  let p;
  let b;
  let t2;
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("PF2E.PriceLabel")}:`;
      t2 = space();
      t3 = text(
        /*price*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*price*/
      2)
        set_data(
          t3,
          /*price*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_catch_block(ctx) {
  let t_value = console.error(
    "(There was an error:",
    /*error*/
    ctx[5].message
  ) + "";
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_then_block(ctx) {
  let p;
  let raw_value = (
    /*text*/
    ctx[4] + ""
  );
  return {
    c() {
      p = element("p");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      p.innerHTML = raw_value;
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_pending_block(ctx) {
  return { c: noop, m: noop, p: noop, d: noop };
}
function create_fragment$e(ctx) {
  let t0;
  let t1;
  let t2;
  let t3;
  let await_block_anchor;
  let if_block0 = (
    /*itemData*/
    ctx[0].traits.rarity && create_if_block_3$4(ctx)
  );
  let if_block1 = (
    /*itemData*/
    ctx[0].level && create_if_block_2$5(ctx)
  );
  let if_block2 = (
    /*itemData*/
    ctx[0].bulk?.value && create_if_block_1$7(ctx)
  );
  let if_block3 = (
    /*price*/
    ctx[1].length > 0 && create_if_block$9(ctx)
  );
  let info = {
    ctx,
    current: null,
    token: null,
    hasCatch: true,
    pending: create_pending_block,
    then: create_then_block,
    catch: create_catch_block,
    value: 4,
    error: 5
  };
  handle_promise(
    /*enrichedText*/
    ctx[3],
    info
  );
  return {
    c() {
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      await_block_anchor = empty();
      info.block.c();
    },
    m(target, anchor) {
      if (if_block0)
        if_block0.m(target, anchor);
      insert(target, t0, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, t1, anchor);
      if (if_block2)
        if_block2.m(target, anchor);
      insert(target, t2, anchor);
      if (if_block3)
        if_block3.m(target, anchor);
      insert(target, t3, anchor);
      insert(target, await_block_anchor, anchor);
      info.block.m(target, info.anchor = anchor);
      info.mount = () => await_block_anchor.parentNode;
      info.anchor = await_block_anchor;
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (
        /*itemData*/
        ctx[0].traits.rarity
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_3$4(ctx);
          if_block0.c();
          if_block0.m(t0.parentNode, t0);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*itemData*/
        ctx[0].level
      ) {
        if (if_block1) {
          if_block1.p(ctx, dirty);
        } else {
          if_block1 = create_if_block_2$5(ctx);
          if_block1.c();
          if_block1.m(t1.parentNode, t1);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*itemData*/
        ctx[0].bulk?.value
      ) {
        if (if_block2) {
          if_block2.p(ctx, dirty);
        } else {
          if_block2 = create_if_block_1$7(ctx);
          if_block2.c();
          if_block2.m(t2.parentNode, t2);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*price*/
        ctx[1].length > 0
      ) {
        if (if_block3) {
          if_block3.p(ctx, dirty);
        } else {
          if_block3 = create_if_block$9(ctx);
          if_block3.c();
          if_block3.m(t3.parentNode, t3);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      update_await_block_branch(info, ctx, dirty);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
        detach(t2);
        detach(t3);
        detach(await_block_anchor);
      }
      if (if_block0)
        if_block0.d(detaching);
      if (if_block1)
        if_block1.d(detaching);
      if (if_block2)
        if_block2.d(detaching);
      if (if_block3)
        if_block3.d(detaching);
      info.block.d(detaching);
      info.token = null;
      info = null;
    }
  };
}
function instance$e($$self, $$props, $$invalidate) {
  let { itemData } = $$props;
  const PF2E = CONFIG.PF2E;
  let price;
  const enrichedText = TextEditor.enrichHTML(itemData.description.value);
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(0, itemData = $$props2.itemData);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*itemData*/
    1) {
      {
        let pricesTemp = [];
        if (itemData.price.value.cp > 0) {
          pricesTemp.push(itemData.price.value.cp + " cp");
        }
        if (itemData.price.value.sp > 0) {
          pricesTemp.push(itemData.price.value.sp + " sp");
        }
        if (itemData.price.value.gp > 0) {
          pricesTemp.push(itemData.price.value.gp + " gp");
        }
        if (itemData.price.value.pp > 0) {
          pricesTemp.push(itemData.price.value.pp + " pp");
        }
        $$invalidate(1, price = pricesTemp.join(" "));
      }
    }
  };
  return [itemData, price, PF2E, enrichedText];
}
class Pf2eDescription extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$e, create_fragment$e, safe_not_equal, { itemData: 0 });
  }
}
function get_each_context$5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$5(key_1, ctx) {
  let span;
  return {
    key: key_1,
    first: null,
    c() {
      span = element("span");
      span.textContent = `${i18n(
        /*PF2E*/
        ctx[1].armorTraits[
          /*property*/
          ctx[4]
        ]
      )}`;
      attr(span, "class", "tag");
      this.first = span;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_5$2(ctx) {
  let span;
  let t0;
  let t1_value = (
    /*itemData*/
    ctx[0].acBonus + ""
  );
  let t1;
  let t2;
  let t3_value = i18n("PF2E.ArmorArmorLabel") + "";
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text("+");
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t1_value !== (t1_value = /*itemData*/
      ctx2[0].acBonus + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_4$2(ctx) {
  let span;
  let t_value = i18n(
    /*PF2E*/
    ctx[1].armorCategories[
      /*itemData*/
      ctx[0].category
    ]
  ) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t_value !== (t_value = i18n(
        /*PF2E*/
        ctx2[1].armorCategories[
          /*itemData*/
          ctx2[0].category
        ]
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3$3(ctx) {
  let span;
  let t0_value = (
    /*itemData*/
    (ctx[0].dexCap > 0 ? `+${/*itemData*/
    ctx[0].dexCap}` : (
      /*itemData*/
      ctx[0].dexCap
    )) + ""
  );
  let t0;
  let t1;
  let t2_value = i18n("PF2E.ArmorDexLabel") + "";
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t0_value !== (t0_value = /*itemData*/
      (ctx2[0].dexCap > 0 ? `+${/*itemData*/
      ctx2[0].dexCap}` : (
        /*itemData*/
        ctx2[0].dexCap
      )) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2$4(ctx) {
  let span;
  let t0_value = (
    /*itemData*/
    (ctx[0].checkPenalty > 0 ? `+${/*itemData*/
    ctx[0].checkPenalty}` : (
      /*itemData*/
      ctx[0].checkPenalty
    )) + ""
  );
  let t0;
  let t1;
  let t2_value = i18n("PF2E.ArmorCheckLabel") + "";
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t0_value !== (t0_value = /*itemData*/
      (ctx2[0].checkPenalty > 0 ? `+${/*itemData*/
      ctx2[0].checkPenalty}` : (
        /*itemData*/
        ctx2[0].checkPenalty
      )) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$6(ctx) {
  let span;
  let t0_value = (
    /*itemData*/
    (ctx[0].speedPenalty > 0 ? `+${/*itemData*/
    ctx[0].speedPenalty}` : (
      /*itemData*/
      ctx[0].speedPenalty
    )) + ""
  );
  let t0;
  let t1;
  let t2_value = i18n("PF2E.ArmorSpeedLabel") + "";
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t0_value !== (t0_value = /*itemData*/
      (ctx2[0].speedPenalty > 0 ? `+${/*itemData*/
      ctx2[0].speedPenalty}` : (
        /*itemData*/
        ctx2[0].speedPenalty
      )) + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$8(ctx) {
  let span;
  let t0_value = i18n("PF2E.ArmorStrengthLabel") + "";
  let t0;
  let t1;
  let t2_value = (
    /*itemData*/
    ctx[0].strength + ""
  );
  let t2;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t2_value !== (t2_value = /*itemData*/
      ctx2[0].strength + ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$d(ctx) {
  let section;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let t5;
  let each_value = ensure_array_like(
    /*properties*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*property*/
    ctx2[4]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$5(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$5(key, child_ctx));
  }
  let if_block0 = (
    /*itemData*/
    ctx[0].acBonus && create_if_block_5$2(ctx)
  );
  let if_block1 = (
    /*itemData*/
    ctx[0].category && create_if_block_4$2(ctx)
  );
  let if_block2 = (
    /*itemData*/
    ctx[0].dexCap && create_if_block_3$3(ctx)
  );
  let if_block3 = (
    /*itemData*/
    ctx[0].checkPenalty && create_if_block_2$4(ctx)
  );
  let if_block4 = (
    /*itemData*/
    ctx[0].speedPenalty && create_if_block_1$6(ctx)
  );
  let if_block5 = (
    /*itemData*/
    ctx[0].strength > 0 && create_if_block$8(ctx)
  );
  return {
    c() {
      section = element("section");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      t3 = space();
      if (if_block3)
        if_block3.c();
      t4 = space();
      if (if_block4)
        if_block4.c();
      t5 = space();
      if (if_block5)
        if_block5.c();
      attr(section, "class", "properties");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      append(section, t0);
      if (if_block0)
        if_block0.m(section, null);
      append(section, t1);
      if (if_block1)
        if_block1.m(section, null);
      append(section, t2);
      if (if_block2)
        if_block2.m(section, null);
      append(section, t3);
      if (if_block3)
        if_block3.m(section, null);
      append(section, t4);
      if (if_block4)
        if_block4.m(section, null);
      append(section, t5);
      if (if_block5)
        if_block5.m(section, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*PF2E, properties*/
      6) {
        each_value = ensure_array_like(
          /*properties*/
          ctx2[2]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, section, destroy_block, create_each_block$5, t0, get_each_context$5);
      }
      if (
        /*itemData*/
        ctx2[0].acBonus
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_5$2(ctx2);
          if_block0.c();
          if_block0.m(section, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*itemData*/
        ctx2[0].category
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4$2(ctx2);
          if_block1.c();
          if_block1.m(section, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*itemData*/
        ctx2[0].dexCap
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block_3$3(ctx2);
          if_block2.c();
          if_block2.m(section, t3);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (
        /*itemData*/
        ctx2[0].checkPenalty
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
        } else {
          if_block3 = create_if_block_2$4(ctx2);
          if_block3.c();
          if_block3.m(section, t4);
        }
      } else if (if_block3) {
        if_block3.d(1);
        if_block3 = null;
      }
      if (
        /*itemData*/
        ctx2[0].speedPenalty
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
        } else {
          if_block4 = create_if_block_1$6(ctx2);
          if_block4.c();
          if_block4.m(section, t5);
        }
      } else if (if_block4) {
        if_block4.d(1);
        if_block4 = null;
      }
      if (
        /*itemData*/
        ctx2[0].strength > 0
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
        } else {
          if_block5 = create_if_block$8(ctx2);
          if_block5.c();
          if_block5.m(section, null);
        }
      } else if (if_block5) {
        if_block5.d(1);
        if_block5 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
    }
  };
}
function instance$d($$self, $$props, $$invalidate) {
  var _a;
  let { itemData } = $$props;
  const PF2E = CONFIG.PF2E;
  const properties2 = (_a = itemData.traits) === null || _a === void 0 ? void 0 : _a.value;
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(0, itemData = $$props2.itemData);
  };
  return [itemData, PF2E, properties2];
}
class Pf2eArmorProperties extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$d, create_fragment$d, safe_not_equal, { itemData: 0 });
  }
}
function get_each_context$4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$4(key_1, ctx) {
  let span;
  return {
    key: key_1,
    first: null,
    c() {
      span = element("span");
      span.textContent = `${i18n(
        /*PF2E*/
        ctx[2].weaponTraits[
          /*property*/
          ctx[4]
        ]
      )}`;
      attr(span, "class", "tag");
      this.first = span;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_2$3(ctx) {
  let span;
  let t_value = i18n(
    /*PF2E*/
    ctx[2].npcAttackTraits["range-increment-" + /*itemData*/
    ctx[0].range]
  ) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t_value !== (t_value = i18n(
        /*PF2E*/
        ctx2[2].npcAttackTraits["range-increment-" + /*itemData*/
        ctx2[0].range]
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_1$5(ctx) {
  let span;
  let t_value = i18n(
    /*PF2E*/
    ctx[2].weaponCategories[
      /*itemData*/
      ctx[0].category
    ]
  ) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t_value !== (t_value = i18n(
        /*PF2E*/
        ctx2[2].weaponCategories[
          /*itemData*/
          ctx2[0].category
        ]
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$7(ctx) {
  let span;
  let t_value = (
    /*itemData*/
    ctx[0].reload.label + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t_value !== (t_value = /*itemData*/
      ctx2[0].reload.label + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$c(ctx) {
  let section;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let t1;
  let t2;
  let each_value = ensure_array_like(
    /*properties*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*property*/
    ctx2[4]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$4(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$4(key, child_ctx));
  }
  let if_block0 = (
    /*itemData*/
    ctx[0].range && create_if_block_2$3(ctx)
  );
  let if_block1 = (
    /*itemData*/
    ctx[0].category && create_if_block_1$5(ctx)
  );
  let if_block2 = (
    /*itemData*/
    ctx[0].reload && create_if_block$7(ctx)
  );
  return {
    c() {
      section = element("section");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      t2 = space();
      if (if_block2)
        if_block2.c();
      attr(section, "class", "properties");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      append(section, t0);
      if (if_block0)
        if_block0.m(section, null);
      append(section, t1);
      if (if_block1)
        if_block1.m(section, null);
      append(section, t2);
      if (if_block2)
        if_block2.m(section, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*PF2E, properties*/
      6) {
        each_value = ensure_array_like(
          /*properties*/
          ctx2[1]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, section, destroy_block, create_each_block$4, t0, get_each_context$4);
      }
      if (
        /*itemData*/
        ctx2[0].range
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_2$3(ctx2);
          if_block0.c();
          if_block0.m(section, t1);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*itemData*/
        ctx2[0].category
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1$5(ctx2);
          if_block1.c();
          if_block1.m(section, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*itemData*/
        ctx2[0].reload
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block$7(ctx2);
          if_block2.c();
          if_block2.m(section, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
    }
  };
}
function instance$c($$self, $$props, $$invalidate) {
  var _a;
  let { itemData } = $$props;
  const properties2 = (_a = itemData.traits) === null || _a === void 0 ? void 0 : _a.value;
  const PF2E = CONFIG.PF2E;
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(0, itemData = $$props2.itemData);
  };
  return [itemData, properties2, PF2E];
}
class Pf2eWeaponProperties extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$c, create_fragment$c, safe_not_equal, { itemData: 0 });
  }
}
function get_each_context$3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$3(key_1, ctx) {
  let span;
  return {
    key: key_1,
    first: null,
    c() {
      span = element("span");
      span.textContent = `${i18n(
        /*PF2E*/
        ctx[1].consumableTraits[
          /*property*/
          ctx[4]
        ]
      )}`;
      attr(span, "class", "tag");
      this.first = span;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block_3$2(ctx) {
  let span;
  let t_value = i18n(
    /*PF2E*/
    ctx[1].consumableCategories[
      /*itemData*/
      ctx[0].category
    ]
  ) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t_value !== (t_value = i18n(
        /*PF2E*/
        ctx2[1].consumableCategories[
          /*itemData*/
          ctx2[0].category
        ]
      ) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$6(ctx) {
  let p;
  let t0;
  let t1_value = (
    /*itemData*/
    ctx[0].damage.formula + ""
  );
  let t1;
  let t2;
  let t3_value = i18n(
    /*PF2E*/
    ctx[1].damageTypes[
      /*itemData*/
      ctx[0].damage.type
    ]
  ) + "";
  let t3;
  function select_block_type(ctx2, dirty) {
    if (
      /*itemData*/
      ctx2[0].damage.kind === "damage"
    )
      return create_if_block_1$4;
    if (
      /*itemData*/
      ctx2[0].damage.kind === "healing"
    )
      return create_if_block_2$2;
    return create_else_block$1;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      p = element("p");
      if_block.c();
      t0 = space();
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      if_block.m(p, null);
      append(p, t0);
      append(p, t1);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (current_block_type !== (current_block_type = select_block_type(ctx2))) {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(p, t0);
        }
      }
      if (dirty & /*itemData*/
      1 && t1_value !== (t1_value = /*itemData*/
      ctx2[0].damage.formula + ""))
        set_data(t1, t1_value);
      if (dirty & /*itemData*/
      1 && t3_value !== (t3_value = i18n(
        /*PF2E*/
        ctx2[1].damageTypes[
          /*itemData*/
          ctx2[0].damage.type
        ]
      ) + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      if_block.d();
    }
  };
}
function create_else_block$1(ctx) {
  let b;
  return {
    c() {
      b = element("b");
      b.textContent = `${i18n("TYPES.Item.effect")}:`;
    },
    m(target, anchor) {
      insert(target, b, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(b);
      }
    }
  };
}
function create_if_block_2$2(ctx) {
  let b;
  return {
    c() {
      b = element("b");
      b.textContent = `${i18n("PF2E.TraitHealing")}:`;
    },
    m(target, anchor) {
      insert(target, b, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(b);
      }
    }
  };
}
function create_if_block_1$4(ctx) {
  let b;
  return {
    c() {
      b = element("b");
      b.textContent = `${i18n("PF2E.DamageLabel")}:`;
    },
    m(target, anchor) {
      insert(target, b, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(b);
      }
    }
  };
}
function create_fragment$b(ctx) {
  let section;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t0;
  let t1;
  let if_block1_anchor;
  let each_value = ensure_array_like(
    /*properties*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*property*/
    ctx2[4]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$3(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$3(key, child_ctx));
  }
  let if_block0 = (
    /*itemData*/
    ctx[0].category && create_if_block_3$2(ctx)
  );
  let if_block1 = (
    /*itemData*/
    ctx[0].damage?.formula && create_if_block$6(ctx)
  );
  return {
    c() {
      section = element("section");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t0 = space();
      if (if_block0)
        if_block0.c();
      t1 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty();
      attr(section, "class", "properties");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      append(section, t0);
      if (if_block0)
        if_block0.m(section, null);
      insert(target, t1, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*PF2E, properties*/
      6) {
        each_value = ensure_array_like(
          /*properties*/
          ctx2[2]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, section, destroy_block, create_each_block$3, t0, get_each_context$3);
      }
      if (
        /*itemData*/
        ctx2[0].category
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_3$2(ctx2);
          if_block0.c();
          if_block0.m(section, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (
        /*itemData*/
        ctx2[0].damage?.formula
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block$6(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
        detach(t1);
        detach(if_block1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d(detaching);
    }
  };
}
function instance$b($$self, $$props, $$invalidate) {
  var _a;
  let { itemData } = $$props;
  const PF2E = CONFIG.PF2E;
  const properties2 = (_a = itemData.traits) === null || _a === void 0 ? void 0 : _a.value;
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(0, itemData = $$props2.itemData);
  };
  return [itemData, PF2E, properties2];
}
class Pf2eConsumableProperties extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$b, create_fragment$b, safe_not_equal, { itemData: 0 });
  }
}
const Pf2eCarryTypeIcon_svelte_svelte_type_style_lang = "";
function create_else_block(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = null_to_empty("fa-solid " + /*classes*/
      ctx[1]) + " svelte-mobile-companion81nkluj30u9vsd-sumfqy");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*classes*/
      2 && i_class_value !== (i_class_value = null_to_empty("fa-solid " + /*classes*/
      ctx2[1]) + " svelte-mobile-companion81nkluj30u9vsd-sumfqy")) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_if_block$5(ctx) {
  let span;
  let i2;
  let i_class_value;
  let t;
  let if_block = (
    /*numberClasses*/
    ctx[2] && create_if_block_1$3(ctx)
  );
  return {
    c() {
      span = element("span");
      i2 = element("i");
      t = space();
      if (if_block)
        if_block.c();
      attr(i2, "class", i_class_value = null_to_empty("fa-solid " + /*classes*/
      ctx[1]) + " svelte-mobile-companion81nkluj30u9vsd-sumfqy");
      attr(span, "class", "fa-stack fa-fw fa-2xs svelte-mobile-companion81nkluj30u9vsd-sumfqy");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, i2);
      append(span, t);
      if (if_block)
        if_block.m(span, null);
    },
    p(ctx2, dirty) {
      if (dirty & /*classes*/
      2 && i_class_value !== (i_class_value = null_to_empty("fa-solid " + /*classes*/
      ctx2[1]) + " svelte-mobile-companion81nkluj30u9vsd-sumfqy")) {
        attr(i2, "class", i_class_value);
      }
      if (
        /*numberClasses*/
        ctx2[2]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block_1$3(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block)
        if_block.d();
    }
  };
}
function create_if_block_1$3(ctx) {
  let i2;
  let i_class_value;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", i_class_value = null_to_empty("fa-solid " + /*numberClasses*/
      ctx[2]) + " svelte-mobile-companion81nkluj30u9vsd-sumfqy");
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*numberClasses*/
      4 && i_class_value !== (i_class_value = null_to_empty("fa-solid " + /*numberClasses*/
      ctx2[2]) + " svelte-mobile-companion81nkluj30u9vsd-sumfqy")) {
        attr(i2, "class", i_class_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function create_fragment$a(ctx) {
  let span;
  function select_block_type(ctx2, dirty) {
    if (
      /*carryType*/
      ctx2[0] === CarryType.HELD
    )
      return create_if_block$5;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx);
  let if_block = current_block_type(ctx);
  return {
    c() {
      span = element("span");
      if_block.c();
      attr(span, "class", "item-carry-type svelte-mobile-companion81nkluj30u9vsd-sumfqy");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      if_block.m(span, null);
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2)) && if_block) {
        if_block.p(ctx2, dirty);
      } else {
        if_block.d(1);
        if_block = current_block_type(ctx2);
        if (if_block) {
          if_block.c();
          if_block.m(span, null);
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if_block.d();
    }
  };
}
function instance$a($$self, $$props, $$invalidate) {
  let carryType;
  let handsHeld;
  let { item } = $$props;
  let classes2;
  let numberClasses;
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(3, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    8) {
      $$invalidate(0, carryType = item.system.equipped.carryType);
    }
    if ($$self.$$.dirty & /*item*/
    8) {
      $$invalidate(4, handsHeld = item.system.equipped.handsHeld);
    }
    if ($$self.$$.dirty & /*carryType, handsHeld*/
    17) {
      {
        switch (carryType) {
          case CarryType.HELD:
            $$invalidate(1, classes2 = "fa-hand-back-fist fa-stack-2x");
            $$invalidate(2, numberClasses = handsHeld === 1 ? "fa-1 fa-inverse fa-stack-1x" : "fa-2 fa-inverse fa-stack-1x");
            break;
          case CarryType.WORN:
            $$invalidate(1, classes2 = "fa-tshirt fa-fw");
            break;
          case CarryType.STOWED:
            $$invalidate(1, classes2 = "fa-box fa-fw");
            break;
          case CarryType.DROPPED:
            $$invalidate(1, classes2 = "fa-grip-lines fa-fw");
            break;
          case CarryType.ATTACHED:
            $$invalidate(1, classes2 = "fa-paperclip fa-fw");
            break;
        }
      }
    }
  };
  return [carryType, classes2, numberClasses, item, handsHeld];
}
class Pf2eCarryTypeIcon extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$a, create_fragment$a, safe_not_equal, { item: 3 });
  }
}
const Pf2eCarryType_svelte_svelte_type_style_lang = "";
function create_if_block$4(ctx) {
  let p;
  let b;
  let t2;
  let t3_value = (
    /*item*/
    ctx[0].hands + ""
  );
  let t3;
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("PF2E.Item.Weapon.HandsLabel")}:`;
      t2 = space();
      t3 = text(t3_value);
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*item*/
      1 && t3_value !== (t3_value = /*item*/
      ctx2[0].hands + ""))
        set_data(t3, t3_value);
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_fragment$9(ctx) {
  let div1;
  let div0;
  let b;
  let t2;
  let span;
  let pf2ecarrytypeicon;
  let t3;
  let t4_value = i18n("PF2E.CarryType." + /*carryTypeText*/
  ctx[1]) + "";
  let t4;
  let t5;
  let current;
  let mounted;
  let dispose;
  pf2ecarrytypeicon = new Pf2eCarryTypeIcon({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  let if_block = (
    /*item*/
    ctx[0].hands && create_if_block$4(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      b = element("b");
      b.textContent = `${i18n("PF2E.Actor.Inventory.CarryType.OpenMenu")}:`;
      t2 = space();
      span = element("span");
      create_component(pf2ecarrytypeicon.$$.fragment);
      t3 = space();
      t4 = text(t4_value);
      t5 = space();
      if (if_block)
        if_block.c();
      attr(span, "aria-hidden", "true");
      attr(div0, "class", "carry-type svelte-mobile-companion81nkluj30u9vsd-e20up");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, b);
      append(div0, t2);
      append(div0, span);
      mount_component(pf2ecarrytypeicon, span, null);
      append(span, t3);
      append(span, t4);
      append(div1, t5);
      if (if_block)
        if_block.m(div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", prevent_default(
          /*changeCarryType*/
          ctx[2]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const pf2ecarrytypeicon_changes = {};
      if (dirty & /*item*/
      1)
        pf2ecarrytypeicon_changes.item = /*item*/
        ctx2[0];
      pf2ecarrytypeicon.$set(pf2ecarrytypeicon_changes);
      if ((!current || dirty & /*carryTypeText*/
      2) && t4_value !== (t4_value = i18n("PF2E.CarryType." + /*carryTypeText*/
      ctx2[1]) + ""))
        set_data(t4, t4_value);
      if (
        /*item*/
        ctx2[0].hands
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$4(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2ecarrytypeicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2ecarrytypeicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(pf2ecarrytypeicon);
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$9($$self, $$props, $$invalidate) {
  let carryType;
  let handsHeld;
  let carryTypeText;
  let { item } = $$props;
  const options = [
    {
      "carryType": CarryType.HELD,
      "handsHeld": 1,
      "inSlot": true
    },
    {
      "carryType": CarryType.HELD,
      "handsHeld": 2,
      "inSlot": true
    },
    {
      "carryType": CarryType.STOWED,
      "handsHeld": 0,
      "inSlot": true
    },
    {
      "carryType": CarryType.DROPPED,
      "handsHeld": 0,
      "inSlot": true
    },
    {
      "carryType": CarryType.WORN,
      "handsHeld": 0,
      "inSlot": true
    }
  ];
  if (item.isAttachable)
    ;
  function getNextCarryType() {
    const currentIndex = options.findIndex((option) => option.carryType === carryType && option.handsHeld === handsHeld);
    const nextIndex = (currentIndex + 1) % options.length;
    return options[nextIndex];
  }
  function changeCarryType() {
    const nextCarryType = getNextCarryType();
    item.actor.changeCarryType(item, nextCarryType);
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(4, carryType = item.system.equipped.carryType);
    }
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(3, handsHeld = item.system.equipped.handsHeld);
    }
    if ($$self.$$.dirty & /*handsHeld, carryType*/
    24) {
      $$invalidate(1, carryTypeText = handsHeld > 0 ? carryType + handsHeld : carryType);
    }
  };
  return [item, carryTypeText, changeCarryType, handsHeld, carryType];
}
class Pf2eCarryType extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$9, create_fragment$9, safe_not_equal, { item: 0 });
  }
}
const Pf2eInvestedIcon_svelte_svelte_type_style_lang = "";
function create_fragment$8(ctx) {
  let i2;
  return {
    c() {
      i2 = element("i");
      attr(i2, "class", "fa-solid fa-gem fa-fw icon svelte-mobile-companion81nkluj30u9vsd-jx0jgx");
      toggle_class(
        i2,
        "active",
        /*isInvested*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, i2, anchor);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isInvested*/
      1) {
        toggle_class(
          i2,
          "active",
          /*isInvested*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(i2);
      }
    }
  };
}
function instance$8($$self, $$props, $$invalidate) {
  let { isInvested } = $$props;
  $$self.$$set = ($$props2) => {
    if ("isInvested" in $$props2)
      $$invalidate(0, isInvested = $$props2.isInvested);
  };
  return [isInvested];
}
class Pf2eInvestedIcon extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$8, create_fragment$8, safe_not_equal, { isInvested: 0 });
  }
}
function create_fragment$7(ctx) {
  let p;
  let b;
  let t2;
  let span;
  let pf2einvestedicon;
  let current;
  let mounted;
  let dispose;
  pf2einvestedicon = new Pf2eInvestedIcon({
    props: { isInvested: (
      /*item*/
      ctx[0].isInvested
    ) }
  });
  return {
    c() {
      p = element("p");
      b = element("b");
      b.textContent = `${i18n("PF2E.ui.equipmentInvested")}:`;
      t2 = space();
      span = element("span");
      create_component(pf2einvestedicon.$$.fragment);
      attr(span, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, p, anchor);
      append(p, b);
      append(p, t2);
      append(p, span);
      mount_component(pf2einvestedicon, span, null);
      current = true;
      if (!mounted) {
        dispose = listen(span, "click", prevent_default(
          /*toggleInvested*/
          ctx[1]
        ));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const pf2einvestedicon_changes = {};
      if (dirty & /*item*/
      1)
        pf2einvestedicon_changes.isInvested = /*item*/
        ctx2[0].isInvested;
      pf2einvestedicon.$set(pf2einvestedicon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2einvestedicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2einvestedicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(p);
      }
      destroy_component(pf2einvestedicon);
      mounted = false;
      dispose();
    }
  };
}
function instance$7($$self, $$props, $$invalidate) {
  let { item } = $$props;
  function toggleInvested() {
    item.actor.toggleInvested(item.id);
  }
  $$self.$$set = ($$props2) => {
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
  };
  return [item, toggleInvested];
}
class Pf2eInvestment extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$7, create_fragment$7, safe_not_equal, { item: 0 });
  }
}
function get_each_context$2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$2(key_1, ctx) {
  let span;
  return {
    key: key_1,
    first: null,
    c() {
      span = element("span");
      span.textContent = `${i18n(
        /*PF2E*/
        ctx[0].equipmentTraits[
          /*property*/
          ctx[4]
        ]
      )}`;
      attr(span, "class", "tag");
      this.first = span;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$6(ctx) {
  let section;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_value = ensure_array_like(
    /*properties*/
    ctx[1]
  );
  const get_key = (ctx2) => (
    /*property*/
    ctx2[4]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$2(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$2(key, child_ctx));
  }
  return {
    c() {
      section = element("section");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      attr(section, "class", "properties");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*PF2E, properties*/
      3) {
        each_value = ensure_array_like(
          /*properties*/
          ctx2[1]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, section, destroy_block, create_each_block$2, null, get_each_context$2);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
    }
  };
}
function instance$6($$self, $$props, $$invalidate) {
  var _a;
  let { itemData } = $$props;
  const PF2E = CONFIG.PF2E;
  const properties2 = (_a = itemData.traits) === null || _a === void 0 ? void 0 : _a.value;
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(2, itemData = $$props2.itemData);
  };
  return [PF2E, properties2, itemData];
}
class Pf2eEquipmentProperties extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$6, create_fragment$6, safe_not_equal, { itemData: 2 });
  }
}
function get_each_context$1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i2];
  return child_ctx;
}
function create_each_block$1(key_1, ctx) {
  let span;
  return {
    key: key_1,
    first: null,
    c() {
      span = element("span");
      span.textContent = `${i18n(
        /*PF2E*/
        ctx[1].shieldTraits[
          /*property*/
          ctx[4]
        ]
      )}`;
      attr(span, "class", "tag");
      this.first = span;
    },
    m(target, anchor) {
      insert(target, span, anchor);
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_if_block$3(ctx) {
  let span;
  let t0;
  let t1_value = (
    /*itemData*/
    ctx[0].acBonus + ""
  );
  let t1;
  let t2;
  let t3_value = i18n("PF2E.ArmorArmorLabel") + "";
  let t3;
  return {
    c() {
      span = element("span");
      t0 = text("+");
      t1 = text(t1_value);
      t2 = space();
      t3 = text(t3_value);
      attr(span, "class", "tag-light");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append(span, t0);
      append(span, t1);
      append(span, t2);
      append(span, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*itemData*/
      1 && t1_value !== (t1_value = /*itemData*/
      ctx2[0].acBonus + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_fragment$5(ctx) {
  let section;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t;
  let each_value = ensure_array_like(
    /*properties*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*property*/
    ctx2[4]
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context$1(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block$1(key, child_ctx));
  }
  let if_block = (
    /*itemData*/
    ctx[0].acBonus && create_if_block$3(ctx)
  );
  return {
    c() {
      section = element("section");
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      t = space();
      if (if_block)
        if_block.c();
      attr(section, "class", "properties");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(section, null);
        }
      }
      append(section, t);
      if (if_block)
        if_block.m(section, null);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*PF2E, properties*/
      6) {
        each_value = ensure_array_like(
          /*properties*/
          ctx2[2]
        );
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, section, destroy_block, create_each_block$1, t, get_each_context$1);
      }
      if (
        /*itemData*/
        ctx2[0].acBonus
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block$3(ctx2);
          if_block.c();
          if_block.m(section, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d();
      }
      if (if_block)
        if_block.d();
    }
  };
}
function instance$5($$self, $$props, $$invalidate) {
  var _a;
  let { itemData } = $$props;
  const PF2E = CONFIG.PF2E;
  const properties2 = (_a = itemData.traits) === null || _a === void 0 ? void 0 : _a.value;
  $$self.$$set = ($$props2) => {
    if ("itemData" in $$props2)
      $$invalidate(0, itemData = $$props2.itemData);
  };
  return [itemData, PF2E, properties2];
}
class Pf2eShieldProperties extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$5, create_fragment$5, safe_not_equal, { itemData: 0 });
  }
}
const Pf2eObject_svelte_svelte_type_style_lang = "";
function create_if_block_8(ctx) {
  let div2;
  let pf2ecarrytypeicon;
  let t;
  let show_if = (
    /*item*/
    ctx[0].traits.has("invested")
  );
  let div_transition;
  let current;
  pf2ecarrytypeicon = new Pf2eCarryTypeIcon({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  let if_block = show_if && create_if_block_9(ctx);
  return {
    c() {
      div2 = element("div");
      create_component(pf2ecarrytypeicon.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      mount_component(pf2ecarrytypeicon, div2, null);
      append(div2, t);
      if (if_block)
        if_block.m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2ecarrytypeicon_changes = {};
      if (dirty & /*item*/
      1)
        pf2ecarrytypeicon_changes.item = /*item*/
        ctx2[0];
      pf2ecarrytypeicon.$set(pf2ecarrytypeicon_changes);
      if (dirty & /*item*/
      1)
        show_if = /*item*/
        ctx2[0].traits.has("invested");
      if (show_if) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_9(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div2, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2ecarrytypeicon.$$.fragment, local);
      transition_in(if_block);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, fade, { duration: 200 }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(pf2ecarrytypeicon.$$.fragment, local);
      transition_out(if_block);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, fade, { duration: 200 }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_component(pf2ecarrytypeicon);
      if (if_block)
        if_block.d();
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_9(ctx) {
  let pf2einvestedicon;
  let current;
  pf2einvestedicon = new Pf2eInvestedIcon({
    props: { isInvested: (
      /*item*/
      ctx[0].isInvested
    ) }
  });
  return {
    c() {
      create_component(pf2einvestedicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2einvestedicon, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2einvestedicon_changes = {};
      if (dirty & /*item*/
      1)
        pf2einvestedicon_changes.isInvested = /*item*/
        ctx2[0].isInvested;
      pf2einvestedicon.$set(pf2einvestedicon_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2einvestedicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2einvestedicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2einvestedicon, detaching);
    }
  };
}
function create_if_block$2(ctx) {
  let div2;
  let t0;
  let t1;
  let t2;
  let t3;
  let t4;
  let pf2ecarrytype;
  let t5;
  let show_if = (
    /*item*/
    ctx[0].traits.has("invested")
  );
  let t6;
  let t7;
  let pf2edescription;
  let div_transition;
  let current;
  let if_block0 = (
    /*item*/
    ctx[0].type === ItemType.weapon && create_if_block_7$1(ctx)
  );
  let if_block1 = (
    /*item*/
    ctx[0].type === ItemType.shield && create_if_block_6$1(ctx)
  );
  let if_block2 = (
    /*item*/
    ctx[0].type === ItemType.armor && create_if_block_5$1(ctx)
  );
  let if_block3 = (
    /*item*/
    ctx[0].type === ItemType.equipment && create_if_block_4$1(ctx)
  );
  let if_block4 = (
    /*item*/
    ctx[0].type === ItemType.consumable && create_if_block_3$1(ctx)
  );
  pf2ecarrytype = new Pf2eCarryType({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  let if_block5 = show_if && create_if_block_2$1(ctx);
  let if_block6 = (
    /*baseAction*/
    ctx[5] && create_if_block_1$2(ctx)
  );
  pf2edescription = new Pf2eDescription({ props: { itemData: (
    /*itemData*/
    ctx[2]
  ) } });
  return {
    c() {
      div2 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      create_component(pf2ecarrytype.$$.fragment);
      t5 = space();
      if (if_block5)
        if_block5.c();
      t6 = space();
      if (if_block6)
        if_block6.c();
      t7 = space();
      create_component(pf2edescription.$$.fragment);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      if (if_block0)
        if_block0.m(div2, null);
      append(div2, t0);
      if (if_block1)
        if_block1.m(div2, null);
      append(div2, t1);
      if (if_block2)
        if_block2.m(div2, null);
      append(div2, t2);
      if (if_block3)
        if_block3.m(div2, null);
      append(div2, t3);
      if (if_block4)
        if_block4.m(div2, null);
      append(div2, t4);
      mount_component(pf2ecarrytype, div2, null);
      append(div2, t5);
      if (if_block5)
        if_block5.m(div2, null);
      append(div2, t6);
      if (if_block6)
        if_block6.m(div2, null);
      append(div2, t7);
      mount_component(pf2edescription, div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*item*/
        ctx2[0].type === ItemType.weapon
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7$1(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div2, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].type === ItemType.shield
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6$1(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, t1);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].type === ItemType.armor
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_5$1(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div2, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].type === ItemType.equipment
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_4$1(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*item*/
        ctx2[0].type === ItemType.consumable
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_3$1(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      const pf2ecarrytype_changes = {};
      if (dirty & /*item*/
      1)
        pf2ecarrytype_changes.item = /*item*/
        ctx2[0];
      pf2ecarrytype.$set(pf2ecarrytype_changes);
      if (dirty & /*item*/
      1)
        show_if = /*item*/
        ctx2[0].traits.has("invested");
      if (show_if) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*item*/
          1) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_2$1(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, t6);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*baseAction*/
        ctx2[5]
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & /*baseAction*/
          32) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_1$2(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div2, t7);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      const pf2edescription_changes = {};
      if (dirty & /*itemData*/
      4)
        pf2edescription_changes.itemData = /*itemData*/
        ctx2[2];
      pf2edescription.$set(pf2edescription_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(pf2ecarrytype.$$.fragment, local);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(pf2edescription.$$.fragment, local);
      if (local) {
        add_render_callback(() => {
          if (!current)
            return;
          if (!div_transition)
            div_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: identity$1, axis: "y" }, true);
          div_transition.run(1);
        });
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(pf2ecarrytype.$$.fragment, local);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(pf2edescription.$$.fragment, local);
      if (local) {
        if (!div_transition)
          div_transition = create_bidirectional_transition(div2, slide, { duration: 200, easing: identity$1, axis: "y" }, false);
        div_transition.run(0);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      destroy_component(pf2ecarrytype);
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      destroy_component(pf2edescription);
      if (detaching && div_transition)
        div_transition.end();
    }
  };
}
function create_if_block_7$1(ctx) {
  let pf2eweaponproperties;
  let current;
  pf2eweaponproperties = new Pf2eWeaponProperties({ props: { itemData: (
    /*itemData*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(pf2eweaponproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2eweaponproperties, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2eweaponproperties_changes = {};
      if (dirty & /*itemData*/
      4)
        pf2eweaponproperties_changes.itemData = /*itemData*/
        ctx2[2];
      pf2eweaponproperties.$set(pf2eweaponproperties_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eweaponproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eweaponproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2eweaponproperties, detaching);
    }
  };
}
function create_if_block_6$1(ctx) {
  let pf2eshieldproperties;
  let current;
  pf2eshieldproperties = new Pf2eShieldProperties({ props: { itemData: (
    /*itemData*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(pf2eshieldproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2eshieldproperties, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2eshieldproperties_changes = {};
      if (dirty & /*itemData*/
      4)
        pf2eshieldproperties_changes.itemData = /*itemData*/
        ctx2[2];
      pf2eshieldproperties.$set(pf2eshieldproperties_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eshieldproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eshieldproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2eshieldproperties, detaching);
    }
  };
}
function create_if_block_5$1(ctx) {
  let pf2earmorproperties;
  let current;
  pf2earmorproperties = new Pf2eArmorProperties({ props: { itemData: (
    /*itemData*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(pf2earmorproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2earmorproperties, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2earmorproperties_changes = {};
      if (dirty & /*itemData*/
      4)
        pf2earmorproperties_changes.itemData = /*itemData*/
        ctx2[2];
      pf2earmorproperties.$set(pf2earmorproperties_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2earmorproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2earmorproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2earmorproperties, detaching);
    }
  };
}
function create_if_block_4$1(ctx) {
  let pf2eequipmentproperties;
  let current;
  pf2eequipmentproperties = new Pf2eEquipmentProperties({ props: { itemData: (
    /*itemData*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(pf2eequipmentproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2eequipmentproperties, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2eequipmentproperties_changes = {};
      if (dirty & /*itemData*/
      4)
        pf2eequipmentproperties_changes.itemData = /*itemData*/
        ctx2[2];
      pf2eequipmentproperties.$set(pf2eequipmentproperties_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eequipmentproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eequipmentproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2eequipmentproperties, detaching);
    }
  };
}
function create_if_block_3$1(ctx) {
  let pf2econsumableproperties;
  let current;
  pf2econsumableproperties = new Pf2eConsumableProperties({ props: { itemData: (
    /*itemData*/
    ctx[2]
  ) } });
  return {
    c() {
      create_component(pf2econsumableproperties.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2econsumableproperties, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2econsumableproperties_changes = {};
      if (dirty & /*itemData*/
      4)
        pf2econsumableproperties_changes.itemData = /*itemData*/
        ctx2[2];
      pf2econsumableproperties.$set(pf2econsumableproperties_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2econsumableproperties.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2econsumableproperties.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2econsumableproperties, detaching);
    }
  };
}
function create_if_block_2$1(ctx) {
  let pf2einvestment;
  let current;
  pf2einvestment = new Pf2eInvestment({ props: { item: (
    /*item*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(pf2einvestment.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2einvestment, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2einvestment_changes = {};
      if (dirty & /*item*/
      1)
        pf2einvestment_changes.item = /*item*/
        ctx2[0];
      pf2einvestment.$set(pf2einvestment_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2einvestment.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2einvestment.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2einvestment, detaching);
    }
  };
}
function create_if_block_1$2(ctx) {
  let pf2eaction;
  let current;
  pf2eaction = new Pf2eAction({ props: { action: (
    /*baseAction*/
    ctx[5]
  ) } });
  return {
    c() {
      create_component(pf2eaction.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2eaction, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2eaction_changes = {};
      if (dirty & /*baseAction*/
      32)
        pf2eaction_changes.action = /*baseAction*/
        ctx2[5];
      pf2eaction.$set(pf2eaction_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eaction.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eaction.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2eaction, detaching);
    }
  };
}
function create_fragment$4(ctx) {
  let section;
  let div2;
  let div0;
  let img;
  let img_src_value;
  let t0;
  let span;
  let t1;
  let t2;
  let div1;
  let t3;
  let quantity;
  let t4;
  let current;
  let mounted;
  let dispose;
  let if_block0 = !/*showItemData*/
  ctx[3] && create_if_block_8(ctx);
  quantity = new Quantity({
    props: {
      quantity: (
        /*itemData*/
        ctx[2].quantity
      ),
      fontFamily: "var(--a5e-font-serif)"
    }
  });
  quantity.$on(
    "onQtyChange",
    /*handleQtyChange*/
    ctx[7]
  );
  let if_block1 = (
    /*showItemData*/
    ctx[3] && create_if_block$2(ctx)
  );
  return {
    c() {
      section = element("section");
      div2 = element("div");
      div0 = element("div");
      img = element("img");
      t0 = space();
      span = element("span");
      t1 = text(
        /*itemName*/
        ctx[4]
      );
      t2 = space();
      div1 = element("div");
      if (if_block0)
        if_block0.c();
      t3 = space();
      create_component(quantity.$$.fragment);
      t4 = space();
      if (if_block1)
        if_block1.c();
      if (!src_url_equal(img.src, img_src_value = /*item*/
      ctx[0].img))
        attr(img, "src", img_src_value);
      attr(
        img,
        "alt",
        /*itemName*/
        ctx[4]
      );
      attr(img, "class", "item-icon svelte-mobile-companion81nkluj30u9vsd-zxz8kj");
      attr(div0, "class", "item svelte-mobile-companion81nkluj30u9vsd-zxz8kj");
      attr(div0, "aria-hidden", "true");
      attr(div1, "class", "states-and-qty svelte-mobile-companion81nkluj30u9vsd-zxz8kj");
      attr(div2, "class", "item-name-and-qty svelte-mobile-companion81nkluj30u9vsd-zxz8kj");
      attr(section, "class", "svelte-mobile-companion81nkluj30u9vsd-zxz8kj");
      toggle_class(
        section,
        "odd",
        /*isOddLine*/
        ctx[1]
      );
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div2);
      append(div2, div0);
      append(div0, img);
      append(div0, t0);
      append(div0, span);
      append(span, t1);
      append(div2, t2);
      append(div2, div1);
      if (if_block0)
        if_block0.m(div1, null);
      append(div1, t3);
      mount_component(quantity, div1, null);
      append(section, t4);
      if (if_block1)
        if_block1.m(section, null);
      current = true;
      if (!mounted) {
        dispose = listen(
          div0,
          "click",
          /*toggleDescription*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*item*/
      1 && !src_url_equal(img.src, img_src_value = /*item*/
      ctx2[0].img)) {
        attr(img, "src", img_src_value);
      }
      if (!current || dirty & /*itemName*/
      16) {
        attr(
          img,
          "alt",
          /*itemName*/
          ctx2[4]
        );
      }
      if (!current || dirty & /*itemName*/
      16)
        set_data(
          t1,
          /*itemName*/
          ctx2[4]
        );
      if (!/*showItemData*/
      ctx2[3]) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*showItemData*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div1, t3);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      const quantity_changes = {};
      if (dirty & /*itemData*/
      4)
        quantity_changes.quantity = /*itemData*/
        ctx2[2].quantity;
      quantity.$set(quantity_changes);
      if (
        /*showItemData*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*showItemData*/
          8) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block$2(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(section, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (!current || dirty & /*isOddLine*/
      2) {
        toggle_class(
          section,
          "odd",
          /*isOddLine*/
          ctx2[1]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(quantity.$$.fragment, local);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(quantity.$$.fragment, local);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0)
        if_block0.d();
      destroy_component(quantity);
      if (if_block1)
        if_block1.d();
      mounted = false;
      dispose();
    }
  };
}
function instance$4($$self, $$props, $$invalidate) {
  let itemData;
  let baseAction;
  let itemName;
  let { actor } = $$props;
  let { item } = $$props;
  let { isOddLine } = $$props;
  let showItemData = false;
  function toggleDescription() {
    $$invalidate(3, showItemData = !showItemData);
  }
  function handleQtyChange(event) {
    const update2 = { system: { quantity: event.detail } };
    item.update(update2);
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(8, actor = $$props2.actor);
    if ("item" in $$props2)
      $$invalidate(0, item = $$props2.item);
    if ("isOddLine" in $$props2)
      $$invalidate(1, isOddLine = $$props2.isOddLine);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(2, itemData = item.system);
    }
    if ($$self.$$.dirty & /*actor, itemData*/
    260) {
      $$invalidate(5, baseAction = actor.system.actions.find((action) => action.slug === itemData.slug));
    }
    if ($$self.$$.dirty & /*item*/
    1) {
      $$invalidate(4, itemName = item.name);
    }
  };
  return [
    item,
    isOddLine,
    itemData,
    showItemData,
    itemName,
    baseAction,
    toggleDescription,
    handleQtyChange,
    actor
  ];
}
class Pf2eObject extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$4, create_fragment$4, safe_not_equal, { actor: 8, item: 0, isOddLine: 1 });
  }
}
const Pf2eCurrency_svelte_svelte_type_style_lang = "";
function create_fragment$3(ctx) {
  let ol;
  let li0;
  let div0;
  let t0;
  let evaluatinginput0;
  let t1;
  let li1;
  let div1;
  let t2;
  let evaluatinginput1;
  let t3;
  let li2;
  let div2;
  let t4;
  let evaluatinginput2;
  let t5;
  let li3;
  let div3;
  let t6;
  let evaluatinginput3;
  let current;
  evaluatinginput0 = new EvaluatingInput({
    props: {
      value: (
        /*currency*/
        ctx[0].pp
      ),
      styleClass: "coin-input",
      id: "currency-pp",
      name: "pp"
    }
  });
  evaluatinginput0.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  evaluatinginput1 = new EvaluatingInput({
    props: {
      value: (
        /*currency*/
        ctx[0].gp
      ),
      styleClass: "coin-input",
      id: "currency-gp",
      name: "gp"
    }
  });
  evaluatinginput1.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  evaluatinginput2 = new EvaluatingInput({
    props: {
      value: (
        /*currency*/
        ctx[0].sp
      ),
      styleClass: "coin-input",
      id: "currency-sp",
      name: "sp"
    }
  });
  evaluatinginput2.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  evaluatinginput3 = new EvaluatingInput({
    props: {
      value: (
        /*currency*/
        ctx[0].cp
      ),
      styleClass: "coin-input",
      id: "currency-cp",
      name: "cp"
    }
  });
  evaluatinginput3.$on(
    "change",
    /*updateValue*/
    ctx[1]
  );
  return {
    c() {
      ol = element("ol");
      li0 = element("li");
      div0 = element("div");
      t0 = space();
      create_component(evaluatinginput0.$$.fragment);
      t1 = space();
      li1 = element("li");
      div1 = element("div");
      t2 = space();
      create_component(evaluatinginput1.$$.fragment);
      t3 = space();
      li2 = element("li");
      div2 = element("div");
      t4 = space();
      create_component(evaluatinginput2.$$.fragment);
      t5 = space();
      li3 = element("li");
      div3 = element("div");
      t6 = space();
      create_component(evaluatinginput3.$$.fragment);
      attr(div0, "class", "coin-image pp svelte-mobile-companion81nkluj30u9vsd-17paqud");
      attr(li0, "class", "coin-item svelte-mobile-companion81nkluj30u9vsd-17paqud");
      attr(div1, "class", "coin-image gp svelte-mobile-companion81nkluj30u9vsd-17paqud");
      attr(li1, "class", "coin-item svelte-mobile-companion81nkluj30u9vsd-17paqud");
      attr(div2, "class", "coin-image sp svelte-mobile-companion81nkluj30u9vsd-17paqud");
      attr(li2, "class", "coin-item svelte-mobile-companion81nkluj30u9vsd-17paqud");
      attr(div3, "class", "coin-image cp svelte-mobile-companion81nkluj30u9vsd-17paqud");
      attr(li3, "class", "coin-item svelte-mobile-companion81nkluj30u9vsd-17paqud");
      attr(ol, "class", "currency-list svelte-mobile-companion81nkluj30u9vsd-17paqud");
    },
    m(target, anchor) {
      insert(target, ol, anchor);
      append(ol, li0);
      append(li0, div0);
      append(li0, t0);
      mount_component(evaluatinginput0, li0, null);
      append(ol, t1);
      append(ol, li1);
      append(li1, div1);
      append(li1, t2);
      mount_component(evaluatinginput1, li1, null);
      append(ol, t3);
      append(ol, li2);
      append(li2, div2);
      append(li2, t4);
      mount_component(evaluatinginput2, li2, null);
      append(ol, t5);
      append(ol, li3);
      append(li3, div3);
      append(li3, t6);
      mount_component(evaluatinginput3, li3, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      const evaluatinginput0_changes = {};
      if (dirty & /*currency*/
      1)
        evaluatinginput0_changes.value = /*currency*/
        ctx2[0].pp;
      evaluatinginput0.$set(evaluatinginput0_changes);
      const evaluatinginput1_changes = {};
      if (dirty & /*currency*/
      1)
        evaluatinginput1_changes.value = /*currency*/
        ctx2[0].gp;
      evaluatinginput1.$set(evaluatinginput1_changes);
      const evaluatinginput2_changes = {};
      if (dirty & /*currency*/
      1)
        evaluatinginput2_changes.value = /*currency*/
        ctx2[0].sp;
      evaluatinginput2.$set(evaluatinginput2_changes);
      const evaluatinginput3_changes = {};
      if (dirty & /*currency*/
      1)
        evaluatinginput3_changes.value = /*currency*/
        ctx2[0].cp;
      evaluatinginput3.$set(evaluatinginput3_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(evaluatinginput0.$$.fragment, local);
      transition_in(evaluatinginput1.$$.fragment, local);
      transition_in(evaluatinginput2.$$.fragment, local);
      transition_in(evaluatinginput3.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(evaluatinginput0.$$.fragment, local);
      transition_out(evaluatinginput1.$$.fragment, local);
      transition_out(evaluatinginput2.$$.fragment, local);
      transition_out(evaluatinginput3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(ol);
      }
      destroy_component(evaluatinginput0);
      destroy_component(evaluatinginput1);
      destroy_component(evaluatinginput2);
      destroy_component(evaluatinginput3);
    }
  };
}
function instance$3($$self, $$props, $$invalidate) {
  let currency;
  let { actor } = $$props;
  function updateValue(event) {
    const { value, name: name2 } = event.detail;
    const fieldName = name2;
    const currentValue = currency[fieldName];
    if (!currentValue) {
      return;
    }
    const delta = value - currentValue;
    const coinUpdate = { [fieldName]: delta };
    if (delta > 0) {
      actor.inventory.addCoins(coinUpdate);
    } else {
      actor.inventory.removeCoins(coinUpdate);
    }
  }
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(2, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    4) {
      $$invalidate(0, currency = actor.inventory.coins);
    }
  };
  return [currency, updateValue, actor];
}
class Pf2eCurrency extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$3, create_fragment$3, safe_not_equal, { actor: 2 });
  }
}
const Pf2eWeight_svelte_svelte_type_style_lang = "";
function create_fragment$2(ctx) {
  let div1;
  let img;
  let img_src_value;
  let t0;
  let span0;
  let t1;
  let div0;
  let span2;
  let t2_value = i18n("PF2E.Item.Physical.Bulk.Label") + "";
  let t2;
  let t3;
  let t4_value = (
    /*bulk*/
    ctx[0].value.normal + ""
  );
  let t4;
  let t5;
  let t6_value = (
    /*bulk*/
    ctx[0].value.light + ""
  );
  let t6;
  let t7;
  let span1;
  let t8_value = i18n("PF2E.condition.encumbered.name") + "";
  let t8;
  let t9;
  let t10_value = (
    /*bulk*/
    ctx[0].encumberedAfter + ""
  );
  let t10;
  let t11;
  let span3;
  let t12_value = i18n("PF2E.BulkMaxLabel") + "";
  let t12;
  let t13;
  let t14_value = (
    /*bulk*/
    ctx[0].max + ""
  );
  let t14;
  let t15;
  let span4;
  return {
    c() {
      div1 = element("div");
      img = element("img");
      t0 = space();
      span0 = element("span");
      t1 = space();
      div0 = element("div");
      span2 = element("span");
      t2 = text(t2_value);
      t3 = text(": ");
      t4 = text(t4_value);
      t5 = text(", ");
      t6 = text(t6_value);
      t7 = text(" L /\r\n            ");
      span1 = element("span");
      t8 = text(t8_value);
      t9 = text(": ");
      t10 = text(t10_value);
      t11 = space();
      span3 = element("span");
      t12 = text(t12_value);
      t13 = text(": ");
      t14 = text(t14_value);
      t15 = space();
      span4 = element("span");
      if (!src_url_equal(img.src, img_src_value = "icons/containers/bags/pack-leather-white-tan.webp"))
        attr(img, "src", img_src_value);
      attr(img, "alt", "Encumbrance");
      attr(span0, "class", "encumbrance-bar svelte-mobile-companion81nkluj30u9vsd-a1ieu5");
      set_style(span0, "width", Math.min(
        /*bulk*/
        ctx[0].maxPercentage,
        100
      ) + "%");
      toggle_class(
        span0,
        "encumbered",
        /*bulk*/
        ctx[0].isEncumbered
      );
      toggle_class(
        span0,
        "over-limit",
        /*bulk*/
        ctx[0].isOverMax
      );
      attr(div0, "class", "encumbrance-label svelte-mobile-companion81nkluj30u9vsd-a1ieu5");
      attr(span4, "class", "bar-bg svelte-mobile-companion81nkluj30u9vsd-a1ieu5");
      attr(div1, "class", "encumbrance svelte-mobile-companion81nkluj30u9vsd-a1ieu5");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, img);
      append(div1, t0);
      append(div1, span0);
      append(div1, t1);
      append(div1, div0);
      append(div0, span2);
      append(span2, t2);
      append(span2, t3);
      append(span2, t4);
      append(span2, t5);
      append(span2, t6);
      append(span2, t7);
      append(span2, span1);
      append(span1, t8);
      append(span1, t9);
      append(span1, t10);
      append(div0, t11);
      append(div0, span3);
      append(span3, t12);
      append(span3, t13);
      append(span3, t14);
      append(div1, t15);
      append(div1, span4);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*bulk*/
      1) {
        set_style(span0, "width", Math.min(
          /*bulk*/
          ctx2[0].maxPercentage,
          100
        ) + "%");
      }
      if (dirty & /*bulk*/
      1) {
        toggle_class(
          span0,
          "encumbered",
          /*bulk*/
          ctx2[0].isEncumbered
        );
      }
      if (dirty & /*bulk*/
      1) {
        toggle_class(
          span0,
          "over-limit",
          /*bulk*/
          ctx2[0].isOverMax
        );
      }
      if (dirty & /*bulk*/
      1 && t4_value !== (t4_value = /*bulk*/
      ctx2[0].value.normal + ""))
        set_data(t4, t4_value);
      if (dirty & /*bulk*/
      1 && t6_value !== (t6_value = /*bulk*/
      ctx2[0].value.light + ""))
        set_data(t6, t6_value);
      if (dirty & /*bulk*/
      1 && t10_value !== (t10_value = /*bulk*/
      ctx2[0].encumberedAfter + ""))
        set_data(t10, t10_value);
      if (dirty & /*bulk*/
      1 && t14_value !== (t14_value = /*bulk*/
      ctx2[0].max + ""))
        set_data(t14, t14_value);
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
    }
  };
}
function instance$2($$self, $$props, $$invalidate) {
  let bulk;
  let { actor } = $$props;
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(1, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor*/
    2) {
      $$invalidate(0, bulk = actor.inventory.bulk);
    }
  };
  return [bulk, actor];
}
class Pf2eWeight extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$2, create_fragment$2, safe_not_equal, { actor: 1 });
  }
}
const Pf2eInventory_svelte_svelte_type_style_lang = "";
function get_each_context(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function get_each_context_1(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[10] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function get_each_context_2(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function get_each_context_3(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[14] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function get_each_context_4(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[16] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function get_each_context_5(ctx, list, i2) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i2];
  child_ctx[9] = i2;
  return child_ctx;
}
function create_if_block_7(ctx) {
  let pf2ecurrency;
  let current;
  pf2ecurrency = new Pf2eCurrency({ props: { actor: (
    /*actor*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(pf2ecurrency.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2ecurrency, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2ecurrency_changes = {};
      if (dirty & /*actor*/
      1)
        pf2ecurrency_changes.actor = /*actor*/
        ctx2[0];
      pf2ecurrency.$set(pf2ecurrency_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2ecurrency.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2ecurrency.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2ecurrency, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let pf2eweight;
  let current;
  pf2eweight = new Pf2eWeight({ props: { actor: (
    /*actor*/
    ctx[0]
  ) } });
  return {
    c() {
      create_component(pf2eweight.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2eweight, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2eweight_changes = {};
      if (dirty & /*actor*/
      1)
        pf2eweight_changes.actor = /*actor*/
        ctx2[0];
      pf2eweight.$set(pf2eweight_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eweight.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eweight.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2eweight, detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_5 = ensure_array_like(
    /*weaponsAndShields*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*weaponOrShield*/
    ctx2[18].id
  );
  for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
    let child_ctx = get_each_context_5(ctx, each_value_5, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_5(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("PF2E.Actor.Inventory.Section.WeaponsAndShields")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(h3, "class", "header-name svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
      attr(div2, "class", "pf2e-item-header svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h3);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*actor, weaponsAndShields*/
      5) {
        each_value_5 = ensure_array_like(
          /*weaponsAndShields*/
          ctx2[2]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_5, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_5, each_1_anchor, get_each_context_5);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_5.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_5(key_1, ctx) {
  let first;
  let pf2eobject;
  let current;
  pf2eobject = new Pf2eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*weaponOrShield*/
        ctx[18]
      ),
      isOddLine: (
        /*index*/
        ctx[9] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(pf2eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(pf2eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const pf2eobject_changes = {};
      if (dirty & /*actor*/
      1)
        pf2eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty & /*weaponsAndShields*/
      4)
        pf2eobject_changes.item = /*weaponOrShield*/
        ctx[18];
      if (dirty & /*weaponsAndShields*/
      4)
        pf2eobject_changes.isOddLine = /*index*/
        ctx[9] % 2 !== 0;
      pf2eobject.$set(pf2eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(pf2eobject, detaching);
    }
  };
}
function create_if_block_4(ctx) {
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_4 = ensure_array_like(
    /*items*/
    ctx[1][ItemType.armor]
  );
  const get_key = (ctx2) => (
    /*armor*/
    ctx2[16].id
  );
  for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
    let child_ctx = get_each_context_4(ctx, each_value_4, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_4(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("TYPES.Item.armor")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(h3, "class", "header-name svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
      attr(div2, "class", "pf2e-item-header svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h3);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*actor, items*/
      3) {
        each_value_4 = ensure_array_like(
          /*items*/
          ctx2[1][ItemType.armor]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_4, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_4, each_1_anchor, get_each_context_4);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_4.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_4(key_1, ctx) {
  let first;
  let pf2eobject;
  let current;
  pf2eobject = new Pf2eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*armor*/
        ctx[16]
      ),
      isOddLine: (
        /*index*/
        ctx[9] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(pf2eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(pf2eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const pf2eobject_changes = {};
      if (dirty & /*actor*/
      1)
        pf2eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.item = /*armor*/
        ctx[16];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.isOddLine = /*index*/
        ctx[9] % 2 !== 0;
      pf2eobject.$set(pf2eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(pf2eobject, detaching);
    }
  };
}
function create_if_block_3(ctx) {
  let div2;
  let h3;
  let t1;
  let span;
  let t2_value = i18n("PF2E.InvestedLabel") + "";
  let t2;
  let t3;
  let t4_value = (
    /*actor*/
    ctx[0].inventory.invested.value + ""
  );
  let t4;
  let t5;
  let t6_value = (
    /*actor*/
    ctx[0].inventory.invested.max + ""
  );
  let t6;
  let t7;
  let t8;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_3 = ensure_array_like(
    /*items*/
    ctx[1][ItemType.equipment]
  );
  const get_key = (ctx2) => (
    /*equipment*/
    ctx2[14].id
  );
  for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
    let child_ctx = get_each_context_3(ctx, each_value_3, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_3(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("TYPES.Item.equipment")}`;
      t1 = space();
      span = element("span");
      t2 = text(t2_value);
      t3 = text(" (");
      t4 = text(t4_value);
      t5 = text("/");
      t6 = text(t6_value);
      t7 = text(")");
      t8 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(h3, "class", "header-name svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
      attr(span, "class", "item-invested-total");
      attr(div2, "class", "pf2e-item-header svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h3);
      append(div2, t1);
      append(div2, span);
      append(span, t2);
      append(span, t3);
      append(span, t4);
      append(span, t5);
      append(span, t6);
      append(span, t7);
      insert(target, t8, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty & /*actor*/
      1) && t4_value !== (t4_value = /*actor*/
      ctx2[0].inventory.invested.value + ""))
        set_data(t4, t4_value);
      if ((!current || dirty & /*actor*/
      1) && t6_value !== (t6_value = /*actor*/
      ctx2[0].inventory.invested.max + ""))
        set_data(t6, t6_value);
      if (dirty & /*actor, items*/
      3) {
        each_value_3 = ensure_array_like(
          /*items*/
          ctx2[1][ItemType.equipment]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_3, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_3, each_1_anchor, get_each_context_3);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_3.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t8);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_3(key_1, ctx) {
  let first;
  let pf2eobject;
  let current;
  pf2eobject = new Pf2eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*equipment*/
        ctx[14]
      ),
      isOddLine: (
        /*index*/
        ctx[9] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(pf2eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(pf2eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const pf2eobject_changes = {};
      if (dirty & /*actor*/
      1)
        pf2eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.item = /*equipment*/
        ctx[14];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.isOddLine = /*index*/
        ctx[9] % 2 !== 0;
      pf2eobject.$set(pf2eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(pf2eobject, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_2 = ensure_array_like(
    /*items*/
    ctx[1][ItemType.consumable]
  );
  const get_key = (ctx2) => (
    /*consumable*/
    ctx2[12].id
  );
  for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
    let child_ctx = get_each_context_2(ctx, each_value_2, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_2(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("TYPES.Item.consumable")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(h3, "class", "header-name svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
      attr(div2, "class", "pf2e-item-header svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h3);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*actor, items*/
      3) {
        each_value_2 = ensure_array_like(
          /*items*/
          ctx2[1][ItemType.consumable]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_2, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_2, each_1_anchor, get_each_context_2);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_2.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_2(key_1, ctx) {
  let first;
  let pf2eobject;
  let current;
  pf2eobject = new Pf2eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*consumable*/
        ctx[12]
      ),
      isOddLine: (
        /*index*/
        ctx[9] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(pf2eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(pf2eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const pf2eobject_changes = {};
      if (dirty & /*actor*/
      1)
        pf2eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.item = /*consumable*/
        ctx[12];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.isOddLine = /*index*/
        ctx[9] % 2 !== 0;
      pf2eobject.$set(pf2eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(pf2eobject, detaching);
    }
  };
}
function create_if_block_1$1(ctx) {
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*items*/
    ctx[1][ItemType.treasure]
  );
  const get_key = (ctx2) => (
    /*treasure*/
    ctx2[10].id
  );
  for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
    let child_ctx = get_each_context_1(ctx, each_value_1, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block_1(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("TYPES.Item.treasure")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(h3, "class", "header-name svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
      attr(div2, "class", "pf2e-item-header svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h3);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*actor, items*/
      3) {
        each_value_1 = ensure_array_like(
          /*items*/
          ctx2[1][ItemType.treasure]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value_1, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block_1, each_1_anchor, get_each_context_1);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value_1.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block_1(key_1, ctx) {
  let first;
  let pf2eobject;
  let current;
  pf2eobject = new Pf2eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*treasure*/
        ctx[10]
      ),
      isOddLine: (
        /*index*/
        ctx[9] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(pf2eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(pf2eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const pf2eobject_changes = {};
      if (dirty & /*actor*/
      1)
        pf2eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.item = /*treasure*/
        ctx[10];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.isOddLine = /*index*/
        ctx[9] % 2 !== 0;
      pf2eobject.$set(pf2eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(pf2eobject, detaching);
    }
  };
}
function create_if_block$1(ctx) {
  let div2;
  let h3;
  let t1;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*items*/
    ctx[1][ItemType.backpack]
  );
  const get_key = (ctx2) => (
    /*backpack*/
    ctx2[7].id
  );
  for (let i2 = 0; i2 < each_value.length; i2 += 1) {
    let child_ctx = get_each_context(ctx, each_value, i2);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i2] = create_each_block(key, child_ctx));
  }
  return {
    c() {
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = `${i18n("TYPES.Item.backpack")}`;
      t1 = space();
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].c();
      }
      each_1_anchor = empty();
      attr(h3, "class", "header-name svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
      attr(div2, "class", "pf2e-item-header svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, h3);
      insert(target, t1, anchor);
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        if (each_blocks[i2]) {
          each_blocks[i2].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty & /*actor, items*/
      3) {
        each_value = ensure_array_like(
          /*items*/
          ctx2[1][ItemType.backpack]
        );
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, each_1_anchor.parentNode, outro_and_destroy_block, create_each_block, each_1_anchor, get_each_context);
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i2 = 0; i2 < each_value.length; i2 += 1) {
        transition_in(each_blocks[i2]);
      }
      current = true;
    },
    o(local) {
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        transition_out(each_blocks[i2]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
        detach(t1);
        detach(each_1_anchor);
      }
      for (let i2 = 0; i2 < each_blocks.length; i2 += 1) {
        each_blocks[i2].d(detaching);
      }
    }
  };
}
function create_each_block(key_1, ctx) {
  let first;
  let pf2eobject;
  let current;
  pf2eobject = new Pf2eObject({
    props: {
      actor: (
        /*actor*/
        ctx[0]
      ),
      item: (
        /*backpack*/
        ctx[7]
      ),
      isOddLine: (
        /*index*/
        ctx[9] % 2 !== 0
      )
    }
  });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(pf2eobject.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(pf2eobject, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const pf2eobject_changes = {};
      if (dirty & /*actor*/
      1)
        pf2eobject_changes.actor = /*actor*/
        ctx[0];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.item = /*backpack*/
        ctx[7];
      if (dirty & /*items*/
      2)
        pf2eobject_changes.isOddLine = /*index*/
        ctx[9] % 2 !== 0;
      pf2eobject.$set(pf2eobject_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2eobject.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2eobject.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(first);
      }
      destroy_component(pf2eobject, detaching);
    }
  };
}
function create_fragment$1(ctx) {
  let section;
  let div0;
  let t0;
  let t1;
  let div1;
  let t2;
  let t3;
  let t4;
  let t5;
  let t6;
  let current;
  let if_block0 = (
    /*isUsingCurrency*/
    ctx[3] && create_if_block_7(ctx)
  );
  let if_block1 = (
    /*isUsingEncumbrance*/
    ctx[4] && create_if_block_6(ctx)
  );
  let if_block2 = (
    /*items*/
    (ctx[1][ItemType.weapon]?.length > 0 || /*items*/
    ctx[1][ItemType.shield]?.length > 0) && create_if_block_5(ctx)
  );
  let if_block3 = (
    /*items*/
    ctx[1][ItemType.armor]?.length > 0 && create_if_block_4(ctx)
  );
  let if_block4 = (
    /*items*/
    ctx[1][ItemType.equipment]?.length > 0 && create_if_block_3(ctx)
  );
  let if_block5 = (
    /*items*/
    ctx[1][ItemType.consumable]?.length > 0 && create_if_block_2(ctx)
  );
  let if_block6 = (
    /*items*/
    ctx[1][ItemType.treasure]?.length > 0 && create_if_block_1$1(ctx)
  );
  let if_block7 = (
    /*items*/
    ctx[1][ItemType.backpack]?.length > 0 && create_if_block$1(ctx)
  );
  return {
    c() {
      section = element("section");
      div0 = element("div");
      if (if_block0)
        if_block0.c();
      t0 = space();
      if (if_block1)
        if_block1.c();
      t1 = space();
      div1 = element("div");
      if (if_block2)
        if_block2.c();
      t2 = space();
      if (if_block3)
        if_block3.c();
      t3 = space();
      if (if_block4)
        if_block4.c();
      t4 = space();
      if (if_block5)
        if_block5.c();
      t5 = space();
      if (if_block6)
        if_block6.c();
      t6 = space();
      if (if_block7)
        if_block7.c();
      attr(div0, "class", "currency-weight svelte-mobile-companion81nkluj30u9vsd-fhfcrr");
      attr(div1, "class", "content-scroll-list");
      attr(section, "class", "category-content");
    },
    m(target, anchor) {
      insert(target, section, anchor);
      append(section, div0);
      if (if_block0)
        if_block0.m(div0, null);
      append(div0, t0);
      if (if_block1)
        if_block1.m(div0, null);
      append(section, t1);
      append(section, div1);
      if (if_block2)
        if_block2.m(div1, null);
      append(div1, t2);
      if (if_block3)
        if_block3.m(div1, null);
      append(div1, t3);
      if (if_block4)
        if_block4.m(div1, null);
      append(div1, t4);
      if (if_block5)
        if_block5.m(div1, null);
      append(div1, t5);
      if (if_block6)
        if_block6.m(div1, null);
      append(div1, t6);
      if (if_block7)
        if_block7.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (
        /*isUsingCurrency*/
        ctx2[3]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*isUsingCurrency*/
          8) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_7(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*isUsingEncumbrance*/
        ctx2[4]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty & /*isUsingEncumbrance*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div0, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (
        /*items*/
        ctx2[1][ItemType.weapon]?.length > 0 || /*items*/
        ctx2[1][ItemType.shield]?.length > 0
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty & /*items*/
          2) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_5(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t2);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (
        /*items*/
        ctx2[1][ItemType.armor]?.length > 0
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty & /*items*/
          2) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_4(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div1, t3);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*items*/
        ctx2[1][ItemType.equipment]?.length > 0
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty & /*items*/
          2) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_3(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div1, t4);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*items*/
        ctx2[1][ItemType.consumable]?.length > 0
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty & /*items*/
          2) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_2(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div1, t5);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (
        /*items*/
        ctx2[1][ItemType.treasure]?.length > 0
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty & /*items*/
          2) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block_1$1(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div1, t6);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (
        /*items*/
        ctx2[1][ItemType.backpack]?.length > 0
      ) {
        if (if_block7) {
          if_block7.p(ctx2, dirty);
          if (dirty & /*items*/
          2) {
            transition_in(if_block7, 1);
          }
        } else {
          if_block7 = create_if_block$1(ctx2);
          if_block7.c();
          transition_in(if_block7, 1);
          if_block7.m(div1, null);
        }
      } else if (if_block7) {
        group_outros();
        transition_out(if_block7, 1, 1, () => {
          if_block7 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(if_block6);
      transition_in(if_block7);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(if_block6);
      transition_out(if_block7);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(section);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d();
      if (if_block2)
        if_block2.d();
      if (if_block3)
        if_block3.d();
      if (if_block4)
        if_block4.d();
      if (if_block5)
        if_block5.d();
      if (if_block6)
        if_block6.d();
      if (if_block7)
        if_block7.d();
    }
  };
}
function instance$1($$self, $$props, $$invalidate) {
  let { actor } = $$props;
  let items = {};
  let weaponsAndShields;
  let isUsingCurrency = true;
  const unsubscribeCurrency = mobileCompanionGameSettings.getWritableStore(settings.pf2e.useCurrency).subscribe((value) => {
    $$invalidate(3, isUsingCurrency = value);
  });
  let isUsingEncumbrance = true;
  const unsubscribeEncumbrance = mobileCompanionGameSettings.getWritableStore(settings.pf2e.useEncumbrance).subscribe((value) => {
    $$invalidate(4, isUsingEncumbrance = value);
  });
  onDestroy(() => {
    unsubscribeCurrency();
    unsubscribeEncumbrance();
  });
  $$self.$$set = ($$props2) => {
    if ("actor" in $$props2)
      $$invalidate(0, actor = $$props2.actor);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*actor, items*/
    3) {
      {
        $$invalidate(1, items = actor.inventory.contents.reduce(
          (acc, curr) => {
            const key = curr.type;
            acc[key] = acc[key] ? [...acc[key], curr] : [curr];
            return acc;
          },
          {}
        ));
        Object.keys(items).forEach((key) => {
          items[key].sort((a, b) => a.name.localeCompare(b.name));
        });
        $$invalidate(2, weaponsAndShields = [...items[ItemType.shield], ...items[ItemType.weapon]]);
      }
    }
  };
  return [actor, items, weaponsAndShields, isUsingCurrency, isUsingEncumbrance];
}
class Pf2eInventory extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance$1, create_fragment$1, safe_not_equal, { actor: 0 });
  }
}
function create_if_block_1(ctx) {
  let p;
  return {
    c() {
      p = element("p");
      p.textContent = "Not yet implemented";
    },
    m(target, anchor) {
      insert(target, p, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(p);
      }
    }
  };
}
function create_if_block(ctx) {
  let pf2einventory;
  let current;
  pf2einventory = new Pf2eInventory({ props: { actor: (
    /*actor*/
    ctx[1]
  ) } });
  return {
    c() {
      create_component(pf2einventory.$$.fragment);
    },
    m(target, anchor) {
      mount_component(pf2einventory, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const pf2einventory_changes = {};
      if (dirty & /*actor*/
      2)
        pf2einventory_changes.actor = /*actor*/
        ctx2[1];
      pf2einventory.$set(pf2einventory_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(pf2einventory.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(pf2einventory.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(pf2einventory, detaching);
    }
  };
}
function create_default_slot(ctx) {
  let main2;
  let header;
  let t;
  let current_block_type_index;
  let if_block;
  let current;
  header = new Header({
    props: {
      customButtons: headerButtons,
      menuButtons,
      activeFilter: (
        /*activeFilter*/
        ctx[2]
      )
    }
  });
  const if_block_creators = [create_if_block, create_if_block_1];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*activeFilter*/
      ctx2[2] === Filters.Object
    )
      return 0;
    if (
      /*activeFilter*/
      ctx2[2] === Filters.Spell
    )
      return 1;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      main2 = element("main");
      create_component(header.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      attr(main2, "class", "pf2e-container");
    },
    m(target, anchor) {
      insert(target, main2, anchor);
      mount_component(header, main2, null);
      append(main2, t);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(main2, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      const header_changes = {};
      if (dirty & /*activeFilter*/
      4)
        header_changes.activeFilter = /*activeFilter*/
        ctx2[2];
      header.$set(header_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(main2, null);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(header.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(header.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(main2);
      }
      destroy_component(header);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
    }
  };
}
function create_fragment(ctx) {
  let applicationshell;
  let updating_elementRoot;
  let current;
  function applicationshell_elementRoot_binding(value) {
    ctx[4](value);
  }
  let applicationshell_props = {
    $$slots: { default: [create_default_slot] },
    $$scope: { ctx }
  };
  if (
    /*elementRoot*/
    ctx[0] !== void 0
  ) {
    applicationshell_props.elementRoot = /*elementRoot*/
    ctx[0];
  }
  applicationshell = new ApplicationShell$1({ props: applicationshell_props });
  binding_callbacks.push(() => bind(applicationshell, "elementRoot", applicationshell_elementRoot_binding));
  return {
    c() {
      create_component(applicationshell.$$.fragment);
    },
    m(target, anchor) {
      mount_component(applicationshell, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const applicationshell_changes = {};
      if (dirty & /*$$scope, actor, activeFilter*/
      134) {
        applicationshell_changes.$$scope = { dirty, ctx: ctx2 };
      }
      if (!updating_elementRoot && dirty & /*elementRoot*/
      1) {
        updating_elementRoot = true;
        applicationshell_changes.elementRoot = /*elementRoot*/
        ctx2[0];
        add_flush_callback(() => updating_elementRoot = false);
      }
      applicationshell.$set(applicationshell_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(applicationshell.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(applicationshell.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(applicationshell, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { elementRoot } = $$props;
  let { props } = $$props;
  init(props);
  let actor = props;
  let activeFilter = Filters.Object;
  const unsubscribeActor = actorStore.subscribe((value) => {
    $$invalidate(1, actor = value);
  });
  const unsubscribeFilter = activeFilterStore.subscribe((value) => {
    $$invalidate(2, activeFilter = value);
  });
  onMount(handleOnMount);
  onDestroy(() => {
    unsubscribeActor();
    unsubscribeFilter();
    handleOnDestroy();
  });
  function applicationshell_elementRoot_binding(value) {
    elementRoot = value;
    $$invalidate(0, elementRoot);
  }
  $$self.$$set = ($$props2) => {
    if ("elementRoot" in $$props2)
      $$invalidate(0, elementRoot = $$props2.elementRoot);
    if ("props" in $$props2)
      $$invalidate(3, props = $$props2.props);
  };
  return [elementRoot, actor, activeFilter, props, applicationshell_elementRoot_binding];
}
let Pf2eFreeAppShell$1 = class Pf2eFreeAppShell extends SvelteComponent {
  constructor(options) {
    super();
    init$3(this, options, instance, create_fragment, safe_not_equal, { elementRoot: 0, props: 3 });
  }
  get elementRoot() {
    return this.$$.ctx[0];
  }
  set elementRoot(elementRoot) {
    this.$$set({ elementRoot });
    flush();
  }
  get props() {
    return this.$$.ctx[3];
  }
  set props(props) {
    this.$$set({ props });
    flush();
  }
};
class Pf2eFreeAppShell2 extends SvelteApplication {
  constructor(actor) {
    super();
    this.options.svelte.props = actor;
  }
  static get defaultOptions() {
    console.log("Loading Pathfinder 2E - Light");
    return foundry.utils.mergeObject(super.defaultOptions, {
      title: "Mobile Companion Pf2e",
      id: moduleId,
      // classes: [],
      width: window.innerWidth,
      height: window.innerHeight,
      zIndex: 99999,
      resizable: false,
      // The other options...
      svelte: {
        class: Pf2eFreeAppShell$1,
        target: document.body,
        props: {}
      }
    });
  }
}
function getCompanionComponent(actor) {
  if (game.system.id === system.DND5E) {
    return new Dnd5eFreeAppShell2({ props: actor });
  }
  if (game.system.id === system.A5E) {
    return new A5eFreeAppShell2({ props: actor });
  }
  if (game.system.id === system.PF2E) {
    return new Pf2eFreeAppShell2({ props: actor });
  }
}
function hideAllElements() {
  const delayTimes = [50, 500, 1e3, 2e3, 4e3, 8e3];
  delayTimes.forEach((delay) => {
    setTimeout(hideOtherElements, delay);
  });
}
function disableSounds() {
  game.settings.set("core", "globalPlaylistVolume", 0);
  game.settings.set("core", "globalAmbientVolume", 0);
  game.settings.set("core", "globalInterfaceVolume", 0);
}
function hideOtherElements() {
  Array.from(document.body.children).forEach((child) => {
    if (child.id !== "mobile-companion") {
      child.style.display = "none";
    }
  });
}
function onReady(callback) {
  mobileCompanionGameSettings.init();
  if (!isSheetOnly()) {
    return;
  }
  hideAllElements();
  disableSounds();
  callback();
}
function onRenderItemSheet(app) {
  if (!isSheetOnly()) {
    return;
  }
  app.element.addClass("mobile-companion full-size-sheet");
  app.setPosition({
    top: 0
  });
}
Hooks.once("ready", () => {
  onReady(() => {
    console.log("Loading Mobile-Companion light version.");
    activateSheet(getCompanionComponent);
  });
});
Hooks.on("renderItemSheet", (app) => {
  onRenderItemSheet(app);
});
